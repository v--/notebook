\section{Predicate logic}\label{sec:predicate_logic}

We will accumulate here historical or otherwise informal remarks about predicate logic. In particular, to reduce visual clutter, we will avoid the convention from \cref{rem:mathematical_logic_conventions/terminal_dots}, which dictates adding dots on top of \hyperref[def:formal_grammar]{terminal symbols}.

\paragraph{Syntax of predicate logic}

\begin{concept}\label{con:predicate_logic}
  \term[ru=предикатная логика (\cite[49]{КолмогоровДрагалин2006Логика}), en=predicate logic (\cite[ch. 2]{VanDalen2004LogicAndStructure})]{Predicate logic} is a phrase used for describing \hyperref[con:logical_system]{logical systems} that build upon \hyperref[def:propositional_logic]{propositional logic} but whose atomic propositions have a subject-predicate structure based on natural language sentences. We will now unravel this structure.

  \begin{thmenum}
    \thmitem{con:predicate_logic/predicate} \incite{Matthews2007DictionaryOfLinguistics} defines a linguistic predicate as follows:
    \begin{displayquote}
      A part of a clause or sentence traditionally seen as representing what is said of, or predicated of, the subject.
    \end{displayquote}

    Our immediate goal is to present a suitable adaptation of this concept.

    As an running example, consider the proposition
    \begin{displayquote}
      Every nonnegative real number has a real square root.
    \end{displayquote}

    Fitting the above statement into a modern formulation of predicate logic requires rewriting it into a more suitable form like
    \begin{displayquote}
      For every real number \( x \), if \( x \) is nonnegative, there exists a real number \( y \) such that \( y \cdot y \) and \( x \) are equal.
    \end{displayquote}

    Let us first focus on the innermost part --- \enquote{\( y \cdot y \) and \( x \) are equal}. It is an atomic sentence whose subjects are \enquote{\( y \cdot y \)} and \enquote{\( x \)} and whose predicate is \enquote{are equal}.

    We can write this symbolically as \enquote{\( y \cdot y = x \)}. The equality here is a binary \term[en=predicate (\cite[74]{Kleene2002Logic})]{predicate} in the sense of predicate logic --- a symbol denoting two-argument function whose value is a proposition. Equality is more fundamental than other predicates and is handled separately.

    The constructs corresponding to linguistic subjects are called \term[en=terms (\cite[237]{Russell1908TypeTheory})]{terms}, based on the terminology of Bertrand Russell described in \cref{rem:hol_formula_order_origin}. Here the terms are \enquote{\( y \cdot y \)} and \enquote{\( x \)}.

    One more thing should be noted here. The formula \enquote{\( y \cdot y = x \)}, which we used to encode the sentence \enquote{\( y \cdot y \) and \( x \) are equal}, more faithfully corresponds to the sentence \enquote{\( y \cdot y \) equals \( x \)}. This latter sentence differs linguistically since only \enquote{\( y \cdot y \)} is its subject. Instead, \enquote{\( x \)} is its object, and the predicate is now \enquote{equals}.

    This is where the analogy with linguistics starts cracking. From the perspective of logic, a predicate is a function whose arguments are terms, and it is irrelevant whether these terms encode linguistic subjects, objects or other entities. In fact, Matthews gives a second definition of linguistic predicates:
    \begin{displayquote}
      A verb or other unit which takes a set of arguments\( {}^* \) within a sentence.
    \end{displayquote}

    The asterisk refers to the following definition of argument:
    \begin{displayquote}
      Any syntactic element seen as required by a verb: e.g. \textit{love} takes two arguments, represented by \textit{she} and \textit{me} in \textit{She loves me}.
    \end{displayquote}

    Matthews remarks that the word \enquote{argument} in linguistics is borrowed from predicate logic. So, symbolic logic and linguistics have both influenced each other since the relatively recent inception of the latter.

    \thmitem{con:predicate_logic/quantifiers} Although \enquote{\( y \cdot y = x \)} is already a proposition, it has \hyperref[con:variable_binding]{free variables} whose role is not clear, just as the sentence \enquote{\( y \cdot y \) equals \( x \)} is ambiguous. We disambiguate both variables in the beginning of the compounds sentence: \enquote{For every real number \( x \), if \( x \) is nonnegative, there exists a real number \( y \) such that\ldots}.

    In logic, these phrases are adapted as \hyperref[con:variable_binding]{variable binders} called \term[en=quantifiers (\cite[73]{Kleene1971Metamathematics})]{quantifiers}. Suppose, for the moment, that all variables range over real numbers. Then we can write the compound sentence symbolically as follows\fnote{The dot delimiter in \( \qforall* x \varphi \) increases the visual space in formulas, thus sometimes making them easier to read, but serves no functional role; see \cref{rem:quantifier_notation}}:
    \begin{equation*}
      \qforall* x \parens[\big]{ x \geq 0 \rightarrow \qexists* y (y \cdot y = x) }.
    \end{equation*}

    Here \enquote{\( \forall \)} is an inverted letter \enquote{\textsf{A}} symbolizing the phrase \enquote{for all}. Similarly, \enquote{\( \exists \)} is an inverted letter \enquote{\textsf{E}} symbolizing the phrase \enquote{there exists}. We place dots on top of symbols only when dealing with quantifiers in the object language.

    These are only loosely related to linguistic quantifiers, which Matthews defines as follows:
    \begin{displayquote}
      Any word or expression which gives a relative or indefinite indication of quantity.
    \end{displayquote}

    Thus, \enquote{all} in \enquote{for all} is a linguistic quantifier, and hence \enquote{for all} is a quantifier phrase. But no part of \enquote{there exists} is a quantifier. This situation can be mildly improved by regarding \( \exists \) as a symbolic expression of the phrase \enquote{for some}.

    Both \enquote{all \( x \)} and \enquote{some \( y \)} are denoting phrases in the terminology of Bertrand Russell, which we elaborate upon in \cref{con:denotation}.

    \thmitem{con:predicate_logic/relativization} A common patterns that can be found in
    \begin{equation*}
      \qforall* x \parens[\big]{ x \geq 0 \rightarrow \qexists* y (y \cdot y = x) }
    \end{equation*}
    is to restrict the range of \( x \) using some predicate. A convenient notational shorthand is
    \begin{equation*}
      \qforall* {x \geq 0} \qexists* y (y \cdot y = x).
    \end{equation*}

    We say that the quantifier in \( \forall {x \geq 0} \) is \term[en=bounded quantifiers (\cite[369]{UnivalentFoundationsProgram2013HoTT})]{bounded} or \term[en=relativized quantifiers (\cite[79]{Andrews2002Logic})]{relativized}. The procedure of adding bounds to quantifiers is called \term[en=relativization (\cite[def. 2.6.42]{Hinman2005Logic})]{relativization}. It is also associated with the eponymous concept in linguistics, defined by Matthews as
    \begin{displayquote}
      The formation of \( {}^* \)relative clauses: specifically, the process by which one element is represented by a relative pronoun or equivalent.
    \end{displayquote}

    \thmitem{con:predicate_logic/models} Now let us relax the assumption that we are working over real numbers and instead allow arbitrary \hyperref[def:ordered_semiring]{ordered (semi)rings}. The reason is that we want to allow different interpretations for the obtained formula
    \begin{equation*}
      \qforall* {x \geq 0} \qexists* y (y \cdot y = x).
    \end{equation*}

    Since it is by intention built for real numbers, it is satisfied by \( \BbbR \) by virtue of the explicitly constructed principal square roots in \cref{def:principal_nonnegative_nth_root}. On the other hand, it is not satisfied by \( \BbbQ \) nor \( \BbbZ \) since, as shown in \cref{thm:nth_root_is_not_rational}, the number \( 2 \) has no square root in either.

    \thmitem{con:predicate_logic/types} This prompts us to generalize the original statement
    \begin{displayquote}
      Every nonnegative real number has a real square root.
    \end{displayquote}
    to
    \begin{displayquote}
      There exists a set every member of which has a square root.
    \end{displayquote}

    To express this symbolically, assuming we are working in a ring \( R \), we must allow some variables to range over member of \( R \) and some --- over subsets of \( R \). Each variable must thus be annotated with what values it is allowed to range over; following Russell's terminology explained in \cref{rem:hol_formula_order_origin}, we call these annotations \term[en=type (\cite[236]{Russell1908TypeTheory})]{types}.

    Again following Russell, we call the terms inhabiting the base type \term[en=individuals (\cite[237]{Russell1908TypeTheory})]{individuals}. These correspond to members of \( R \). Instead of treating subsets of \( R \) as sets, then, we can treat them as unary predicates over individuals. Using the notation of Church explained in \fullref{sec:higher_order_logic}, we annotate individual variables with \( \iota \) and unary predicate variables with \( \iota \rightarrow \omicron \).

    All this leads to the formula
    \begin{equation*}
      \qexists* {p^{\iota \rightarrow \omicron}} \qforall* {x^{\iota}} \parens[\big]{ p(x) \rightarrow \qexists* {y^{\iota}} (y \cdot y = x) }.
    \end{equation*}

    Note that the type of a variable is an essential part of the language in higher-order logic. Without a type, we cannot know what a variable should refer to. This is fundamentally different from relativization, which is only a notational shorthand.

    We discuss in \fullref{sec:ramified_types} how types allow stratifying formulas into orders, which in turn leads to some statements being called first-order, second-order, etc., with higher-order logic allowing predicate formulas of great complexity. Although the latter are much more versatile, first-order logic is simpler because all its variables are individuals; it is better studied and more ubiquitous. In fact, some authors like \incite[ch. 2]{VanDalen2004LogicAndStructure} and \incite[\S I.9]{КолмогоровДрагалин2006Логика} refer to first-order logic as \enquote{predicate logic}. Furthermore, as shown in \cref{alg:higher_order_to_first_order_logic}, first-order logic is able to emulate most of higher-order logic.

    For these reasons, we will almost exclusively focus on first-order logic. This is enhanced by the availability of \fullref{ch:set_theory}, which roughly allows emulating types via relativization to sets.

    \thmitem{con:predicate_logic/sorts} Even when restricted to first-order logic, it is sometimes convenient to consider multiple types of individuals. We will call them \term[en=sorts (\cite[35]{BaaderNipkow2012TermRewriting})]{sorts}\fnote{Sorts, as used here, are unrelated to sorts in \hyperref[def:pure_type_system]{pure type systems}, which act as \hyperref[con:type_universe]{type universes} rather than base types.}.

    For example, when dealing with \hyperref[def:graph]{graphs}, we may wish to combine in a single formula vertices, inhabiting the sort \( v \), and arcs, inhabiting the sort \( a \). We can then describe complete graphs via the formula
    \begin{equation*}
      \qforall* {h^{v}} \qforall* {t^{v}} \qexists* {e^{a}} (H(e) = h \wedge T(e) = t),
    \end{equation*}
    where \( H \) and \( T \) denote the head and tail of an arc, correspondingly.

    We call the resulting logical system \term[en=one-sorted (predicate calculus) (\cite[84]{Kleene2002Logic})]{one-sorted} or \term[en=many-sorted predicate logic (\cite[\S 4.4.13]{TroelstraSchwichtenberg2000BasicProofTheory})]{many-sorted} depending on the amount of sorts. Many-sorted first-order logic can be emulated in one-sorted logic; see \cref{alg:many_sorted_to_one_sorted_theory}.
  \end{thmenum}
\end{concept}

\begin{remark}\label{rem:quantifier_notation}
  There are different possible notations for formulas with \hyperref[con:predicate_logic/quantifiers]{quantifiers}. The most straightforward notation, \( \mathinner{\forall x} \varphi \), seems to be dominating --- it is used in
  \cite[ch. 2]{Hinman2005Logic},
  \cite[ch. 2]{VanDalen2004LogicAndStructure},
  \cite[ch. II]{Kleene2002Logic},
  \cite{TroelstraSchwichtenberg2000BasicProofTheory},
  \cite[ch. 2]{Andrews2002Logic},
  \cite[\S I.9]{КолмогоровДрагалин2006Логика},
  \cite[def. 2.1.6]{Герасимов2014Вычислимость},
  \cite[ch. 3]{ШеньВерещагин2017ЯзыкиИИсчисления} and
  \cite[ch. II]{Эдельман1975Логика}.

  This notation becomes cumbersome with \hyperref[con:predicate_logic/relativization]{bounded quantification}. Consider several variants of the same formula:
  \begin{align}
    \forall {y \in B} \mathinner{\space} \forall {x \in A} \mathinner{\space} (f(x) = y), \label{eq:rem:quantifier_notation/bare} \\
    (\forall {y \in B}) (\forall {x \in A}) (f(x) = y), \label{eq:rem:quantifier_notation/parentheses} \\
    \qforall* {y \in B} \qexists* {x \in A} f(x) = y. \label{eq:rem:quantifier_notation/dots}
  \end{align}

  We prefer the latter notation \eqref{eq:rem:quantifier_notation/dots} that utilizes dot delimiters. Our main motivation is that it is most appealing of the three when dealing with formalized grammars, where we need a restricted linear language without formatting. This is consistent with \fullref{ch:lambda_calculus} --- see \cref{rem:lambda_term_abstractor_dot} for the relevant discussion regarding \hyperref[def:lambda_term]{\( \muplambda \)-terms}. This convention stems from the dot delimiters of Russell and Whitehead, which are discussed in detail in \cref{ex:dot_delimiters_in_logic}, but our delimiters have only a visual role --- they do not dictate how subformulas are grouped. This convention is used by \incite{Mimram2020ProgramEqualsProof} and \incite{Farmer2008STTVirtues}.

  Out of the books mentioned above, \cite[def. 2.5.12]{VanDalen2004LogicAndStructure} and \cite[79]{Andrews2002Logic} use the parenthesizes variant \eqref{eq:rem:quantifier_notation/parentheses}, but only for bounded quantifiers. Andrews also avoids dots in \( \muplambda \)-terms. When discussing models of set theory, \cite[ch. 12]{Jech2006SetTheory} also uses parenthesized bounded quantifiers.

  The parenthesis-free variant \eqref{eq:rem:quantifier_notation/bare} is used in \cite[def. 11.5.4]{TroelstraSchwichtenberg2000BasicProofTheory}. The authors use dot delimiters when briefly discussing (typed) \( \muplambda \)-terms, but avoid them in logical formulas. This notation is also used in \cite{Kunen2013SetTheory} when discussing axiomatic set theory.

  Still other conventions are discussed in \cite{MathSE:standards_for_quantifier_notation}.
\end{remark}

\begin{example}\label{ex:dot_delimiters_in_logic}
  The syntax of predicate logic has evolved drastically since its inception in the 19th century. We will demonstrate several examples.

  \begin{thmenum}
    \thmitem{ex:dot_delimiters_in_logic/contraposition} For example, we can express the \hyperref[def:conditional_formula/contrapositive]{contrapositive} equivalence \cref{thm:classical_equivalences/contrapositive} as follows:
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/contraposition/plain}
      (p \rightarrow q) \leftrightarrow (\neg q \rightarrow \neg p)
    \end{equation}

    Compare this to Russell and Whitehead's three-volume \enquote{Principia Mathematica} (\cite{WhiteheadRussell1927PrincipiaMathematicaVol1}, \cite{WhiteheadRussell1927PrincipiaMathematicaVol2} and \cite{WhiteheadRussell1927PrincipiaMathematicaVol3}), which we will more carefully analyze in \fullref{sec:ramified_types}. In the first book, \eqref{eq:ex:dot_delimiters_in_logic/contraposition/plain} can be found as (\( \anon 4 \ 1 \)):
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/contraposition/principia}
      p \rightimply q \qdot \equiv \qdot \sim q \rightimply \ \sim p
    \end{equation}

    Without familiarity with the syntax, it is clear here that dots act as delimiters, but it is not clear how. As it turns out, the rules are quite complicated, and it is unclear why there were chosen at all.

    In \cite[9]{WhiteheadRussell1927PrincipiaMathematicaVol1}, in a paragraph called \enquote{The use of dots}, Russell and Whitehead explain how dots are used either as conjunctions or as delimiters depending on their position. In the latter case, \enquote{a larger number of dots indicates an outside bracket, a smaller number indicates an inside bracket}. The \enquote{number of dots} refers to clusters of dots in more complicated formulas such as \eqref{eq:ex:dot_delimiters_in_logic/complicated/principia}, which we will inspect next.

    The precise rules require dividing the occurrences of dots into three groups:
    \begin{itemize}
      \item \enquote{Group I} consists of dots adjoining a propositional connective or \enquote{equality by definition} (which construct does not exist in our formulation). In our notation, we place each connective formula in parentheses to avoid the need of such a group.

      \item \enquote{Group II} consists of dots following \hyperref[con:predicate_logic/quantifiers]{quantifiers}. In our notation, we place a quantifiers's body in parentheses to avoid the need of such a group.

      \item \enquote{Group III} consists of dots which \enquote{stand between propositions in order to indicate a logical product} (i.e. a conjunction). In our notation, we simply use a distinguished conjunction symbol to avoid the need for such a group.
    \end{itemize}

    Finally,
    \begin{displayquote}
      The scope of the bracket indicated by any collection of dots extends backwards or forwards beyond any \textit{smaller} number of dots, or any \textit{equal} number from a group of less force, until we reach either the end of the asserted proposition or a \textit{greater} number of dots or an \textit{equal} number belonging to a group of equal or superior force.
    \end{displayquote}

    Since \eqref{eq:ex:dot_delimiters_in_logic/contraposition/principia} features no quantifiers, and since the dots are all singular, we can conclude that \eqref{eq:ex:dot_delimiters_in_logic/contraposition/principia} corresponds to
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/contraposition/principia_parens}
      (p \rightimply q) \equiv (\sim q \rightimply \ \sim p),
    \end{equation}
    which differs from \eqref{eq:ex:dot_delimiters_in_logic/contraposition/plain} only by the choice of connective symbols.

    The convention is attributed to Peano's \cite{Peano1908FormulatioMathematico}, first published in 1894. There, the same formula can be found as (I.4.2) on page 10:
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/contraposition/peano}
      a \rightimply b \qdot \equiv \qdot - a \rightimply - b
    \end{equation}

    Modulo the variable names and the negation symbol, this coincides with \eqref{eq:ex:dot_delimiters_in_logic/contraposition/principia} from Principia Mathematica. The exact same formula can be found in Peano's earlier work \cite{Peano1889ArithmeticesPrincipia} on formalized arithmetic as (22.) on page IX. Dot delimiters are more convenient in Peano's work because he does not use quantifiers and denotes conjunction by the symbol \( {\cap} \), so Russell and Whitehead's groups II and III are irrelevant to his writing.

    \thmitem{ex:dot_delimiters_in_logic/complicated} Even without quantifiers and conjunctions, the formulas in Principia Mathematica can be difficult to parse. The following is given as an example when discussing the dot delimiters:
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/complicated/principia}
      p \vee q \qdot \rightimply \mathinner{\phantom{:}\mathllap{:}\mathrlap{.}\phantom{.}} p \qdot \vee \qdot q \rightimply r \mathinner{:} \rightimply \qdot p \vee r
    \end{equation}

    First, we eliminate the triple dots:
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/complicated/principia_without_triple}
      p \vee q \ . \rightimply \parens[\big]{ p \qdot \vee \qdot q \rightimply r \mathinner{:} \rightimply \qdot p \vee r }
    \end{equation}

    Then the double dots:
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/complicated/principia_without_double}
      p \vee q \qdot \rightimply \parens[\big]{ \parens[\big]{ p \qdot \vee \qdot q \rightimply r } \rightimply \qdot p \vee r }
    \end{equation}

    Finally, we eliminate the single dots:
    \begin{equation}\label{eq:ex:dot_delimiters_in_logic/complicated/plain}
      (p \vee q) \rightimply \parens[\big]{ \parens[\big]{ p \vee (q \rightimply r) } \rightimply (p \vee r) }
    \end{equation}

    \thmitem{ex:dot_delimiters_in_logic/quantifiers} The quantifier formulas \( \qforall* x \phi(x) \) and \( \qexists* x \phi(x) \) become, in Russell and Whitehead's notation, \( (x) \qdot \phi x \) and \( (\exists x) \qdot \phi x \).

    The dots in these latter formulas belong to group II discussed above, so, written without dots, we obtain \( (x) (\phi x) \) and \( (\exists x) (\phi x) \).

    Even though we have strayed from the grouping role of dot delimiters, following popular convention, we use them to create visual space when dealing with \hyperref[con:variable_binding]{variable binders} in \( \muplambda \)-calculus --- see \cref{rem:lambda_term_abstractor_dot} --- and also reuse the latter convention for quantifiers in predicate logic --- see \cref{rem:quantifier_notation}.
  \end{thmenum}
\end{example}

\begin{definition}\label{def:function_application_notation}\mimprovised
  Fix a \hyperref[def:formal_language/symbol]{symbol} \( f \) intended to denote a function of \hyperref[con:function_arguments]{arity} \( n \).

  \begin{thmenum}
    \thmitem{def:function_application_notation/prefix} The following is a simple \hyperref[def:formal_grammar]{formal grammar rule} for the standard notation for \( f \), specifically for \hyperref[con:predicate_logic]{predicate logic}:
    \begin{bnfextra*}
      \bnfprod{prefix notation} {\bnfts{\( f \)}}                                                                                                                                                           \bnfe{if \( n = 0 \)} \\
      \bnfprod{prefix notation} {\bnfts{\( f \)} \bnfsp \bnftsq{(} \bnfsp \underbrace{\bnfpn{term} \bnfsp \bnftsq{,} \bnfsp \cdots \bnfsp \bnftsq{,} \bnfsp \bnfpn{term}}_{n \T*{terms}} \bnfsp \bnftsq{)}} \bnfe{if \( n > 0 \)}
    \end{bnfextra*}

    Here the \( \bnfpn{term} \) rule is taken from the ambient \hyperref[def:formal_grammar/schema]{grammar schema}; for example, these will be the different in \hyperref[def:first_order_logic]{first-order logic} and in \hyperref[def:higher_order_logic]{higher-order logic}.

    \thmitem{def:function_application_notation/condensed} One variation is to avoid parentheses and commas:
    \begin{bnf*}
      \bnfprod{condensed notation}  {\bnfts{\( f \)} \bnfsp \underbrace{\bnfpn{term} \bnfsp \cdots \bnfsp \bnfpn{term}}_{n \T*{terms}}}
    \end{bnf*}

    We call this notation \enquote{condensed}; a more popular but more ambiguous name is \enquote{Polish notation}; see \cref{rem:def:function_application_notation/polish} for a broader discussion.

    \thmitem{def:function_application_notation/postfix} An an alternative to prefix notation, we can also put the operator after its arguments:
    \begin{bnfextra*}
      \bnfprod{postfix notation} {\bnfts{\( f \)}}                                                                                                                                                           \bnfe{if \( n = 0 \)} \\
      \bnfprod{postfix notation} {\bnftsq{(} \bnfsp \underbrace{\bnfpn{term} \bnfsp \bnftsq{,} \bnfsp \cdots \bnfsp \bnftsq{,} \bnfsp \bnfpn{term}}_{n \T*{terms}} \bnfsp \bnftsq{)} \bnfsp \bnfts{\( f \)}} \bnfe{if \( n > 0 \)}
    \end{bnfextra*}

    The usefulness of postfix notation is limited. We describe in \cref{rem:def:function_application_notation/reverse_polish} how condensed postfix notation can simplify evaluation in some cases. The only ubiquitous use of it in mathematics is perhaps the \hyperref[def:factorial]{factorial function} \( n! \), although variations like subscripts and superscripts are very common.

    \thmitem{def:function_application_notation/infix} For \hyperref[def:operation_on_set]{binary operations}, which are traditionally denoted using non-letter symbols, both notations becomes cumbersome. For example, \( \anon(x, y) \) and \( (x, y)\anon \) denote an application of the operator \( \anon \). In this case, we find useful the \term[ru=инфиксная форма (\cite[example 6.6]{БелоусовТкачёв2004ДискретнаяМатематика}), en=infix notation (\cite[833]{HighamEtAl2015PrincetonCompanion})]{infix notation} \( (x \anon y) \). More generally:
    \begin{bnf*}
      \bnfprod{infix notation} {\bnftsq{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{\( \anon \)} \bnfsp \bnfpn{term} \bnfsp \bnftsq{)}}
    \end{bnf*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The improper symbols used here are the comma and parentheses, both from the \hyperref[def:predicate_logic_alphabet]{predicate logic alphabet}.
\end{comments}

\begin{remark}\label{rem:def:function_application_notation}
  We will discuss here several aspects of the different notations from \cref{def:function_application_notation}.

  \begin{thmenum}
    \thmitem{rem:def:function_application_notation/s_expression} Prefix notation is the basis of the programming language LISP and its derivatives. These languages are based on only one syntactic construct, which, when describing LISP, \incite[187]{McCarthy1960SExpressionsPartI} called an \term{S-expression}. They can be described via the following \hyperref[def:formal_grammar]{grammar}, assuming a predefined set of atomic \( S \)-expressions (e.g. alphanumeric strings or arithmetic operators):
    \begin{bnf*}
      \bnfprod{S-expression list} {\bnfpn{S-expression} \bnfor \bnfpn{S-expression} \bnfsp \bnftsq{\textvisiblespace} \bnfsp \bnfpn{S-expression list}} \\
      \bnfprod{S-expression}      {\bnfpn{atomic S-expression} \bnfor \bnftsq{(} \bnfsp \bnfpn{S-expression list} \bnfsp \bnftsq{)}}
    \end{bnf*}

    For example, the arithmetic expression \( 3(1 + 2) \) can be described via the \( S \)-expression
    \begin{center}
      \begin{BVerbatim}[gobble=8]
        (* 3 (+ 1 2))
      \end{BVerbatim}
    \end{center}

    \thmitem{rem:def:function_application_notation/polish} With prefix notation, the infix formula
    \begin{equation*}
      ((p \wedge q) \rightarrow r)
    \end{equation*}
    becomes
    \begin{equation*}
      (\rightarrow (\wedge p q) r).
    \end{equation*}

    We can take one step further and use the condensed notation
    \begin{equation*}
      \rightarrow \wedge p q r
    \end{equation*}
    that can be parsed unambiguously, unlike
    \begin{equation*}
      p \wedge q \rightarrow r.
    \end{equation*}

    Specifically for propositional connectives, \incite[38]{Church1956LogicVol1} calls this the \enquote{parenthesis-free notation of Jan \L{}ukasiewicz}. More generally, is also called \enquote{Polish notation} in his honor, for example in \cite[338]{Knuth1997ArtVol1} and \cite[45]{Andrews2002Logic}.

    It should be noted that the Polish notation we describe here is not merely prefix notation, but condensed prefix notation (without commas and parenthesis). Nonetheless, the latter two authors use \enquote{Polish notation} and \enquote{prefix notation} interchangeably.

    Peter Hinman, who initially defines propositional formulas via Polish notation in \cite[def. 1.1.2]{Hinman2005Logic}, later reflects upon it:
    \begin{displayquote}
      It is convenient for proving unique readability and other technical matters, but it is clearly not well designed for \textit{human} readability.
    \end{displayquote}

    He then proceeds to use infix notation for the rest of the book.

    \thmitem{rem:def:function_application_notation/reverse_polish} Condensed postfix notation is also called \enquote{reverse Polish notation}, for example in \cite[833]{HighamEtAl2015PrincetonCompanion} and \cite[817]{Rosen2019DiscreteMathematics}. It is particularly apt for performing calculations using a stack --- an abstract data type supporting only \enquote{pushing} an element to the top and \enquote{popping} the top element.

    We will sketch the general technique with an example. Consider the arithmetic expression \( 3(1 + 2) \). When written in parenthesis-free postfix notation, it becomes
    \begin{center}
      \begin{BVerbatim}[gobble=8]
        3 1 2 + *
      \end{BVerbatim}
    \end{center}

    We start with an empty stack. We keep reading (space-delimited) \hyperref[def:positional_number_system/decimal]{decimal strings} and pushing the corresponding integers to the stack until we encounter an operator. In our example, when we encounter \( + \), the stack looks as follows:
    \begin{MemoryLine}{3}
      3 & 1 & \MemoryLineArrow 2
    \end{MemoryLine}

    Knowing that the operator \( + \) is binary, we pop two elements from the stack and sum them. We then push the result to the stack:
    \begin{MemoryLine}{2}
      3 & \MemoryLineArrow 3
    \end{MemoryLine}

    We continue traversing the source string. We again encounter a binary operator, so we pop the remaining two elements and multiply them to obtain \( 9 \).

    At this point we have traversed the input string, so the expression is well-formed, and we managed to successfully evaluate it to \( 9 \).
  \end{thmenum}
\end{remark}

\paragraph{Description operators}

\begin{concept}\label{con:denotation}
  Bertrand Russell begins his philosophical paper \cite{Russell1905OnDenoting} as follows:
  \begin{displayquote}
    By a \enquote{denoting phrase} I mean a phrase such as any one of the following: a man, some man, any man, every man, all men, the present King of England, the present King of France, the centre of mass of the Solar System at the first instant of the twentieth century, the revolution of the earth round the sun, the revolution of the sun round the earth. Thus a phrase is denoting solely in virtue of its form. We may distinguish three cases: (1) A phrase may be denoting, and yet not denote anything; \textit{e.g.}, \enquote{the present King of France}. (2) A phrase may denote one definite object; \textit{e.g.}, \enquote{the present King of England} denotes a certain man. (3) A phrase may denote ambiguously, \textit{e.g.}, \enquote{a man} denotes not many men, but an ambiguous man. The interpretation of such phrases is a matter of considerable difficulty; indeed, it is very hard to frame any theory not susceptible of formal refutation.
  \end{displayquote}

  Later in the paper, Russell discusses \term{denotations} and how they relate to the meaning of denoting phrases:
  \begin{displayquote}
    When we wish to speak about the \textit{meaning} of a denoting phrase, as opposed to its \textit{denotation}, the natural mode of doing so it by inverted commas.
    \begin{equation*}
      \vdots
    \end{equation*}
    We say to begin with, that when \( C \) occurs it is the \textit{denotation} that we are speaking about; but when \enquote{C} occurs, it is the \textit{meaning}.
  \end{displayquote}

  Russell provides an example --- the first line of Gray's Elegy is the meaning of the denoting phrase \enquote{the first line of Gray's Elegy}, while the textual content of that line is its denotation.

  When defining the \hyperref[con:evaluation]{evaluation} of a \hyperref[con:expression]{formal expression} in some \hyperref[con:metalanguage]{object language}, we are only interested in its denotation.
\end{concept}

\begin{concept}\label{con:description_operator}
  Consider the unary \hyperref[con:predicate_logic/predicate]{predicate} \( p(x) \). We will present here several \hyperref[con:variable_binding]{variable binders} related to Russell's theory of denotations (which we touch upon in \cref{con:denotation}).

  To summarize, they act as follows on three kinds of denoting phrases considered by Russell in \cite{Russell1905OnDenoting}:
  \begin{center}
    \begin{tabular}{l c c c c}
      \toprule
                                                        & \( \qexists* x p(x) \) & \( \quantifier \varepsilon x p(x) \) & \( \quantifier \rotiota x p(x) \) & \( \qExists* x p(x) \) \\
      \midrule
      \( p(x) \) does not hold for any value of \( x \) & \( \sembot \)          & ambiguous                            & undefined                         & \( \sembot \) \\
      \( p(x) \) holds for a unique value \( x = a \)   & \( \semtop \)          & \( a \)                              & \( a \)                           & \( \semtop \) \\
      \( p(x) \) holds for multiple values of \( x \)   & \( \semtop \)          & ambiguous                            & undefined                         & \( \sembot \) \\
      \bottomrule
    \end{tabular}
  \end{center}

  We now discuss these binders in more detail:
  \begin{thmenum}
    \thmitem{con:description_operator/exists} The \( \exists \) quantifier merely postulates the existence of a value of \( x \) satisfying \( p \). It is one of the two quantifies commonly considered, and we will consider it an indispensable part of first-order logic.

    \thmitem{con:description_operator/epsilon} David Hilbert's \( \varepsilon \) operator, described in \cite{Leisenring1969MathematicalLogic}, produces a particular value of \( x \) satisfying \( p \), if one exists, and otherwise produces a value \hi{not} satisfying \( p \).

    Hilbert's intention was to regard \( \varepsilon \) as a \hyperref[con:primitive_notion]{primitive notion}, and define \( \qexists* x p(x) \) as an \hyperref[con:syntactic_abbreviation]{abbreviation} for \( p(\quantifier \varepsilon x p(x)) \).

    In this case, the particular value given by \( \varepsilon \) does not matter, but the nondeterminism may be undesirable in general. The semantics suggested by \incite[\S 3.3]{Leisenring1969MathematicalLogic} for \( \quantifier \varepsilon x p(x) \) requires a \hyperref[def:choice_function]{choice function} for determining a particular value of \( x \) satisfying \( p(x) \), and a fixed value (independent of \( p \)) in case no value satisfies \( p(x) \). These choices are in general not obvious.

    \incite[\S 8.3]{Farmer2008STTVirtues} calls the \( \varepsilon \) operator \term{indefinite description}.

    \thmitem{con:description_operator/iota} Bertrand Russell's \( \rotiota \) operator is by intention left undefined wherever \( \varepsilon \) has an ambiguous value.

    \incite*[30]{WhiteheadRussell1927PrincipiaMathematicaVol1} call it a \term{description} operator. \incite{Farmer2008STTVirtues} suggests calling it \term{definite description} to distinguish it from indefinite descriptions.

    The symbol \( \rotiota \) is an \enquote{inverted} (rotated) Greek iota. The inversion is perhaps reminiscent of how Russell calls \enquote{inverted commas} the quotes that abstract away the meaning of a sentence.

    Unlike Hilbert's \( \varepsilon \) operator, by intention the description is well-defined only if a unique unambiguous value \( x = a \) satisfies \( p(x) \). We list two suggestions for the semantics of  \( \quantifier \rotiota x p(x) \) in the other cases:
    \begin{thmenum}
      \thmitem{con:description_operator/iota/error} We can, as with \( \varepsilon \), provide a dedicated \enquote{error value}. This is done by \incite[\S 3.2]{Farmer2008STTVirtues}, and also by \incite[\S 54]{Andrews2002Logic}.

      As in the case of the \( \varepsilon \) operator, such a choice has the downside of generally not being obvious or even meaningful.

      \thmitem{con:description_operator/iota/undefined} Alternatively, we can leave \( \quantifier \rotiota x p(x) \) \hyperref[con:undefinedness]{undefined} in the case of nonuniqueness. This is done by \incite{Farmer1990PartialFunctionSTT}, and, for first-order logic, by \incite{Hamkins2022DefiniteDescriptions} (in several variants).

      This however requires every formula depending on \( \quantifier \rotiota x p(x) \) to possibly be undefined, which leads to elaborate rules of when a formula may even have a truth value.
    \end{thmenum}

    \thmitem{con:description_operator/unique_existence} Finally, if we wish to merely postulate the existence of a unique value satisfying \( p \), but are not interested in the value itself, we can use the \term{unique existential quantifier} \( \qExists* x p(x) \).

    Unique existence comes in two parts:
    \begin{thmenum}
      \thmitem{con:description_operator/unique_existence/exists} There must exist a value \( a \) satisfying \( p \).
      \thmitem{con:description_operator/unique_existence/unique} For every \( b \), if \( b \) satisfies \( p \), then \( b \) must equal \( a \).
    \end{thmenum}

    Unlike the \( \rotiota \) operator with its complexities, this quantifier can easily be defined as an abbreviation via other logical connectives --- see \cref{rem:fol_formula_conventions/unique_existence}.
  \end{thmenum}
\end{concept}
