\section{Predicate logic}\label{sec:predicate_logic}

\paragraph{Syntax of predicate logic}

\begin{remark}\label{rem:predicate_logic}
  We have defined \enquote{predicates} in \cref{def:boolean_function} as \hyperref[con:boolean_value]{Boolean-valued} functions. We are interested here in \hyperref[con:syntax_semantics_duality]{syntactic} constructs that allow encoding such functions.

  As described in \cref{def:propositional_valuation/formula_valuation}, \hyperref[def:propositional_syntax/formula]{propositional formulas} are evaluated to Boolean (not merely Boolean-valued) functions under \hyperref[def:first_order_semantics]{classical semantics}. Predicate logic extends propositional logic by formalizing not only relationship between \hyperref[con:proposition]{propositions}, but also the structure of individual propositions. An atomic proposition in predicate logic may depend on \hyperref[con:variable]{variables} that range over arbitrary domains. We will give a formal definition of syntactic predicate in \cref{def:simply_typed_hol_formula}.

  \incite*[74]{Kleene2002Logic} describes the relationship between predicates and propositions as follows:
  \begin{displayquote}
    \ldots the predicate is seen to be a \textit{propositional function}, i.e. for each value of the (independent) variable \enquote{\( x \)}, it becomes (or takes as value) a proposition.
  \end{displayquote}

  As mentioned in \cref{con:proposition}, propositions are sometimes called \enquote{sentences}. The name \enquote{predicate} is based on the grammatical role of a predicate in a sentence, as pointed out by Kleene:
  \begin{displayquote}
    In the propositional calculus, we studied those occurrences of variables, logical relationships which depend on how some propositions are from other propositions by operations (expressed by the symbols \( \sim \), \( \rightimply \), \( \land \), \( \vee \), \( \neg \)) in which the latter
    propositions enter as unanalyzed wholes. In the \textit{predicate calculus}, we carry the analysis a step deeper to take into account also what in grammar is called \enquote{subject-predicate structure}, and we use two further operations, \( \forall \) (\enquote{for all}) and \( \exists \) (\enquote{for some} or \enquote{there exists}) which depend on that structure. (The predicate calculus includes the propositional calculus.)
  \end{displayquote}

  These two operations are \hyperref[con:variable_binding]{variable binders} called quantifiers; we will formally introduce them in \cref{def:predicate_logic_alphabet/quantifiers}. They can be viewed as generalizations of disjunction and conjunction --- \( \qforall* x \varphi \) encodes the \hyperref[con:judgment]{judgment} that \( \varphi \) holds for any value of \( x \) (here \( x \) is a \hyperref[con:variable_binding]{free variable}), without having to list all values in a conjunction, while \( \qexists* x \varphi \) instead states that \( \varphi \) holds for at least one \( x \).

  In this analogy, the variables upon which a predicate depends are subjects. We will call these subject variables \enquote{individual variables} based on Russell's usage described in \cref{con:ramified_type_theory}.

  Also based on Russell's usage is the stratification of formulas into orders. We will describe here some generalities that do not belong to a particular level of this hierarchy, and which we will collectively call \term{higher-order logic}. Later, in \fullref{sec:first_order_logic}, we will narrow out focus in order to study particular predicate formulas more elaborately.
\end{remark}

\begin{definition}\label{def:predicate_logic_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} of predicate logic extends the \hyperref[def:propositional_alphabet]{alphabet of propositional logic} with the following:
  \begin{thmenum}
    \thmitem{def:predicate_logic_alphabet/quantifiers}\mcite[80]{Kleene2002Logic} The following symbols, collectively called \term[ru=кванторы (\cite[72]{ШеньВерещагин2017ЯзыкиИИсчисления})]{quantifiers}:
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/quantifiers/universal} The \term[ru=квантор общости (\cite[61]{Эдельман1975Логика})]{universal quantifier} \enquote{\( \synforall \)}.
      \thmitem{def:predicate_logic_alphabet/quantifiers/existential}\mcite[80]{Kleene2002Logic} The \term[ru=квантор существования (\cite[61]{Эдельман1975Логика})]{existential quantifier} \enquote{\( \synexists \)}.
    \end{thmenum}

    We will denote by \( \op*{Quant} \) the set \( \set{ \synforall, \synexists } \) of quantifiers.

    \thmitem{def:predicate_logic_alphabet/equality}\mcite[def. 2.1.2(vi)]{Hinman2005Logic} The \hyperref[def:function_application_syntax]{infix} \term{equality symbol} \enquote{\( \syneq \)}

    \thmitem{def:predicate_logic_alphabet/comma} In addition to the parentheses, we will also need another auxiliary symbol --- the comma \enquote{\( , \)} for delimiting \hyperref[con:function_arguments]{function arguments}.
  \end{thmenum}
\end{definition}

\begin{remark}\label{rem:notation_for_quantifiers}
  There are different possible notations for formulas with \hyperref[def:predicate_logic_alphabet/quantifiers]{quantifier}. We use the most straightforward notation, \( \qforall x \varphi \), because it seems to be dominating --- it is used in
  \cite[ch. 2]{Hinman2005Logic},
  \cite[ch. II]{Kleene2002Logic},
  \cite[ch. IV]{Smullyan1995FOL},
  \cite[\S I.9]{КолмогоровДрагалин2006Логика},
  \cite[def. 2.1.6]{Герасимов2011Вычислимость},
  \cite[ch. 3]{ШеньВерещагин2017ЯзыкиИИсчисления} and
  \cite[ch. II]{Эдельман1975Логика}.

  Another options is to use \( \quantifier* \synforall x \varphi \) in order to stay consistent with \( \muplambda \)-calculus --- see \cref{rem:lambda_term_abstractor_dot} for the relevant discussion regarding \hyperref[def:lambda_term]{\( \muplambda \)-terms}. This convention stems from the dot delimiters of Russell and Whitehead, which are discussed in detail in \cref{ex:dot_delimiters_in_logic}. It is used by \incite{Farmer2008STTVirtues}.

  A general discussion of syntactic conventions for quantifiers can be found in \cite{MathSE:standards_for_quantifier_notation}. The answers suggest \( (\synforall x) \varphi \) as a popular alternative. The latter is used by \incite[\S 20]{Andrews2002Logic}. Ironically, Andrews also discusses his \( \muplambda \)-calculus based system \hyperref[rem:simply_typed_hol]{\( \logic{Q}_0 \)} in the same book, and avoids dots in his \( \muplambda \)-terms.

  We avoid dots after variables in the monograph to keep close to the popular convention, but keep in the code because it aids readability in monospaced text.
\end{remark}

\begin{remark}\label{rem:predicate_logic_formalization}
  We will first present a syntax of predicate logic in \cref{def:simply_typed_hol_abbreviations} via \hyperref[con:metalingual_abbreviation]{abbreviations}, and then describe it via \hyperref[def:formal_grammar]{formal grammar rules} in \cref{def:first_order_syntax} in the special case of first-order logic.

  Still, we will not attempt to fully formalize the metalanguage of inference rules and derivations like we did with propositional logic in \fullref{sec:propositional_axiomatic_derivations} and \fullref{sec:propositional_natural_deduction}, and like we will do for first-order logic in \fullref{sec:first_order_natural_deduction}.

  In this section, our main obstacle is the fundamental reliance on metalingual abbreviation, which requires us to work with several distinct syntaxes simultaneously. Furthermore, the rules \ref{inf:def:simply_typed_hol_proof_tree/rules/r} and \ref{inf:def:simply_typed_hol_proof_tree/rules/beta} carry a lot of subtleties.

  As in \fullref{sec:dependent_types}, formalizing the syntax of inference rules requires a more sophisticated approach than what we have available.
\end{remark}
\begin{comments}
  \item We described in \cref{rem:dependent_type_rule_formalization} several significant complications that arise when formalizing \hyperref[def:mltt]{Martin-L\"of type theory}. As described in \cref{rem:higher_order_logic_and_type_theory/terms}, we will use an approach to \hyperref[rem:predicate_logic]{higher-order logic} that only requires simple types, and is thus more susceptible to formalization.

  More concretely, the concern over \hyperref[rem:well_formed_contexts]{ill-formed type contexts} is inapplicable since we will be working with simple types, and the ambiguity of choice of representatives from \hyperref[con:equality]{judgmental equality classes} is also inapplicable since, as discussed in \cref{rem:typing_rule_eigenvariables}, predicate logic does not assume implicit judgmental equality (except for the \hyperref[con:metalingual_abbreviation]{abbreviations} presented in \cref{def:simply_typed_hol_abbreviations}).

  Still, as described in the remark, formalization of the syntax for the rules of inference requires a more sophisticated approach than what we are willing to invest our effort in.
\end{comments}

\begin{definition}\label{def:function_application_syntax}\mimprovised
  Fix a \hyperref[def:formal_language/symbol]{symbol} \( f \) intended to denote a function of \hyperref[con:function_arguments]{arity} \( n \). The following is a simple \hyperref[def:formal_grammar]{formal grammar rule} for \( f \), specifically for \hyperref[rem:predicate_logic]{predicate logic}:
  \begin{bnf*}
    \bnfprod{function application} {\bnfts{\( f \)} \bnfsp \bnftsq{(} \bnfsp \underbrace{\bnfpn{variable} \bnfsp \bnftsq{,} \bnfsp \cdots \bnfsp \bnftsq{,} \bnfsp \bnfpn{variable}}_{n \T*{variables}} \bnfsp \bnftsq{)}}
  \end{bnf*}

  Here the variable syntax is taken from the ambient \hyperref[def:formal_grammar/schema]{grammar schema}; in simply typed higher-order logic that would be the grammar schema of \hi{uncontextually typed} \( \muplambda \)-terms from \cref{def:typed_lambda_term}.

  We call this the \term[en=prefix notation (\cite[45]{Andrews2002Logic})]{prefix notation}. In the special case where \( n = 0 \), we avoid even the parentheses and use
  \begin{bnf*}
    \bnfprod{function application} {\bnfts{\( f \)}}
  \end{bnf*}

  We can also put the operator after its arguments to obtain \term[en=postfix form (\cite[818]{Rosen2019DiscreteMathematics})]{postfix notation}:
  \begin{bnf*}
    \bnfprod{postfix application} {\bnftsq{(} \bnfsp \underbrace{\bnfpn{variable} \bnfsp \bnftsq{,} \bnfsp \cdots \bnfsp \bnftsq{,} \bnfsp \bnfpn{variable}}_{n \T*{variables}} \bnfsp \bnftsq{)} \bnfsp \bnfts{\( f \)}}
  \end{bnf*}

  The usefulness of postfix notation is limited. We discuss some applications in \cref{rem:def:function_application_syntax}. The only ubiquitous use of it is perhaps the \hyperref[def:factorial]{factorial function} \( n! \).

  For \hyperref[def:binary_operator]{binary operators}, which are traditionally denoted using non-letter symbols, both notations becomes cumbersome. For example, \( \ast(x, y) \) and \( (x, y)\ast \) denote an application of the operator \( \ast \). In this case, we find useful the \term[ru=инфиксная форма (\cite[example 6.6]{БелоусовТкачёв2004ДискретнаяМатематика}), en=infix notation (\cite[833]{HighamEtAl2015PrincetonCompanion})]{infix notation} \( x \ast y \). More generally:
  \begin{bnf*}
    \bnfprod{infix application} {\bnftsq{(} \bnfsp \bnfpn{variable} \bnfsp \bnfts{\( \ast \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{)}}
  \end{bnf*}
\end{definition}
\begin{comments}
  \item The improper symbols used here are the comma and parentheses, both from the corresponding alphabet from \cref{def:predicate_logic_alphabet}.
\end{comments}

\begin{remark}\label{rem:def:function_application_syntax}
  We will discuss here several aspects of \hyperref[def:function_application_syntax]{prefix and postfix notation}.

  \begin{thmenum}
    \thmitem{rem:def:function_application_syntax/s_expression} Prefix notation is the basis of the programming language LISP and its derivatives. These languages feature are based on only one syntactic construct, which, when describing LISP, \incite[187]{McCarthy1960SExpressionsPartI} calls an \term[en=S-expression (\cite[187]{McCarthy1960SExpressionsPartI})]{S-expression}. They can be described via the following \hyperref[def:formal_grammar]{grammar}, assuming a predefined set of atomic \( S \)-expressions (e.g. alphanumeric strings or arithmetic operators):
    \begin{bnf*}
      \bnfprod{S-expression list} {\bnfpn{S-expression} \bnfor \bnfpn{S-expression} \bnfsp \bnftsq{ } \bnfsp \bnfpn{S-expression list}} \\
      \bnfprod{S-expression}      {\bnfpn{atomic S-expression} \bnfor \bnftsq{(} \bnfsp \bnfpn{S-expression list} \bnfsp \bnftsq{)}}
    \end{bnf*}

    For example, the arithmetic expression \( (1 + 2) / 4 \) can be described via the \( S \)-expression
    \begin{center}
      \begin{BVerbatim}[gobble=8]
        (/ (+ 1 2) 4)
      \end{BVerbatim}
    \end{center}

    \thmitem{rem:def:function_application_syntax/polish} \incite*[45]{Andrews2002Logic} explains that prefix notation is also called \enquote{Polish notation} because, in the context of \hyperref[def:propositional_alphabet/connectives]{propositional connectives}, it was used by some Polish logicians. In prefix notation, the formula
    \begin{equation*}
      ((\synp \synwedge \synq) \synimplies \synr)
    \end{equation*}
    becomes
    \begin{equation*}
      (\synimplies (\synwedge \synp \synq) \synr).
    \end{equation*}

    The advantage of this notation is that, knowing the arity of the operators, we can avoid all parentheses because
    \begin{equation*}
      \synimplies \synwedge \synp \synq \synr
    \end{equation*}
    can be parsed unambiguously, unlike
    \begin{equation*}
      \synp \synwedge \synq \synimplies \synr.
    \end{equation*}

    Alonzo Church, who in \cite[38]{Church1956LogicVol1} uses Russell and Whitehead's notation (explained in \cref{ex:dot_delimiters_in_logic}), calls this the \enquote{parenthesis-free notation of Jan \L{}ukasiewicz}. He remarks
    \begin{displayquote}
      The possibility of this is interesting. But the notation so obtained is unfamiliar, and less perspicuous than the usual one.
    \end{displayquote}

    \thmitem{rem:def:function_application_syntax/reverse_polish} Postfix notation is also called \enquote{reverse Polish notation}, for example in \cite[833]{HighamEtAl2015PrincetonCompanion} and \cite[817]{Rosen2019DiscreteMathematics}. It is particularly apt for performing calculations using a stack --- an abstract data type supporting only \enquote{pushing} an element to the top and \enquote{popping} the top element.

    We will sketch the general technique with an example. Consider the arithmetic expression \( (1 + 2) / 4 \). When written in parenthesis-free postfix notation, it becomes
    \begin{center}
      \begin{BVerbatim}[gobble=8]
        1 2 + 4 /
      \end{BVerbatim}
    \end{center}

    We start with an empty stack. We keep reading (space-delimited) \hyperref[def:positional_number_system/decimal]{decimal strings} and pushing the corresponding integers to the stack until we encounter an operator. In our example, when we encounter \( + \), the stack looks as follows:
    \begin{MemoryLine}{2}
      1 & \MemoryLineArrow 2
    \end{MemoryLine}

    Knowing that the operator \( + \) is binary, we pop two elements from the stack and add them. We then push the result to the stack:
    \begin{MemoryLine}{1}
      \MemoryLineArrow 3
    \end{MemoryLine}

    We continue traversing the source string. We again encounter a number, \( 4 \), which we push to the stack:
    \begin{MemoryLine}{2}
      3 & \MemoryLineArrow 4
    \end{MemoryLine}

    It now remains to divide to the two elements of the stack.
  \end{thmenum}
\end{remark}

\begin{remark}\label{rem:simple_type_function_syntax}
  We will often utilize the different notations from \cref{def:function_application_syntax} as notational shorthands in the \hyperref[con:metalogic]{metalanguage} which does not affect the object language.

  Given a (simple) \hyperref[con:type_annotation]{type assertion} \( f: \tau \), we will find it convenient to write \( f(x_1, \ldots, x_n) \) rather than the conventional \( \muplambda \)-term application syntax \( f x_1 \cdots x_n \), which itself is a simplification of the variant with explicit parentheses, \( (\ldots ((f x_1) x_2) \ldots x_n) \).

  To achieve this, we only need to know the arity of \( f \). This is easy for untyped \( \muplambda \)-terms, for which we have defined the arity in \eqref{eq:alg:untyped_lambda_term_to_function/arity}. We will define its counterpart for \hyperref[def:simple_type]{simple types} as follows:
  \begin{equation*}
    \op*{Arity}(\tau) \coloneqq \begin{cases}
      1 + \op*{Arity}(\rho), &\tau = \sigma \synimplies \rho, \\
      0,                     &\T{otherwise.}
    \end{cases}
  \end{equation*}

  As an example, we define in \cref{def:simply_typed_hol_formula} formulas as terms having the type of propositions \( \syn\omicron \). Such a formula \( \varphi \) is nullary, so its prefix and suffix notations are both simply \( \varphi \) itself.

  On the other hand, the predicate \( \varphi \) of type \( \syn\iota \synimplies \syn\iota \synimplies \syn\omicron \) has arity \( 2 \), so we must choose between \( \varphi(x, y) \) and \( x \mathbin{\varphi} y \) and \( (x, y)\varphi \).
\end{remark}

\begin{concept}\label{con:description_operator}
  Bertrand Russell begins his philosophical paper \cite{Russell1905OnDenoting} as follows:
  \begin{displayquote}
    By a \enquote{denoting phrase} I mean a phrase such as any one of the following: a man, some man, any man, every man, all men, the present King of England, the present King of France, the centre of mass of the Solar System at the first instant of the twentieth century, the revolution of the earth round the sun, the revolution of the sun round the earth. Thus a phrase is denoting solely in virtue of its form. We may distinguish three cases: (1) A phrase may be denoting, and yet not denote anything; \textit{e.g.}, \enquote{the present King of France}. (2) A phrase may denote one definite object; \textit{e.g.}, \enquote{the present King of England} denotes a certain man. (3) A phrase may denote ambiguously, \textit{e.g.}, \enquote{a man} denotes not many men, but an ambiguous man. The interpretation of such phrases is a matter of considerable difficulty; indeed, it is very hard to frame any theory not susceptible of formal refutation.
  \end{displayquote}

  Later in the paper, Russell discusses \term{denotations} and how they relate to the meaning of denoting phrases:
  \begin{displayquote}
    When we wish to speak about the \textit{meaning} of a denoting phrase, as opposed to its \textit{denotation}, the natural mode of doing so it by inverted commas.
    \begin{equation*}
      \vdots
    \end{equation*}
    We say to begin with, that when \( C \) occurs it is the \textit{denotation} that we are speaking about; but when \enquote{C} occurs, it is the \textit{meaning}.
  \end{displayquote}

  Russell provides an example --- the first line of Gray's Elegy is the meaning of the sentence \enquote{the first line of Gray's Elegy}, while the textual content of that line is its denotation. When defining the \hyperref[con:evaluation]{evaluation} of a \hyperref[con:expression]{formal expression} in some \hyperref[con:metalogic]{object language}, we are only interested in its denotation.

  With that in mind, we will now inspect Russell's three cases via different \hyperref[con:variable_binding]{variable binders} --- the \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantifier} \( \exists \), David Hilbert's \( \varepsilon \) operator described in \cite{Leisenring1969MathematicalLogic}, and Russell and Whitehead's \( \rotiota \) operator described in \cite[30]{WhiteheadRussell1927PrincipiaMathematicaVol1}, and the unique existence quantifier \( \exists ! \) based on Russell's discussion of definite descriptions in \cite{Russell1905OnDenoting}:
  \begin{center}
    \begin{tabular}{l c c c c}
      \toprule
                                                        & \( \qexists* x p(x) \) & \( \quantifier \varepsilon x p(x) \) & \( \quantifier \rotiota x p(x) \) & \( \qExists* x p(x) \) \\
      \midrule
      \( p(x) \) does not hold for any value of \( x \) & \( F \)                & ambiguous                            & undefined                         & \( F \) \\
      \( p(x) \) holds for a unique value \( x = a \)   & \( T \)                & \( a \)                              & \( a \)                           & \( T \) \\
      \( p(x) \) holds for multiple values of \( x \)   & \( T \)                & ambiguous                            & undefined                         & \( F \) \\
      \bottomrule
    \end{tabular}
  \end{center}

  We now discuss these binders in more detail:
  \begin{thmenum}
    \thmitem{con:description_operator/exists} The \( \exists \) quantifier merely postulates the existence of a value of \( x \) satisfying \( p \).

    \thmitem{con:description_operator/epsilon} The \( \varepsilon \) operator produces a particular value of \( x \) satisfying \( p \), if one exists, and otherwise produces a value \hi{not} satisfying \( p \).

    Hilbert's intention was to define \( \exists \) via \( \varepsilon \) by using \( p(\quantifier \varepsilon x p(x)) \) as an abbreviation for \( \qexists* x p(x) \).

    In this case, the particular value given by \( \varepsilon \) does not matter, but the nondeterminism may be undesirable in general. The semantics suggested by \incite[\S 3.3]{Leisenring1969MathematicalLogic} for \( \quantifier \varepsilon x p(x) \) requires a \hyperref[def:choice_function]{choice function} for determining a particular value of \( x \) satisfying \( p(x) \), and a fixed constant value (independent of \( p \)) in case no value satisfies \( p(x) \). These choices are in general not obvious.

    \incite[\S 8.3]{Farmer2008STTVirtues} calls the \( \varepsilon \) operator \term{indefinite description}.

    \thmitem{con:description_operator/iota} The \( \rotiota \) operator is by intention ill-defined wherever \( \varepsilon \) has an ambiguous value.

    \incite*[30]{WhiteheadRussell1927PrincipiaMathematicaVol1} call it a \term{description} operator. \incite{Farmer2008STTVirtues} suggests calling it \term{definite description} to distinguish it from indefinite descriptions.

    The symbol \( \rotiota \) is an \enquote{inverted} (rotated) Greek iota. In Russell's terms, it provides the denotation of a denoting phrase. The inversion is perhaps reminiscent of how Russell calls \enquote{inverted commas} the quotes that abstract away the meaning of a sentence.

    Unlike Hilbert's \( \varepsilon \) operator, by intention the description is well-defined only in the case (2) of uniqueness and meaningless in the case (1) of nonexistence or (3) of ambiguity.

    We list two suggestions for the semantics of  \( \quantifier \rotiota x p(x) \) in cases (1) and (3):
    \begin{thmenum}
      \thmitem{con:description_operator/iota/error} We can, as with \( \varepsilon \), provide a dedicated \enquote{error value}. This is done by \incite[\S 3.2]{Farmer2008STTVirtues}, and also by \incite[\S 54]{Andrews2002Logic}.

      As in the case of the \( \varepsilon \) operator, such a choice has the downside of generally not being obvious or even meaningful.

      \thmitem{con:description_operator/iota/undefined} Alternatively, we can leave \( \quantifier \rotiota x p(x) \) \hyperref[con:undefinedness]{undefined} in the case of nonuniqueness. This is done by \incite{Farmer1990PartialFunctionSTT}, and, for first-order logic, by \incite{Hamkins2022DefiniteDescriptions} (in several variants).

      This however requires every formula depending on \( \quantifier \rotiota x p(x) \) to possibly be undefined, which leads to elaborate rules of when a formula may even have a truth value.
    \end{thmenum}

    \thmitem{con:description_operator/exists_unique} If we wish to merely postulate the existence of a unique value satisfying \( p \), we can use the \term{unique existential quantifier} \( \exists ! \).

    The formula \( \qExists* x p(x) \) is intended to state the existence of a unique value of \( x \) satisfying \( p(x) \), which comes in two parts:
    \begin{thmenum}
      \thmitem{con:description_operator/exists_unique/exists} There must exist a value \( a_0 \) satisfying \( p \).
      \thmitem{con:description_operator/exists_unique/unique} For every \( b \), if \( b \) satisfies \( p \), then \( b \) must equal \( a_0 \).
    \end{thmenum}

    Unlike the \( \rotiota \) operator with its complexities, this quantifier can easily be defined via other logical connectives, as we will do in \cref{def:simply_typed_hol_abbreviations} for simply typed higher-order logic and in \cref{rem:first_order_formula_conventions/exists_unique} for first-order logic.
  \end{thmenum}
\end{concept}
\begin{comments}
  \item The idea of representing \( \synExists \) via other quantifiers is also due to Russell and is outlined in \cite{Russell1905OnDenoting}.
\end{comments}

\paragraph{Simply typed higher-order logic}

\begin{remark}\label{rem:higher_order_logic_and_type_theory}
  Type theory allows two unrelated approaches to \hyperref[rem:predicate_logic]{higher-order logic}:
  \begin{thmenum}
    \thmitem{rem:higher_order_logic_and_type_theory/terms} As mentioned in \cref{rem:type_theory}, Alonzo Church initially formulated typed \( \muplambda \)-calculus as a way to encode logical formulas via \hyperref[def:typed_lambda_term]{uncontextually typed \( \muplambda \)-terms}.

    This approach has later been extended by his students Leon Henkin and Peter Andrews. The latter describes a \hyperref[con:logical_system]{logical system} \( \logic{Q}_0 \) in \cite[ch. 5]{Andrews2002Logic} based on his and Henkin's refinements. More recently, William Farmer suggests modernized variants of Church's and Andrews' systems; he briefly outlines such a system in \cite{Farmer2008STTVirtues}.

    We present our own variant of their systems based on the availability of \fullref{ch:lambda_calculus}. We sketch its syntax and semantics and then shift our focus to first-order logic as a particularly well-studied restriction.

    Furthermore, this system presupposes \hyperref[con:classical_logic]{classical logic}, while we will discuss \hyperref[con:minimal_logic]{minimal logic} and \hyperref[con:intuitionistic_logic]{intuitionistic} semantics for first-order logic.

    \thmitem{rem:higher_order_logic_and_type_theory/types} A much more powerful approach is based on the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, which hints at how \hi{types} rather than \( \muplambda \)-terms can be used to encode logical formulas.

    The correspondence itself is briefly outlined in \cref{con:curry_howard_correspondence} and formalized for \hyperref[def:propositional_syntax/formula]{propositional formulas} via \fullref{alg:type_derivation_to_proof_tree} and \fullref{alg:proof_tree_to_type_derivation}.

    We describe in \cref{rem:mltt_hol} how \hyperref[def:mltt]{Martin-L\"of type theory} can be used as a form of higher-order logic.

    We avoid this approach because, although it is rightfully considered elegant, it is also much more complicated to study metatheoretically.
  \end{thmenum}
\end{remark}

\begin{concept}\label{con:primitive_notion}
  In a sufficiently complex \hyperref[con:metalogic]{object theory}, different notions can be defined via each other. If we want to use \hyperref[def:well_founded_relation]{well-founded} notions that are not defined circularly via each other, we must choose a subset of them that should to be characterized via axioms, and then use them to define the rest (we discuss such definitions more broadly in \ref{con:metalingual_abbreviation}). Following \incite[28]{Kleene1971Metamathematics}, we will refer call these notions as \term{primitive}.

  For instance, when formalizing \hyperref[def:lattice]{lattices}, we may use an object theory based on one \hyperref[def:partially_ordered_set]{partial order relation} \( {\synleq} \), as we have done in \cref{def:lattice/theory}, or we may use a theory based on two operations \( {\synvarwedge} \) and \( {\synvarvee} \).

  The object language will feature all three symbols anyway. If we use the formalization from \cref{def:lattice/theory}, however, we will specify the behavior of \( {\synleq} \) via axioms, while the behavior of \( {\synvarwedge} \) and \( {\synvarvee} \) will be defined via that of \( {\synleq} \). Conversely, \cref{thm:lattice_from_binary_operations} shows how we can take \( {\synvarwedge} \) and \( {\synvarvee} \) as primitive and use them to specify how \( {\synleq} \) behaves.

  Usually the essential object of study is taken as primitive --- for example, sets are primitive in \fullref{ch:set_theory}, groups are primitive in \fullref{ch:group_theory}, vectors are primitive in \fullref{ch:linear_algebra} and so forth. This is mildly ironic because, for example, linear algebra cannot answer what a vector is beyond characterizing it as \enquote{an element of an abstract vector space}.
\end{concept}
\begin{comments}
  \item In addition to the adjective \enquote{primitive}, \incite[28]{Kleene1971Metamathematics} suggests \enquote{technical} and \enquote{undefined}. We will avoid the latter term because it would conflict with undefinedness as described in \cref{con:undefinedness}. See \cref{rem:undefined_and_primitive_terms} for disambiguation of the different notions of undefinedness.

  \item We avoid introducing a distinct term for symbols whose behavior is defined via others. \incite[28]{Kleene1971Metamathematics} suggests \enquote{ordinary}, \enquote{logical} and \enquote{defined}.
\end{comments}

\begin{remark}\label{rem:simply_typed_hol}
  As mentioned in \cref{rem:higher_order_logic_and_type_theory/terms}, we are interested is a variant of Church's typed \( \muplambda \)-calculus that allows us to outline some aspects of \hyperref[rem:predicate_logic]{predicate logic}.

  This approach is based on simply typed \( \muplambda \)-calculus, and we will assume the availability of \fullref{ch:lambda_calculus}.

  In order to express logical constructs, \incite[56]{Church1940STT} suggested using logical formulas as \hyperref[con:metalingual_abbreviation]{abbreviations} for certain \( \muplambda \)-terms. There are two languages involved --- the familiar syntax of simply typed \( \muplambda \)-terms over a dedicated \hyperref[def:simple_type_signature]{signature}, as well as a dedicated syntax for higher-order logic. These are appropriately viewed as distinct layers rather than alternatives, since both the syntax and semantics of the logical formulas depends on the underlying \( \muplambda \)-terms, while the usability of the system as an \hyperref[def:abstract_logic]{abstract logic} relies on the upper \enquote{logical} layer.

  Church's type theory is briefly described in \cref{rem:type_theory}; there are three notable ways in which it differs from ours. The first is minor and only concerns notation --- we denote by \( \tau \synimplies \sigma \) the arrow type that Church denotes by \( (\sigma\tau) \).

  The second one is more significant. Church places a \hyperref[con:type_annotation]{type annotation} on every \( \muplambda \)-term (even though many of the types are in fact \hyperref[def:polymorphic_typed_lambda_calculus]{polymorphic} and require formal adjustments). As discussed in \cref{rem:simply_typed_hol_type_annotations}, we will annotate all variables (but not the constants or the other \( \muplambda \)-terms). This will lead us to define a variant of typed \( \muplambda \)-terms in \cref{def:freely_typed_lambda_term}.

  The third notable difference concerns the choice of \hyperref[con:primitive_notion]{primitive constant \( \muplambda \)-terms}. When presenting his logical system, Church uses several constants --- \( N_{oo} \) for \hyperref[def:propositional_alphabet/negation]{negation}, \( A_{ooo} \) for \hyperref[def:propositional_alphabet/connectives/conjunction]{conjunction}, \( \Pi_{o(o\alpha)} \) for \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantification} and \( \iota_{\alpha(o\alpha)} \) for \hyperref[con:description_operator/iota]{definite description}. The other logical constants, connectives and quantifiers are then built from these via \( \muplambda \)-abstraction and application.

  \incite*{Henkin1963TheoryOfPropositionalTypes} presents a formulation that uses only \( Q_{o \alpha \alpha } \) for \hyperref[def:predicate_logic_alphabet/equality]{equality}, acknowledging that one such constant is needed for each type \( \alpha \). His formulation is restricted to propositional formulas, but later in \cite{Henkin1975Identity} he extends it to all types supported by Church's original system.

  \incite*[\S 51]{Andrews2002Logic} presents a refinement of the systems of Church, Henkins and himself. Andrews calls this system \( \logic{Q}_0 \). It is based on two (familiar) of primitive constant \( \muplambda \)-terms --- \( Q_{o \alpha \alpha} \) for formal equality and \( \iota_{\iota (o \iota)} \) for definite description.

  A modernized presentation is suggested by \incite{Farmer2008STTVirtues}, who uses our simplified syntax and makes explicit the notion of signature\fnote{Even though Andrews different sets of constants, he does not have a clear notion of signature.}. Farmer also introduces dedicated syntax for equality and definite descriptions, and experiments with semantics, especially regarding definite descriptions.

  We use a combination of all the systems presented above, with comments reflecting our choices. The major difference with \( \logic{Q}_0 \) is that we discard the description operator because of the semantic problems described in \cref{con:description_operator/iota}.
\end{remark}

\begin{remark}\label{rem:simply_typed_hol_type_annotations}
  When defining typed \( \muplambda \)-terms in \cref{def:typed_lambda_term}, we placed \hyperref[con:type_annotation]{type annotations} only on abstractor variables. If \( f \) and \( x \) are both variables, the \( \muplambda \)-term \( fx \) is typable in the context \( \Gamma = f: \tau \synimplies \sigma, x: \tau \), but not if we swap the types of \( f \) and \( x \).

  Although this approach is suitable for \fullref{ch:lambda_calculus}, in \hyperref[def:simply_typed_hol]{simply typed higher-order logic} becomes inconvenient because we have to deal with both type contexts (consisting of type assertions) and logical contexts (consisting of formulas that may depend on type contexts). We will find it easier to eliminate the need of type contexts by instead annotating all variables. There are several immediate considerations:
  \begin{itemize}
    \item The \( \muplambda \)-term \( f^{\tau \synimplies \sigma} x^\tau \) is unconditionally \hyperref[def:typability]{\hi{typable}}, while \( f^\tau x^{\tau \synimplies \sigma} \) is unconditionally \hi{untypable}.

    The usefulness of untypable \( \muplambda \)-terms is questionable. So, naturally, we must restrict ourselves only to those \( \muplambda \)-terms that are typable according to the rules of the system.

    \item The \( \muplambda \)-term \( x^{\tau \synimplies \sigma} x^\tau \) that uses multiple annotations for the same variable forces us to deviate from how \hyperref[def:type_context]{type contexts} require each free variable to have a unique type.

    We want to avoid straying unnecessarily from the theory in \fullref{ch:lambda_calculus}.

    \item We want to avoid visual clutter when annotating bound variables because \( \qabs {f^{\tau \synimplies \sigma}} f^{\tau \synimplies \sigma} x^\tau \) is unnecessarily verbose compared to \( \qabs {f^{\tau \synimplies \sigma}} f x^\tau \).

    Fortunately, this can be done in the \hyperref[con:metalingual_abbreviation]{metalanguage} without changing the underlying object language.
  \end{itemize}

  The aforementioned considerations lead to \cref{def:freely_typed_lambda_term}.
\end{remark}

\begin{definition}\label{def:simply_typed_hol_signature}\mimprovised
  A \hyperref[con:improper_symbol]{signature} \( \Sigma \) for simply typed higher-order logic consists of two \hi{nonempty} sets, \( \op*{Sort}_\Sigma \) and \( \op*{NLConst}_\Sigma \), which must act as follows:
  \begin{thmenum}
    \thmitem{def:simply_typed_hol_signature/types} The elements of \( \op*{Sort}_\Sigma \), which we will call \term[en=sorts (\cite[35]{BaaderNipkow2012TermRewriting})]{sorts}, act as base types along with a dedicated type symbol \( \syn\omicron \) for \hyperref[con:boolean_value]{Boolean values} called the \term[en=type of propositions (\cite[56]{Church1940STT})]{type of propositions}.

    As mentioned in \cref{con:simple_type_theory/hol}, we are interested in the \hyperref[con:syntax_fragment]{fragment} of \hyperref[def:simple_type]{simple types} over these base types with only arrow types (i.e. without product and sum types or even type variables). The sorts must not include improper symbols from \cref{def:simple_type_alphabet}, but are allowed to range over small Greek identifiers because there are no type variables to clash with (we have used small Greek omicron to denote the type of propositions).

    Unless explicitly noted otherwise, we suppose that \( \op*{Sort}_\Sigma \) consists of a single symbol --- \( \syn\iota \) --- called the \term[en=type of individuals (\cite[56]{Church1940STT})]{type of individuals}\fnote{The term \enquote{individuals} is discussed in \cref{con:ramified_type_theory/types}. The symbol we use to denote their type is Church's small iota from \cite[56]{Church1940STT} with a dot on top, as per \cref{rem:object_language_dots}.}.

    If there is more than one sort, we call the resulting logical system \term[en=many-sorted predicate logic (\cite[\S 4.4.13]{TroelstraSchwichtenberg2000BasicProofTheory})]{many-sorted}.

    \thmitem{def:simply_typed_hol_signature/const} The elements of \( \op*{NLConst}_\Sigma \) should be \hyperref[def:type_assertion]{type assertions} for \hi{distinct} \( \muplambda \)-term constants. We call them \term[en=nonlogical constants (\cite[211]{Andrews2002Logic})]{nonlogical constants}.

    Additionally, we have a single constant, \( \synQ \), for denoting equality as per \cref{rem:simply_typed_hol}. Naturally, we call it a \term[en=logical constants (\cite[211]{Andrews2002Logic})]{logical constant} to distinguish it from the rest. We associate no \hyperref[con:type_annotation]{type annotations} with it because the annotation must be \hyperref[def:polymorphic_typed_lambda_calculus]{polymorphic}, while we are working only with simple types. \hyperref[con:typing_rule]{Typing rules} for \( \synQ \) will be provided in \cref{def:simply_typed_hol_typing/equality}.

    The logical and nonlogical constants, along with the base types discussed above, form a \hyperref[def:simple_type_signature]{simple type signature}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is loosely based on \bycite[270]{Farmer2008STTVirtues}:
  \begin{displayquote}
    A \textit{language} of STT is a pair \( L = (\mscrC, \tau) \) where is \( \mscrC \) is a set of symbols called \textit{constants} and \( \tau: \mscrC \to \mscrT \) is a total function. That is, a language is a set of symbols with assigned types (what computer scientists usually call a \enquote{signature}). The constants are the nonlogical primitive symbols that are used to construct the expressions of the language.
  \end{displayquote}

  Farmer assumes here that \( \syn\iota \) is the only sort, but later suggests adding other sorts (which he calls base types).

  We have decided to call the non-propositional base types \enquote{sorts} based on similar usage in many-sorted first-order logic, which is discussed in \cite[\S 4.4.13]{TroelstraSchwichtenberg2000BasicProofTheory} and \cite[def. 62]{GoguenBurstall1992Institutions}.

  \item Sorts as defined here are unrelated to sorts in \hyperref[def:pure_type_system]{pure type systems}, which act as \hyperref[con:type_universe]{type universes} rather than types.

  \item We stated in \cref{rem:logical_symbol_terminology} that the separation into \enquote{logical} and \enquote{nonlogical} symbols is generally ambiguous, but in this case there will be no ambiguity because we specify the kind of entity we refer to, e.g. \enquote{logical constant \( \muplambda \)-term} rather than simply \enquote{logical symbol}.
\end{comments}

\begin{definition}\label{def:simply_typed_hol_typing}\mimprovised
  In addition to the arrow \hyperref[con:typing_rule]{typing rules} \ref{inf:def:arrow_type/elim} and \ref{inf:def:arrow_type/intro/explicit}, we introduce several rules for the \( \muplambda \)-terms of a given \hyperref[def:simply_typed_hol_signature]{simply typed higher-order logic signature}:
  \begin{thmenum}
    \thmitem{def:simply_typed_hol_typing/var} As discussed in \cref{rem:simply_typed_hol_type_annotations}, we want to avoid the need for \hyperref[def:type_context]{type contexts} by placing \hyperref[con:type_annotation]{type annotations} on all variables. We will use the following rule to justify this:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Var} }]{inf:def:simply_typed_hol_typing/var}
      \begin{prooftree}
        \infer0[\ref{inf:def:simply_typed_hol_typing/var}]{ x^\tau: \tau }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:simply_typed_hol_typing/equality} The following rule allows typing the \hyperref[def:simply_typed_hol_signature/const]{equality logical constant} \( \synQ \):
    \begin{equation*}\taglabel[\ensuremath{ Q_+ }]{inf:def:simply_typed_hol_typing/equality}
      \begin{prooftree}
        \hypo{ M: \tau }
        \hypo{ N: \tau }
        \infer2[\ref{inf:def:simply_typed_hol_typing/equality}]{ \synQ M N: \syn\omicron }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:simply_typed_hol_typing/const} For every assertion \( C: \tau \) among non-logical constants of the signature, we need the following rule:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Ax}_C }]{inf:def:simply_typed_hol_typing/const}
      \begin{prooftree}
        \infer0[\ref{inf:def:simply_typed_hol_typing/const}]{ C: \tau }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item As presented, all rules are in fact simple typing rules, i.e. it can be easily expressed via formalized schemas. We mostly avoid such schemas because, as discussed in \cref{rem:predicate_logic_formalization}, the syntax and derivation system of higher-order logic has many subtleties elsewhere.
\end{comments}

\begin{definition}\label{def:freely_typed_lambda_term}\mimprovised
  As discussed in \cref{rem:simply_typed_hol_type_annotations}, we will need to adjust typed \( \muplambda \)-terms from \cref{def:typed_lambda_term} for \hyperref[def:simply_typed_hol]{simply typed higher-order logic}.

  Consider the \hyperref[def:formal_grammar]{grammar} from \cref{def:typed_lambda_term}, but with the rule \( \bnfpn{atom} \) replaced with
  \begin{bnf*}
    \bnfprod{atom}               {\bnfpn{annotated variable} \bnfor \bnfpn{constant}}
  \end{bnf*}

  We will call such \( \muplambda \)-terms \term{freely typed} since they do not depend on a \hyperref[def:type_context]{type context}. Given a \hyperref[def:simply_typed_hol_signature]{signature}, we can determine which of them are \hyperref[def:typability]{typable} with respect to the rules from \cref{def:simply_typed_hol_typing}. We will consider the rest \hyperref[con:expression]{ill-formed} (or rather ill-typed) and disregard them.

  We will also consider ill-formed those \( \muplambda \)-terms in which a single free variable has more than one annotation. This reflects how free variables are affected by type contexts.

  To avoid visual clutter, within the \hyperref[con:metalingual_abbreviation]{metalanguage} we will avoid annotating bound variables since their type does not depend on a type context anyway.
\end{definition}
\begin{comments}
  \item We want our theory to stay as closely as possible to that presented in \fullref{ch:lambda_calculus}, so our annotated free variables merely \enquote{embed} the types that would otherwise be part of a type context.

  As a benefit, with cosmetic adaptations, we can reuse \Fullref{alg:simply_typed_substitution}, \fullref{alg:simply_typed_substitution} and \fullref{alg:simply_typed_reduction}.

  \item Farmer's \enquote{STT expressions} from \cite[270]{Farmer2008STTVirtues} are also based on typed \( \muplambda \)-terms with annotations on all variables and unannotated constants.

  Farmer allows the same variable to have multiple annotations, however. This is also technically allowed by \incite[57]{Church1940STT} and \incite[211]{Andrews2002Logic}, who consider variables of different types to be distinct.

  \item We only allow unannotated constants because constants do not need type hints; the rule \ref{inf:def:simply_typed_hol_typing/const} can be used to unambiguously derive the type of a non-logical constant, while the equality constant \( \synQ \) cannot be annotated via \hyperref[def:simple_type]{simple types} anyway.
\end{comments}

\begin{proposition}\label{thm:simply_typed_hol_type_uniqueness}
  The type of a (well-formed) \hyperref[def:freely_typed_lambda_term]{freely typed \( \muplambda \)-term} is unique.
\end{proposition}
\begin{proof}
  Let \( T \) and \( T' \) be tree deriving \( M: \tau \) and \( M: \tau' \), correspondingly. We will show that \( T \) and \( T' \) coincide, from which it will also follow that \( \tau = \tau' \).

  Assuming \( x \) is free in \( M \), we will also show that all annotations of \( x \) coincide.

  For this, we must use \fullref{thm:induction_on_rooted_trees} on \( T \), simultaneously on all \( T' \):
  \begin{itemize}
    \item If \( T \) is an application tree for \ref{inf:def:simply_typed_hol_typing/var}, then \( M = x^\tau \) for some variable \( x \) and type \( \tau \).

    In this case the only possibility for \( T' \) is to also be an application of \ref{inf:def:simply_typed_hol_typing/var}, and for \( T \) and \( T' \) to coincide.

    \item If \( T \) is an application tree for \ref{inf:def:simply_typed_hol_typing/const}, then \( M \) is a nonlogical constant, and the only possibility for \( T' \) is to be an application of the same rule.

    \item If \( T \) is an application tree for \ref{inf:def:simply_typed_hol_typing/equality}, then \( M = \synQ N K \) for some \( \muplambda \)-terms \( N \) and \( K \), \( \tau = \omicron \) and \( T \) has subtrees \( T_N \) and \( T_K \) deriving \( N: \sigma \) and \( K: \sigma \) for some type \( \sigma \).

    Then \( T' \) must also be an application tree for \ref{inf:def:simply_typed_hol_typing/equality}. Then its subtrees \( T_N' \) and \( T_K' \) derive \( N: \sigma' \) and \( K: \sigma' \) for some type \( \sigma' \).

    Since the inductive hypothesis holds for \( T_N \) and \( T_K \), we can conclude that \( \sigma = \sigma' \), and therefore the two derivation trees in each pair coincide.

    \item If \( T \) is an application of \ref{inf:def:arrow_type/elim} or \ref{inf:def:arrow_type/intro/explicit}, we proceed as in \cref{thm:typed_term_habitation_uniqueness}.
  \end{itemize}
\end{proof}

\begin{definition}\label{def:simply_typed_hol}
  We call \term{simply typed higher-order logic} over the \hyperref[def:simply_typed_hol_signature]{eponymous signature} the \hyperref[def:simple_type_system]{simple type system} based on the rules from \cref{def:simply_typed_hol_typing}\fnote{Unlike the type systems we consider in \fullref{ch:lambda_calculus}, here we work with \hyperref[def:freely_typed_lambda_term]{freely typed \( \muplambda \)-terms}. Still, many concepts for simple type systems are useful with only cosmetic adaptation.}.
\end{definition}
\begin{comments}
  \item We consider the following an indispensable part of the system:
  \begin{itemize}
    \item The \enquote{logical layer} of the syntax, introduced via \hyperref[con:metalingual_abbreviation]{metalinguistic abbreviations} in \cref{def:simply_typed_hol_formula}.
    \item The axiomatic derivation proof system described in \cref{def:simply_typed_hol_proof_tree}.
  \end{itemize}
\end{comments}

\begin{definition}\label{def:simply_typed_hol_formula}\mcite[270]{Farmer2008STTVirtues}
  A \term{formula} of \hyperref[def:simply_typed_hol]{simply typed higher-order logic} is a \( \muplambda \)-term \hyperref[def:type_habitation]{inhabiting} the \hyperref[def:simply_typed_hol_signature/types]{type of propositions} \( \syn\omicron \).

  More generally, a \term{predicate} is a \( \muplambda \)-term inhabiting \( \tau \synimplies \syn\omicron \) for some type \( \tau \). It is convenient for a predicate to utilize the prefix notation from \cref{def:function_application_syntax}; that is, if \( p \) has arity \( n \), we write \( p(x_1, \ldots, x_n) \).
\end{definition}
\begin{comments}
  \item We will present a dedicated syntax for formulas in \cref{def:simply_typed_hol_abbreviations} based on \hyperref[con:metalingual_abbreviation]{metalinguistic abbreviations}. First-order logic will allow a simple description of formulas via \hyperref[def:formal_grammar]{formal grammars} --- see \ref{def:first_order_syntax}.

  \item We will justify the use of \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} in \cref{def:simply_typed_hol_proof_tree}, which will allow us to regard \( p(x_1, \ldots, x_n) \) as function application in the sense of \fullref{alg:untyped_lambda_term_to_function}.
\end{comments}

\begin{concept}\label{con:metalingual_abbreviation}\mimprovised
  We discussed in \cref{con:primitive_notion} how, in a fixed \hyperref[con:metalogic]{object language}, some symbols are considered primitive and characterized via axioms, while others are defined using the established primitive symbols.

  It is impractical to make a definitive list of all useful symbols beforehand. Furthermore, it is often handy to introduce ad-hoc relations and operations, and fundamentally necessary to be able to name new functions. This amounts to collapsing an arbitrarily complicated \hyperref[con:expression]{expression} to a single symbol.

  Definitional extensions, which we will discuss in \cref{def:simply_typed_definitional_extension}, provide a rigorous way to perform this. We will also find convenient to use metalingual notational shorthands that do not affect the object language, similarly to the parenthesis conventions for \hyperref[def:propositional_syntax/formula]{propositional formulas} from \cref{rem:propositional_formula_notation_conventions}. When we introduce a metalingual symbol that acts as a shorthand for a more complicated expression, we call the symbol an \term{abbreviation}.

  Abbreviations have subtleties that are handled differently in simply typed higher-order logic and in first-order logic. See \cref{rem:simply_typed_hol_abbreviations} for the former and \cref{rem:first_order_abbreviations} for the latter.
\end{concept}
\begin{comments}
  \item Abbreviations often presuppose not only collapsing an expression to one symbol, but also using a specific notation. Being only metalinguistic shorthands, abbreviations allow us to freely use any notation we like.

  Different cases are discussed in \cref{rem:simple_type_function_syntax}.
\end{comments}

\begin{definition}\label{def:freely_typed_lambda_term_schema}
  We generalize the schemas for context-dependent typed \( \muplambda \)-terms from \cref{def:lambda_term_schema} to \hyperref[def:freely_typed_lambda_term]{freely typed \( \muplambda \)-terms} by endowing variable and term placeholders with \hyperref[con:type_annotation]{type annotations}.

  Such a schema depends on a \hyperref[def:simply_typed_hol_signature]{simply typed higher-order logic signature}. We thus disallow the sorts and constant symbols as placeholders. In particular, \( \synQ \) will always refer to the equality constant rather than a term placeholder, while \( \syn\omicron \) will always refer to the type of propositions rather than a type placeholder.

  We also disallow multiple annotations on the same placeholder since they are likely to produce an ill-formed \( \muplambda \)-term.
\end{definition}

\begin{definition}\label{def:simply_typed_hol_abbreviations}\mcite[212]{Andrews2002Logic}
  For \hyperref[def:simply_typed_hol]{simply typed higher-order logic}, we will use \hyperref[con:metalingual_abbreviation]{metalingual abbreviation} to introduce a dedicated syntax for \hyperref[def:simply_typed_hol_formula]{formulas}.

  The \( \muplambda \)-term schemas and their intended notation are listed in \cref{tab:def:simply_typed_hol_abbreviations}. The placeholders in the notation should match those in the schema, while the rest are allowed to take any value.

  \begin{table}
    \begin{center}
      \begin{tabular}{l l}
        \toprule
        \multicolumn{1}{c}{Metalingual abbreviation}        & \multicolumn{1}{c}{Metalingual \( \muplambda \)-term schema}                                                                                                                                                                          \\
        \midrule
        \( M^\tau \syneq N^\tau \)                          & \( \synQ M^\tau N^\tau \)                                                                                                                                                                                                             \\
        \( \syntop \)                                       & \( (\qabs {\synp^{\syn\omicron}} \synp) \syneq (\qabs {\synp^{\syn\omicron}} \synp) \)                                                                                                                                                \\
        \( \synbot \)                                       & \( (\qabs {\synp^{\syn\omicron}} \syntop) \syneq (\qabs {\synp^{\syn\omicron}} \synp) \)                                                                                                                                              \\
        \( \synneg P^{\syn\omicron} \)                      & \( \synbot \syneq P^{\syn\omicron} \)                                                                                                                                                                                                 \\
        \( P^{\syn\omicron} \synwedge R^{\syn\omicron} \)   & \( (\qabs {f^{\syn\omicron \synimplies \syn\omicron \synimplies \syn\omicron}} \syns \syntop \syntop) \syneq (\qabs {f^{\syn\omicron \synimplies \syn\omicron \synimplies \syn\omicron}} \syns P^{\syn\omicron} R^{\syn\omicron}) \), \\
                                                            & \quad where \( f = \sharp(\op*{Free}(P) \cup \op*{Free}(R)) \)                                                                                                                                                                        \\
        \( P^{\syn\omicron} \synvee R^{\syn\omicron} \)     & \( \synneg (\synneg P^{\syn\omicron} \synwedge \synneg R^{\syn\omicron}) \)                                                                                                                                                           \\
        \( P^{\syn\omicron} \synimplies R^{\syn\omicron} \) & \( P^{\syn\omicron} \syneq P^{\syn\omicron} \synwedge R^{\syn\omicron} \)                                                                                                                                                             \\
        \( P^{\syn\omicron} \syniff R^{\syn\omicron} \)     & \( P^{\syn\omicron} \syneq R^{\syn\omicron} \)                                                                                                                                                                                        \\
        \( \qforall {x^\tau} P^{\syn\omicron} \)            & \( (\qabs {x^\tau} P^{\syn\omicron}) \syneq (\qabs {x^\tau} \syntop) \)                                                                                                                                                               \\
        \( \qexists {x^\tau} P^{\syn\omicron} \)            & \( \synneg (\qforall {x^\tau} \synneg P^{\syn\omicron}) \)                                                                                                                                                                            \\
        \bottomrule
      \end{tabular}
    \end{center}

    \caption{Encoding \hyperref[rem:predicate_logic]{predicate logic} in \hyperref[def:simply_typed_hol]{simply typed higher-order logic}.}\label{tab:def:simply_typed_hol_abbreviations}
  \end{table}
\end{definition}
\begin{comments}
  \item Most abbreviations are based on \bycite[212]{Andrews2002Logic}, with the exception of \( \syntop \), taken from \bycite[273]{Farmer2008STTVirtues}.
\end{comments}

\paragraph{Proofs in simply typed higher-order logic}

\begin{definition}\label{def:simply_typed_hol_proof_tree}\mimprovised
  We will now define a \hyperref[def:consequence_relation]{consequence relation} for \hyperref[def:simply_typed_hol_formula]{formulas} of \hyperref[def:simply_typed_hol]{simply typed higher-order logic} based on a combination of axiomatic derivations for propositional logic from \fullref{sec:propositional_axiomatic_derivations} and natural deduction from \fullref{sec:propositional_natural_deduction}.

  \begin{thmenum}[series=def:simply_typed_hol_proof_tree]
    \thmitem{def:simply_typed_hol_proof_tree/axioms} The following will act as axiom schemas:
    \begin{align}
      &\synP^{\syn\omicron \synimplies \syn\omicron}(\syntop) \synwedge \synP^{\syn\omicron \synimplies \syn\omicron}(\synbot) \syniff \qforall {\synx^{\syn\omicron}} \synP^{\syn\omicron \synimplies \syn\omicron}(\synx) \tag{\logic{A1}} \label{eq:def:simply_typed_hol_proof_tree/axioms/a1} \\
      &(\synX^{\syn\tau} \syneq \synY^{\syn\tau}) \synimplies \qforall {\synp^{\syn\tau \synimplies \syn\omicron}} (\synp(\synX^{\syn\tau}) \syniff \synp(\synY^{\syn\tau}) \tag{\ensuremath{ \logic{A2} }} \label{eq:def:simply_typed_hol_proof_tree/axioms/a2} \\
      &(\synF^{\syn\tau \synimplies \syn\sigma} \syneq \synG^{\syn\tau \synimplies \syn\sigma}) \syniff \qforall {\synx^{\syn\tau}} (\synF^{\syn\tau \synimplies \syn\sigma}(\synx) = \synG^{\syn\tau \synimplies \syn\sigma}(\synx)) \tag{\ensuremath{ \logic{A3} }} \label{eq:def:simply_typed_hol_proof_tree/axioms/a3}
    \end{align}

    These schemas generalize those for context-dependent typed \( \muplambda \)-terms from \cref{def:lambda_term_schema} by placing type annotations over \( \muplambda \)-term placeholders. We will not use formalized schemas for freely typed \( \muplambda \)-terms elsewhere.

    The schema \eqref{eq:def:simply_typed_hol_proof_tree/axioms/a2} is a form of the \enquote{indiscernibility of identicals} principle discussed in \cref{rem:identity_of_indiscernibles}, while \eqref{eq:def:simply_typed_hol_proof_tree/axioms/a3} is a form of function extensionality, which as a general principle we discuss in \cref{con:extensionality}.

    Unsurprisingly, we refer to instances of an axiom schema as \term{axioms}.

    \thmitem{def:simply_typed_hol_proof_tree/reduction} We will need ad-hoc \( \muplambda \)-term reduction relations. Namely, for every pair of \( \muplambda \)-terms \( A \) and \( B \) and every set of variables \( V \), we define a reduction relation based on the following rule:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_{A \mapsto_V B} }]{inf:def:simply_typed_hol_proof_tree/reduction/base}
      \begin{prooftree}
        \infer0[\ref{inf:def:simply_typed_hol_proof_tree/reduction/base}]{ A \redrel{A \mapsto_V B} B }.
      \end{prooftree}
    \end{equation*}

    As per \cref{def:typed_term_reduction}, we extend this relation via the rules \ref{inf:def:lambda_term_reduction/alpha}, \ref{inf:def:lambda_term_reduction/app_left} and \ref{inf:def:lambda_term_reduction/app_right}, but modify \ref{inf:def:typed_term_reduction/abs} as follows:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_{A \mapsto_V B} }]{inf:def:simply_typed_hol_proof_tree/reduction/abs}
      \begin{prooftree}
        \hypo{ M \redrel{A \mapsto_V B} N }
        \hypo{ x \not\in V }
        \infer2[\ref{inf:def:simply_typed_hol_proof_tree/reduction/abs}]{ \qabs {x^\tau} M \redrel{A \mapsto_V B} \qabs {x^\tau} N }.
      \end{prooftree}
    \end{equation*}

    The reduction relation \( {\redrel{A \mapsto_V B}} \) replaces a single occurrence of \( A \) with \( B \), as long as it is not in the body of an abstraction whose variable lies in \( V \).

    \thmitem{def:simply_typed_hol_proof_tree/rules} We will rely on the following \hyperref[def:inference_rule]{inference rules}:
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{A}_n }]{inf:def:simply_typed_hol_proof_tree/rules/an}
          \begin{prooftree}
            \infer0[\ref{inf:def:simply_typed_hol_proof_tree/rules/an}]{ M },
          \end{prooftree}
        \end{equation*}
        where \( M \) is an instance of axiom \( \logic{A}n \), \( n = 1, 2, 3 \).
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{A}_4 }]{inf:def:simply_typed_hol_proof_tree/rules/beta}
          \begin{prooftree}
            \infer0[\ref{inf:def:simply_typed_hol_proof_tree/rules/beta}]{ M \syneq N },
          \end{prooftree}
        \end{equation*}
        where \( M \bred N \).
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{R} }]{inf:def:simply_typed_hol_proof_tree/rules/r}
          \begin{prooftree}
            \hypo{ M }
            \hypo{ A \syneq B }
            \infer2[\ref{inf:def:simply_typed_hol_proof_tree/rules/r}]{ N },
          \end{prooftree}
        \end{equation*}
        where \( M \redrel{A \mapsto B}_\Gamma N \).
      \end{nthcolumn}
    \end{paracol}

    In \ref{inf:def:simply_typed_hol_proof_tree/rules/r}, \( A \), \( B \) and \( V \) are parameters that should be provided when applying the rule.

    \thmitem{def:simply_typed_hol_proof_tree/proof} \hyperref[con:proof_tree]{Proof trees} for \hyperref[def:simply_typed_hol_formula]{formulas of simply typed higher-order logic} are rather simple since no discharging or eigenvalues are involved, but their inherent nondeterminism makes them hard to formalize.

    To use the rule \ref{inf:def:simply_typed_hol_proof_tree/rules/r}, we fix arbitrary \( \muplambda \)-terms \( A \) and \( B \) of the same type and define
    \begin{equation*}
      V \coloneqq \parens[\Big]{ \op*{Free}(A) \cup \op*{Free}(B) } \cap \bigcup_{M \in \Gamma} \op*{Free}(M),
    \end{equation*}
    where \( \Gamma \) is the set of assumptions of the premise subtrees of \( A \) and \( B \).

    \thmitem{def:simply_typed_hol_proof_tree/consequence} Finally, we let \( \Gamma \vdash \varphi \) if there exists a proof tree with conclusion \( \varphi \) whose assumptions are in \( \Gamma \).
  \end{thmenum}
\end{definition}
\begin{defproof}
  We can prove that \( {\vdash} \) is indeed a \hyperref[def:consequence_relation]{consequence relation} similarly to how we have done this for propositional logic in \cref{def:axiomatic_derivation_entailment}.
\end{defproof}
\begin{comments}
  \item This definition is amalgamated from all \hyperref[con:logical_system]{logical systems} discussed in \cref{rem:simply_typed_hol}. Namely, the axiom schemas \eqref{eq:def:simply_typed_hol_proof_tree/axioms/a1}, \eqref{eq:def:simply_typed_hol_proof_tree/axioms/a2} and \eqref{eq:def:simply_typed_hol_proof_tree/axioms/a3} are adaptations of the eponymous axioms from Henkin's paper \cite[37]{Henkin1975Identity}. They are also found in Andrew's system \( \logic{Q}_0 \) from \cite[\S 51]{Andrews2002Logic} and Farmer's system from \cite[278]{Farmer2008STTVirtues}.

  All the above feature a fourth axiom allowing \( \beta \)-reduction. We could not easily adapt this axiom to our underlying formalisms, but fortunately our extensive discussion of \( \beta \)-reduction in \fullref{sec:lambda_term_reductions} and \fullref{sec:simply_typed_subject_reduction} allowed us to very simply state the rule \ref{inf:def:simply_typed_hol_proof_tree/rules/beta} instead.

  All the above systems imitate an axiomatic derivation system by listing several axiom schemas and only one rule. Namely, all the above systems feature \enquote{rule R}. For example, \incite[213]{Andrews2002Logic} postulates the following:
  \begin{displayquote}
    \textit{Rule R}. From \( \mathbf{C} \) and \( \mathbf{A_\alpha} = \mathbf{B_\alpha} \) to infer the result of replacing one occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) by an occurrence of \( \mathbf{B_\alpha} \), provided that the occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) is not (an occurrence of a variable) immediately preceded by \( \muplambda \).
  \end{displayquote}

  For conditional hypotheses, Andrews further refines this rule as follows:
  \begin{displayquote}
    (Rule R') If \( \mscrH \vdash \mathbf{A_\alpha} = \mathbf{B_\alpha} \), and \( \mscrH \vdash \mathbf{C} \), and \( \mathbf{D} \) is obtained from \( \mathbf{C} \) by replacing one occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) by an occurrence of \( \mathbf{B_\alpha} \), then \( \mscrH \vdash \mathbf{A_\alpha} \), provided that the occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) is not a variable immediately preceded by \( \mathbf{\muplambda} \), and the occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) is not a wf part \( [\mathbf{\muplambda x_\beta E_\gamma}] \) of \( \mathbf{C} \), where \( \mathbf{x_\beta} \) is free in a member of \( \mscrH \) and free in \( \mathbf{A_\alpha} = \mathbf{B_\alpha} \).
  \end{displayquote}

  Here we have again relied on our extensive discussion of reductions in order to define an appropriate relation \( M \redrel{A \mapsto_\Gamma B} N \), apt for stating \ref{inf:def:simply_typed_hol_proof_tree/rules/r}.
\end{comments}

\begin{proposition}\label{thm:simply_typed_hol_equivalence}
  Equality in \hyperref[def:simply_typed_hol]{simply typed higher-order logic} acts like an \hyperref[def:equivalence_relation]{equivalence relation} with respect to \hyperref[def:simply_typed_hol_proof_tree]{derivability}. More precisely:

  \begin{thmenum}
    \thmitem{thm:simply_typed_hol_equivalence/reflexivity} \hyperref[def:relation_closures/reflexive]{Reflexivity}: for any (freely typed) \( \muplambda \)-term \( M \), we have \( \vdash M \syneq M \).

    \thmitem{thm:simply_typed_hol_equivalence/symmetry} \hyperref[def:relation_closures/symmetric]{Symmetry}: we have \( M \syneq N \vdash N \syneq M \).

    \thmitem{thm:simply_typed_hol_equivalence/transitivity} \hyperref[def:relation_closures/transitive]{Transitivity}: we have \( M \syneq N, N \syneq K \vdash M \syneq K \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:simply_typed_hol_equivalence/reflexivity} Let \( \tau \) be the type of \( M \). Then
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:simply_typed_hol_proof_tree/rules/beta}]{ (\qabs {x^\tau} x) M \syneq M }
      \infer0[\ref{inf:def:simply_typed_hol_proof_tree/rules/beta}]{ (\qabs {x^\tau} x) M \syneq M }
      \infer2[\ref{inf:def:simply_typed_hol_proof_tree/rules/r}]{ M \syneq M }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:simply_typed_hol_equivalence/symmetry}
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {} { M \syneq M }

      \hypo{ M \syneq N }

      \infer2[\ref{inf:def:simply_typed_hol_proof_tree/rules/r}]{ N \syneq M }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:simply_typed_hol_equivalence/transitivity}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ M \syneq N }
      \hypo{ N \syneq K }
      \infer2[\ref{inf:def:simply_typed_hol_proof_tree/rules/r}]{ M \syneq K }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:simply_typed_hol_natural_deduction}
  Under the \hyperref[def:simply_typed_hol_proof_tree]{simply typed higher-order logic derivation system}, the propositional natural deduction rules from \cref{def:propositional_natural_deduction_systems} are \hyperref[con:inference_rule_admissibility]{admissible}.
\end{proposition}
\begin{proof}
  \SubProofOf{inf:def:propositional_natural_deduction_systems/top/intro} Special case of \cref{thm:simply_typed_hol_equivalence/reflexivity} with \( M = \qabs {\synp^{\syn\omicron}} \synp \).

  \SubProofOf{inf:def:propositional_natural_deduction_systems/bot/dne} Let \( T \) be a tree deriving \( \synbot \) from \( \synneg \varphi \). Then

  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synneg \varphi }
      \ellipsis { T } { \synbot }

      \hypo { \overbrace{\synneg \varphi}^{\varphi \syneq \synbot} }

      \infer2[\ref{inf:def:simply_typed_hol_proof_tree/rules/r}]{ \varphi }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{definition}\label{def:nth_order_logic}
\end{definition}

\begin{definition}\label{def:simply_typed_definitional_extension}\mimprovised
\end{definition}
