\section{Predicate logic}\label{sec:predicate_logic}

\paragraph{Predicates}

\begin{concept}\label{con:denotation}
  Bertrand Russell begins his philosophical paper \cite{Russell1905OnDenoting} as follows:
  \begin{displayquote}
    By a \enquote{denoting phrase} I mean a phrase such as any one of the following: a man, some man, any man, every man, all men, the present King of England, the present King of France, the centre of mass of the Solar System at the first instant of the twentieth century, the revolution of the earth round the sun, the revolution of the sun round the earth. Thus a phrase is denoting solely in virtue of its form. We may distinguish three cases: (1) A phrase may be denoting, and yet not denote anything; \textit{e.g.}, \enquote{the present King of France}. (2) A phrase may denote one definite object; \textit{e.g.}, \enquote{the present King of England} denotes a certain man. (3) A phrase may denote ambiguously, \textit{e.g.}, \enquote{a man} denotes not many men, but an ambiguous man. The interpretation of such phrases is a matter of considerable difficulty; indeed, it is very hard to frame any theory not susceptible of formal refutation.
  \end{displayquote}

  Later in the paper, Russell discusses \term{denotations} and how they relate to the meaning of denoting phrases:
  \begin{displayquote}
    When we wish to speak about the \textit{meaning} of a denoting phrase, as opposed to its \textit{denotation}, the natural mode of doing so it by inverted commas.
    \begin{equation*}
      \vdots
    \end{equation*}
    We say to begin with, that when \( C \) occurs it is the \textit{denotation} that we are speaking about; but when \enquote{C} occurs, it is the \textit{meaning}.
  \end{displayquote}

  Russell provides an example --- the first line of Gray's Elegy is the meaning of the denoting phrase \enquote{the first line of Gray's Elegy}, while the textual content of that line is its denotation. When defining the \hyperref[con:evaluation]{evaluation} of a \hyperref[con:expression]{formal expression} in some \hyperref[con:metalogic]{object language}, we are only interested in its denotation.
\end{concept}

\begin{remark}\label{rem:predicate_logic}
  In \cref{rem:boolean_valued_functions_and_predicates}, we mentioned that the word \enquote{predicate} is sometimes used as a synonym for \enquote{\hyperref[con:boolean_value]{Boolean-valued} function}. We are interested here in \hyperref[con:syntax_semantics_duality]{syntactic} constructs that allow encoding such functions.

  As described in \cref{def:propositional_valuation/formula_valuation}, \hyperref[def:propositional_syntax/formula]{propositional formulas} are evaluated to Boolean (not merely Boolean-valued) functions under \hyperref[def:first_order_semantics]{classical semantics}. Predicate logic extends propositional logic by also formalizing \hyperref[con:denotation]{denoting phrases} --- it is able to express not only relationship between \hyperref[con:proposition]{propositions}, but also the structure of individual propositions. An atomic proposition in predicate logic may depend on \hyperref[con:variable]{variables} that range over arbitrary domains. We will give a formal definition of syntactic predicate in \cref{def:hol_term/predicate}.

  \incite*[74]{Kleene2002Logic} describes the relationship between predicates and propositions as follows:
  \begin{displayquote}
    \ldots the predicate is seen to be a \textit{propositional function}, i.e. for each value of the (independent) variable \enquote{\( x \)}, it becomes (or takes as value) a proposition.
  \end{displayquote}

  As mentioned in \cref{con:proposition}, propositions are sometimes called \enquote{sentences}. The name \enquote{predicate} is based on the grammatical role of a predicate in a sentence, as pointed out by Kleene:
  \begin{displayquote}
    In the propositional calculus, we studied those occurrences of variables, logical relationships which depend on how some propositions are from other propositions by operations (expressed by the symbols \( \sim \), \( \rightimply \), \( \land \), \( \vee \), \( \neg \)) in which the latter
    propositions enter as unanalyzed wholes. In the \textit{predicate calculus}, we carry the analysis a step deeper to take into account also what in grammar is called \enquote{subject-predicate structure}, and we use two further operations, \( \forall \) (\enquote{for all}) and \( \exists \) (\enquote{for some} or \enquote{there exists}) which depend on that structure. (The predicate calculus includes the propositional calculus.)
  \end{displayquote}

  These two operations are \hyperref[con:variable_binding]{variable binders} called \enquote{quantifiers}; see \cref{def:predicate_logic_alphabet/quantifiers}. They can be viewed as generalizations of disjunction and conjunction --- \( \qforall* x \varphi \) encodes the \hyperref[con:judgment]{judgment} that \( \varphi \) holds for any value of \( x \) (here \( x \) is a possibly \hyperref[con:variable_binding]{free} in \( \varphi \)), without having to list all values in a conjunction, while \( \qexists* x \varphi \) instead states that \( \varphi \) holds for at least one \( x \).

  In this analogy, the variables upon which a predicate depends are subjects. We will call these subject variables \enquote{individual variables} based on Russell's usage described in \cref{def:ramified_theory_of_types}.

  Also based on Russell's usage is the stratification of formulas into \hyperref[def:ramified_theory_of_types/ramified_type]{ramified types}. We will describe here some generalities that do not belong to a particular level of this hierarchy. Later, in \fullref{sec:first_order_logic}, we will narrow out focus in order to study particular predicate formulas more elaborately.
\end{remark}

\begin{concept}\label{con:description_operator}
  Consider the unary predicate \( p(x) \). We will present here several \hyperref[con:variable_binding]{variable binders} related to Russell's theory of denotations (which we touch upon in \cref{con:denotation}).

  To summarize, they act as follows on three kinds of denoting phrases considered by Russell in \cite{Russell1905OnDenoting}:
  \begin{center}
    \begin{tabular}{l c c c c}
      \toprule
                                                        & \( \qexists* x p(x) \) & \( \quantifier \varepsilon x p(x) \) & \( \quantifier \rotiota x p(x) \) & \( \qExists* x p(x) \) \\
      \midrule
      \( p(x) \) does not hold for any value of \( x \) & \( F \)                & ambiguous                            & undefined                         & \( F \) \\
      \( p(x) \) holds for a unique value \( x = a \)   & \( T \)                & \( a \)                              & \( a \)                           & \( T \) \\
      \( p(x) \) holds for multiple values of \( x \)   & \( T \)                & ambiguous                            & undefined                         & \( F \) \\
      \bottomrule
    \end{tabular}
  \end{center}

  We now discuss these binders in more detail:
  \begin{thmenum}
    \thmitem{con:description_operator/exists} The \( \exists \) quantifier merely postulates the existence of a value of \( x \) satisfying \( p \). It is one of the two quantifies commonly considered, as is part of both the syntax of higher-order logic, described in \cref{def:hol_term}, and of first-order logic, described in \cref{def:first_order_syntax}.

    \thmitem{con:description_operator/epsilon} David Hilbert's \( \varepsilon \) operator, described in \cite{Leisenring1969MathematicalLogic}, produces a particular value of \( x \) satisfying \( p \), if one exists, and otherwise produces a value \hi{not} satisfying \( p \).

    Hilbert's intention was to regard \( \varepsilon \) as a \hyperref[con:primitive_notion]{primitive notion}, and define \( \qexists* x p(x) \) as an abbreviation for \( p(\quantifier \varepsilon x p(x)) \).

    In this case, the particular value given by \( \varepsilon \) does not matter, but the nondeterminism may be undesirable in general. The semantics suggested by \incite[\S 3.3]{Leisenring1969MathematicalLogic} for \( \quantifier \varepsilon x p(x) \) requires a \hyperref[def:choice_function]{choice function} for determining a particular value of \( x \) satisfying \( p(x) \), and a fixed value (independent of \( p \)) in case no value satisfies \( p(x) \). These choices are in general not obvious.

    \incite[\S 8.3]{Farmer2008STTVirtues} calls the \( \varepsilon \) operator \term{indefinite description}.

    \thmitem{con:description_operator/iota} Bertrand Russell's \( \rotiota \) operator is by intention left undefined wherever \( \varepsilon \) has an ambiguous value.

    \incite*[30]{WhiteheadRussell1927PrincipiaMathematicaVol1} call it a \term{description} operator. \incite{Farmer2008STTVirtues} suggests calling it \term{definite description} to distinguish it from indefinite descriptions.

    The symbol \( \rotiota \) is an \enquote{inverted} (rotated) Greek iota. The inversion is perhaps reminiscent of how Russell calls \enquote{inverted commas} the quotes that abstract away the meaning of a sentence.

    Unlike Hilbert's \( \varepsilon \) operator, by intention the description is well-defined only if a unique unambiguous value \( x = a \) satisfies \( p(x) \). We list two suggestions for the semantics of  \( \quantifier \rotiota x p(x) \) in the other cases:
    \begin{thmenum}
      \thmitem{con:description_operator/iota/error} We can, as with \( \varepsilon \), provide a dedicated \enquote{error value}. This is done by \incite[\S 3.2]{Farmer2008STTVirtues}, and also by \incite[\S 54]{Andrews2002Logic}.

      As in the case of the \( \varepsilon \) operator, such a choice has the downside of generally not being obvious or even meaningful.

      \thmitem{con:description_operator/iota/undefined} Alternatively, we can leave \( \quantifier \rotiota x p(x) \) \hyperref[con:undefinedness]{undefined} in the case of nonuniqueness. This is done by \incite{Farmer1990PartialFunctionSTT}, and, for first-order logic, by \incite{Hamkins2022DefiniteDescriptions} (in several variants).

      This however requires every formula depending on \( \quantifier \rotiota x p(x) \) to possibly be undefined, which leads to elaborate rules of when a formula may even have a truth value.
    \end{thmenum}

    \thmitem{con:description_operator/exists_unique} Finally, if we wish to merely postulate the existence of a unique value satisfying \( p \), but are not interested in the value itself, we can use the \term{unique existential quantifier} \( \qExists* x p(x) \).

    Unique existence comes in two parts:
    \begin{thmenum}
      \thmitem{con:description_operator/exists_unique/exists} There must exist a value \( a \) satisfying \( p \).
      \thmitem{con:description_operator/exists_unique/unique} For every \( b \), if \( b \) satisfies \( p \), then \( b \) must equal \( a \).
    \end{thmenum}

    Unlike the \( \rotiota \) operator with its complexities, this quantifier can easily be defined via other logical connectives, as we will do in \cref{rem:exists_unique_abbreviation} for higher-order logic.
  \end{thmenum}
\end{concept}

\paragraph{Syntax of predicate logic}

\begin{definition}\label{def:function_application_syntax}\mimprovised
  Fix a \hyperref[def:formal_language/symbol]{symbol} \( f \) intended to denote a function of \hyperref[con:function_arguments]{arity} \( n \). The following is a simple \hyperref[def:formal_grammar]{formal grammar rule} for \( f \), specifically for \hyperref[rem:predicate_logic]{predicate logic}:
  \begin{bnf*}
    \bnfprod{function application} {\bnfts{\( f \)} \bnfsp \bnftsq{(} \bnfsp \underbrace{\bnfpn{variable} \bnfsp \bnftsq{,} \bnfsp \cdots \bnfsp \bnftsq{,} \bnfsp \bnfpn{variable}}_{n \T*{variables}} \bnfsp \bnftsq{)}}
  \end{bnf*}

  Here the variable syntax is taken from the ambient \hyperref[def:formal_grammar/schema]{grammar schema}; in higher-order logic, these will be Latin identifiers.

  We call this the \term[en=prefix notation (\cite[45]{Andrews2002Logic})]{prefix notation}. In the special case where \( n = 0 \), we avoid the parentheses and use
  \begin{bnf*}
    \bnfprod{function application} {\bnfts{\( f \)}}
  \end{bnf*}

  We can also put the operator after its arguments to obtain \term[en=postfix form (\cite[818]{Rosen2019DiscreteMathematics})]{postfix notation}:
  \begin{bnf*}
    \bnfprod{postfix application} {\bnftsq{(} \bnfsp \underbrace{\bnfpn{variable} \bnfsp \bnftsq{,} \bnfsp \cdots \bnfsp \bnftsq{,} \bnfsp \bnfpn{variable}}_{n \T*{variables}} \bnfsp \bnftsq{)} \bnfsp \bnfts{\( f \)}}
  \end{bnf*}

  The usefulness of postfix notation is limited. We discuss some applications in \cref{rem:def:function_application_syntax}. The only ubiquitous use of it is perhaps the \hyperref[def:factorial]{factorial function} \( n! \).

  For \hyperref[def:binary_operator]{binary operators}, which are traditionally denoted using non-letter symbols, both notations becomes cumbersome. For example, \( \ast(x, y) \) and \( (x, y)\ast \) denote an application of the operator \( \ast \). In this case, we find useful the \term[ru=инфиксная форма (\cite[example 6.6]{БелоусовТкачёв2004ДискретнаяМатематика}), en=infix notation (\cite[833]{HighamEtAl2015PrincetonCompanion})]{infix notation} \( (x \ast y) \). More generally:
  \begin{bnf*}
    \bnfprod{infix application} {\bnftsq{(} \bnfsp \bnfpn{variable} \bnfsp \bnfts{\( \ast \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{)}}
  \end{bnf*}
\end{definition}
\begin{comments}
  \item The improper symbols used here are the comma and parentheses, both from the corresponding alphabet from \cref{def:predicate_logic_alphabet}.
\end{comments}

\begin{remark}\label{rem:def:function_application_syntax}
  We will discuss here several aspects of \hyperref[def:function_application_syntax]{prefix and postfix notation}.

  \begin{thmenum}
    \thmitem{rem:def:function_application_syntax/s_expression} Prefix notation is the basis of the programming language LISP and its derivatives. These languages are based on only one syntactic construct, which, when describing LISP, \incite[187]{McCarthy1960SExpressionsPartI} called an \term{S-expression}. They can be described via the following \hyperref[def:formal_grammar]{grammar}, assuming a predefined set of atomic \( S \)-expressions (e.g. alphanumeric strings or arithmetic operators):
    \begin{bnf*}
      \bnfprod{S-expression list} {\bnfpn{S-expression} \bnfor \bnfpn{S-expression} \bnfsp \bnftsq{\textvisiblespace} \bnfsp \bnfpn{S-expression list}} \\
      \bnfprod{S-expression}      {\bnfpn{atomic S-expression} \bnfor \bnftsq{(} \bnfsp \bnfpn{S-expression list} \bnfsp \bnftsq{)}}
    \end{bnf*}

    For example, the arithmetic expression \( 3(1 + 2) \) can be described via the \( S \)-expression
    \begin{center}
      \begin{BVerbatim}[gobble=8]
        (* 3 (+ 1 2))
      \end{BVerbatim}
    \end{center}

    \thmitem{rem:def:function_application_syntax/polish} \incite*[45]{Andrews2002Logic} explains that prefix notation is also called \enquote{Polish notation} because, in the context of \hyperref[def:propositional_alphabet/connectives]{propositional connectives}, it was used by some Polish logicians. In prefix notation, the formula
    \begin{equation*}
      ((\synp \synwedge \synq) \synimplies \synr)
    \end{equation*}
    becomes
    \begin{equation*}
      (\synimplies (\synwedge \synp \synq) \synr).
    \end{equation*}

    The advantage of this notation is that, knowing the arity of the operators, we can avoid all parentheses because
    \begin{equation*}
      \synimplies \synwedge \synp \synq \synr
    \end{equation*}
    can be parsed unambiguously, unlike
    \begin{equation*}
      \synp \synwedge \synq \synimplies \synr.
    \end{equation*}

    Alonzo Church, who in \cite[38]{Church1956LogicVol1} uses Russell and Whitehead's notation (explained in \cref{ex:dot_delimiters_in_logic}), calls this the \enquote{parenthesis-free notation of Jan \L{}ukasiewicz}. He remarks
    \begin{displayquote}
      The possibility of this is interesting. But the notation so obtained is unfamiliar, and less perspicuous than the usual one.
    \end{displayquote}

    \thmitem{rem:def:function_application_syntax/reverse_polish} Postfix notation is also called \enquote{reverse Polish notation}, for example in \cite[833]{HighamEtAl2015PrincetonCompanion} and \cite[817]{Rosen2019DiscreteMathematics}. It is particularly apt for performing calculations using a stack --- an abstract data type supporting only \enquote{pushing} an element to the top and \enquote{popping} the top element.

    We will sketch the general technique with an example. Consider the arithmetic expression \( 3(1 + 2) \). When written in parenthesis-free postfix notation, it becomes
    \begin{center}
      \begin{BVerbatim}[gobble=8]
        3 1 2 + *
      \end{BVerbatim}
    \end{center}

    We start with an empty stack. We keep reading (space-delimited) \hyperref[def:positional_number_system/decimal]{decimal strings} and pushing the corresponding integers to the stack until we encounter an operator. In our example, when we encounter \( + \), the stack looks as follows:
    \begin{MemoryLine}{3}
      3 & 1 & \MemoryLineArrow 2
    \end{MemoryLine}

    Knowing that the operator \( + \) is binary, we pop two elements from the stack and sum them. We then push the result to the stack:
    \begin{MemoryLine}{2}
      3 & \MemoryLineArrow 3
    \end{MemoryLine}

    We continue traversing the source string. We again encounter a binary operator, so we pop the remaining two elements and multiply them to obtain \( 9 \).

    At this point we have traversed the input string, so the expression is well-formed, and we managed to successfully evaluate it to \( 9 \).
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:predicate_logic_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} of predicate logic extends the \hyperref[def:propositional_alphabet]{alphabet of propositional logic} as follows:
  \begin{thmenum}
    \thmitem{def:predicate_logic_alphabet/quantifiers}\mcite[80]{Kleene2002Logic} The following symbols called \term[ru=кванторы (\cite[72]{ШеньВерещагин2017ЯзыкиИИсчисления})]{quantifiers}:
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/quantifiers/universal} The \term[ru=квантор общости (\cite[61]{Эдельман1975Логика})]{universal quantifier} \enquote{\( \synforall \)}.
      \thmitem{def:predicate_logic_alphabet/quantifiers/existential}\mcite[80]{Kleene2002Logic} The \term[ru=квантор существования (\cite[61]{Эдельман1975Логика})]{existential quantifier} \enquote{\( \synexists \)}.
    \end{thmenum}

    We will denote by \( \op*{Quant} \) the set \( \set{ \synforall, \synexists } \) of quantifiers.

    \thmitem{def:predicate_logic_alphabet/equality}\mcite[def. 2.1.2(vi)]{Hinman2005Logic} The \hyperref[def:function_application_syntax]{infix} \term{equality symbol} \enquote{\( \syneq \)}

    \thmitem{def:predicate_logic_alphabet/comma} In addition to the parentheses, we will also need another auxiliary symbol --- the comma \enquote{\( , \)} for delimiting \hyperref[con:function_arguments]{function arguments}.
  \end{thmenum}
\end{definition}

\begin{remark}\label{rem:notation_for_quantifiers}
  There are different possible notations for formulas with \hyperref[def:predicate_logic_alphabet/quantifiers]{quantifiers}. We use the most straightforward notation, \( \qforall x \varphi \), because it seems to be dominating --- it is used in
  \cite[ch. 2]{Hinman2005Logic},
  \cite[ch. II]{Kleene2002Logic},
  \cite[ch. IV]{Smullyan1995FOL},
  \cite[\S I.9]{КолмогоровДрагалин2006Логика},
  \cite[def. 2.1.6]{Герасимов2011Вычислимость},
  \cite[ch. 3]{ШеньВерещагин2017ЯзыкиИИсчисления} and
  \cite[ch. II]{Эдельман1975Логика}.

  Another options is to use \( \quantifier* \synforall x \varphi \) in order to stay consistent with \( \muplambda \)-calculus --- see \cref{rem:lambda_term_abstractor_dot} for the relevant discussion regarding \hyperref[def:lambda_term]{\( \muplambda \)-terms}. This convention stems from the dot delimiters of Russell and Whitehead, which are discussed in detail in \cref{ex:dot_delimiters_in_logic}. This convention is used by \incite{Mimram2020ProgramEqualsProof} and \incite{Farmer2008STTVirtues}.

  A general discussion of syntactic conventions for quantifiers can be found in \cite{MathSE:standards_for_quantifier_notation}. The answers suggest \( (\synforall x) \varphi \) as a popular alternative. The latter is used by \incite[\S 20]{Andrews2002Logic}. Ironically, Andrews also discusses his \( \muplambda \)-calculus based logical system \hyperref[rem:simply_typed_hol]{\( \logic{Q}_0 \)} in the same book, and avoids dots in his \( \muplambda \)-terms.

  We avoid dots after variables in the monograph to keep close to the popular convention, but using dots in the code because it aids readability in monospaced text.
\end{remark}

\paragraph{Type theory and predicate logic}

\begin{remark}\label{rem:higher_order_logic_and_type_theory}
  Type theory allows two unrelated approaches to \hyperref[rem:predicate_logic]{predicate logic}:
  \begin{thmenum}
    \thmitem{rem:higher_order_logic_and_type_theory/terms} As mentioned in \cref{rem:type_theory}, Alonzo Church initially formulated typed \( \muplambda \)-calculus as a way to encode logical formulas via \hyperref[con:type_annotation]{type-annotated} \hyperref[def:lambda_term]{\( \muplambda \)-terms}.

    This approach was later extended by his students Leon Henkin and Peter Andrews. Andrews describes a \hyperref[con:logical_system]{logical system} \( \logic{Q}_0 \) in \cite[ch. 5]{Andrews2002Logic} based on his and Henkin's refinements. More recently, William Farmer suggests modernized variants of Church's and Andrews' systems; he briefly outlines such a system in \cite{Farmer2008STTVirtues} and \cite{Farmer1990PartialFunctionSTT}. All these systems presuppose \hyperref[con:classical_logic]{classical logic}.

    Based on the availability of \fullref{ch:lambda_calculus}, which itself grew out of Church's system, we outline their aforementioned approaches to predicate logic in \cref{rem:simply_typed_hol}.

    The system we present here uses a different formulation, but after the basics are built, it ends up quite similar. This allows us to use Henkin's notion of semantics.

    \thmitem{rem:higher_order_logic_and_type_theory/types} A much more powerful approach is based on the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, which hints at how \hi{types} rather than \( \muplambda \)-terms can be used to encode logical formulas.

    The correspondence itself is briefly outlined in \cref{con:curry_howard_correspondence} and formalized for \hyperref[def:propositional_syntax/formula]{propositional formulas} via \fullref{alg:type_derivation_to_proof_tree} and \fullref{alg:proof_tree_to_type_derivation}.

    With certain adaptations, we use \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} to approximate Church's original system. This involves introducing dedicated syntax for logical terms and formulas in \cref{rem:hol_term_notation} and restricting types of variables to the type universe \( \syn\BbbQ \) of \hyperref[def:hol_signature/universes/quant]{quantifiable types}.

    As we shall see, this approach allows us to reconstruct a proof system much more easily.
  \end{thmenum}
\end{remark}

\begin{concept}\label{con:syntactic_abbreviation}\mimprovised
  It is sometimes convenient to introduce a simplified notation for a more intricate \hyperref[con:expression]{expression}. We call this process \term{abbreviation}.

  We mostly avoid modifying the \hyperref[con:metalogic]{object languages}, which are carefully crafted, and instead use notational shorthands entirely within the \hyperref[con:metalogic]{metalanguage}. For example, we use the \hyperref[con:description_operator/exists_unique]{unique existence quantifier} \( \qExists {x^\tau} \varphi \) as an abbreviation of the more complicated expression \eqref{eq:rem:exists_unique_abbreviation}.

  Definitional extensions, which we will introduce formally in \cref{def:hol_definitional_extension}, provide a rigorous way to perform abbreviation.
\end{concept}

\begin{concept}\label{con:primitive_notion}
  In a sufficiently complex \hyperref[con:metalogic]{object theory}, different notions can be defined via each other. If we want to use \hyperref[def:well_founded_relation]{well-founded} notions that are not defined circularly via each other, we must choose a subset of them that should to be characterized via axioms, and then use them to define the rest. Following \incite[28]{Kleene1971Metamathematics}, we will refer call these notions as \term{primitive}.

  For instance, when formalizing \hyperref[def:lattice]{lattices}, we may use an object theory based on one \hyperref[def:partially_ordered_set]{partial order relation} \( {\synleq} \), as we have done in \cref{def:lattice/theory}, or we may use a theory based on two operations \( {\synvarwedge} \) and \( {\synvarvee} \).

  The object language will feature all three symbols anyway. If we use the formalization from \cref{def:lattice/theory}, however, we will specify the behavior of \( {\synleq} \) via axioms, while the behavior of \( {\synvarwedge} \) and \( {\synvarvee} \) will be defined via that of \( {\synleq} \). Conversely, \cref{thm:lattice_from_binary_operations} shows how we can take \( {\synvarwedge} \) and \( {\synvarvee} \) as primitive and use them to specify how \( {\synleq} \) behaves.

  Usually the essential object of study is taken as primitive --- for example, sets and set membership are primitive in \fullref{ch:set_theory}, groups and group operations are primitive in \fullref{ch:group_theory}, vectors and vector space operations are primitive in \fullref{ch:linear_algebra} and so forth. This is mildly ironic because, for example, linear algebra cannot answer what a vector is beyond characterizing it as \enquote{an element of an abstract vector space}.

  Since it is impractical to make a definitive list of all useful symbols beforehand, we will find useful both \hyperref[con:syntactic_abbreviation]{metalingual abbreviations} and \hyperref[def:hol_definitional_extension]{definitional extensions}.
\end{concept}
\begin{comments}
  \item In addition to the adjective \enquote{primitive}, \incite[28]{Kleene1971Metamathematics} suggests \enquote{technical} and \enquote{undefined}. We will avoid the latter term because it would conflict with undefinedness as described in \cref{con:undefinedness}. See \cref{rem:undefined_and_primitive_terms} for disambiguation of the different notions of undefinedness.

  \item We avoid introducing a distinct term for symbols whose behavior is defined via others. \incite[28]{Kleene1971Metamathematics} suggests \enquote{ordinary}, \enquote{logical} and \enquote{defined}.
\end{comments}

\begin{remark}\label{rem:simply_typed_hol}
  As mentioned in \cref{rem:higher_order_logic_and_type_theory/terms}, we are interested in a variant of Church's typed \( \muplambda \)-calculus that allows us to outline some aspects of \hyperref[rem:predicate_logic]{predicate logic}.

  This approach is based on simply typed \( \muplambda \)-calculus, and we can benefit from the availability of \fullref{ch:lambda_calculus}.

  In order to express logical constructs, \incite[56]{Church1940STT} suggests using logical formulas as \hyperref[con:syntactic_abbreviation]{abbreviations} for certain \( \muplambda \)-terms. There are two languages involved --- the familiar syntax of simply typed \( \muplambda \)-terms over a dedicated \hyperref[def:simple_type_signature]{signature}, as well as a dedicated syntax for higher-order logic. These are appropriately viewed as distinct layers rather than alternatives, since both the syntax and semantics of the logical formulas depends on the underlying \( \muplambda \)-terms, while the usability of the system as an \hyperref[def:abstract_logic]{abstract logic} relies on the upper \enquote{logical} layer.

  \begin{thmenum}
    \thmitem{rem:simply_typed_hol/types} Church considers two base types --- the type of individuals in \( \syn\iota \), and the type of propositions \( \syn\omicron \), as well as arrow types\fnote{As mentioned in \cref{rem:type_theory}, Church denotes by \( (\alpha\beta) \) what we denote by \( \alpha \synimplies \beta \).}. Extensions such as type variables, product types and sum types were developed later, and actually do not benefit Church's encoding of predicate logic.

    We call these in \cref{def:hol_signature/universes/quant} as \enquote{quantifiable types}.

    \thmitem{rem:simply_typed_hol/annotations} We discuss in \cref{rem:typing_style} how Church places a \hyperref[con:type_annotation]{type annotation} on every \( \muplambda \)-term\fnote{Some of the types Church uses are in fact \hyperref[def:polymorphic_typed_lambda_calculus]{polymorphic}, and thus not expressible in his system. This can be seen in \cref{rem:simply_typed_hol/abbreviation}.}. \incite[211]{Andrews2002Logic} even considers a distinct set of variables for every type.

    A modernized presentation is suggested by \incite{Farmer2008STTVirtues}, who splits a \( \muplambda \)-term from its annotation, and requires explicit annotations only on variables (both free and bound).

    Our own approach in \fullref{sec:simply_typed_lambda_terms} hints at placing annotation on only variables and then using \hyperref[con:typing_rule]{typing rules} to infer the types of compound expressions. The expression \( M \coloneqq \qabs {x^\tau} {p x} \) has an annotation for \( x \), but not for \( p \), so, to infer a type for \( M \), we supply a type for \( p \) using a \hyperref[def:type_context]{type context} such as \( p: \tau \synimplies \sigma \).

    We describe in \cref{rem:hol_term_notation} a notation that visually attaches the types specified in a type context to the free variables, reducing visual clutter and bringing our notation closer to Church's. We formally describe the obtained logical terms in \cref{def:hol_term}.

    \thmitem{rem:simply_typed_hol/abbreviation} We will rely on the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} to encode logical constructs, but will quickly elaborate the simply-typed approach here.

    Unlike the other notions mentioned, the choice of \hyperref[con:primitive_notion]{primitive} constant \( \muplambda \)-terms, used to encode logical constructs, has evolved a lot.

    Church originally used several constants --- \( N_{oo} \) for \hyperref[def:propositional_alphabet/negation]{negation}, \( A_{ooo} \) for \hyperref[def:propositional_alphabet/connectives/conjunction]{conjunction}, \( \Pi_{o(o\alpha)} \) for \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantification} and \( \iota_{\alpha(o\alpha)} \) for \hyperref[con:denotation/iota]{definite description}. The latter two are in fact families of constants depending on \( \alpha \).

    \incite*{Henkin1963TheoryOfPropositionalTypes} presented a formulation that used only \( Q_{o \alpha \alpha } \) for \hyperref[def:predicate_logic_alphabet/equality]{equality}, acknowledging that one such constant is needed for each type \( \alpha \). His formulation is restricted to propositional formulas, but later in \cite{Henkin1975Identity} he extended it to all types supported by Church's original system.

    We show concrete abbreviations in \cref{tab:rem:simply_typed_hol/abbreviation}, based on the \( \muplambda \)-term constant \( \synQ \), typable via the rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ M: \tau }
        \hypo{ N: \tau }
        \infer2[\ensuremath{ Q_+ }]{ \synQ M N: \syn\omicron }
      \end{prooftree}
    \end{equation*}

    Most of these abbreviations are based on \bycite[212]{Andrews2002Logic}, with the exception of \( \syntop \), which is instead taken from \bycite[273]{Farmer2008STTVirtues}. In the abbreviation of \( \varphi^{\syn\omicron} \synwedge \psi^{\syn\omicron} \), as in \cref{def:lambda_term_substitution/sharp}, the function \( \sharp(V) \) gives the smallest identifier not in \( V \).

    \begin{table}
      \begin{center}
        \begin{tabular}{l l}
          \toprule
          \multicolumn{1}{c}{Abbreviation} & \multicolumn{1}{c}{\( \muplambda \)-term}                                                                                                                                                                \\
          \midrule
          \( M^\tau \syneq N^\tau \)       & \( \synQ M^\tau N^\tau \)                                                                                                                                                                                \\
          \( \syntop \)                    & \( (\qabs {\synp^{\syn\omicron}} \synp) \syneq (\qabs {\synp^{\syn\omicron}} \synp) \)                                                                                                                   \\
          \( \synbot \)                    & \( (\qabs {\synp^{\syn\omicron}} \synp) \syneq (\qabs {\synp^{\syn\omicron}} \syntop) \)                                                                                                                 \\
          \( \synneg \varphi \)            & \( \varphi \syneq \synbot \)                                                                                                                                                                             \\
          \( \varphi \synwedge \psi \)     & \( (\qabs {f^{\syn\omicron \synimplies \syn\omicron \synimplies \syn\omicron}} f \syntop \syntop) \syneq (\qabs {f^{\syn\omicron \synimplies \syn\omicron \synimplies \syn\omicron}} f \varphi \psi) \), \\
                                           & \quad where \( f = \sharp(\op*{Free}(\varphi) \cup \op*{Free}(\psi)) \)                                                                                                                                  \\
          \( \varphi \synvee \psi \)       & \( \synneg (\synneg \varphi \synwedge \synneg \psi) \)                                                                                                                                                   \\
          \( \varphi \synimplies \psi \)   & \( \varphi \syneq \varphi \synwedge \psi \)                                                                                                                                                              \\
          \( \varphi \syniff \psi \)       & \( \varphi \syneq \psi \)                                                                                                                                                                                \\
          \( \qforall {x^\tau} \varphi \)  & \( (\qabs {x^\tau} \varphi) \syneq (\qabs {x^\tau} \syntop) \)                                                                                                                                           \\
          \( \qexists {x^\tau} \varphi \)  & \( \synneg (\qforall {x^\tau} \synneg \varphi) \)                                                                                                                                                        \\
          \bottomrule
        \end{tabular}
      \end{center}

      \caption{Encoding \hyperref[rem:predicate_logic]{predicate logic} in \hyperref[def:simply_typed_hol]{simply typed higher-order logic}.}\label{tab:rem:simply_typed_hol/abbreviation}
    \end{table}

    \incite*[\S 51]{Andrews2002Logic} presents a refinement of the systems of Church, Henkin and himself. Andrews calls this system \( \logic{Q}_0 \). It is based on two families of primitive constant \( \muplambda \)-terms --- \( Q_{o \alpha \alpha} \) for formal equality and \( \iota_{\iota (o \iota)} \) for definite description.

    \incite{Farmer2008STTVirtues} introduces dedicated syntax for equality and definite descriptions, and experiments with semantics, especially regarding definite descriptions.

    We discard the description operator because we will have no use for it; furthermore, as seen in \cref{con:description_operator/iota}, it can complicate semantics.

    \thmitem{rem:simply_typed_hol/proofs} We will outline the proof system of Andrews' \( \logic{Q}_0 \) since it is the most refined of the bunch.

    It is based on \hyperref[def:axiomatic_derivation_system]{axiomatic derivation systems}, but instead of \ref{inf:thm:axiomatic_derivation_as_natural_deduction/mp}, it features a peculiar rule:
    \begin{displayquote}
      \textit{Rule R}. From \( \mathbf{C} \) and \( \mathbf{A_\alpha} = \mathbf{B_\alpha} \) to infer the result of replacing one occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) by an occurrence of \( \mathbf{B_\alpha} \), provided that the occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) is not (an occurrence of a variable) immediately preceded by \( \muplambda \).
    \end{displayquote}

    For conditional hypotheses, Andrews further refines this rule as follows:
    \begin{displayquote}
      (Rule R') If \( \mscrH \vdash \mathbf{A_\alpha} = \mathbf{B_\alpha} \), and \( \mscrH \vdash \mathbf{C} \), and \( \mathbf{D} \) is obtained from \( \mathbf{C} \) by replacing one occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) by an occurrence of \( \mathbf{B_\alpha} \), then \( \mscrH \vdash \mathbf{A_\alpha} \), provided that the occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) is not a variable immediately preceded by \( \mathbf{\muplambda} \), and the occurrence of \( \mathbf{A_\alpha} \) in \( \mathbf{C} \) is not in a wf part \( [\mathbf{\muplambda x_\beta E_\gamma}] \) of \( \mathbf{C} \), where \( \mathbf{x_\beta} \) is free in a member of \( \mscrH \) and free in \( \mathbf{A_\alpha} = \mathbf{B_\alpha} \).
    \end{displayquote}

    He then spends considerable effort demonstrating that part of the familiar natural deduction rules from \cref{def:propositional_natural_deduction_systems} are \hyperref[con:inference_rule_admissibility]{admissible}.

    The axioms are constructed so that they allow deriving many useful proofs. For example, axiom \( 4 \) allow performing \( \beta \)-reduction; it can roughly be expressed as
    \begin{equation*}
      (\qabs {\synx^\tau} M^\sigma) \syneq M^\sigma[x^\tau \mapsto N^\tau].
    \end{equation*}

    This allows proving
    \begin{equation*}
      \begin{prooftree}
        \infer0[\ensuremath{ \logic{Ax}_4 }]{ (\qabs {\synx^\tau} \synx) M^\tau \syneq M^\tau }
        \infer0[\ensuremath{ \logic{Ax}_4 }]{ (\qabs {\synx^\tau} \synx) M^\tau \syneq M^\tau }
        \infer2[\logic{ R' }]{ M^\tau \syneq M^\tau }
      \end{prooftree}
    \end{equation*}

    The rule \ref{inf:def:propositional_natural_deduction_systems/top/intro} follows from a special case where \( M^\tau = \qabs {\synp^{\syn\omicron}} \synp \).

    We can immediately encounter some subtleties:
    \begin{itemize}
      \item Does the choice of variable \( f \) from the abbreviation of \( \varphi \synwedge \psi \) allow substituting in \( \varphi \) or \( \psi \) using the rule \logic{R'}? An affirmative answer requires a careful formalization of the rule.

      \item Hypothesis discharging in rules such as \ref{inf:def:propositional_natural_deduction_systems/imp/intro} requires rewriting the entire proof, akin to \fullref{alg:derivation_conclusion_hypothesis_introduction} (but more complicated).
    \end{itemize}

    Instead, we choose to reuse the rules of \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} from \fullref{sec:dependent_types}.
  \end{thmenum}
\end{remark}
\begin{comments}
  \item There are technicalities in formalizing axiom \( 4 \) above, either as a \hyperref[con:schemas_and_instances]{syntactic schema} or even as an \hyperref[def:inference_rule]{inference rule}. The rule \( \logic{R'} \) is not simpler. In fact, both require formalizing variants of the generic \( \muplambda \)-term reduction rules from \cref{def:lambda_term_reduction}.

  Thus, formalization would still not much simpler than what we would have to do for Martin-L\"of type theory (see \cref{rem:dependent_type_rule_formalization}), but would additionally require translating between the \enquote{logical layer} and the \enquote{\( \muplambda \)-term layer}.
\end{comments}

\paragraph{Higher-order logic}

\begin{remark}\label{rem:hol_term_notation}
  We will present a dedicated notation for \hyperref[rem:predicate_logic]{predicate logic} based on adapting the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}.

  Consider the \hyperref[def:mltt_entailment]{type derivations} \( \Gamma \vdash \varphi: \BbbT \) and \( \Delta \vdash \psi: \BbbT \), where \( \BbbT \) is a \hyperref[def:mltt_signature/universe]{type universe}. When regarding types as \hyperref[con:proposition]{logical formulas}, we may wish to postulate that \( \varphi \) entails \( \psi \), which is customarily expressed symbolically as \( \varphi \vdash \psi \). Since logical consequence (type derivation) relies on the formulas (types) being \hyperref[def:mltt_well_formed_context/types]{well-formed}, if \( \varphi \) and \( \psi \) depend on free variables typed in their contexts, we may have to use a more cumbersome notation such as
  \begin{equation*}
    [\Gamma] \varphi \vdash [\Delta] \psi.
  \end{equation*}

  We will present a more convenient \hyperref[def:metalogic]{metalingual notation} that works for types and more general \( \muplambda \)-terms.

  Consider \cref{def:hol_term}, where a logical term is defined as a triple \( (\Gamma, M, \tau) \) such that \( \Gamma \vdash M: \tau \) (with certain restrictions on \( \Gamma \) and \( \tau \)).

  Based on our syntax for type annotations discussed in \cref{con:type_annotation}, we denote \( (\Gamma, M, \tau) \) by \( M^\tau \) (or \( M \) if \( \tau \) is understood). Additionally, we use following notational enhancements:
  \begin{itemize}
    \item We also place the type of every free variable in \( M \) in a superscript, i.e. we denote the logical term \( (x: \tau, x) \) by \( x^\tau \).

    \item Since the type of the two sides in \( M^\tau \syneq_\tau N^\tau \) is clear, we avoid the type suffix on the equality symbol itself.

    \item We replace the improper symbols for type constants and connectives with their logical counterparts as per \fullref{alg:type_derivation_to_proof_tree}. Additionally, we use the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier} \( \synforall \) instead of the dependent product binder \( \synprod \), and the \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantifier} \( \synexists \) instead of the dependent sum binder \( \synsum \).
  \end{itemize}
\end{remark}
\begin{comments}
  \item This (metalingual) notation uses improper symbols only from the predicate logic alphabet from \cref{def:predicate_logic_alphabet} and the base \( \muplambda \)-term alphabet from \cref{def:lambda_term_alphabet/binder}.

  It resembles Church's original notation for typed \( \muplambda \)-terms from \cite{Church1940STT}, but is fundamentally different; see \cref{rem:simply_typed_hol}.
\end{comments}

\begin{definition}\label{def:hol_signature}\mimprovised
  A \hyperref[con:logical_system_signature]{signature} \( \Sigma \) for higher-order logic consists of two nonempty finite sets \( \op*{Sort} \) and \( \op*{Const} \) of symbols acting as constant \( \muplambda \)-terms, as well as a set \( \op*{CType} \) of \hyperref[def:type_assertion]{type assertions} for the constants.

  For the underlying type system, we will build a relevant \hyperref[def:mltt_signature]{Martin-L\"of type theory signature} \( \Sigma' \) based on \( \Sigma \).

  In addition to the \hyperref[con:improper_symbol]{improper symbols} from \cref{def:lambda_term_alphabet} and \cref{def:mltt_alphabet} disallowed as constants in \( \Sigma' \), we also disallow as sorts and constant terms the predicate logic alphabet from \cref{def:predicate_logic_alphabet}.

  \begin{thmenum}
    \thmitem{def:hol_signature/sorts} Unless explicitly noted otherwise, we suppose that \( \op*{Sort}_\Sigma \) consists of a single symbol --- \( \syn\iota \) --- called the \term[en=type of individuals (\cite[56]{Church1940STT})]{type of individuals}\fnote{The term \enquote{individuals} is based on Russell's usage; see \cref{rem:hol_formula_order_origin}. The symbol we use to denote their type is Church's small iota from \cite[56]{Church1940STT} with a dot on top, as per \cref{rem:object_language_dots}.}.

    If there is more than one sort, we call the resulting logical system \term[en=many-sorted predicate logic (\cite[\S 4.4.13]{TroelstraSchwichtenberg2000BasicProofTheory})]{many-sorted}.

    \thmitem{def:hol_signature/const} The elements of \( \op*{Const}_\Sigma \) are meant to be used directly as constants in \( \Sigma' \).

    To distinguish them from the \hyperref[def:propositional_alphabet/constants]{propositional constants} \( \syntop \) and \( \synbot \), we may also call them \term[en=nonlogical constants (\cite[211]{Andrews2002Logic})]{nonlogical constants}.

    \thmitem{def:hol_signature/universes} Before discussing the assertions in \( \op*{CType} \), we must discuss the two \hyperref[def:mltt_signature/universe]{type universes} we intend to have in \( \Sigma' \):
    \begin{thmenum}
      \thmitem{def:hol_signature/universes/prop} The \term[en=type of propositions (\cite[56]{Church1940STT})]{type of propositions} \( \syn\omicron \)\fnote{\tcite{In #2, where #1}[56]{Church1940STT} pioneers a dedicated syntax for types, formulas have a dedicated type --- the \enquote{type of propositions}, denoted by \( \omicron \). It can be regarded as either a Latin or a Greek letter; here we suppose the latter. In accordance with \cref{rem:object_language_dots}, we place a dot on top.}, to be used as the main universe towards which the generic types belong. It is intended to contain the types that should act as \hyperref[con:proposition]{logical formulas}.

      \thmitem{def:hol_signature/universes/quant} The universe \( \syn\BbbQ \) of \term{quantifiable types}, populated by the following rules:
      \columnratio{0.3,0.3,0.4}
      \begin{paracol}{3}
        \begin{nthcolumn}{0}
          \ParacolAlignmentHack
          \begin{equation*}\taglabel[\ensuremath{ \BbbQ_{\omicron} }]{inf:def:hol_signature/universes/quant/prop}
            \begin{prooftree}
              \infer0[\ref{inf:def:hol_signature/universes/quant/prop}]{ \syn\omicron: \syn\BbbQ }
            \end{prooftree}
          \end{equation*}
        \end{nthcolumn}

        \begin{nthcolumn}{1}
          \ParacolAlignmentHack
          \begin{equation*}\taglabel[\ensuremath{ \BbbQ_{\logic{Sort}} }]{inf:def:hol_signature/universes/quant/sort}
            \begin{prooftree}
              \infer0[\ref{inf:def:hol_signature/universes/quant/sort}]{ S: \syn\BbbQ },
            \end{prooftree}
          \end{equation*}
          where \( S \in \op*{Sort} \).
        \end{nthcolumn}

        \begin{nthcolumn}{2}
          \ParacolAlignmentHack
          \begin{equation*}\taglabel[\ensuremath{ \BbbQ_\rightarrow }]{inf:def:hol_signature/universes/quant/arrow}
            \begin{prooftree}
              \hypo{ M: \syn\BbbQ }
              \hypo{ N: \syn\BbbQ }
              \infer2[\ref{inf:def:hol_signature/universes/quant/arrow}]{ M \synimplies N: \syn\BbbQ }
            \end{prooftree}
          \end{equation*}
        \end{nthcolumn}
      \end{paracol}
      \columnratio{}
    \end{thmenum}

    \thmitem{def:hol_signature/ctype} The set \( \op*{CType} \) should contain one type assertion for every constant in \( \op*{Const} \), where the type should be quantifiable, i.e. it should inhabit \( \syn\BbbQ \).

    This leads to the following typing rule:
    \begin{equation*}\taglabel[\logic{Const}]{inf:def:hol_signature/ctype}
      \begin{prooftree}
        \infer0[\ref{inf:def:hol_signature/ctype}]{ c: \tau },
      \end{prooftree}
    \end{equation*}
    where \( c: \tau \) ranges over \( \op*{CType} \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item As defined here, sorts are unrelated to sorts in \hyperref[def:pure_type_system]{pure type systems}, which instead act as type universes.

  We decided to call the nonlogical base types \enquote{sorts} based on similar usage in many-sorted first-order logic; see \cite[\S 4.4.13]{TroelstraSchwichtenberg2000BasicProofTheory} and \cite[def. 62]{GoguenBurstall1992Institutions}.

  \item We stated in \cref{rem:logical_symbol_terminology} that the separation into \enquote{logical} and \enquote{nonlogical} symbols is generally ambiguous, but in this case there will be no ambiguity because we specify the kind of entity we refer to, e.g. \enquote{nonlogical constant} rather than simply \enquote{nonlogical symbol}.
\end{comments}

\begin{definition}\label{def:hol_term}\mimprovised
  Over a fixed \hyperref[def:hol_signature]{signature of higher-order logic}, consider the \hyperref[def:mltt_entailment]{type derivation} \( \Gamma \vdash M: \tau \).

  We call the triple \( (\Gamma, M, \tau) \) a \term{logical term} if the following conditions are satisfied:
  \begin{thmenum}[series=def:hol_term]
    \thmitem{def:hol_term/type} The type \( \tau \) is \hyperref[def:hol_signature/universes/quant]{quantifiable}.

    \thmitem{def:hol_term/quant} The bound variables in \( M \) inhabit quantifiable types.

    \thmitem{def:hol_term/context} The types in \( \Gamma \) are all quantifiable; hence, all free variables of \( M \) also inhabit quantifiable types.

    We also require all variables in \( \Gamma \) to be free in \( M \).
  \end{thmenum}

  We will use the dedicated notation for logical terms from \cref{rem:hol_term_notation}. The requirement that the variables of \( \Gamma \) are free in \( M \) ensures that every assertion in \( \Gamma \) is shown in this simplified notation, and that the triple \( (\Gamma, M, \tau) \) is uniquely characterized by the simplified notation alone\fnote{Equality then behaves as expected because, for the logical terms \( (\Gamma, M, \tau) \) and \( (\Delta, N, \sigma) \), if the symbols shown in their simplified notation coincide, we have \( (\Gamma, M, \tau) = (\Delta, N, \sigma) \).}.

  \begin{thmenum}[resume=def:hol_term]
    \thmitem{def:hol_term/formula} If \( \tau \) is the type of propositions, we also call the logical term a \term{formula}.

    For denoting a generic formula, instead of the notation \( M^\tau \) for general logical terms, we prefer the Greek letters we have dedicated to formulas in \cref{rem:mathematical_logic_conventions/greek_alphabet} --- \( \varphi \), \( \psi \), \( \theta \), etc.

    \thmitem{def:hol_term/predicate} If \( \tau = \sigma_1 \synimplies \cdots \synimplies \sigma_n \synimplies \syn\omicron \), we instead call the logical term a \term{predicate}.

    Predicates may be full-fledged syntactic statements, but may also be variables annotated with an appropriate type.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The phrase \enquote{logical term} is inspired by \hyperref[def:first_order_syntax/term]{first-order terms}, which is in turn inspired by Russell's terminology discussed in \cref{rem:hol_formula_order_origin}; we add the adjective \enquote{logical} to distinguish them conceptually from \( \muplambda \)-terms. Unlike in first-order logic, terms here are more general than formulas since the (quantifiable) type of any term can be quantified over.
\end{comments}

\begin{remark}\label{rem:quantifiable_type_uncurrying}
  For \hyperref[def:hol_term]{higher-order logical terms}, we will find it convenient to utilize, within the \hyperref[con:metalogic]{metalanguage}, the different notations from \cref{def:function_application_syntax}.

  For the term \( M^\tau \), where \( \tau = \sigma_1 \synimplies \cdots \synimplies \sigma_n \synimplies \theta \) and \( \theta = \syn\omicron \) or \( \theta \in \op*{Sort} \), we will find it convenient to write \( M(x_1, \ldots, x_n) \) rather than the conventional \( \muplambda \)-term application syntax \( M x_1 \ldots x_n \), which itself is a simplification of the notation with explicit parentheses, \( (\ldots ((M x_1) x_2) \ldots x_n) \).

  This acts as \hyperref[def:function_currying]{uncurrying} on the level of syntax.

  Of course, most constants we will encounter will be non-letter symbols denoting binary operations, and for them we will prefer infix notation.
\end{remark}

\begin{remark}\label{rem:paramters_in_hol}
  We described in \cref{rem:simply_typed_lambda_term_dependency} how (typed) \( \muplambda \)-abstraction can be used to create ad-hoc functions entirely within the \hyperref[con:metalogic]{object language}.

  This approach, usable in \hyperref[def:higher_order_logic]{higher-order logic}, reduces the utility of free variables, which can emulate functions in more restrictive systems such as \hyperref[def:propositional_logic]{propositional logic} (see \cref{def:propositional_valuation/valuation_function}) or \hyperref[def:first_order_logic]{first-order logic} (see \cref{def:first_order_valuation/term_valuation}).

  For example, \( F \coloneqq \qabs {\synx^{\syn\iota}} \qabs {\syny^{\syn\iota}} \syntop \) represents a function of type \( \syn\iota \synimplies \syn\iota \synimplies \syn\omicron \) (i.e. it is a binary predicate). Applying \( F \) to the individual logical terms \( a \) and \( b \) is done on two levels:
  \begin{itemize}
    \item In the object language, we form the logical term \( Fab \) of type \( \syn\omicron \) (i.e. it is a formula). This merely indicates our intent to apply \( a \) and \( b \) to \( F \).

    \item In the metatheory, we can further \( \beta \)-reduce \( Fab \) to \( \syntop \), or evaluate the expression semantically. This performs the actual application.
  \end{itemize}

  Without \( \muplambda \)-abstraction, we lack the ability to create a function or to express our intent to apply it. Instead, we can emulate this behavior via substitution. For example, \( \syntop[\synx \mapsto a, \syny \mapsto b] \) emulates the function application above. This is done entirely in the metalanguage and relies on implicit conventions on the ordering of variables. Furthermore, \enquote{applying} a function via substitution can only meaningfully be done on free variables.
\end{remark}

\begin{definition}\label{def:higher_order_logic}
  We call \term{higher-order logic} over the \hyperref[def:hol_signature]{eponymous signature} the corresponding \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} without implicit \hyperref[con:equality]{judgmental equality}, restricted only to \hyperref[def:hol_term]{logical terms}.
\end{definition}

\begin{remark}\label{rem:exists_unique_abbreviation}
  We can introduce the \hyperref[con:description_operator/exists_unique]{unique existence quantifier} \( \qExists {x^\tau} \varphi \) into \hyperref[def:higher_order_logic]{higher-order logic} via the following \hyperref[con:syntactic_abbreviation]{metalingual abbreviation}:
  \begin{equation}\label{eq:rem:exists_unique_abbreviation}
    \qexists {x^\tau} \parens[\big]{ \varphi \synwedge \qforall {y^\tau} (\varphi[x \mapsto y] \synimplies y \syneq x) },
  \end{equation}
  where \( y = \sharp(\op*{Free}(\varphi) \cup \set{ x }) \). Here, as in \cref{def:lambda_term_substitution/sharp}, the function \( \sharp(V) \) gives the smallest identifier not in \( V \).
\end{remark}
\begin{comments}
  \item The idea of representing \( \synExists \) via other quantifiers is also due to Russell and is outlined in \cite{Russell1905OnDenoting}.
\end{comments}

\paragraph{Definitional extensions}

\begin{definition}\label{def:hol_definitional_extension}\mimprovised
\end{definition}
