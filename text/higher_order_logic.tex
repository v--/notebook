\section{Higher-order logic}\label{sec:higher_order_logic}

This section depends on most of \fullref{ch:lambda_calculus}, and provides general definitions that will be used in \fullref{sec:first_order_logic} and \fullref{sec:first_order_models}. At the same time, it is intended to generalize first-order logic, for which reason the presentation will inevitably suffer.

\begin{concept}\label{con:higher_order_logic}
  \term{Higher-order logic} is a loose term for \hyperref[def:abstract_logic]{abstract logics} whose sentences can encode \hyperref[con:judgment]{judgments} not only about objects of discourse --- the individuals --- but also judgments about \hyperref[con:proposition]{propositions} about individuals.
\end{concept}

\begin{remark}\label{rem:higher_order_logic_and_type_theory}
  Type theory allows two unrelated approaches to \hyperref[con:higher_order_logic]{higher-order logic}:
  \begin{thmenum}
    \thmitem{rem:higher_order_logic_and_type_theory/terms} As mentioned in \fullref{rem:type_theory}, Alonzo Church initially formulated typed \( \muplambda \)-calculus as a way to encode logical formulas via \hyperref[def:typed_lambda_term]{typed \( \muplambda \)-terms}.

    This approach has later been extended by his student Peter Andrews. We present here a variant of Andrews' system \( \logic{Q}_0 \).

    The appeal of this approach for us is that it allows to generalize the semantics of first-order logic as traditionally described.

    \thmitem{rem:higher_order_logic_and_type_theory/types} A much more powerful approach is based on the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, which hints at how \hi{types} rather than terms can be used to encode logical formulas.

    The correspondence itself is briefly outlined in \fullref{con:curry_howard_correspondence} and formalized for \hyperref[def:propositional_syntax/formula]{propositional formulas} via \fullref{alg:type_derivation_to_proof_tree} and \fullref{alg:proof_tree_to_type_derivation}.

    We describe in \fullref{rem:mltt_hol} how \hyperref[def:mltt]{Martin-L\"of type theory} can be used as a form of higher-order logic.

    We avoid this approach because, although it is rightfully considered elegant, it is also much more complicated to study metatheoretically.
  \end{thmenum}
\end{remark}

\paragraph{Syntax of higher-order logic}

\begin{concept}\label{con:quantifier}
  \hyperref[con:variable_binding]{Variable binders} in logic are called \term{quantifiers}.
\end{concept}
\begin{comments}
  \item There are two quantifiers, defined in \fullref{def:simply_typed_hol_alphabet/quantifiers} --- a universal quantifier, \( \forall \), encoding the words \enquote{for each}, and an existential quantifier, \( \exists \), encoding \enquote{there exists}.

  Despite them being ubiquitous, the term \enquote{quantifier} in isolation is not, and our referenced authors do not hint at a general theory of quantifiers. \incite*[41]{Church1956LogicVol1} dedicates the following two sentences to the general concept of quantifiers:
  \begin{displayquote}
    Of special importance for our purpose are \textit{quantifiers}. These are operators for which both the operands and the new constant or form produced by application of the operator are sentences or propositional forms.
  \end{displayquote}
\end{comments}

\begin{definition}\label{def:simply_typed_hol_alphabet}\mimprovised
  A \hyperref[con:logical_system]{logical system} based on \( \muplambda \)-calculus must inevitably combine the syntax of both. We will extend simultaneously the \hyperref[def:formal_language/alphabet]{alphabet} of propositional logic from \fullref{def:propositional_alphabet} and the alphabet of \( \muplambda \)-terms from \fullref{def:lambda_term_alphabet}, as well as the alphabet of simple types from \fullref{def:simple_type_alphabet} without product or sum types. Following \fullref{rem:object_language_dots}, we place dots on top of (most) symbols.

  \begin{thmenum}
    \thmitem{def:simply_typed_hol_alphabet/types} The following will be used as base types in the sense of \fullref{def:simple_type}:
    \begin{thmenum}[series=def:simply_typed_hol_alphabet]
      \thmitem{def:simply_typed_hol_alphabet/types/propositions}\mcite[57]{Church1940STT} The \term{type of propositions} \enquote{\( \syn\omicron \)}.
      \thmitem{def:simply_typed_hol_alphabet/types/iota}\mcite[57]{Church1940STT} The \term{type of individuals} \enquote{\( \syn\iota \)} (Small Greek iota \( \iota \) with a dot).
    \end{thmenum}

    As discussed in \fullref{con:reserved_symbol}, both \( \syn\omicron \) and \( \syn\iota \) take precedence over the variables with the same name, i.e. both need to be parsed as constants in simply typed higher-order logic.

    \thmitem{def:simply_typed_hol_alphabet/const} The following will be used as constant \( \muplambda \)-terms in the sense of \fullref{def:lambda_term}:
    \begin{thmenum}[resume=def:simply_typed_hol_alphabet]
      \thmitem{def:simply_typed_hol_alphabet/const/equality}\mcite[270]{Farmer2008STTVirtues} The \term{equality} term \enquote{\( \synQ \)}.
      \thmitem{def:simply_typed_hol_alphabet/const/description}\mcite[270]{Farmer2008STTVirtues} The \term{definite description} term \enquote{\( \synI \)}.
    \end{thmenum}

    \thmitem{def:simply_typed_hol_alphabet/aux} Except for the auxiliary symbols from \fullref{def:lambda_term_alphabet}, we will also need another auxiliary symbol --- the comma \enquote{\( , \)} for separating function arguments.

    \thmitem{def:simply_typed_hol_alphabet/equality}\mcite[def. 2.1.2(vi)]{Hinman2005Logic} Corresponding to the equality term \( \synQ \) is the more convenient \hyperref[rem:first_order_formula_conventions/infix]{infix} \term{equality symbol} \enquote{\( \syneq \)}

    \thmitem{def:simply_typed_hol_alphabet/quanifiers} Finally, we will use the following symbols as quantifiers in the sense of \fullref{con:quantifier}:
    \begin{thmenum}[resume=def:simply_typed_hol_alphabet]
      \thmitem{def:simply_typed_hol_alphabet/quanifiers/universal}\mcite[80]{Kleene2002Logic} The \term[ru=квантор общости (\cite[61]{Эдельман1975Логика})]{universal quantifier} \enquote{\( \synforall \)}.
      \thmitem{def:simply_typed_hol_alphabet/quanifiers/existential}\mcite[80]{Kleene2002Logic} The \term[ru=квантор существования (\cite[61]{Эдельман1975Логика})]{existential quantifier} \enquote{\( \synexists \)}.
    \end{thmenum}

    We will denote by \( \op*{Quant} \) the set \( \set{ \synforall, \synexists } \) of quantifiers.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:syntax_of_simply_typed_hol}
  Similarly to untyped \( \muplambda \)-terms, which we defined in \fullref{def:lambda_term}, we will need a (finite) \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Const} \), whose elements we will call \term[en=constants (\cite[202]{Andrews2002Logic})]{constants}.
\end{definition}

\begin{concept}\label{con:primitive_notion}
  When formalizing \hyperref[def:lattice]{lattices}, we may use an \hyperref[con:metalogic]{object theory} based on one \hyperref[def:partially_ordered_set]{partial order relation} \( {\synleq} \), as we have done in \fullref{def:lattice/theory}, or we may use a theory based on two operations \( {\synvarwedge} \) and \( {\synvarvee} \).

  The object language will feature all three symbols anyway. If we use the formalization from \fullref{def:lattice/theory}, however, we will specify the behavior of \( {\synleq} \) via axioms, while the behavior of \( {\synvarwedge} \) and \( {\synvarvee} \) will be defined via that of \( {\synleq} \). In this case we will call symbol \( {\synleq} \) \term[en=primitive (\cite[28]{Kleene1971Metamathematics})]{primitive} to distinguish it from the rest.

  \Fullref{thm:lattice_from_binary_operations} shows that the two approaches are equivalent in the sense that, when using \( {\synleq} \) as primitive, it can be used to define \( {\synvarwedge} \) and \( {\synvarvee} \), and vice versa.

  More generally, when formalizing a theory, we need to choose which notions to take as primitive and characterize via axioms. Usually the essential object of study is taken as primitive --- for example, sets are primitive in \fullref{ch:set_theory}, groups are primitive in \fullref{ch:group_theory}, vectors are primitive in \fullref{ch:linear_algebra} and so forth. This is mildly ironic because, for example, linear algebra cannot answer what a vector is beyond characterizing it as \enquote{an element of an abstract vector space}.

  Such an approach is necessary if we want to use \hyperref[def:well_founded_relation]{well-founded} notions that are not defined circularly via each other.
\end{concept}
\begin{comments}
  \item In addition to the adjective \enquote{primitive}, \incite[28]{Kleene1971Metamathematics} suggests \enquote{technical} and \enquote{undefined}. We will avoid the latter term because it would conflict with undefinedness as described in \fullref{con:undefinedness}. See \fullref{rem:undefined_and_primitive_terms} for disambiguation.

  \item We avoid introducing a distinct term for symbols whose behavior is defined via others. \incite[28]{Kleene1971Metamathematics} suggests \enquote{ordinary}, \enquote{logical} and \enquote{defined}.
\end{comments}

\begin{definition}\label{def:simply_typed_hol}\mimprovised
  We will describe a variant of Peter Andrews' system \( \logic{Q}_0 \) presented in \cite[\S 51]{Andrews2002Logic} and, with some variations, in \incite{Farmer2008STTVirtues}. Andrews' system is itself a variation of Church's simply typed \( \lambda \)-calculus from \cite{Church1940STT}.

  \thmitem{def:simply_typed_hol/equality}
  \thmitem{def:simply_typed_hol/formula}
\end{definition}

\begin{definition}\label{def:nth_order_logic}
\end{definition}
