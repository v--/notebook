\subsection{Propositional logic}\label{subsec:propositional_logic}

Propositional logic allows us to express basic relations between atomic propositions --- variables that can be true or false or, in the case of \hyperref[def:propositional_semantics]{non-classical semantics}, have some intermediate value.

\paragraph{Syntax of propositional logic}\hfill

There are different approaches to formalizing the syntax of propositional logic. We use the theory of formal grammars that we have developed in \fullref{subsec:formal_languages} and \fullref{subsec:syntax_trees}. This requires specific adjustments related to other treatments of propositional logic --- e.g. \incite[ch. 1]{Hinman2005}, \incite[pt. I]{Smullyan1995} and \incite[ch. 1]{КолмогоровДрагалин2006} --- which rely on a more informal treatment of syntax more akin to what can be achieved via \fullref{thm:least_fixed_point_recursion}. Our approach allows us to use powerful tools while treating the object logic in complete formality. \incite[45]{Mimram2020} also describes syntax via formal grammars, but does not utilize the theory of formal languages.

\begin{remark}\label{rem:grammar_rules_for_variables}
  We need to introduce conventions for identifiers --- i.e. names of variables, functions and so forth --- in order to be able to be able to express infinitely many variables with finitely many grammar rules. The variable names that we will actually use will be a very specific subset of the ones we allow formally. Consider the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{Latin letter}           {\bnftsq{A} \bnfor \bnftsq{B} \bnfor \cdots \bnfor \bnftsq{Z} \bnfor \bnftsq{a} \bnfor \bnftsq{b} \bnfor \cdots \bnfor \bnftsq{z}}, \\
    \bnfprod{Latin string}           {\bnfpn{Latin letter} \bnfor \bnfpn{Latin letter} \bnfsp \bnfpn{Latin string}}, \\
    \bnfprod{Latin identifier}       {\bnfpn{Latin string} \bnfor \bnfpn{Latin string} \bnfsp \bnfpn{natural number}},
  \end{bnf*}
  where grammar rules for natural numbers can be taken from \fullref{rem:decimal_notation_grammar}.

  An identifier is a nonempty sequence of Latin letters, optionally followed by a number. Within the metalogic, we treat this number as a suffix and write it as a subscript, that is, we write \( P_1 \) instead of \( P1 \).

  We use a number of related rules defined in an obvious way:
  \begin{itemize}
    \item In \fullref{def:untyped_lambda_term}, we use the nonterminal \( \bnfpn{Short Latin identifier} \), which consists of a single Latin letter with a numeric subscript.
    \item In \fullref{def:first_order_syntax} and \fullref{def:inference_rule}, we will use the nonterminal \( \bnfpn{Greek identifier} \) with analogous rules for denoting first-order variables.
    \item In \fullref{def:logical_context}, we have used distinct rules for small and capital Greek letters.
  \end{itemize}

  A benefit of this naming schema is that we can introduce a \hyperref[thm:def:well_ordered_set/lexicographic]{lexicographic well-ordering} on the set of identifiers. This ordering can help reduce ambiguity in \fullref{def:propositional_valuation/valuation_function}, \fullref{def:lambda_substitution} and \fullref{def:first_order_substitution/term_in_formula} (although, in practice, we will prefer the ordering \( \xi < \eta < \zeta \) resembling \( x < y < z \)). We use the following conventions:
  \begin{itemize}
    \item Individual digits are ordered as they are listed in \fullref{rem:decimal_notation_grammar}, i.e.
    \begin{equation*}
      0 < 1 < \cdots < 9.
    \end{equation*}

    \item Individual letters are ordered as they are listed above, i.e.
    \begin{equation*}
      A < B < \cdots < Z < a < b < \cdots < z.
    \end{equation*}

    \item Digits are smaller than letters.

    \item In the case of words of different lengths, if one word is a prefix of another, we assume that the shorter word is smaller, i.e.
    \begin{equation*}
      a < a_{13} < aa.
    \end{equation*}

    Comparing words of different lengths is discussed in \fullref{ex:def:lexicographic_order/heterogenous_words}.
  \end{itemize}
\end{remark}

\begin{definition}\label{def:propositional_alphabet}\mcite[4; 5]{Smullyan1995}
  The \hyperref[def:formal_language/alphabet]{alphabet} of \term[ru=логика высказываний (\cite[43]{КолмогоровДрагалин2006})]{propositional logic} consists of:

  \begin{thmenum}
    \thmitem{def:propositional_alphabet/constants} Two \term{propositional constants}:
    \begin{thmenum}
      \thmitem{def:propositional_alphabet/constants/verum}\mcite[70]{CitkinMuravitsky2021} \term{verum} \enquote{\( \syntop \)}.
      \thmitem{def:propositional_alphabet/constants/falsum}\mcite[70]{CitkinMuravitsky2021} \term{falsum} \enquote{\( \synbot \)}.
    \end{thmenum}

    \thmitem{def:propositional_alphabet/negation} \term[ru=отрицание (\cite[17]{КолмогоровДрагалин2006})]{Negation} \enquote{\( \synneg \)}.
    \thmitem{def:propositional_alphabet/connectives} The set \( \op*{Conn} \) of \term{binary propositional connectives}, namely
    \begin{thmenum}
      \thmitem{def:propositional_alphabet/connectives/disjunction} \term[ru=дизъюнкция (\cite[17]{КолмогоровДрагалин2006})]{Disjunction} \enquote{\( \synvee \)}, also known as \hyperref[def:standard_boolean_functions]{\term{or}}.
      \thmitem{def:propositional_alphabet/connectives/conjunction} \term[ru=конъюнкция (\cite[17]{КолмогоровДрагалин2006})]{Conjunction} \enquote{\( \synwedge \)}, also known as \hyperref[def:standard_boolean_functions]{\term{and}}.
      \thmitem{def:propositional_alphabet/connectives/conditional} \term{Conditional}\fnote{Note that \enquote{conditional} and \enquote{biconditional} are used nouns in this context, although we prefer the phrase \enquote{conditional formula}. We use these terms to avoid confusion with the same connectives in the metalogic, for example \enquote{A biconditional formula is equivalent \dots} could otherwise become \enquote{An equivalence is equivalent \dots}.} \( \synimplies \), also known as \term{if\ldots then} and \hyperref[def:standard_boolean_functions]{\term[ru=импликация (\cite[17]{КолмогоровДрагалин2006})]{implication}}.
      \thmitem{def:propositional_alphabet/connectives/biconditional} \term{Biconditional} \enquote{\( \syniff \)}, also known as \term{if and only if} (\hyperref[def:standard_boolean_functions]{\term{iff}}) and \term[ru=эквиваленция (\cite[17]{КолмогоровДрагалин2006})]{equivalence}.
    \end{thmenum}

    \thmitem{def:propositional_alphabet/parentheses} Parentheses \enquote{\( ( \)} and \enquote{\( ) \)} for defining the order of operations unambiguously.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item If desired, we can utilize a smaller propositional language without losing its semantical properties. Important example are the \hyperref[def:cnf_and_dnf]{conjunctive normal forms} in \fullref{alg:perfect_cnf_and_dnf}, although similar constructions hold for other \hyperref[def:boolean_closure/complete]{complete sets of Boolean functions} like those from \fullref{thm:complete_sets_of_boolean_functions}.

  \item We place dots over the various symbols in order to highlight that they are merely symbols without semantics --- see \fullref{rem:mathematical_logic_conventions/connective_symbols} for a general discussion.

  \item \enquote{Conjunctio} and \enquote{disjunctio} are Latin words for \enquote{union} and \enquote{separation}, respectively. \enquote{Implicatio} is Latin for \enquote{entangled}.
\end{comments}

\begin{definition}\label{def:propositional_syntax}\mimprovised
  We will introduce a \hyperref[def:formal_grammar/schema]{grammar schema} whose rules and generated languages we will collectively call the \term[en=syntax (\cite[8]{Hinman2005})]{syntax} of propositional logic:
  \begin{thmenum}
    \thmitem{def:propositional_syntax/schema} Consider the following \hyperref[def:formal_grammar/schema]{grammar schema}:
    \begin{bnf*}
      \bnfmore              {\textbf{\hyperref[con:abstract_syntax_tree/lexical]{Lexical rules}}} \\
      \bnfprod{variable}    {\bnfpn{Latin identifier}} \\
      \bnfprod{connective}  {\bnftsq{\( \synvee \)} \bnfor \bnftsq{\( \synwedge \)} \bnfor \bnftsq{\( \synimplies \)}\bnfor \bnftsq{\( \syniff \)}} \\
      \bnfmore              {\textbf{\hyperref[con:abstract_syntax_tree/syntactic]{Syntactic rules}}} \\
      \bnfprod{formula}     {\bnftsq{\( \syntop \)} \bnfor \bnftsq{\( \synbot \)} \bnfor} \\
      \bnfmore              {\bnfpn{variable} \bnfor} \\
      \bnfmore              {\bnftsq{\( \synneg \)} \bnfsp \bnfpn{formula} \bnfor} \\
      \bnfmore              {\bnftsq{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnftsq{)}}
    \end{bnf*}
    where we use the identifiers discussed in \fullref{rem:grammar_rules_for_variables}.

    \thmitem{def:propositional_syntax/prop} We denote by \( \op*{Prop} \) the set of all \term[ru=пропозициональные переменные (\cite[43]{КолмогоровДрагалин2006})]{propositional variables}, that is, all strings generated by the above grammar schema with starting nonterminal \( \bnfpn{variable} \).

    \thmitem{def:propositional_syntax/formula} Similarly, we denote by \( \op*{Form} \) the set of \term[ru=формула (\cite[43]{КолмогоровДрагалин2006})]{formulas}, that is, strings generated with starting nonterminal \( \bnfpn{formula} \).

    Propositional formulas are also called \term{sentences}, for example by Peter Hinman in \incite[def. 1.1.2]{Hinman2005}. This contrasts with first-order logic, where only specific formulas are called sentences --- see \fullref{def:first_order_syntax/closed_formula}.

    \thmitem{def:propositional_syntax/language} By \enquote{language of propositional logic} we will mean the set \( \op*{Form} \) of formulas (and hence also the variables).

    \thmitem{def:propositional_syntax/fragment} By a \enquote[en=fragment (\cite[49]{Mimram2020})]{fragment} of propositional logic we will mean a subset of \( \op*{Form} \), most easily obtained by restricting which rules from the full schema are used. See \fullref{def:implicational_propositional_fragment}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Various authors refer to the \enquote{propositional language} --- for example \incite[13]{Hinman2005} and \incite[72]{Galatos2007} --- in relation to various syntactic constructions. These authors do not formally define this language, however. Since we use the mechanism of \hyperref[def:formal_language]{formal languages}, we prefer being more concrete about which syntactic notions we refer to.

  \item We implicitly associate with each propositional formula an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} --- see \fullref{def:propositional_formula_ast}. The grammar of propositional formulas is unambiguous as shown via \fullref{thm:propositional_formulas_are_unambiguous}, which makes it possible to perform proofs via \fullref{thm:induction_on_syntax_trees}.

  \item If the root of the tree is a conjunction, we refer to the formula itself as a conjunction, and similarly for other propositional connectives.
\end{comments}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:propositional_syntax/formula]{propositional formulas} is \hyperref[def:grammar_ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  It is straightforward to adapt the proof from \fullref{ex:natural_number_arithmetic_grammar/unambiguous}.
\end{proof}

\begin{definition}\label{def:conditional_formula}
  For a given \hyperref[def:propositional_syntax/formula]{conditional formula} \( \varphi \synimplies \psi \), we introduce the following terminology:
  \begin{thmenum}
    \thmitem{def:conditional_formula/sufficient_condition}\mcite[def. I.4.1]{Эдельман1975} \( \varphi \) is a \term[ru=достаточное условие]{sufficient condition} for \( \psi \).

    \thmitem{def:conditional_formula/necessary_condition}\mcite[def. I.4.1]{Эдельман1975} \( \psi \) is a \term[ru=необходимое условие]{necessary condition} for \( \varphi \).

    \thmitem{def:conditional_formula/antecedent}\mcite[16]{Эдельман1975} \( \varphi \) is the \term[ru=посылка, en=antecedent (\cite[35]{Rosen1999})]{antecedent} of the conditional \( \varphi \synimplies \psi \).

    \thmitem{def:conditional_formula/consequent}\mcite[16]{Эдельман1975} \( \psi \) is the \term[ru=следствие, en=consequent (\cite[37]{Rosen1999})]{consequent} of \( \varphi \synimplies \psi \).

    \thmitem{def:conditional_formula/inverse}\mcite[def. I.4.3]{Эдельман1975} We call the formula \( \synneg \varphi \synimplies \synneg \psi \) the \term[ru=противоположная (теорема), en=inverse (\cite[49]{Rosen1999})]{inverse} of \( \varphi \).

    \thmitem{def:conditional_formula/converse}\mcite[13]{Kleene2002Logic} We call the formula \( \psi \synimplies \varphi \) the \term[ru=обратная (теорема) (\cite[def. I.4.2]{Эдельман1975})]{converse} of \( \varphi \).

    \thmitem{def:conditional_formula/contrapositive}\mcite[13]{Kleene2002Logic} The formula \( \synneg \psi \synimplies \synneg \varphi \) is the \term[ru=контрапозиция (\cite[26]{Эдельман1975})]{contrapositive} of \( \varphi \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item In \hyperref[def:classical_logic]{classical logic}, the contrapositive is \hyperref[def:semantic_equivalence]{equivalent} to the original formula due to \fullref{thm:boolean_equivalences/contrapositive}.
\end{comments}

\begin{definition}\label{def:propositional_formula_ast}\mimprovised
  We implicitly associate with each propositional formula \( \varphi \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\varphi) \) defined as follows:
  \begin{thmenum}
    \thmitem{def:propositional_fomula_ast/atomic} If \( \varphi \) is a propositional constant or variable, let \( T(\varphi) \) be the singleton tree with value \( \varphi \).

    \thmitem{def:propositional_fomula_ast/negation} If \( \varphi = \synneg \psi \), assuming we have already built \( T(\psi) \), we obtain \( T(\varphi) \) by adding a new root with value \( \synneg \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__propositional_formula_ast}
    \end{equation*}

    \thmitem{def:propositional_fomula_ast/connective} If \( \varphi = \psi \syncirc \theta \), assuming we have built \( T(\psi) \) and \( T(\chi) \), we obtain \( T(\varphi) \) by joining them by a new root with value \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__propositional_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This is similar to \enquote{formation trees} used by \incite[9]{Smullyan1995}, but drawn in reverse and having no excess information present.
  \item The \hyperref[def:rooted_tree/leaf]{leaves} of the tree are variables and constants, while every other node is either a binary connective or negation.
\end{comments}

\begin{example}\label{ex:def:propositional_fomula_ast}
  We list examples of \hyperref[def:propositional_fomula_ast]{abstract syntax trees for propositional formulas}:
  \begin{thmenum}
    \thmitem{ex:def:propositional_fomula_ast/lnc} The law of non-contradiction \eqref{eq:thm:minimal_propositional_negation_laws/lnc} has the following AST:
    \begin{equation*}
      \includegraphics[page=1]{output/ex__def__propositional_formula_ast}
    \end{equation*}

    \thmitem{ex:def:propositional_fomula_ast/associative_conjunction} We will define semantics for conjunction and disjunction so that they become associative Boolean operators. Following our general discussion of such binary operations in \fullref{rem:binary_operation_syntax_trees}, we will generally conflate the formula
    \begin{equation*}
      ((P \synwedge Q) \synwedge R)
    \end{equation*}
    with AST
    \begin{equation*}
      \includegraphics[page=2]{output/ex__def__propositional_formula_ast}
    \end{equation*}
    and the formula
    \begin{equation*}
      ((P \synwedge Q) \synwedge R)
    \end{equation*}
    with AST
    \begin{equation*}
      \includegraphics[page=3]{output/ex__def__propositional_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:propositional_formula_balanced_parentheses}
  Propositional formulas have \hyperref[ex:thm:regular_pumping_lemma/balanced_parentheses]{balanced parentheses}, that is, for any formula there are as many left parentheses as there are right parentheses.
\end{proposition}
\begin{proof}
  Denote by \( l_\varphi \) and \( r_\varphi \) the number of left and right parentheses in the formula \( \varphi \).

  We will use \fullref{thm:induction_on_syntax_trees} on \( \varphi \) to prove that \( l_\varphi = r_\varphi \).
  \begin{itemize}
    \item If \( \varphi \) is a constant or variable, there are no parentheses, and \( l_\varphi = r_\varphi = 0 \).
    \item If \( \varphi = \synneg \psi \) and if the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      l_\varphi = l_\psi \reloset{\T{ind.}} = r_\psi = r_\varphi
    \end{equation*}

    \item If \( \varphi = (\psi \syncirc \theta) \) and if the hypothesis holds for \( \psi \) and \( \theta \), then
    \begin{equation*}
      l_\varphi = l_\psi + l_\theta + 1 \reloset{\T{ind.}} = r_\psi + r_\theta + 1 = r_\varphi.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{remark}\label{rem:propositional_formula_parentheses}
  We use several following \enquote{abuse-of-notation} conventions regarding parentheses. These are only notations shortcuts in the \hyperref[con:metalogic]{metalanguage} and the formulas themselves (as abstract mathematical objects) are still assumed to contain parentheses that help them avoid syntactic ambiguity.

  \begin{thmenum}
    \thmitem{rem:propositional_formula_parentheses/outermost} We may skip the outermost parentheses in formulas with top-level \hyperref[def:propositional_alphabet/connectives]{connectives}, e.g. we may write \( \varphi \synwedge \psi \) rather than \( (\varphi \synwedge \psi) \).

    \thmitem{rem:propositional_formula_parentheses/associative} Because of the associativity of \( \synwedge \) and \( \synvee \), which is implied by \fullref{def:propositional_valuation/valuation_function} and \fullref{def:standard_boolean_functions}, we may skip the parentheses in chains like
    \begin{equation*}
      ( \ldots ((\varphi_1 \synwedge \varphi_2) \synwedge \varphi_3) \synwedge \ldots \synwedge \varphi_{n-1} ) \synwedge \varphi_n.
    \end{equation*}
    and instead write
    \begin{equation*}
      \varphi_1 \synwedge \varphi_2 \synwedge \ldots \synwedge \varphi_{n-1} \synwedge \varphi_n.
    \end{equation*}

    \thmitem{rem:propositional_formula_parentheses/additional} Although not formally necessary, for the sake of readability we may choose to add parentheses around certain formulas like
    \begin{equation*}
      \synneg \varphi \synvee \synneg \psi.
    \end{equation*}
    and instead write
    \begin{equation*}
      (\synneg \varphi) \synvee (\synneg \psi).
    \end{equation*}

    This latter convention is more useful for quantifiers in \hyperref[def:first_order_syntax/formula]{first-order formulas}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:propositional_subformula}\incite[8]{Smullyan1995}
  For every \hyperref[def:propositional_syntax/formula]{propositional formula}, we define the set of \term{subformulas} as follows:
  \begin{equation*}
    \op*{Subform}(\varphi) \coloneqq \begin{cases}
      \set{ \varphi },                                                        &\varphi \in \set{ \syntop, \synbot } \T{or} \varphi \in \op*{Prop}, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \synneg \psi, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi) \cup \op*{Subform}(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}.
    \end{cases}
  \end{equation*}
\end{definition}

\begin{lemma}\label{thm:propositional_subformula_lemma}
  If the formula \( \psi \) is a \hyperref[def:formal_language/substring]{substring} of the formula \( \varphi \), we have the following possibilities:
  \begin{thmenum}
    \thmitem{thm:propositional_subformula/variable} \( \varphi \) is a variable or constant and \( \psi = \varphi \).
    \thmitem{thm:propositional_subformula/negation_self} \( \varphi = \neg \theta \) and \( \psi \) coincides with \( \varphi \).
    \thmitem{thm:propositional_subformula/negation} \( \varphi = \neg \theta \) and \( \psi \) is a subformula of \( \theta \).
    \thmitem{thm:propositional_subformula/connective_self} \( \varphi = (\theta \syncirc \chi) \) and \( \psi \) coincides with \( \varphi \).
    \thmitem{thm:propositional_subformula/connective_left} \( \varphi = (\theta \syncirc \chi) \) and \( \psi \) is a subformula of \( \theta \).
    \thmitem{thm:propositional_subformula/connective_right} \( \varphi = (\theta \syncirc \chi) \) and \( \psi \) is a subformula of \( \chi \) but not \( \theta \).
  \end{thmenum}
\end{lemma}
\begin{proof}
  We use \fullref{thm:induction_on_syntax_trees} on \( \varphi \):
  \begin{itemize}
    \item If \( \varphi \) is a variable or constant, it is a single lexeme, and the only possible substring that is a formula is \( \varphi \) itself. This corresponds to \fullref{thm:propositional_subformula/variable}.
    \item If \( \varphi = \neg \theta \) and if the inductive hypothesis holds for \( \theta \), we have the following possibilities:
    \begin{itemize}
      \item If \( \psi = \varphi \), then \fullref{thm:propositional_subformula/negation_self} holds.
      \item If \( \psi = \neg \), it is a substring of \( \varphi \), but not itself a formula.
      \item If \( \psi \) is a substring of \( \theta \), we apply the inductive hypothesis --- then \fullref{thm:propositional_subformula/negation} holds.
    \end{itemize}

    \item If \( \varphi = (\theta \syncirc \chi) \), where the inductive hypothesis holds for \( \theta \) and \( \chi \), we have the following possibilities:
    \begin{itemize}
      \item If \( \psi = \varphi \), then \fullref{thm:propositional_subformula/connective_self} holds.
      \item If \( \psi \) is a substring of \( \theta \), then \fullref{thm:propositional_subformula/connective_left} holds.
      \item If \( \psi \) is a substring of \( \chi \) but not of \( \theta \), then \fullref{thm:propositional_subformula/connective_right} holds.
      \item If \( \psi = (\theta \syncirc \psi_\chi \), where \( \psi_\chi \) is a prefix of \( \chi \), then \( \psi \) has unbalanced parentheses, which contradicts \fullref{thm:propositional_formula_balanced_parentheses}, and thus \( \psi \) is not a formula.
      \item Similarly, if \( \psi = \psi_\theta \syncirc \chi) \), where \( \psi_\theta \) is a suffix of \( \theta \), then again \( \psi \) has unbalanced parentheses.
      \item If \( \psi = \psi_\theta \syncirc \psi_\chi \), where \( \psi_\theta \) is a suffix of \( \theta \) and \( \psi_\chi \) is a prefix of \( \chi \), then \( \psi \) is again not a formula because it is not wrapped in parentheses.
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:propositional_formula_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \psi \) of the formula \( \varphi \) is a \hyperref[def:propositional_subformula]{subformula} of \( \varphi \) if and only if \( \psi \) is itself a formula.
\end{proposition}
\begin{proof}
  \SufficiencySubProof Straightforward.
  \NecessitySubProof Suppose that \( \psi \) is itself a formula. Then \fullref{thm:propositional_subformula_lemma} implies that it falls into one of the cases of \fullref{def:propositional_subformula}, and is thus a subformula of \( \varphi \).
\end{proof}

\paragraph{Intuitionistic propositional semantics}

\begin{definition}\label{def:truth_value_algebra}
  In order to determine whether a sentence holds under given circumstances, we must have a set of \term[ru=истинностное значение (\cite[17]{Герасимов2011}), en=truth value (\cite[9]{Smullyan1995})]{truth values}, for example the Boolean values \( T \) and \( F \) from \fullref{con:boolean_value}. This set may need some additional structure depending on the syntax of the sentences. The aforementioned set is naturally a \hyperref[def:boolean_algebra]{Boolean algebra}, and the most general setting we will consider are \hyperref[def:heyting_algebra]{Heyting algebras}.

  When working with \hyperref[def:institution/models]{models} and notions related to them, we will presume that an underlying Heyting algebra \( \BbbH \) is fixed. In accordance with \fullref{rem:mathematical_logic_conventions/propositional_constants}, we will denote the top and bottom element of \( \BbbH \) by \( T \) and \( F \).
\end{definition}
\begin{comments}
  \item In \fullref{def:propositional_semantics} we will introduce new terminology based on the particular choice of \( \BbbH \).
\end{comments}

\begin{definition}\label{def:propositional_formula_variables}\mimprovised
  For each formula \( \varphi \), we \hyperref[con:evaluation]{recursively define} the set of variables occurring in the \hyperref[def:propositional_syntax/formula]{propositional formulas}:
  \begin{equation*}
    \op*{Var}(\varphi) \coloneqq \begin{cases}
      \varnothing,                            &\varphi \in \set{ \syntop, \synbot }, \\
      \set{ \varphi },                        &\varphi \in \op*{Prop}, \\
      \op*{Var}(\psi),                        &\varphi = \synneg \psi, \\
      \op*{Var}(\psi) \cup \op*{Var}(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}.
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}\label{def:propositional_valuation}\mimprovised
  We will define valuations for propositional formulas in a fixed \hyperref[def:truth_value_algebra]{truth value Heyting algebra} \( \BbbH \).

  \begin{thmenum}
    \thmitem{def:propositional_valuation/interpretation} An \term[ru=интерпретация (\cite[17]{Герасимов2011}), en=interpretation (\cite[10]{Smullyan1995})]{propositional interpretation} is a function with signature \( I: \op*{Prop} \to \BbbH \).

    We may call an interpretation a \enquote{propositional model} in accordance with \fullref{rem:institutional_model_terminology}. This is further discussed in \fullref{rem:classical_propositional_interpretations}.

    \thmitem{def:propositional_valuation/formula_valuation} Given an interpretation \( I \), we define the corresponding \term[ru=значение истинности (формулы) (\cite[8]{Эдельман1975}), en=valuation (\cite[10]{Smullyan1995})]{valuation} of a formula \( \varphi \) inductively as follows:
    \begin{equation}\label{eq:def:propositional_valuation/formula_valuation}
      \Bracks{\varphi}_I \coloneqq \begin{cases}
        T,                                         &\varphi = \syntop \\
        F,                                         &\varphi = \synbot \\
        I(\varphi),                                &\varphi \in \op*{Prop} \\
        \widetilde{\Bracks{\psi}_I},               &\varphi = \synneg \psi \\
        \Bracks{\psi}_I \relcirc \Bracks{\theta}_I &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn},
      \end{cases}
    \end{equation}
    where \( \relcirc \) denotes \hyperref[def:heyting_algebra]{Heyting algebra} operation corresponding to the connective \( \syncirc \).

    \thmitem{def:propositional_valuation/valuation_function} If \( \op*{Var}(\varphi) \subseteq \set{ P_1, \ldots, P_n } \), the valuation \( \Bracks{\varphi}_I \) only depends on the particular values \( I(P_1), \ldots, I(P_n) \) of \( I \). Hence, if the variables are clear from the context, we obtain a Boolean function
    \begin{equation*}
      \begin{aligned}
        &\Bracks{\varphi}: \BbbH^n \to \BbbH, \\
        &\Bracks{\varphi}(x_1, \ldots, x_n) \coloneqq \Bracks{\varphi}_I,
      \end{aligned}
    \end{equation*}
    where \( I \) is any interpretation such that \( I(P_k) = x_k \) for \( k = 1, \ldots, n \).

    Unless otherwise noted, we assume that \( P_1, \ldots, P_n \) are precisely the variables of \( \varphi \), ordered lexicographically as discussed in \fullref{rem:grammar_rules_for_variables}. We will call this the \term{valuation function} of \( \varphi \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Different authors use different terminology for the concepts in this definition:
  \begin{itemize}
    \item In a very general setting where \hyperref[def:operation_on_set]{algebraic operations} are assigned to abstract logical connectives, \incite[14]{Galatos2007} uses \enquote{assignment} and \enquote{valuation} interchangeably for what we call \enquote{interpretation}, while in the same setting \incite[def. 3.2.3]{CitkinMuravitsky2021} use \enquote{valuation}. The aforementioned authors explain how valuations can be extended for all formulas without introducing additional terminology.

    \item When restricted to the case where \( \BbbH = \set{ T, F } \), which in accordance to \hyperref{def:propositional_semantics} we will call \enquote{classical semantics}, \incite[10]{Smullyan1995} uses terminology analogous to ours, but instead allows valuations to be arbitrary functions satisfying \eqref{eq:def:propositional_valuation/formula_valuation}. \incite[80]{Mimram2020} proceeds similarly for interpretations, but introduces no special term for valuations. \incite[def. 1.1.6]{Hinman2005} follows a similar approach, but uses the term \enquote{atomic truth assignment} for what we call \enquote{propositional interpretation}, and \enquote{truth assignment} for what we call \enquote{valuation}.
  \end{itemize}
\end{comments}

\begin{definition}\label{def:propositional_institution}\mimprovised
  For a fixed \hyperref[def:truth_value_algebra]{truth value Heyting algebra} \( \BbbH \), \hyperref[def:propositional_valuation/interpretation]{propositional interpretations} naturally give rise to an \hyperref[def:institution]{institution} as follows:
  \begin{thmenum}
    \thmitem{thm:propositional_institution/signatures} For the category of \hyperref[def:institution/signatures]{signatures}, fix some symbol \( \anon \) and let \( \cat{Sign} \) be the \hyperref[def:discrete_category]{discrete category} on \( \set{ \anon } \).

    \thmitem{thm:propositional_institution/sentences} The \hyperref[def:institution/sentences]{sentence functor} is \( \anon \mapsto \op*{Form} \).

    \thmitem{thm:propositional_institution/models} Let \( \BbbI \) be the discrete category on the function set \( \fun(\op*{Prop}, \BbbH) \). The \hyperref[def:institution/models]{model functor} can then be described as \( \anon \mapsto \BbbI \).

    \thmitem{thm:propositional_institution/satisfaction} Finally, let the \hyperref[def:institution/satisfaction]{satisfaction} relation \( I \vDash_{\anon} \varphi \) hold if \( \Bracks{\varphi}_I = T \).
  \end{thmenum}
\end{definition}
\begin{defproof}
  We must show that this is indeed an institution, which requires verifying \eqref{eq:def:institution/satisfaction}. But this is vacuous because there are no nontrivial signature morphisms.
\end{defproof}

\begin{definition}\label{def:propositional_semantics}\mimprovised
  By the \term[ru=семантика (\cite[54]{КолмогоровДрагалин2006}), en=semantics (\cite[8]{Hinman2005})]{semantics} of propositional logic we mean the \hyperref[def:propositional_institution]{propositional institution} and all related notions like \hyperref[def:institution/models]{models}, \hyperref[def:institution/satisfaction]{satisfaction}, \hyperref[def:institutional_entailment]{semantic entailment} and \hyperref[def:semantic_equivalence]{semantic equivalence}. We will say that the semantics are \term{\hyperref[def:intuitionistic_logic]{intuitionistic}}, while in the special case where the \hyperref[def:truth_value_algebra]{truth value Heyting algebra} is the two-element Boolean algebra \( \set{ T, F } \), we will call them \term{\hyperref[def:classical_logic]{classical}} or \term{Boolean}.
\end{definition}

\begin{remark}\label{rem:classical_propositional_interpretations}
  Note that the same propositional interpretation may be used to define different valuations, and the notion of \enquote{classical} or \enquote{intuitionistic} semantics from \fullref{def:propositional_semantics} only applies when \eqref{eq:def:propositional_valuation/formula_valuation} is used. For example, a slight variation of the aforementioned valuation results in \fullref{def:minimal_propositional_semantics}. Thus, an interpretation cannot, by itself, be classical.

  On the other hand, (institutional) models can be classical, and propositional models are interpretations, so we are free to use the term \enquote{classical model} when referring to interpretations in an appropriate context.
\end{remark}

\begin{definition}\label{def:propositional_entailment}\mimprovised
  For a fixed \hyperref[def:truth_value_algebra]{truth value Heyting algebra}, we will now consider the \hyperref[def:institutional_entailment]{institutional entailment} relation obtained via \fullref{def:propositional_institution}, according to which that the set \( \Gamma \) of \hyperref[def:propositional_syntax/formula]{propositional formulas} entails \( \psi \) if, whenever some \hyperref[def:propositional_valuation/interpretation]{interpretation} \hyperref[thm:propositional_institution/satisfaction]{satisfies} every formula of \( \Gamma \), it also satisfies \( \psi \).

  We denote the corresponding relation via \( {\vDash} \). Similarly to other \hyperref[def:entailment_system/entailment]{entailment relations}, we use the sequent notation discussed in \fullref{rem:sequent_notation}.
\end{definition}

\begin{definition}\label{def:propositional_tautology}
  We say that \( \varphi \) is a \term[ru=пропозициональная тавтология (\cite[44]{КолмогоровДрагалин2006})]{propositional tautology} if any of the following equivalent conditions hold:
  \begin{thmenum}
    \thmitem{def:propositional_tautology/interpretations}\mcite[11]{Smullyan1995} We have \( \Bracks{\varphi}_I = T \) for every interpretation \( I \).
    \thmitem{def:propositional_tautology/entailment} We have the entailment \( \vDash \varphi \).
    \thmitem{def:propositional_tautology/equivalence} We have the equivalence \( \varphi \gleichstark \syntop \).
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:propositional_contradiction}
  We say that \( \varphi \) is a \term[en=contradictory (formula) (\cite[28]{Kleene2002Logic})]{propositional contradiction} if any of the following equivalent conditions hold:
  \begin{thmenum}
    \thmitem{def:propositional_contradiction/interpretations}\mcite[def. 1.4.1(i)]{Hinman2005} We have \( \Bracks{\varphi}_I = F \) for every interpretation \( I \).
    \thmitem{def:propositional_contradiction/entailment} We have the entailment \( \varphi \vDash \synbot \).
    \thmitem{def:propositional_contradiction/equivalence} We have the equivalence \( \varphi \gleichstark \synbot \).
  \end{thmenum}
\end{definition}

\begin{theorem}[Propositional semantic deduction theorem]\label{thm:propositional_semantic_deduction_theorem}
  For arbitrary propositional formulas, we have
  \begin{equation*}
    \Gamma, \varphi \vDash \psi \T{if and only if} \Gamma \vDash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item See \fullref{rem:deduction_theorem_list} for a list of similar theorems.
\end{comments}
\begin{proof}
  Fix an interpretation \( I \) satisfying \( \Gamma \).

  \SufficiencySubProof Suppose that from \( I \vDash \varphi \) it follows that \( I \vDash \psi \). If \( I \vDash \varphi \), then
  \begin{equation*}
    \Bracks{\varphi \synimplies \psi}_I
    =
    \underbrace{\Bracks{\varphi}_I}_T \rightarrow \underbrace{\Bracks{\psi}_I}_T
    \reloset {\ref{thm:def:heyting_algebra/top_left}} =
    \underbrace{\Bracks{\psi}_I}_T,
  \end{equation*}
  thus \( I \vDash (\varphi \synimplies \psi) \).

  \NecessitySubProof Suppose that \( I \vDash (\varphi \synimplies \psi) \). If \( I \vDash \varphi \), then
  \begin{equation*}
    \underbrace{\Bracks{\varphi \synimplies \psi}_I}_{T}
    =
    \underbrace{\Bracks{\varphi}_I}_T \rightarrow \Bracks{\psi}_I
    \reloset {\ref{thm:def:heyting_algebra/top_left}} =
    \Bracks{\psi}_I,
  \end{equation*}
  thus \( I \vDash \psi \).
\end{proof}

\begin{corollary}\label{thm:propositional_semantic_deduction_consequences}
  We list some consequences of \Fullref{thm:propositional_semantic_deduction_theorem}:
  \begin{thmenum}
    \thmitem{thm:propositional_semantic_deduction_consequences/reflexivity} For every formula \( \varphi \), the formula \( \varphi \synimplies \varphi \) is a \hyperref[def:propositional_tautology]{tautology}.

    \thmitem{thm:propositional_semantic_deduction_consequences/top_elim} \( \syntop \synimplies \varphi \gleichstark \varphi \) for every formula \( \varphi \).

    \thmitem{thm:propositional_semantic_deduction_consequences/top} \( \varphi \vDash \top \) for every formula \( \varphi \).

    \thmitem{thm:propositional_semantic_deduction_consequences/bot} \( \synbot \vDash \varphi \) for every formula \( \varphi \).
  \end{thmenum}
\end{corollary}
\begin{proof}
  \SubProofOf{thm:propositional_semantic_deduction_consequences/reflexivity} Follows from \fullref{def:consequence_relation/reflexivity}.

  \SubProofOf{thm:propositional_semantic_deduction_consequences/top_elim} Follows from \fullref{thm:def:heyting_algebra/top_left}.

  \SubProofOf{thm:propositional_semantic_deduction_consequences/top} Follows from \fullref{thm:def:heyting_algebra/top_left}.

  \SubProofOf{thm:propositional_semantic_deduction_consequences/bot} Follows from \fullref{thm:def:heyting_algebra/leq}.
\end{proof}

\begin{remark}\label{rem:deduction_theorem_list}
  The following is a list of different flavors of the \enquote{deductive theorem} that allows us to use \hyperref[def:propositional_alphabet/connectives/conditional]{implication} and \hyperref[def:entailment_system/entailment]{entailment} interchangeably:
  \begin{thmenum}
    \thmitem{rem:deduction_theorem_list/propositional_semantic} \Fullref{thm:propositional_semantic_deduction_theorem}
    \thmitem{rem:deduction_theorem_list/implicational_syntactic} \Fullref{thm:implicational_syntactic_deduction_theorem}
  \end{thmenum}
\end{remark}

\paragraph{Classical propositional semantics}

\begin{proposition}\label{thm:boolean_equivalences}
  We will list some \hyperref[def:propositional_semantics]{classical} propositional \hyperref[def:semantic_equivalence]{equivalences}\fnote{These are actually statements about \hyperref[def:standard_boolean_functions]{standard Boolean functions}, but nevertheless we find propositional logic more convenient for stating them.}:
  \begin{thmenum}
    \thmitem{thm:boolean_equivalences/negation_bottom} Negation can be expressed as a conditional formula whose \hyperref[def:conditional_formula/consequent]{consequent} is the falsum:
    \begin{equation}\label{eq:thm:boolean_equivalences/negation_bottom}
      \mathllap{\synneg \varphi} \gleichstark \mathrlap{\varphi \synimplies \synbot.}
    \end{equation}

    This equivalence motivates the axioms \eqref{eq:def:minimal_propositional_hilbert_system/neg/elim} and \eqref{eq:def:minimal_propositional_hilbert_system/neg/intro} for the \hyperref[def:minimal_propositional_hilbert_system]{minimal propositional Hilbert system}.

    \thmitem{thm:boolean_equivalences/double_negation} Negation is an \hyperref[def:involution]{involution}:
    \begin{equation}\label{eq:thm:boolean_equivalences/double_negation}
      \mathllap{\synneg \synneg \varphi} \gleichstark \mathrlap{\varphi.}
    \end{equation}

    This equivalence motivates the infamous law \eqref{eq:thm:minimal_propositional_negation_laws/dne} of double negation elimination.

    \thmitem{thm:boolean_equivalences/conditional_as_disjunction} A conditional formula is a disjunction with the \hyperref[def:conditional_formula/antecedent]{antecedent} negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/conditional_as_disjunction}
      \mathllap{\varphi \synimplies \psi} \gleichstark \mathrlap{ \synneg \varphi \synvee \psi. }
    \end{equation}

    This equivalence is known under the name \enquote{material implication} and is discussed in \fullref{con:material_implication}.

    \thmitem{thm:boolean_equivalences/contrapositive} A conditional formula is equivalent to its \hyperref[def:conditional_formula/contrapositive]{contrapositive}:
    \begin{equation}\label{eq:thm:boolean_equivalences/contrapositive}
      \mathllap{\varphi \synimplies \psi} \gleichstark \mathrlap{\synneg \psi \synimplies \synneg \varphi.}
    \end{equation}

    \thmitem{thm:boolean_equivalences/distributivity} Disjunctions and conjunctions distribute over each other:
    \begin{subequations}
      \begin{align}
        \mathllap{\varphi \synvee (\psi \synwedge \theta)} &\gleichstark \mathrlap{(\varphi \synvee \psi) \synwedge (\varphi \synvee \theta),}   \label{eq:thm:boolean_equivalences/distributivity/join_over_meet} \\
        \mathllap{\varphi \synwedge (\psi \synvee \theta)} &\gleichstark \mathrlap{(\varphi \synwedge \psi) \synvee (\varphi \synwedge \theta).} \label{eq:thm:boolean_equivalences/distributivity/meet_over_join}
      \end{align}
    \end{subequations}

    This equivalence motivates axioms \eqref{eq:def:distributive_lattice/join_over_meet} and \eqref{eq:def:distributive_lattice/meet_over_join} for \hyperref[def:distributive_lattice]{distributive lattices}.

    \thmitem{thm:boolean_equivalences/de_morgan} Conjunctions and disjunctions are obtained from each other via negation:
    \begin{subequations}
      \begin{align}
        \mathllap{\synneg (\varphi \synvee \psi)}   &\gleichstark \mathrlap{\synneg \varphi \synwedge \synneg \psi,} \label{eq:thm:boolean_equivalences/de_morgan/complement_of_join} \\
        \mathllap{\synneg (\varphi \synwedge \psi)} &\gleichstark \mathrlap{\synneg \varphi \synvee \synneg \psi.}   \label{eq:thm:boolean_equivalences/de_morgan/complement_of_meet}
      \end{align}
    \end{subequations}

    This equivalence motivates \fullref{thm:de_morgans_laws}.

    \thmitem{thm:boolean_equivalences/biconditional_member_negation} A biconditional formula is equivalent to its termwise negation:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_member_negation}
      \mathllap{\varphi \syniff \psi} \gleichstark \mathrlap{\synneg \varphi \syniff \synneg \psi.}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_negation} A negation of a biconditional formula is again a biconditional with one of the terms negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_negation}
      \begin{aligned}
        \mathllap{\synneg \parens{\varphi \syniff \psi}}
        &\gleichstark
        \mathrlap{\synneg \varphi \syniff \psi \gleichstark}
        \\ &\gleichstark
        \mathrlap{\varphi \syniff \synneg \psi.}
      \end{aligned}
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item These equivalences fail more generally in \hyperref[def:intuitionistic_logic]{intuitionistic logic}.
\end{comments}
\begin{proof}
  The proofs follow directly from the table in \fullref{def:standard_boolean_functions}.
\end{proof}

\begin{concept}\label{con:material_implication}
  Consider the conditional formula \( \varphi \synimplies \psi \). Via \fullref{thm:propositional_semantic_deduction_theorem}, the equivalence \eqref{eq:thm:boolean_equivalences/conditional_as_disjunction} can be restated as follows:
  \begin{displayquote}
    The formula \( \varphi \synimplies \psi \) holds unless the antecedent \( \varphi \) holds and the consequent \( \psi \) doesn't.
  \end{displayquote}

  This equivalence goes back to Philo of Megara, who lived in the third century B.C. We refer to it as \term[ru=материальная импликация (\cite[74]{КолмогоровДрагалин2006}), en=material implication (\cite[9]{Kleene2002Logic})]{material implication} to distinguish it from \enquote{strict} and \enquote{relevant} implications, as well as \enquote{assertions} and other possibilities that try to avoid the so-called \enquote{paradoxes of material implication}. A survey of the aforementioned concepts has been written by \incite{StanfordPlato:logic_of_conditionals}.
\end{concept}

\paragraph{Substitution}

\begin{definition}\label{def:propositional_substitution}
  We sometimes want to substitute a propositional variable with another variable or even with a formula. This is akin to applying a \hyperref[def:boolean_function]{Boolean function} like \( x \synvee y \) to different variables (e.g. to obtain \( x \synvee x \)) or even concrete values (e.g. \( F \synvee T \)), except that it is done on a purely syntactic level without involving any semantics involved.

  \begin{thmenum}
    \thmitem{def:propositional_substitution/literal}\mcite[def. 1.3.13]{Hinman2005} We define the \term[ru=подстановка (\cite[66]{КолмогоровДрагалин2006}), en=substitution]{literal substitution} of the propositional formula \( \chi \) with \( \omega \) in \( \varphi \) as follows:
    \begin{equation}\label{eq:def:propositional_substitution/single}
      \varphi[\chi \mapsto \omega] \coloneqq \begin{cases}
        \omega,                                                         &\varphi = \chi \\
        \varphi,                                                        &\varphi \neq \chi \T{and} \varphi \in \set{ \syntop, \synbot } \cup \op*{Prop} \\
        \synneg \psi[\chi \mapsto \omega],                              &\varphi \neq \chi \T{and} \varphi = \synneg \psi \\
        \psi[\chi \mapsto \omega] \syncirc \theta[\chi \mapsto \omega], &\varphi \neq \chi \T{and} \varphi = \psi \syncirc \theta, \circ \in \op*{Conn}.
      \end{cases}
    \end{equation}

    Note that it is not necessary for \( \chi \) to be a subformula of \( \varphi \) --- the substitution simply does nothing otherwise.

    \thmitem{def:propositional_substitution/uniform}\mcite[def. 3.1.3]{CitkinMuravitsky2021} A \term{uniform substitution} is a map \( \sigma: \op*{Form} \to \op*{Form} \) such that
    \begin{align*}
      \sigma(\neg \varphi) = \neg \sigma(\varphi) &&\T{and}&& \sigma(\varphi \syncirc \psi) = \neg \sigma(\varphi) \syncirc \sigma(\psi).
    \end{align*}

    These conditions make it clear how to extend a substitution only defined for variables.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  If \( \chi \gleichstark \omega \), then
  \begin{equation*}
    \varphi[\chi \mapsto \omega] \gleichstark \varphi.
  \end{equation*}
\end{proposition}
\begin{proof}
  Suppose that \( \chi \gleichstark \omega \). We use \fullref{thm:induction_on_syntax_trees} on \( \varphi \) to show that
  \begin{equation}\label{eq:thm:propositional_substitution_equivalence/proof}
    \varphi[\chi \mapsto \omega] \gleichstark \varphi.
  \end{equation}

  \begin{itemize}
    \item If \( \varphi = \chi \), then \( \varphi[\chi \mapsto \omega] = \omega \) and, by definition,
    \begin{equation*}
      \varphi = \chi \gleichstark \omega = \varphi[\chi \mapsto \omega].
    \end{equation*}

    \item If \( \varphi \neq \chi \) and \( \varphi \in \set{ \syntop, \synbot } \cup \op*{Prop} \), then \( \varphi[\chi \mapsto \omega] = \varphi \) and \eqref{eq:thm:propositional_substitution_equivalence/proof} again holds trivially.

    \item If \( \varphi \neq \chi \) and \( \varphi = \synneg \omega \) and if the inductive hypothesis holds for \( \omega \), then
    \begin{equation*}
      \varphi[\chi \mapsto \omega] = \synneg \psi[\chi \mapsto \omega].
    \end{equation*}

    For any interpretation \( I \),
    \begin{equation*}
      \Bracks[\Big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \oline{\Bracks[\Big]{\psi[\chi \mapsto \omega] }_I}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi}_I}
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    Generalizing on \( I \), we conclude that \eqref{eq:thm:propositional_substitution_equivalence/proof} holds in this case.

    \item If \( \varphi \neq \chi \) and \( \varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn} \) and if the inductive hypothesis holds for both \( \psi \) and \( \theta \), then for any interpretation \( I \),
    \begin{equation*}
      \Bracks[\Big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \Bracks[\Big]{ \psi[\chi \mapsto \omega] }_I \relcirc \Bracks[\Big]{ \theta[\chi \mapsto \omega] }_I
      \reloset {\T{ind.}} =
      \Bracks[\Big]{\psi}_I \relcirc \Bracks[\Big]{\theta}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    Again, generalizing on \( I \), we conclude that \eqref{eq:thm:propositional_substitution_equivalence/proof} holds.
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_substitution_equivalence/proof} holds in all cases.
\end{proof}

\begin{remark}\label{rem:uniform_substitution_notation}
  For \hyperref[def:propositional_substitution/uniform]{uniform substitution}, instead of writing \( \sigma(\varphi) \), we may write \( \varphi[\sigma] \) or, in case only finitely many variables are not \hyperref[def:fixed_point]{fixed points},
  \begin{equation*}
    \varphi[P_1 \mapsto \sigma(P_1), \cdots, P_n \mapsto \sigma(P_n)]
  \end{equation*}

  when the variables \( P_1, \ldots, P_n \) are clear from the context, we write
  \begin{equation*}
    \varphi[\omega_1, \cdots, \omega_n]
  \end{equation*}
  as a shorthand for
  \begin{equation*}
    \varphi[P_1 \to \omega_1, \cdots, P_n \to \omega_n].
  \end{equation*}

  This also applies to the different kinds of first-order substitution defined in \fullref{def:first_order_substitution}, where the notation also allows us to use predicate formulas discussed in \fullref{rem:uniform_substitution_notation}.
\end{remark}

\paragraph{Conjunctive and disjunctive normal forms}

\begin{definition}\label{def:cnf_and_dnf}\mimprovised
  We will now introduce \term[ru=конъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975}), en=conjunctive normal form (\cite[def. 1.3.10]{Hinman2005})]{conjunctive normal forms} (CNF) and \term[ru=дизъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975}), en=disjunctive normal form (\cite[def. 1.3.10]{Hinman2005})]{disjunctive normal forms} (DNF) for propositional formulas.

  The structure of these formulas is best described by the following extension of the \hyperref[def:propositional_syntax]{propositional syntax grammar schema}:
  \begin{bnf*}
    \bnfprod{positive literal}       {\bnfpn{variable}} \\
    \bnfprod{negative literal}       {\synneg \bnfpn{variable}} \\
    \bnfprod{literal}                {\bnfpn{positive literal}       \bnfor \bnfpn{negative literal}} \\
    \bnfprod{elementary disjunction} {\bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{CNF}                    {\bnfpn{elementary disjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{CNF}              \bnfsp \bnftsq{\( \synwedge \)} \bnfsp \bnfpn{CNF}             \bnfsp \bnftsq{)}} \\
    \bnfprod{elementary conjunction} {\bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{DNF}                    {\bnfpn{elementary conjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{DNF}              \bnfsp \bnftsq{\( \synvee \)}   \bnfsp \bnfpn{DNF}             \bnfsp \bnftsq{)}}
  \end{bnf*}
\end{definition}
\begin{comments}
  \item The terms \enquote{literal}, \enquote{positive literal} and \enquote{negative literal} are used by \incite[40; 108]{Rosen1999}. The adjective \enquote{elementary} for conjunctions and disjunctions is based on \cite[36]{Эдельман1975}. \incite[13]{Smullyan1995} instead uses \enquote{basic conjunction}.
  \item The concepts are related but distinct from that of \hyperref[rem:lattice_polynomials]{lattice polynomials}.
  \item As usual, we utilize the convention in \fullref{rem:propositional_formula_parentheses} and avoid excessive parentheses.
\end{comments}

\begin{theorem}[Principle of duality for CNF and DNF]\label{thm:cnf_and_dnf_duality}
  Suppose we are working with \hyperref[def:propositional_semantics]{classical semantics}.

  Fix a propositional formula \( \varphi \) in \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}). Consider its opposite \( \varphi^\oppos \), in which we swap all conjunctions and disjunctions, then make all positive literals negative and vice versa. Obviously \( \varphi^\oppos \) is in DNF (resp. CNF).

  Furthermore, \( \neg \varphi \) is \hyperref[def:semantic_equivalence]{semantically equivalent} to \( \varphi^\oppos \).
\end{theorem}
\begin{proof}
  Consider an elementary disjunction
  \begin{equation*}
    \psi = L_1 \synvee L_2 \synvee \cdots \synvee L_n,
  \end{equation*}
  where, for every \( k = 1, \ldots, n \), \( L_k \) is either \( P_k \) or \( \neg P_k \).

  We have
  \begin{equation*}
    \psi^\oppos = L_1^\oppos \synwedge L_2^\oppos \synwedge \cdots \synwedge L_n^\oppos.
  \end{equation*}

  Then, for any interpretation \( I \),
  \begin{equation*}
    \Bracks{\psi^\oppos}_I
    =
    \Bracks{L_1^\oppos}_I \wedge \cdots \wedge \Bracks{L_n^\oppos}_I
    =
    \oline{\Bracks{L_1}_I} \wedge \cdots \wedge \oline{\Bracks{L_n}_I}
    \reloset {\ref{thm:boolean_equivalences/de_morgan}} =
    \oline{ \Bracks{L_1}_I \vee \cdots \vee \Bracks{L_n}_I }
    =
    \oline{ \Bracks{\psi}_I }
    =
    \Bracks{\neg \psi}_I.
  \end{equation*}

  Now consider a formula in CNF
  \begin{equation*}
    \varphi = \psi_1 \synwedge \psi_2 \synwedge \cdots \synwedge \psi_m,
  \end{equation*}
  where, for every \( k = 1, \ldots, m \), \( \psi_k \) is an elementary disjunction.

  Then
  \begin{equation*}
    \Bracks{\varphi^\oppos}_I
    =
    \Bracks{\psi_1^\oppos}_I \vee \cdots \vee \Bracks{\psi_m^\oppos}_I
    =
    \oline{\Bracks{\psi_1}_I} \vee \cdots \vee \oline{\Bracks{\psi_m}_I}
    \reloset {\ref{thm:boolean_equivalences/de_morgan}} =
    \oline{ \Bracks{\psi_1}_I \wedge \cdots \wedge \Bracks{\psi_m}_I }
    =
    \oline{ \Bracks{\varphi}_I }
    =
    \Bracks{\neg \varphi}_I.
  \end{equation*}
\end{proof}

\begin{remark}\label{rem:straightforward_traversal}
  Consider the identity operator for formulas:
  \begin{equation*}
    \begin{aligned}
      \id(\varphi) \coloneqq \begin{cases}
        \varphi,                        &\varphi \in \set{ \syntop, \synbot } \\
        \varphi,                        &\varphi \in \op*{Prop} \\
        \synneg \id(\psi),              &\varphi = \synneg \psi, \\
        \id(\psi) \syncirc \id(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \end{cases}
    \end{aligned}
  \end{equation*}

  When defining an operator acting on formulas, we usually handle only a few cases, and the others become straightforward. For example, replacing \( \synneg \varphi \) with \( \varphi \synimplies \synbot \), as justified by \fullref{thm:boolean_equivalences/negation_bottom}, can be achieved via
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        \varphi,                     &\varphi \in \set{ \syntop, \synbot } \\
        \varphi,                     &\varphi \in \op*{Prop} \\
        R(\psi) \synimplies \synbot, &\varphi = \synneg \psi, \\
        R(\psi) \syncirc R(\theta),  &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \end{cases}
    \end{aligned}
  \end{equation*}

  We can instead use the notational shorthand
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        R(\psi) \synimplies \synbot,                                             &\varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{aligned}
  \end{equation*}

  In computer programming, this exact problem is solved via the visitor design pattern --- visitors for formulas of first-order logic can be found in \cite{code}.
\end{remark}

\begin{algorithm}[Formula to CNF or DNF]\label{alg:cnf_and_dnf}
  Again, suppose we are working with \hyperref[def:propositional_semantics]{classical semantics}.

  We will define four operators, \( C_1 \) through \( C_4 \), such that, for a \hyperref[def:propositional_syntax/formula]{propositional formula} \( \varphi \)
  \begin{equation*}
    [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\varphi)
  \end{equation*}
  is a formula in \hyperref[def:cnf_and_dnf]{conjunctive normal form} that is \hyperref[def:semantic_equivalence]{semantically equivalent} to \( \varphi \).

  In order to obtain a \hyperref[def:cnf_and_dnf]{disjunctive normal form} instead, we will need to use \( C_4^\oppos \) rather than \( C_4 \).

  \begin{thmenum}
    \thmitem{alg:cnf_and_dnf/constants} First, we remove the propositional constants. Choose any propositional variable, say \( P \), and let
    \begin{equation*}
      C_1(\varphi) \coloneqq \begin{cases}
        P \vee \synneg P,                                                        &\varphi = \syntop, \\
        P \wedge \synneg P,                                                      &\varphi = \synbot, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Fullref{thm:propositional_substitution_equivalence} implies that, since \( P \vee \synneg P \gleichstark \syntop \) and \( P \wedge \synneg P \gleichstark \synbot \), then \( C_1(\varphi) \gleichstark \varphi \).

    \thmitem{alg:cnf_and_dnf/conditional} Next, we remove the conditional \( \synimplies \) and biconditional \( \syniff \). Let
    \begin{equation*}
      C_2(\varphi) \coloneqq \begin{cases}
        \synneg C_2(\psi) \synvee C_2(\theta),                                   &\varphi = \psi \synimplies \theta, \\
        C_2(\psi \synimplies \theta) \synwedge C_2(\theta \synimplies \psi),     &\varphi = \psi \syniff \theta, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Fullref{thm:boolean_equivalences/conditional_as_disjunction} and \fullref{def:heyting_algebra/biconditional} justify the substitutions and ensure that \( C_2(\varphi) \gleichstark \varphi \).

    \thmitem{alg:cnf_and_dnf/negation} We \enquote{push} negations inwards. Let
    \begin{equation*}
      C_3(\varphi) \coloneqq \begin{cases}
        C_3(\synneg \psi) \synwedge C_3(\synneg \theta),                         &\varphi = \synneg (\psi \synvee \theta), \\
        C_3(\synneg \psi) \synvee C_3(\synneg \theta),                           &\varphi = \synneg (\psi \synwedge \theta), \\
        C_3(\psi),                                                               &\varphi = \synneg \synneg \psi, \\
        \synneg C_3(\psi),                                                       &\T{otherwise if} \varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Fullref{thm:boolean_equivalences/de_morgan} and \fullref{thm:boolean_equivalences/double_negation} ensure that \( C_3(\varphi) \gleichstark \varphi \) for any formula \( \varphi \).

    If case \( \varphi \) has no (bi)conditionals (e.g. due to \( C_2 \)), the result \( C_3(\varphi) \) has negations only before propositional variables.

    \thmitem{alg:cnf_and_dnf/distributive} Finally, we \enquote{pull} conjunctions outwards. Let
    \begin{equation*}
      C_4(\varphi) \coloneqq \begin{cases}
        C_4(\psi_1 \synvee \theta) \synwedge C_4(\psi_1 \synvee \theta),         &\varphi = \psi \synvee \theta \T{and} C_4(\psi) = \psi_1 \synwedge \psi_2, \\
        C_4(\psi \synvee \theta_1) \synwedge C_4(\psi \synvee \theta_2),         &\T{otherwise if} \varphi = \psi \synvee \theta \T{and} C_4(\theta) = \theta_1 \synwedge \theta_2, \\
        C_4(\psi) \synvee C_4(\theta),                                           &\T{otherwise if} \varphi = \psi \synvee \theta, \\
        C_4(\psi) \synwedge C_4(\theta),                                         &\varphi = \psi \synwedge \theta, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The last case is due to the usual traversal rules, and we could avoid writing it, but we wanted to be explicit about how conjunction behaves with \( C_4 \).

    \Fullref{thm:boolean_equivalences/distributivity} ensures that \( C_4(\varphi) \gleichstark \varphi \) for any formula \( \varphi \).

    To \enquote{pull} out disjunctions instead, we will need the operator \( C_4^\oppos \), which is defined like \( C_4 \) but with \( \synvee \) and \( \synwedge \) swapped.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{fol.cnf.to_cnf} in \cite{code}.
\end{comments}
\begin{defproof}
  It is obvious from our comments that \( \varphi \) is equivalent to
  \begin{equation*}
    \varphi' \coloneqq [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\varphi).
  \end{equation*}

  We will use \hyperref[con:induction/peano_arithmetic]{natural number induction} on the length of \( \varphi \) to show that it is in conjunctive normal form.

  \begin{itemize}
    \item If \( \varphi = \syntop \), then \( \varphi' = C_1(\varphi) = P \synvee \synneg P \), which is a disjunction of literals.
    \item If \( \varphi = \synbot \), then \( \varphi' = C_1(\varphi) = P \synwedge \synneg P \), which is a conjunction of \enquote{unary} disjuncts of literals.
    \item If \( \varphi \) is a propositional variable, then \( \varphi' = \varphi \) is a literal.

    \item If \( \varphi = \psi_1 \synvee \psi_2 \), then
    \begin{equation*}
      \varphi'
      =
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \synvee \psi_2)
      =
      C_4\parens[\Big]{ [C_3 \bincirc C_2 \bincirc C_1](\psi_1) \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) }
    \end{equation*}

    The result of applying \( C_4 \) depends on \( \psi_1' \) and \( \psi_2' \). Note that both are shorter than \( \varphi \), so both must be in CNF.
    \begin{itemize}
      \item If \( (\synneg \theta_1)' = \chi_1 \synwedge \chi_2 \), then
      \begin{balign*}
        \varphi'
        &=
        C_4\parens[\bigg]{ \parens[\Big]{ \chi_1 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } \synwedge \parens[\Big]{ \chi_2 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } }
        = \\ &=
        C_4\parens[\Big]{ \chi_1 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } \synwedge C_4\parens[\Big]{ \chi_2 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) }
        = \\ &=
        (\chi_1 \synvee \psi_2)' \synwedge (\chi_2 \synvee \psi_2)'.
      \end{balign*}

      Since both \( (\chi_1 \synvee \psi_2)' \) and \( (\chi_2 \synvee \psi_2)' \) are shorter than \( \varphi \), the inductive hypothesis implies that they are in CNF. Then \( \varphi' \) itself is also in CNF.

      \item If \( \psi_1' \) is not a conjunction and if \( \psi_2' = \chi_1 \synwedge \chi_2 \), then, by analogy with the case above, we conclude that \( \varphi' \) is in CNF.

      \item If neither \( \psi_1' \) nor \( \psi_2' \) are conjunctions, then they must be disjunctions of literals, and hence \( \varphi' \) is also a disjunction of literals.
    \end{itemize}

    \item If \( \varphi = \psi_1 \synwedge \psi_2 \), the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), hence \( \varphi' = \psi_1' \synwedge \psi_2' \) is in CNF.

    \item If \( \varphi = \psi_1 \synimplies \psi_2 \), then
    \begin{balign*}
      \varphi'
      &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \synimplies \psi_2)
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2]\parens[\Big]{ C_1(\psi_1) \synimplies C_1(\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3]\parens[\Big]{ [C_2 \bincirc C_1](\synneg \psi_1) \synvee [C_2 \bincirc C_1](\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\synneg \psi_1 \synvee \psi_2).
    \end{balign*}

    This reduces to the case where \( \varphi \) is a disjunction, hence we can conclude that \( \varphi' \) is in CNF.

    \item If \( \varphi = \psi_1 \syniff \psi_1 \), then
    \small
    \begin{balign*}
      \varphi'
      &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \syniff \psi_2)
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2]\parens[\Big]{ C_1(\psi_1) \syniff C_1(\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3]\parens[\bigg]{ \parens[\Big]{\synneg [C_2 \bincirc C_1](\psi_1) \synvee [C_2 \bincirc C_1](\psi_2)} \synwedge \parens[\Big]{ [C_2 \bincirc C_1](\psi_1) \synvee \synneg [C_2 \bincirc C_1](\psi_2) } }
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1]\parens[\Big]{ (\synneg \psi_1 \synvee \psi_2) \synwedge (\psi_1 \synvee \synneg \psi_2) },
    \end{balign*}
    \normalsize
    which reduces to the case where \( \varphi \) is a conjunction.

    \item If \( \varphi = \synneg \psi \), where \( \psi' \) is in CNF, then we must use nested induction on \( \psi' \):
    \begin{itemize}
      \item If \( \psi = \syntop \), then
      \begin{multline*}
        \varphi'
        =
        C_3(C_1(\synneg \syntop))
        =
        C_3(\synneg C_1(\syntop))
        =
        C_3(\synneg (P \synvee \synneg P))
        = \\ =
        C_3(\synneg P) \synvee C_3(\synneg \synneg P)
        =
        \synneg C_3(P) \synwedge C_3(P)
        =
        \synneg P \synwedge P,
      \end{multline*}
      which is again a conjunction of unary disjuncts of literals.

      \item Dually, if \( \psi = \synbot \), then
      \begin{equation*}
        \varphi'
        =
        C_3(C_1(\synneg \synbot))
        =
        C_3(\synneg (P \synwedge \synneg P))
        =
        \synneg P \synvee P,
      \end{equation*}
      which is a disjunction of literals.

      \item If \( \psi = \synneg \theta \), we have \( \varphi' = \theta' \). Furthermore, since \( \theta \) is shorter than \( \varphi \), \( \theta' \) is in CNF, and hence so is.

      \item If \( \psi = \theta_1 \synvee \theta_2 \), then
      \begin{balign*}
        \varphi'
        &=
        [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1]\parens[\Big]{\synneg (\theta_1 \synvee \theta_2) }
        = \\ &=
        [C_4 \bincirc C_3]\parens[\Big]{ \synneg \parens[\Big]{ [C_2 \bincirc C_1](\theta_1) \synvee [C_2 \bincirc C_1](\theta_2) } }
        = \\ &=
        C_4\parens[\Big]{ C_3\parens[\Big]{ \synneg [C_2 \bincirc C_1](\theta_1) } \synwedge C_3\parens[\Big]{ \synneg [C_2 \bincirc C_1](\theta_2) } }
        = \\ &=
        C_4\parens[\Big]{ [C_3 \bincirc C_2 \bincirc C_1](\synneg \theta_1) \synwedge [C_3 \bincirc C_2 \bincirc C_1](\synneg \theta_2) }
        = \\ &=
        (\synneg \theta_1 \synwedge \synneg \theta_2)'
      \end{balign*}

      This reduces to the case where \( \varphi' \) is a conjunction.

      \item If \( \psi = \theta_1 \synwedge \theta_2 \), then
      \begin{align*}
        \varphi'
        =
        (\synneg \theta_1 \synvee \synneg \theta_2)',
      \end{align*}
      which reduces to the case where \( \varphi \) is a disjunction.

      \item If \( \psi = \theta_1 \synimplies \theta_2 \), this reduces to the case where \( \psi \) is a disjunction and \( \varphi \) is a conjunction.
      \item If \( \psi = \theta_1 \syniff \theta_2 \), this reduces to the case where \( \psi \) is a conjunction and \( \varphi \) is a disjunction.
    \end{itemize}

    In all cases for \( \psi \) in \( \varphi = \synneg \psi \), we have shown that \( \varphi' \) is in CNF.
  \end{itemize}

  We have finished the inductive proof that, for any formula \( \varphi \), the result \( \varphi' \) of applying the transformations \( C_1 \) through \( C_4 \) is a formula in CNF.
\end{defproof}

\begin{definition}\label{def:perfect_cnf_and_dnf}\mimprovised
  We say that the \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}) is \term[ru=совершенная (\cite[def. 6.3; def. 6.4]{Эдельман1975}), en=full (\cite[38]{Rosen1999}) / strict (\cite[def. 1.3.10]{Hinman2005})]{perfect} if the following hold:
  \begin{thmenum}
    \thmitem{def:perfect_cnf_and_dnf/literals} Every elementary disjunction (resp. conjunction) contains exactly one literal for each variable encountered in the formula, and these variables are ordered as per \fullref{rem:grammar_rules_for_variables}.

    More explicitly, if the variables are \( P_1, \ldots, P_n \), every elementary disjunction has the form
    \begin{equation*}
      L_1 \synvee L_2 \synvee \cdots \synvee L_n,
    \end{equation*}
    where, for every \( k = 1, \ldots, n \), \( L_k \) is either \( P_k \) or \( \neg P_k \).

    \thmitem{def:perfect_cnf_and_dnf/elementary} The elementary disjunctions (resp. conjunctions) are ordered \hyperref[def:lexicographic_order]{lexicographically} so that \( P_k < \neg P_k \) for every variable \( P_k \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is based on \cite[def. 6.3; def. 6.4]{Эдельман1975}, but with adjustments made in order to improve rigor.
\end{comments}

\begin{proposition}\label{thm:perfect_cnf_and_dnf_uniqueness}
  A \hyperref[def:perfect_cnf_and_dnf]{perfect} \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}) is unique.
\end{proposition}
\begin{proof}
  Trivial.
\end{proof}

\begin{example}\label{ex:def:cnf_and_dnf}
  We list examples of formulas in \hyperref[def:cnf_and_dnf]{conjunctive and disjunctive normal forms}:
  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/perfect_cnf} The \hyperref[thm:boolean_equivalences]{Boolean equivalence} \eqref{eq:thm:boolean_equivalences/conditional_as_disjunction} allows us to represent convert the \hyperref[def:propositional_alphabet/connectives/conditional]{conditional} \( \varphi \synimplies \psi \) to \( \synneg \varphi \synvee \psi \), which is both in CNF and in DNF.

    It is an elementary disjunction, hence it is vacuously in perfect CNF.

    The DNF is not perfect, however, because the condition \fullref{def:perfect_cnf_and_dnf/literals} is not satisfied.

    \thmitem{def:cnf_and_dnf/perfect_dnf} Consider instead the formula
    \begin{equation*}
      (\varphi \synwedge \psi) \synvee (\synneg \varphi \synwedge \psi) \synvee (\synneg \varphi \synwedge \synneg \psi)
    \end{equation*}

    It is in perfect DNF, and it is equivalent to \( \varphi \synimplies \psi \).
  \end{thmenum}
\end{example}

\begin{algorithm}[Boolean function to perfect CNF or DNF]\label{alg:perfect_cnf_and_dnf}\mcite[thm. I.1.3]{Яблонский2003}
  Let \( f(x_1, \ldots, x_n) \) be an arbitrary \hyperref[def:boolean_function]{Boolean function}.

  We will build a formula \( \varphi \) in \hyperref[def:perfect_cnf_and_dnf]{perfect} \hyperref[def:cnf_and_dnf]{conjunctive normal form} whose \hyperref[def:propositional_valuation/valuation_function]{induced function} under \hyperref[def:propositional_semantics]{classical semantics} will be \( f \).

  \begin{thmenum}
    \thmitem{alg:perfect_cnf_and_dnf/true} If \( f \) is canonically true, let \( \varphi \coloneqq P \synvee \neg P \).

    \thmitem{alg:perfect_cnf_and_dnf/false} If \( n = 0 \) and \( f = F \), let \( \varphi \coloneqq P \synwedge \neg P \).

    \thmitem{alg:perfect_cnf_and_dnf/elementary} Otherwise, fix some propositional variables \( P_1, \ldots, P_n \). Given a tuple \( x_1, \ldots, x_n \) of Boolean values, we can construct the following elementary disjunction:
    \begin{equation}\label{alg:perfect_cnf_and_dnf/cnf}
      P_1^{x_1} \synvee \cdots \synvee P_n^{x_n},
    \end{equation}
    where
    \begin{equation*}
      P_k^{x_k} \coloneqq \begin{cases}
        P_k,      &x_k = F, \\
        \neg P_k, &x_k = T.
      \end{cases}
    \end{equation*}

    \thmitem{alg:perfect_cnf_and_dnf/total} Finally, order the disjunctions with respect to the \hyperref[def:lexicographic_order]{lexicographic order} on the set \( \set{ T, F }^n \) (\( F < T \)) to which the tuples of Boolean values \( (x_1, \ldots, x_n) \) belong. Then let \( \varphi \) be the conjunction of the corresponding elementary disjunctions for which
    \begin{equation*}
      f(x_1, \ldots, x_n) = F.
    \end{equation*}

    \thmitem{alg:perfect_cnf_and_dnf/dual} In order to obtain a perfect DNF instead, we can utilize \fullref{thm:cnf_and_dnf_duality} by instead considering the function
    \begin{equation*}
      \oline{f(x_1, \ldots, x_n)},
    \end{equation*}
    obtaining a formula \( \varphi \) in CNF and then using the dual formula \( \varphi^\oppos \).
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{fol.cnf.function_to_cnf} in \cite{code}.
\end{comments}
\begin{defproof}
  We will use induction on \( n \) to show that
  \begin{equation*}
    \Bracks{\varphi}(x_1, \ldots, x_n) = f(x_1, \ldots, x_n).
  \end{equation*}

  \begin{itemize}
    \item The case \( n = 0 \) is special.
    \begin{itemize}
      \item If \( f = T \), then, by \fullref{alg:perfect_cnf_and_dnf/true}, \( \varphi = P \synvee \neg P \), which is a tautology.
      \item If \( f = F \), then, by \fullref{alg:perfect_cnf_and_dnf/false}, \( \varphi = P \synwedge \neg P \), which is a contradictory formula.
    \end{itemize}

    \item Let \( n = 1 \).
    \begin{itemize}
      \item If \( f(x) = T \), then again by \fullref{alg:perfect_cnf_and_dnf/true}, \( \varphi = P \synvee \neg P \) is a tautology.
      \item If \( f(x) = F \), then \fullref{alg:perfect_cnf_and_dnf/elementary} provides us with the elementary disjunctions \( P^F = P \) and \( P^T = \neg P \) and \fullref{alg:perfect_cnf_and_dnf/total} gives us \( \varphi = P \wedge \neg P \).
      \item If \( f(x) = x \), then we only consider the elementary disjunction \( P^F = P \), which leads us to \( \varphi = P \).
      \item If \( f(x) = \oline{x} \), then \( \varphi = \neg P \).
    \end{itemize}

    Therefore, if \( f \) is unary, the formula \( \varphi \) constructed via this algorithm satisfies \( \Bracks{\varphi}(x) = f(x) \).

    \item Consider the function \( f(x_1, \ldots, x_n, x_{n+1}) \) and suppose that, for any \( n \)-ary Boolean function \( g \), the interpretation of its corresponding formula coincides with \( g \).

    Let \( \varphi_F \) be the formula obtained for \( f(x_1, \ldots, x_n, F) \) and let \( \varphi_F' \) be the formula obtained from \( \varphi_F \) by adding the literal \( P_{n+1} \) to each elementary disjunction.

    Dually, let \( \varphi_T \) be the formula for \( f(x_1, \ldots, x_n, T) \) and let \( \varphi_T' \) be the formula obtained by adding the literal \( \neg P_{n+1} \) to each elementary disjunction.

    Then
    \begin{equation*}
      \Bracks{\varphi_F' \wedge \varphi_T'}(x_1, \ldots, x_n, F)
      =
      \underbrace{\Bracks{\varphi_F'}(x_1, \ldots, x_n, F)}_{\mathclap{\Bracks{\varphi_F}(x_1, \ldots, x_n) \T*{because} \Bracks{P_{n+1}}(F) = F}} \wedge \overbrace{\Bracks{\varphi_T'}(x_1, \ldots, x_n, F)}^{T \T*{because} \Bracks{\neg P_{n+1}}(F) = T}
      =
      \underbrace{\Bracks{\varphi_F}(x_1, \ldots, x_n)}_{f(x_1, \ldots, x_n, F)}
    \end{equation*}
    and similarly
    \begin{equation*}
      \Bracks{\varphi_F' \wedge \varphi_T'}(x_1, \ldots, x_n, T)
      =
      \Bracks{\varphi_T}(x_1, \ldots, x_n)
      =
      f(x_1, \ldots, x_n, T).
    \end{equation*}
  \end{itemize}

  We conclude that the interpretation of a formula obtained through this algorithm is the initial function.
\end{defproof}

\paragraph{Equivalence of propositional formulas and Boolean functions}

\begin{proposition}\label{thm:propositional_formulas_and_boolean_functions}
  \hyperref[def:propositional_syntax/formula]{Propositional formulas} under \hyperref[def:propositional_semantics]{classical semantics} have the following structural properties when treated as \hyperref[def:boolean_function]{Boolean functions}:

  \begin{thmenum}
    \thmitem{thm:propositional_formulas_and_boolean_functions/equivalence_classes} \hyperref[def:semantic_equivalence]{Semantic equivalence} \( \gleichstark \) is an \hyperref[def:equivalence_relation]{equivalence relation} on the set \( \op*{Form} \) of all propositional formulas.

    \thmitem{thm:propositional_formulas_and_boolean_functions/bijection} Given the set \( \mscrB \) of all \hyperref[def:boolean_function]{Boolean functions} of arbitrary arity, the following map is bijective:
    \begin{equation*}
      \begin{aligned}
        &\Phi: \op*{Form} / {\gleichstark} \to \mscrB \\
        &\Phi([\varphi]) \coloneqq \Bracks{\varphi}.
      \end{aligned}
    \end{equation*}
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item This is one of the motivations for studying \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebras}.
  \item Both \( \op*{Form} / {\gleichstark} \) and \( \mscrB \) are provably Boolean algebras, but we give very different proofs --- the former is a Boolean algebra due to the syntactic \fullref{thm:intuitionistic_lindenbaum_tarski_algebra}, and the latter is a Boolean algebra due to the semantic \fullref{thm:functions_over_model_form_model}. This is another demonstration of the soundness and completeness stated in \fullref{thm:classical_first_order_logic_is_sound_and_complete}. See also \fullref{rem:thm:intuitionistic_lindenbaum_tarski_algebra/syntactic_proof}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:propositional_formulas_and_boolean_functions/equivalence_classes} Straightforward.

  \SubProofOf{thm:propositional_formulas_and_boolean_functions/bijection} The map \( \Phi \) is well-defined since, by definition of semantic equivalence, \( \varphi \gleichstark \psi \) whenever \( \Bracks{\varphi}_I = \Bracks{\psi}_I \) for every interpretation \( I \).

  Injectivity of \( \Phi \) is also obvious from the definition of semantic equivalence, while surjectivity is given by \fullref{alg:perfect_cnf_and_dnf}.
\end{proof}
