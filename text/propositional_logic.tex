\subsection{Propositional logic}\label{subsec:propositional_logic}

Propositional logic allows us to express basic relations between atomic propositions --- variables that are either true or false.

\begin{remark}\label{rem:propositional_syntax_and_grammars}
  There are different approaches to formalizing the syntax of propositional logic. We use the theory of formal grammars that we have developed in \fullref{subsec:formal_languages} and \fullref{subsec:syntax_trees}. This requires specific adjustments related to other treatments of propositional logic --- e.g. Peter Hinman in \incite[ch. 1]{Hinman2005} --- but allows us to use powerful tools while treating the object logic in complete formality.
\end{remark}

\begin{remark}\label{rem:grammar_rules_for_variables}
  We need to introduce conventions for identifiers --- i.e. names of variables, functions and so forth --- in order to be able to be able to express infinitely many variables with finitely many grammar rules. The variable names that we will actually use will be a very specific subset of the ones we allow formally. Consider the following \hyperref[rem:backus_normal_form]{grammar schema}:
  \begin{bnf*}
    \bnfprod{Latin letter}       {\bnftsq{A} \bnfor \bnftsq{B} \bnfor \cdots \bnfor \bnftsq{Z} \bnfor \bnftsq{a} \bnfor \bnftsq{b} \bnfor \cdots \bnfor \bnftsq{z}} \\
    \bnfprod{Latin word}         {\bnfpn{Latin letter} \bnfor \bnfpn{Latin letter} \bnfsp \bnfpn{Latin word}} \\
    \bnfprod{Latin identifier}   {\bnfpn{Latin word} \bnfor \bnfpn{Latin word} \bnfsp \bnfpn{natural number}},
  \end{bnf*}
  where grammar rules for natural numbers can be taken from \fullref{rem:decimal_notation_grammar}.

  An identifier is a nonempty sequence of Latin letters, optionally followed by a number. We treat this number as a suffix and write it as a subscript, that is, we write \( P_1 \) instead of \( P1 \).

  A benefit of this naming schema is that we can introduce a \hyperref[thm:def:well_ordered_set/lexicographic]{lexicographic well-ordering} on the set of identifiers. This ordering will benefit us in \fullref{def:propositional_valuation/valuation_function}, \fullref{def:propositional_substitution/simultaneous} and \fullref{def:first_order_substitution/term_in_formula}. We use the following conventions:
  \begin{itemize}
    \item Individual digits are ordered as they are listed in \fullref{rem:decimal_notation_grammar}, i.e.
    \begin{equation*}
      0 < 1 < \cdots < 9.
    \end{equation*}

    \item Individual letters are ordered as they are listed above, i.e.
    \begin{equation*}
      A < B < \cdots < Z < a < b < \cdots < z.
    \end{equation*}

    \item Digits are smaller than letters.

    \item In the case of words of different lengths, if one word is a prefix of another, we assume that the shorter word is smaller, i.e.
    \begin{equation*}
      a < a_{13} < aa.
    \end{equation*}

    Comparing words of different lengths is discussed in \fullref{ex:def:lexicographic_order/heterogenous_words}.
  \end{itemize}

  We introduce analogous rules for \( \bnfpn{Greek identifier} \) that we will use in \fullref{def:first_order_syntax}.
\end{remark}

\begin{definition}\label{def:propositional_language}\mcite[14]{Hinman2005}
  The \term{language of propositional logic}\footnote{This is strictly speaking, an \hyperref[def:formal_language]{alphabet} rather than a \hyperref[def:formal_language/language]{formal language}. Nonetheless, this is the established terminology.} consists of:

  \begin{thmenum}
    \thmitem{def:propositional_language/constants} Two \term{propositional constants} (also known as \term{truth values}):
    \begin{thmenum}
      \thmitem{def:propositional_language/constants/verum} The \term{verum} \enquote{\( \top \)}.
      \thmitem{def:propositional_language/constants/falsum} The \term{falsum} \enquote{\( \bot \)}.
    \end{thmenum}

    \thmitem{def:propositional_language/negation} \term{Negation} \enquote{\( \neg \)}.
    \thmitem{def:propositional_language/connectives} The set \( \Sigma \) of \term{propositional binary connectives}, namely
    \begin{thmenum}
      \thmitem{def:propositional_language/connectives/disjunction} \term{Disjunction} \enquote{\( \vee \)}, also known as \hyperref[def:standard_boolean_operators]{\term{or}} and \hyperref[def:semilattice/join]{\term{join}}.
      \thmitem{def:propositional_language/connectives/conjunction} \term{Conjunction} \enquote{\( \wedge \)}, also known as \hyperref[def:standard_boolean_operators]{\term{and}} and \hyperref[def:semilattice/meet]{\term{meet}}.
      \thmitem{def:propositional_language/connectives/conditional} \term{Conditional}\footnote{Note that \enquote{conditional} and \enquote{biconditional} are nouns in this context.} \enquote{\( \rightarrow \)}, also known as \term{if\ldots then} and \hyperref[def:material_implication]{\term{material implication}}.
      \thmitem{def:propositional_language/connectives/biconditional} \term{Biconditional} \enquote{\( \leftrightarrow \)}, also known as \term{iff}\footnote{\enquote{iff} is a common abbreviation for \enquote{if and only if}.} and \term{material equivalence}.
    \end{thmenum}

    \thmitem{def:propositional_language/parentheses} Parentheses \enquote{\( ( \)} and \enquote{\( ) \)} for defining the order of operations unambiguously.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item If desired, we can utilize a smaller propositional language without losing its semantical properties. One important example are the \hyperref[def:cnf_and_dnf]{conjunctive normal forms} in \fullref{alg:perfect_cnf_and_dnf}, although similar constructions hold for other \hyperref[def:boolean_closure/complete]{complete sets of Boolean operators} like those from \fullref{thm:complete_sets_of_boolean_operators}.
\end{comments}

\begin{definition}\label{def:propositional_syntax}\mimprovised
  The following related definitions constitute what is called the \term{syntax of propositional logic}.

  \begin{thmenum}
    \thmitem{def:propositional_syntax/grammar_schema} Consider the following \hyperref[rem:backus_normal_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}           {\bnfpn{Latin identifier}} \\
      \bnfprod{connective}         {\bnftsq{\( \vee \)} \bnfor \bnftsq{\( \wedge \)} \bnfor \bnftsq{\( \rightarrow \)} \bnfor \bnftsq{\( \leftrightarrow \)}} \\
      \bnfprod{formula}            {\bnftsq{\( \top \)} \bnfor \bnftsq{\( \bot \)} \bnfor} \\
      \bnfmore                     {\bnfpn{variable} \bnfor} \\
      \bnfmore                     {\bnftsq{\( \neg \)} \bnfsp \bnfpn{formula} \bnfor} \\
      \bnfmore                     {\bnftsq{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnftsq{)}}
    \end{bnf*}
    where we use the identifiers discussed in \fullref{rem:grammar_rules_for_variables}.

    \thmitem{def:propositional_syntax/prop} We denote by \( \boldop{Prop} \) the set of strings generated by the above grammar schema with starting rule \( \bnfpn{variable} \).

    \thmitem{def:propositional_syntax/formula} Similarly, we denote by \( \boldop{Form} \) the set of strings generated with starting rule \( \bnfpn{formula} \).

    We implicitly associate with each propositional formula a syntax tree. The grammar of propositional formulas is unambiguous as shown via \fullref{thm:propositional_formulas_are_unambiguous}, which makes it possible to perform proofs via \fullref{thm:induction_on_syntax_trees}.

    \thmitem{def:propositional_syntax/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:formal_language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \term{subformula} of \( \varphi \).

    \thmitem{def:propositional_syntax/formula_variables} For each formula \( \varphi \), we \hyperref[rem:evaluation]{recursively define} the set of variables occurring in the formula:
    \begin{equation}\label{eq:def:propositional_syntax/varables}
      \boldop{Var}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                  &\varphi \in \set{ \top, \bot } \\
        \set{ P },                                    &\varphi = P \in \boldop{Prop} \\
        \boldop{Var}(\psi),                           &\varphi = \neg \psi \\
        \boldop{Var}(\psi) \cup \boldop{Var}(\theta), &\varphi = \psi \bincirc \theta, \bincirc \in \Sigma.
      \end{cases}
    \end{equation}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Propositional formulas are also called \term{sentences}, for example by Peter Hinman in \incite[def. 1.1.2]{Hinman2005}. This contrasts with first-order logic, where only specific formulas are called sentences --- see \fullref{def:first_order_syntax/closed_formula}.
\end{comments}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The grammar of \hyperref[def:propositional_syntax/formula]{propositional formulas} is \hyperref[def:grammar_ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  This can be proved based on a similar proof from \fullref{ex:natural_number_arithmetic_grammar/unambiguous}.
\end{proof}

\begin{remark}\label{rem:propositional_formula_parentheses}
  We use several following \enquote{abuse-of-notation} conventions regarding parentheses. These are only notations shortcuts in the \hyperref[rem:metalogic]{metalanguage} and the formulas themselves (as abstract mathematical objects) are still assumed to contain parentheses that help them avoid syntactic ambiguity.

  \begin{thmenum}
    \thmitem{rem:propositional_formula_parentheses/outermost} We may skip the outermost parentheses in formulas with top-level \hyperref[def:propositional_language/connectives]{connectives}, e.g. we may write \( P \wedge Q \) rather than \( (P \wedge Q) \).

    \thmitem{rem:propositional_formula_parentheses/associative} Because of the associativity of \( \wedge \) and \( \vee \), which is implied by \fullref{def:propositional_valuation/valuation_function} and \fullref{def:standard_boolean_operators}, we may skip the parentheses in chains like
    \begin{equation*}
      ( \ldots ((P_1 \wedge P_2) \wedge P_3) \wedge \ldots \wedge P_{n-1} ) \wedge P_n.
    \end{equation*}
    and instead write
    \begin{equation*}
      P_1 \wedge P_2 \wedge \ldots \wedge P_{n-1} \wedge P_n.
    \end{equation*}

    \thmitem{rem:propositional_formula_parentheses/additional} Although not formally necessary, for the sake of readability we may choose to add parentheses around certain formulas like
    \begin{equation*}
      \neg P \vee \neg Q.
    \end{equation*}
    and instead write
    \begin{equation*}
      (\neg P) \vee \neg Q.
    \end{equation*}

    This latter convention is more useful for quantifiers in \hyperref[def:first_order_syntax/formula]{first-order formulas}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:material_implication}\mcite[1]{DienerMcKubreJordens2016}
  Theorems in mathematics usually have the form \( P \rightarrow Q \). Formulas of this form are called \term{material implications} in order to distinguish them from logical implication, which relates to the metatheoretic concept of \hyperref[def:propositional_semantics/entailment]{entailment}. Note that the term \enquote{material implication} sometimes also refers to the conditional connective \hyperref[def:propositional_language/connectives/conditional]{\( \rightarrow \)} itself.

  We introduce terminology that is conventionally used when dealing with theorems:

  \begin{thmenum}
    \thmitem{def:material_implication/sufficient_condition} \( P \) is a \term{sufficient condition} for \( Q \).

    \thmitem{def:material_implication/necessary_condition} \( Q \) is a \term{necessary condition} for \( P \).

    \thmitem{def:material_implication/antecedent} \( P \) is the \term{antecedent} of \( \varphi \).

    \thmitem{def:material_implication/consequent} \( Q \) is the \term{consequent} of \( \varphi \).

    \thmitem{def:material_implication/inverse} The formula \( \neg P \rightarrow \neg Q \) is the \term[bg=противоположна,ru=противоположная]{inverse} of \( \varphi \).

    \thmitem{def:material_implication/converse} The formula \( Q \rightarrow P \) is the \term[bg=обратна,ru=обратная]{converse} of \( \varphi \).

    \thmitem{def:material_implication/contrapositive} The formula \( \neg Q \rightarrow \neg P \) is the \term{contrapositive} of \( \varphi \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item  In classical logic, the contrapositive is \hyperref[def:propositional_semantics/equivalence]{equivalent} to the original formula due to \fullref{thm:boolean_equivalences/contrapositive}.
\end{comments}

\begin{definition}\label{def:propositional_valuation}
  We will define \term[bg=оценка,ru=оценка]{valuations} for propositional formulas.

  \begin{thmenum}
    \thmitem{def:propositional_valuation/interpretation}\mcite[def. 1.1.6(i)]{Hinman2005} A \term{propositional interpretation} is a function with signature \( I: \boldop{Prop} \to \set{ T, F } \).

    \medskip

    \thmitem{def:propositional_valuation/formula_valuation}\mcite[thm. 1.1.7]{Hinman2005} Given an interpretation \( I \), we define the \term{valuation} of a formula \( \varphi \) inductively as follows:
    \begin{equation}\label{eq:def:propositional_valuation/formula_interpretation}
      \Bracks{\varphi}_I \coloneqq \begin{cases}
        T,                                                                &\varphi = \top \\
        F,                                                                &\varphi = \bot \\
        I(P),                                                             &\varphi = P \in \boldop{Prop} \\
        \overline{\Bracks{\psi}_I},                                       &\varphi = \neg \psi \\
        \Bracks{\psi_1}_I \Bracks{\bincirc} \Bracks{\psi_2}_I &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma,
      \end{cases}
    \end{equation}
    where \( \Bracks{\bincirc} \) denotes \hyperref[def:standard_boolean_operators]{Boolean operator} corresponding to the connective \( \bincirc \).

    \thmitem{def:propositional_valuation/valuation_function} If \( \boldop{Var}(\varphi) \subseteq \set{ P_1, \ldots, P_n } \), the valuation \( \Bracks{\varphi}_I \) only depends on the particular values \( I(P_1), \ldots, I(P_n) \) of \( I \). Hence, if the variables are clear from the context, we obtain a Boolean operator
    \begin{equation*}
      \begin{aligned}
        &\Bracks{\varphi}: \set{ T, F }^n \to \set{ T, F }, \\
        &\Bracks{\varphi}(x_1, \ldots, x_n) \coloneqq \Bracks{\varphi}_I,
      \end{aligned}
    \end{equation*}
    where \( I \) is any interpretation such that \( I(P_k) = x_k \) for \( k = 1, \ldots, n \).

    Unless otherwise noted, we assume that \( \boldop{Var}(\varphi) = \set{ P_1, \ldots, P_n } \), where we use the lexicographic ordering on identifiers discussed in \fullref{rem:grammar_rules_for_variables}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item See \fullref{def:boolean_value} for remarks regarding the \hyperref[def:boolean_algebra]{Boolean algebra} \( \set{ T, F } \) and the \fullref{def:standard_boolean_operators} for a list of some standard Boolean operators.
  \item It is possible to define different valuations, so in case of doubt, we will refer to the one defined here as the \term{classical valuation} giving \term{classical semantics}. It implicitly depends on the \hyperref[def:boolean_algebra]{Boolean algebra} fixed in \fullref{def:boolean_value}. When dealing with \hyperref[def:propositional_heyting_algebra_semantics]{Heyting semantics}, we use more general Heyting algebras where not only the top and bottom, but also other values are utilized.
\end{comments}

\begin{definition}\label{def:propositional_semantics}\mimprovised
  We now define \term{semantical} properties of \hyperref[def:propositional_syntax/formula]{formulas}.

  \begin{thmenum}
    \thmitem{def:propositional_semantics/interpretation_entailment} We say that the set of \hyperref[def:propositional_syntax/formula]{propositional formulas} \( \Gamma \) \term{entails} \( \psi \) under the \hyperref[def:propositional_valuation/interpretation]{interpretation} \( I \) if, whenever \( \Bracks{\varphi}_I = T \) for all \( \varphi \in \Gamma \), it follows that \( \Bracks{\psi}_I = T \).

    \thmitem{def:propositional_semantics/entailment}\mcite[def. 1.4.1(ii)]{Hinman2005} If \( \Gamma \) entails \( \psi \) under all possible interpretations, we say that \( \Gamma \) entails \( \psi \) and write \( \Gamma \vDash \psi \).

    If \( \Gamma \) does not entail \( \varphi \) under at least one interpretation, we write \( \Gamma \not\vDash \varphi \).

    We prefer the notation \( \gamma_1, \ldots, \gamma_n \vDash \psi \) to \( \set{ \gamma_1, \ldots, \gamma_n } \vDash \psi \). In particular, we write \( \varphi \vDash \psi \) in case of one formula \( \vDash \psi \) in case of zero formulas.

    \thmitem{def:propositional_semantics/equivalence}\mcite[def. 1.3.2(ii)]{Hinman2005} We say that \( \varphi \) and \( \psi \) are \term{semantically equivalent} and write \( \varphi \gleichstark \psi \) if either:
    \begin{thmenum}
      \thmitem{def:propositional_semantics/equivalence/interpretations} We have \( \Bracks{\varphi}_I = \Bracks{\psi}_I \) for every interpretation \( I \).
      \thmitem{def:propositional_semantics/equivalence/entailment} Both \( \varphi \vDash \psi \) and \( \psi \vDash \varphi \).
    \end{thmenum}

    \thmitem{def:propositional_semantics/tautology}\mcite[def. 1.4.1(i)]{Hinman2005} We say that \( \varphi \) is a \term{propositional tautology} if any of the following equivalent conditions hold:
    \begin{thmenum}
      \thmitem{def:propositional_semantics/tautology/interpretations} We have \( \Bracks{\varphi}_I = T \) for every interpretation \( I \).
      \thmitem{def:propositional_semantics/tautology/entailment} We have the entailment \( \vDash \varphi \).
      \thmitem{def:propositional_semantics/tautology/equivalence} We have the equivalence \( \varphi \gleichstark \top \).
    \end{thmenum}

    \thmitem{def:propositional_semantics/contradiction}\mcite[def. 1.4.1(i)]{Hinman2005} Dually, we say that \( \varphi \) is a \term{propositional contradiction} if any of the following equivalent conditions hold:
    \begin{thmenum}
      \thmitem{def:propositional_semantics/contradiction/interpretations} We have \( \Bracks{\varphi}_I = F \) for every interpretation \( I \).
      \thmitem{def:propositional_semantics/contradiction/entailment} We have the entailment \( \varphi \vDash \bot \).
      \thmitem{def:propositional_semantics/contradiction/equivalence} We have the equivalence \( \varphi \gleichstark \bot \).
    \end{thmenum}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:def:propositional_entailment}
  \hyperref[def:propositional_semantics/entailment]{Propositional entailment} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:propositional_entailment/transitivity} It is \hyperref[def:binary_relation/transitive]{transitive} in the following sense: if \( \Gamma \vDash \psi \) for every \( \psi \in \Delta \), and if \( \Delta \vDash \theta \), then \( \Gamma \vDash \theta \).

    \thmitem{thm:def:propositional_entailment/more_on_left} If \( \Gamma \vDash \varphi \), then \( \Gamma, \Delta \vDash \varphi \) for any set of formulas \( \Delta \).

    \thmitem{thm:def:propositional_entailment/top} \( \varphi \vDash \top \) for every formula \( \varphi \).

    \thmitem{thm:def:propositional_entailment/bot} \( \bot \vDash \varphi \) for every formula \( \varphi \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:propositional_entailment/transitivity} Trivial.

  \SubProofOf{thm:def:propositional_entailment/more_on_left} Trivial.

  \SubProofOf{thm:def:propositional_entailment/top} For any interpretation \( I \), \( \Bracks{\top}_I = T \) regardless of the value of \( \Bracks{\varphi}_I \).

  \SubProofOf{thm:def:propositional_entailment/bot} For any interpretation \( I \), since \( \Bracks{\bot}_I = F \), everything is vacuously true regarding the \hyperref[def:material_implication/consequent]{consequent} \( \varphi \). In particular, \( \bot \) entails \( \varphi \) under \( I \) \footnote{This proof may not seem sound, but it is valid in \hyperref[rem:intuitionistic_logic]{intuitionistic} \hyperref[rem:metalogic]{metalogic} (and hence also in \hyperref[rem:classical_logic]{classical} metalogic) because of \eqref{eq:def:intuitionistic_propositional_deductive_systems/rules/efq}}.
\end{proof}

\begin{proposition}\label{thm:boolean_equivalences}
  The following (and many more) are called \term{Boolean equivalences} because they are actually statements about \hyperref[def:standard_boolean_operators]{standard Boolean operators}. They are formulated here because the framework of propositional logic is more convenient for stating the equivalences.

  For arbitrary propositional formulas \( \varphi \) and \( \psi \), the following semantic equivalences hold:
  \begin{thmenum}
    \thmitem{thm:boolean_equivalences/negation_bottom} \hyperref[def:propositional_language/negation]{Negation} can be expressed via the \hyperref[def:propositional_language/constants/falsum]{falsum}:
    \begin{equation}\label{eq:thm:boolean_equivalences/negation_bottom}
      \begin{split}
        \mathllap{\neg \varphi} &\gleichstark \mathrlap{\varphi \rightarrow \bot}.
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/double_negation} \hyperref[def:propositional_language/negation]{Negation} is an \hyperref[def:involution]{involution}:
    \begin{equation}\label{eq:thm:boolean_equivalences/double_negation}
      \begin{split}
        \mathllap{\neg \neg \varphi} &\gleichstark \mathrlap{\varphi}.
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/contrapositive} A \hyperref[def:material_implication]{material implication} is equivalent to its \hyperref[def:material_implication/contrapositive]{contrapositive}:
    \begin{equation}\label{eq:thm:boolean_equivalences/contrapositive}
      \begin{split}
        \mathllap{\varphi \rightarrow \psi} &\gleichstark \mathrlap{\neg \psi \rightarrow \neg \varphi.}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/conditional_as_disjunction} A \hyperref[def:propositional_language/connectives/conditional]{conditional} is a \hyperref[def:propositional_language/connectives/disjunction]{disjunction} with the \hyperref[def:material_implication/antecedent]{antecedent} negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/conditional_as_disjunction}
      \begin{split}
        \mathllap{\varphi \rightarrow \psi} &\gleichstark \mathrlap{ \neg \varphi \vee \psi. }
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_via_conditionals} A \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is a \hyperref[def:propositional_language/connectives/conjunction]{conjunction} of \hyperref[def:propositional_language/connectives]{conditionals}:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_via_conditionals}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{(\varphi \rightarrow \psi) \wedge (\psi \rightarrow \varphi).}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_as_conjunction} The \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is a \hyperref[def:propositional_language/connectives/disjunction]{conjunction} of \hyperref[def:propositional_language/connectives/conjunction]{disjunctions}:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_as_conjunction}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{(\neg \varphi \vee \psi) \wedge (\neg \varphi \vee \psi).}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_as_disjunction} The \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is a \hyperref[def:propositional_language/connectives/disjunction]{disjunction} of \hyperref[def:propositional_language/connectives/conjunction]{conjunctions}:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_as_disjunction}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{(\varphi \wedge \psi) \vee (\neg \varphi \wedge \neg \psi).}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_member_negation} A \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is equivalent its termwise negation:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_member_negation}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{\neg \varphi \leftrightarrow \neg \psi.}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_negation} A negation of a \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is again a biconditional with one of the terms negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_negation}
      \begin{split}
        \mathllap{\neg \parens{\varphi \leftrightarrow \psi}}
        &\gleichstark
        \mathrlap{\neg \varphi \leftrightarrow \psi \gleichstark}
        \\ &\gleichstark
        \mathrlap{\varphi \leftrightarrow \neg \psi.}
      \end{split}
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item Most of these equivalences fail in \hyperref[rem:intuitionistic_logic]{intuitionistic logic}.
\end{comments}
\begin{proof}
  The proofs follow directly from the table in \fullref{def:standard_boolean_operators}.
\end{proof}

\begin{definition}\label{def:propositional_substitution}
  We sometimes want to substitute a propositional variable with another variable or even with a formula. This is akin to applying a \hyperref[def:boolean_operator]{Boolean operator} like \( x \vee y \) to different variables (e.g. to obtain \( x \vee x \)) or even concrete values (e.g. \( F \vee T \)), except that it is done on a purely syntactic level without involving any semantics involved.

  \begin{thmenum}
    \thmitem{def:propositional_substitution/single}\mcite[1.3.13]{Hinman2005} We define the \term{substitution} of the propositional formula \( \theta \) with \( \chi \) in \( \varphi \) as follows:
    \begin{equation}\label{eq:def:propositional_substitution/single}
      \varphi[\theta \mapsto \chi] \coloneqq \begin{cases}
        \chi,                                                             &\varphi = \theta \\
        \varphi,                                                          &\varphi \neq \theta \T{and} \varphi \in \set{ \top, \bot } \cup \boldop{Prop} \\
        \neg \psi[\theta \mapsto \chi],                                   &\varphi \neq \theta \T{and} \varphi = \neg \psi \\
        \psi_1[\theta \mapsto \chi] \bincirc \psi_2[\theta \mapsto \chi], &\varphi \neq \theta \T{and} \varphi = \psi_1 \bincirc \psi_2, \circ \in \Sigma.
      \end{cases}
    \end{equation}

    Note that it is not strictly necessary for \( \theta \) to be a subformula of \( \varphi \).

    In the case where \( \theta \) is a single variable \( P \), then \( \varphi[P \mapsto \chi] \) is said to be an \term{instance} of \( \varphi \).

    \thmitem{def:propositional_substitution/simultaneous}\mcite[exer. 2.2.50]{Hinman2005} We will now define \term{simultaneous substitution} of \( \theta_1, \ldots, \theta_n \) with \( \chi_1, \ldots, \chi_n \). We wish to avoid the case where \( \theta_k \) is a subformula of \( \chi_{k-1} \), and it accidentally gets replaced during \( \varphi[\theta_{k-1} \mapsto \chi_{k-1}][\theta_k \mapsto \chi_k] \).

    Define
    \begin{equation*}
      \cat{Bound} \coloneqq \boldop{Var}(\chi_1) \cup \ldots \cup \boldop{Var}(\chi_n).
    \end{equation*}
    and, for each variable \( P_k \) in \( \cat{Bound} \), pick a variable \( Q_k \) from \( \boldop{Prop} \setminus \boldop{Bound} \). We are able to do a deterministic choice of new variables due to our well-ordering of identifiers discussed in \fullref{rem:grammar_rules_for_variables}. Let \( m \) be the \hyperref[def:cardinal]{cardinality} of \( \boldop{Bound} \). The simultaneous substitution can now be defined as
    \begin{align*}
      \varphi[\theta_1 \mapsto \chi_1, \ldots, \theta_n \mapsto \chi_n] \coloneqq \varphi
      [\theta_1 \mapsto \chi_1[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      \vdots \hspace{3cm} \\
      [\theta_n \mapsto \chi_n[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      [Q_1 \mapsto P_1, \ldots, Q_m \mapsto P_m].
    \end{align*}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  If \( \theta \gleichstark \chi \), then
  \begin{equation}\label{eq:thm:propositional_substitution_equivalence}
    \varphi[\theta \mapsto \chi] \gleichstark \varphi.
  \end{equation}
\end{proposition}
\begin{comments}
  \item By induction, this also holds for \hyperref[def:propositional_substitution/simultaneous]{simultaneous substitution}.
\end{comments}
\begin{proof}
  We use \fullref{thm:induction_on_syntax_trees} on \( \varphi \):

  \begin{itemize}
    \item If \( \varphi = \theta \), then \( \varphi[\theta \mapsto \chi] = \chi \) and, by definition,
    \begin{equation*}
      \varphi = \theta \gleichstark \chi = \varphi[\theta \mapsto \chi].
    \end{equation*}

    \item If \( \varphi \neq \theta \) and \( \varphi \in \set{ \top, \bot } \cup \boldop{Prop} \), then \( \varphi[\theta \mapsto \chi] = \varphi \) and \eqref{eq:thm:propositional_substitution_equivalence} again holds trivially.

    \item If \( \varphi \neq \theta \) and \( \varphi = \neg \chi \) and if the inductive hypothesis holds for \( \chi \), then
    \begin{equation*}
      \varphi[\theta \mapsto \chi] = \neg \psi[\theta \mapsto \chi].
    \end{equation*}

    For any interpretation \( I \),
    \begin{equation*}
      \Bracks[\Big]{ \varphi[\theta \mapsto \chi] }_I
      =
      \overline{\Bracks[\Big]{\psi[\theta \mapsto \chi] }_I}
      \reloset {\T{ind.}} =
      \overline{\Bracks{\psi}_I}
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    Therefore, \eqref{eq:thm:propositional_substitution_equivalence} holds in this case.

    \item If \( \varphi \neq \theta \) and \( \varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma \) and if the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), then for any interpretation \( I \),
    \begin{equation*}
      \Bracks[\Big]{ \varphi[\theta \mapsto \chi] }_I
      =
      \Bracks[\Big]{ \psi_1[\theta \mapsto \chi] }_I \bincirc \Bracks[\Big]{ \psi_2[\theta \mapsto \chi] }_I
      \reloset {\T{ind.}} =
      \Bracks[\Big]{\psi_1}_I \Bracks{\bincirc} \Bracks[\Big]{\psi_2}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    Therefore, \eqref{eq:thm:propositional_substitution_equivalence} holds in this case also.
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_substitution_equivalence} holds in all cases.
\end{proof}

\begin{remark}\label{rem:substitution_shorthand_notation}
  In order to simplify notation for substitution, when the variables \( P_1, \ldots, P_n \) are clear from the context, we use the notation
  \begin{equation*}
    \varphi[\psi_1, \cdots, \psi_n]
  \end{equation*}
  as a shorthand for
  \begin{equation*}
    \varphi[P_1 \to \psi_1, \cdots, P_n \to \psi_n].
  \end{equation*}

  This also applies to the different kinds of first-order substitution defined in \fullref{def:first_order_substitution}.
\end{remark}

\begin{definition}\label{def:cnf_and_dnf}\mcite[I.1.\S4]{Яблонский2003}
  We will now introduce \term[ru=конъюнктивная нормальная форма, en=conjunctive normal form (\cite[sec. 2.3.2]{Savage1998})]{conjunctive normal forms} (CNF) and \term[ru=дизъюнктивная нормальная форма, en=disjunctive normal form (\cite[sec. 2.3.1]{Savage1998})]{disjunctive normal forms} (DNF) for propositional formulas. The concepts are related but distinct from that of \hyperref[rem:lattice_polynomials]{lattice polynomials}.

  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/grammar} The structure of these formulas is best described by the \hyperref[rem:backus_normal_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{positive literal}     {\bnfpn{variable}} \\
      \bnfprod{negative literal}     {\neg \bnfpn{positive literal}} \\
      \bnfprod{literal}              {\bnfpn{positive literal} \bnfor \bnfpn{negative literal}} \\
      \bnfprod{disjunct}             {\bnfpn{literal} \bnfor \bnftsq{(} \bnfsp \bnfpn{literal}  \bnfsp \bnftsq{\( \vee \)}   \bnfsp \bnfpn{disjunct} \bnfsp \bnftsq{)}} \\
      \bnfprod{CNF}                  {\bnfpn{CNF}     \bnfor \bnftsq{(} \bnfsp \bnfpn{disjunct} \bnfsp \bnftsq{\( \wedge \)} \bnfsp \bnfpn{CNF}      \bnfsp \bnftsq{)}} \\
      \bnfprod{conjunct}             {\bnfpn{literal} \bnfor \bnftsq{(} \bnfsp \bnfpn{literal}  \bnfsp \bnftsq{\( \wedge \)} \bnfsp \bnfpn{conjunct} \bnfsp \bnftsq{)}} \\
      \bnfprod{DNF}                  {\bnfpn{DNF}     \bnfor \bnftsq{(} \bnfsp \bnfpn{conjunct} \bnfsp \bnftsq{\( \vee \)}   \bnfsp \bnfpn{DNF}      \bnfsp \bnftsq{)}}
    \end{bnf*}

    As usual, we utilize the convention in \fullref{rem:propositional_formula_parentheses} and avoid excessive parentheses.

    In this context, the terms \term{conjunct} and \term{disjunct} are commonly used to refer to sets of literals rather than the formulas containing them.

    \thmitem{def:cnf_and_dnf/variable_power} Given a variable \( P \) and a \hyperref[def:boolean_value]{Boolean value} \( x \in \set{ T, F } \), define
    \begin{equation*}
      P^x \coloneqq \begin{cases}
        P      &x = T, \\
        \neg P &x = F.
      \end{cases}
    \end{equation*}

    \thmitem{def:cnf_and_dnf/perfect} Given a finite sequence of distinct variables \( P_1, \ldots, P_n \), we say that a formula is in \term{perfect} CNF with respect to them if the following conditions hold:
    \begin{thmenum}
      \thmitem{def:cnf_and_dnf/perfect/fullness} Every disjunct contains \( n \) literals and the \( k \)-th literal is either \( P_k \) or \( \neg P_k \).
      \thmitem{def:cnf_and_dnf/perfect/ordering} The disjuncts are ordered \hyperref[def:lexicographic_order]{lexicographically} so that, for the \( k \)-th literals, \( L_k \leq R_k \) if either \( L_k \) is a negative literal or if both literals are positive.
    \end{thmenum}

    These additional conditions ensure uniqueness --- see \fullref{alg:perfect_cnf_and_dnf}.

    A formula in perfect conjunctive normal form can be written as
    \begin{equation*}
      \bigwedge_{(x_1, \ldots, x_n) \in \set{ T, F }^n} P_1^{x_1} \vee \cdots \vee P_n^{x_n}.
    \end{equation*}

    Perfect DNFs are defined analogously.
  \end{thmenum}
\end{definition}

\begin{example}\label{ex:def:cnf_and_dnf}
  We list examples of formulas in \hyperref[def:cnf_and_dnf]{conjunctive and disjunctive normal forms}:
  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/perfect_cnf} The \hyperref[thm:boolean_equivalences]{Boolean equivalence} \eqref{eq:thm:boolean_equivalences/conditional_as_disjunction} allows us to convert the \hyperref[def:propositional_language/connectives/conditional]{conditional} \( P \to Q \) to \( \neg P \vee Q \), which is both in CNF and in DNF.

    It is its own only disjunct, and it contains both variable, hence it is in perfect CNF.

    The DNF is not perfect, however. because neither conditions \fullref{def:cnf_and_dnf/perfect/fullness} nor \fullref{def:cnf_and_dnf/perfect/ordering} are satisfied.

    \thmitem{def:cnf_and_dnf/perfect_dnf} Consider instead the formula
    \begin{equation*}
      (\neg P \wedge \neg Q) \vee (\neg P \wedge Q) \vee (P \wedge Q).
    \end{equation*}

    It is in perfect DNF, and it is equivalent to \( P \to Q \).
  \end{thmenum}
\end{example}

\begin{algorithm}[Perfect CNFs and DNFs]\label{alg:perfect_cnf_and_dnf}\mcite[thm. I.1.3]{Яблонский2003}
  Let \( f(x_1, \ldots, x_n) \) be an arbitrary \hyperref[def:boolean_operator]{Boolean operator}. We will build a formula in \hyperref[def:cnf_and_dnf/perfect]{perfect disjunctive normal form} and one in \hyperref[def:cnf_and_dnf/perfect]{perfect conjunctive normal form}. The \hyperref[def:propositional_valuation/valuation_function]{induced function} of both of these formulas will be \( f \). Both formulas are unique, as we will show.

  \begin{thmenum}
    \thmitem{alg:perfect_cnf_and_dnf/guard} If \( f \) is constant, the constant itself is both a perfect CNF and DNF.

    \thmitem{alg:perfect_cnf_and_dnf/algorithm} Suppose that \( f \) is nonconstant and fix some propositional variables \( P_1, \ldots, P_n \). The following is a formula in perfect CNF whose \hyperref[def:propositional_valuation/valuation_function]{induced function} is \( f \):
    \begin{equation}\label{alg:perfect_cnf_and_dnf/cnf}
      \bigwedge_{f(x_1, \ldots, x_n) = F} P_1^{x_1} \vee \cdots \vee P_n^{x_n}.
    \end{equation}

    We order the disjuncts with respect to the \hyperref[def:lexicographic_order]{lexicographic order} on the set \( \set{ T, F }^n \) to which the tuples of Boolean values \( (x_1, \ldots, x_n) \) belong.

    \hyperref[def:semilattice/duality]{Dually}, we construct the perfect DNF as
    \begin{equation}\label{alg:perfect_cnf_and_dnf/dnf}
      \bigvee_{f(x_1, \ldots, x_n) = T} P_1^{\overline{x_1}} \wedge \cdots \wedge P_n^{\overline{x_n}},
    \end{equation}
  \end{thmenum}
\end{algorithm}
\begin{defproof}
  We will derive existence and uniqueness of perfect DNFs simultaneously from first principles. The derivation for CNFs is dual, but is more convoluted conceptually.

  Fix sequences of Boolean values \( a_1, \ldots, a_n \) and \( x_1, \ldots, x_n \). Then
  \begin{center}
    \begin{tabular}{c c | c}
      \( x_k \) & \( a_k \) & \( P_k^{\overline{x_k}}\Bracks{a_k} \) \\
      \hline
      \( F \)   & \( F \)   & \( T \) \\
      \( F \)   & \( T \)   & \( F \) \\
      \( T \)   & \( F \)   & \( F \) \\
      \( T \)   & \( T \)   & \( T \)
    \end{tabular}
  \end{center}

  Therefore, \( P_k^{\overline{x_1}}\Bracks{a_k} = T \) if and only if \( x_k = a_k \). Then
  \begin{equation*}
    \parens*{ P_1^{\overline{x_1}} \vee \cdots \vee P_n^{\overline{x_1}} }\bracks{ a_1, \ldots, a_n }
    =
    \begin{cases}
      T, &a_k = x_k \T{for all} k = 1, \ldots, n, \\
      F, &\T{otherwise.}
    \end{cases}
  \end{equation*}

  Given some set \( B \subseteq \set{ T, F }^n \), we have
  \begin{equation*}
    \parens*{ \bigvee_{(x_1, \ldots, x_n) \in B} P_1^{\overline{x_1}} \vee \cdots \vee P_n^{\overline{x_n}} }\bracks{ a_1, \ldots, a_n } = T
  \end{equation*}
  if and only if there exists some tuple \( (x_1, \ldots, x_n) \in B \) such that \( x_k = a_k \) for every index \( k \). That is, if the tuple \( (a_1, \ldots, a_n) \) belongs to the complement \( B \). This leads us to the only possible definition
  \begin{equation*}
    B \coloneqq \set{ (x_1, \ldots, x_n) \given f(x_1, \ldots, x_n) = T }.
  \end{equation*}
\end{defproof}

\begin{proposition}\label{thm:lindenmaum_tarski_algebra_of_full_propositional_logic}
  \hyperref[def:propositional_syntax/formula]{Propositional formulas} have the following structural properties when treated as \hyperref[def:boolean_operator]{Boolean operators}:

  \begin{thmenum}
    \thmitem{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/equivalence_classes} The \hyperref[def:propositional_semantics/equivalence]{semantic equivalence} \( \gleichstark \) is an equivalence relation on the set \( \boldop{Form} \) of all propositional formulas.

    \thmitem{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/bijection} The map
    \begin{equation*}
      \begin{aligned}
        &\Phi: \boldop{Form} / {}\gleichstark{} \to \mscrB \\
        &\Phi([\varphi]) \coloneqq \Bracks{\varphi}.
      \end{aligned}
    \end{equation*}
    is a well-defined bijection, where \( \mscrB \) is the set of all \hyperref[def:boolean_operator]{Boolean operators} of arbitrary arity.
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item This is one of the motivations for studying \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebras}.
  \item Both \( \boldop{Form} / {}\gleichstark{} \) and \( \mscrB \) are provably Boolean algebras, but we give very different proofs --- the former is a Boolean algebra due to the syntactic \fullref{thm:intuitionistic_lindenbaum_tarski_algebra}, and the latter is a Boolean algebra due to the semantic \fullref{thm:functions_over_model_form_model}. This is another demonstration of the soundness and completeness stated in \fullref{thm:classical_first_order_logic_is_sound_and_complete}. See also \fullref{rem:thm:intuitionistic_lindenbaum_tarski_algebra/syntactic_proof}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/equivalence_classes} Straightforward.

  \SubProofOf{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/bijection} The map \( \Phi \) is well-defined since, by definition of semantic equivalence, \( \Bracks{\varphi}_I = \Bracks{\psi}_I \) for every interpretation \( I \) whenever \( \varphi \gleichstark \psi \).

  Injectivity of \( \Phi \) is also obvious from the definition of semantic equivalence, while surjectivity is given by \fullref{alg:perfect_cnf_and_dnf}.
\end{proof}
