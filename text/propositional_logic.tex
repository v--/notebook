\subsection{Propositional logic}\label{subsec:propositional_logic}

Propositional logic allows us to express basic relations between atomic propositions --- variables that are either true or false.

\paragraph{Syntax of propositional logic}\hfill

There are different approaches to formalizing the syntax of propositional logic. We use the theory of formal grammars that we have developed in \fullref{subsec:formal_languages} and \fullref{subsec:syntax_trees}. This requires specific adjustments related to other treatments of propositional logic --- e.g. \incite[ch. 1]{Hinman2005}, \incite[ch. 1]{VanDalen2004} and \incite[ch. 1]{КолмогоровДрагалин2006} --- which rely on a more informal treatment of syntax. Our approach allows us to use powerful tools while treating the object logic in complete formality.

\begin{remark}\label{rem:grammar_rules_for_variables}
  We need to introduce conventions for identifiers --- i.e. names of variables, functions and so forth --- in order to be able to be able to express infinitely many variables with finitely many grammar rules. The variable names that we will actually use will be a very specific subset of the ones we allow formally. Consider the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{Latin letter}           {\bnftsq{A} \bnfor \bnftsq{B} \bnfor \cdots \bnfor \bnftsq{Z} \bnfor \bnftsq{a} \bnfor \bnftsq{b} \bnfor \cdots \bnfor \bnftsq{z}} \\
    \bnfprod{Short Latin identifier} {\bnfpn{Latin letter} \bnfor \bnfpn{Latin letter} \bnfsp \bnfpn{natural number}}, \\
    \bnfprod{Latin word}             {\bnfpn{Latin letter} \bnfor \bnfpn{Latin letter} \bnfsp \bnfpn{Latin word}} \\
    \bnfprod{Latin identifier}       {\bnfpn{Latin word} \bnfor \bnfpn{Latin word} \bnfsp \bnfpn{natural number}},
  \end{bnf*}
  where grammar rules for natural numbers can be taken from \fullref{rem:decimal_notation_grammar}.

  An identifier is a nonempty sequence of Latin letters, optionally followed by a number. Within the metalogic, we treat this number as a suffix and write it as a subscript, that is, we write \( P_1 \) instead of \( P1 \).

  For denoting first-order variables in \fullref{def:first_order_syntax}, we will use the nonterminal \( \bnfpn{Greek identifier} \) with analogous rules.

  A benefit of this naming schema is that we can introduce a \hyperref[thm:def:well_ordered_set/lexicographic]{lexicographic well-ordering} on the set of identifiers. This ordering can help reduce ambiguity in \fullref{def:propositional_valuation/valuation_function}, \fullref{def:propositional_substitution/simultaneous}, \fullref{def:lambda_substitution} and \fullref{def:first_order_substitution/term_in_formula} (although we will prefer the ordering \( \xi < \eta < \zeta \) resembling \( x < y < z \)). We use the following conventions:
  \begin{itemize}
    \item Individual digits are ordered as they are listed in \fullref{rem:decimal_notation_grammar}, i.e.
    \begin{equation*}
      0 < 1 < \cdots < 9.
    \end{equation*}

    \item Individual letters are ordered as they are listed above, i.e.
    \begin{equation*}
      A < B < \cdots < Z < a < b < \cdots < z.
    \end{equation*}

    \item Digits are smaller than letters.

    \item In the case of words of different lengths, if one word is a prefix of another, we assume that the shorter word is smaller, i.e.
    \begin{equation*}
      a < a_{13} < aa.
    \end{equation*}

    Comparing words of different lengths is discussed in \fullref{ex:def:lexicographic_order/heterogenous_words}.
  \end{itemize}
\end{remark}

\begin{definition}\label{def:propositional_alphabet}\mcite[def. 1.1.1]{VanDalen2004}
  The \hyperref[def:formal_language/alphabet]{alphabet} of \term[ru=логика высказываний (\cite[43]{КолмогоровДрагалин2006})]{propositional logic} consists of:

  \begin{thmenum}
    \thmitem{def:propositional_alphabet/constants} Two \term{propositional constants} (also known as \term{truth values}):
    \begin{thmenum}
      \thmitem{def:propositional_alphabet/constants/verum}\mcite[18]{VanDalen2004} \term{verum} \enquote{\( \syntop \)}.
      \thmitem{def:propositional_alphabet/constants/falsum} \term{falsum} \enquote{\( \synbot \)}.
    \end{thmenum}

    \thmitem{def:propositional_alphabet/negation} \term[ru=отрицание (\cite[17]{КолмогоровДрагалин2006})]{Negation} \enquote{\( \synneg \)}.
    \thmitem{def:propositional_alphabet/connectives} The set \( \Sigma \) of \term{binary propositional connectives}, namely
    \begin{thmenum}
      \thmitem{def:propositional_alphabet/connectives/disjunction} \term[ru=дизъюнкция (\cite[17]{КолмогоровДрагалин2006})]{Disjunction} \enquote{\( \synvee \)}, also known as \hyperref[def:standard_boolean_functions]{\term{or}}.
      \thmitem{def:propositional_alphabet/connectives/conjunction} \term[ru=конъюнкция (\cite[17]{КолмогоровДрагалин2006})]{Conjunction} \enquote{\( \synwedge \)}, also known as \hyperref[def:standard_boolean_functions]{\term{and}}.
      \thmitem{def:propositional_alphabet/connectives/conditional}\mcite[46]{Rosen1999} \term{Conditional}\fnote{Note that \enquote{conditional} and \enquote{biconditional} are used nouns in this context, although we prefer the phrase \enquote{conditional formula}. We use these terms to avoid confusion with the same connectives in the metalogic, for example \enquote{A biconditional formula is equivalent \dots} could otherwise become \enquote{An equivalence is equivalent \dots}.} \( \synimplies \), also known as \term{if\ldots then} and \hyperref[rem:material_implication]{\term[ru=импликация (\cite[17]{КолмогоровДрагалин2006})]{implication}}.
      \thmitem{def:propositional_alphabet/connectives/biconditional}\mcite[46]{Rosen1999} \term{Biconditional} \enquote{\( \syniff \)}, also known as \term{if and only if} (\hyperref[def:standard_boolean_functions]{\term{iff}}) and \term[ru=эквиваленция (\cite[17]{КолмогоровДрагалин2006})]{equivalence}.
    \end{thmenum}

    \thmitem{def:propositional_alphabet/parentheses} Parentheses \enquote{\( ( \)} and \enquote{\( ) \)} for defining the order of operations unambiguously.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item If desired, we can utilize a smaller propositional language without losing its semantical properties. Important example are the \hyperref[def:cnf_and_dnf]{conjunctive normal forms} in \fullref{alg:perfect_cnf_and_dnf}, although similar constructions hold for other \hyperref[def:boolean_closure/complete]{complete sets of Boolean functions} like those from \fullref{thm:complete_sets_of_boolean_functions}.

  \item We place dots over the various symbols in order to highlight that not semantics --- see \fullref{rem:mathematical_logic_conventions/connective_symbols}.

  \item \enquote{Conjunctio} and \enquote{disjunctio} are Latin words for \enquote{union} and \enquote{separation}, respectively. \enquote{Implicatio} is Latin for \enquote{entangled}.
\end{comments}

\begin{definition}\label{def:propositional_grammar_schema}
  Consider the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{variable}           {\bnfpn{Latin identifier}} \\
    \bnfprod{connective}         {\bnftsq{\( \synvee \)} \bnfor \bnftsq{\( \synwedge \)} \bnfor \bnftsq{\( \synimplies \)} \bnfor \bnftsq{\( \syniff \)}} \\
    \bnfprod{formula}            {\bnftsq{\( \syntop \)} \bnfor \bnftsq{\( \synbot \)} \bnfor} \\
    \bnfmore                     {\bnfpn{variable} \bnfor} \\
    \bnfmore                     {\bnftsq{\( \synneg \)} \bnfsp \bnfpn{formula} \bnfor} \\
    \bnfmore                     {\bnftsq{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnftsq{)}}
  \end{bnf*}
  where we use the identifiers discussed in \fullref{rem:grammar_rules_for_variables}.

  \begin{thmenum}
    \thmitem{def:propositional_grammar_schema/prop} We denote by \( \boldop{Prop} \) the set of all \term[ru=пропозициональные переменные (\cite[43]{КолмогоровДрагалин2006})]{propositional variables}, that is, all strings generated by the above grammar schema with starting nonterminal \( \bnfpn{variable} \).

    \thmitem{def:propositional_grammar_schema/formula} Similarly, we denote by \( \boldop{Form} \) the set of \term[ru=формула (\cite[43]{КолмогоровДрагалин2006})]{formulas}, that is, strings generated with starting nonterminal \( \bnfpn{formula} \).

    \thmitem{def:propositional_grammar_schema/language} By \enquote{language of propositional logic} we will mean the set \( \boldop{Form} \) of formulas (and hence also the variables).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Various authors refer to \enquote{the language of propositional logic} --- for example \incite[def. 1.1.1]{VanDalen2004} and \incite[13]{Hinman2005} --- in relation to various syntactic constructions. These authors do not formally define this language, however. Since we use the mechanism of \hyperref[def:formal_language]{formal languages}, we prefer being more concrete about which syntactic notions we refer to.

  \item We implicitly associate with each propositional formula an \hyperref[rem:abstract_syntax_tree]{abstract syntax tree} --- see \fullref{def:propositional_formula_ast}. The grammar of propositional formulas is unambiguous as shown via \fullref{thm:propositional_formulas_are_unambiguous}, which makes it possible to perform proofs via \fullref{thm:induction_on_syntax_trees}.

  \item If the root of the tree is a conjunction, we refer to the formula itself as a conjunction, and similarly for other propositional connectives.

  \item Propositional formulas are also called \term{sentences}, for example by Peter Hinman in \incite[def. 1.1.2]{Hinman2005}. This contrasts with first-order logic, where only specific formulas are called sentences --- see \fullref{def:first_order_syntax/closed_formula}.
\end{comments}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:propositional_grammar_schema/formula]{propositional formulas} is \hyperref[def:grammar_ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  It is straightforward to adapt the proof from \fullref{ex:natural_number_arithmetic_grammar/unambiguous}.
\end{proof}

\begin{definition}\label{def:propositional_fomula_ast}
  We implicitly associate with each propositional formula \( \varphi \) an \hyperref[rem:abstract_syntax_tree]{abstract syntax tree} \( T(\varphi) \) defined as follows:
  \begin{thmenum}
    \thmitem{def:propositional_fomula_ast/atomic} If \( \varphi \) is a propositional constant or constant, let \( T(\varphi) \) be a tree with a single node labeled by it.

    \thmitem{def:propositional_fomula_ast/negation} If \( \varphi = \synneg \psi \), assuming we have already built \( T(\psi) \), we obtain \( T(\varphi) \) by adding one node, and labeling it via \( \synneg \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__propositional_formula_ast}
    \end{equation*}

    \thmitem{def:propositional_fomula_ast/connective} If \( \varphi = \psi \syncirc \theta \), assuming we have built \( T(\psi) \) and \( T(\chi) \), we obtain \( T(\varphi) \) by joining their, and labeling the new node via \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__propositional_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The \hyperref[def:rooted_tree/leaf]{leaves} of the tree are variables and constants, while every other node is either a binary connective or negation.
\end{comments}

\begin{example}\label{ex:def:propositional_fomula_ast}
  We list examples of \hyperref[def:propositional_fomula_ast]{abstract syntax trees for propositional formulas}:
  \begin{thmenum}
    \thmitem{ex:def:propositional_fomula_ast/lnc} The law of non-contradiction \eqref{eq:thm:minimal_propositional_negation_laws/lnc} has the following AST:
    \begin{equation*}
      \includegraphics[page=1]{output/ex__def__propositional_formula_ast}
    \end{equation*}

    \thmitem{ex:def:propositional_fomula_ast/associative_conjunction} We will define semantics for conjunction and disjunction so that they become associative Boolean operators. Following our general discussion of such binary operations in \fullref{rem:binary_operation_syntax_trees}, we will generally conflate the formula
    \begin{equation*}
      ((P \synwedge Q) \synwedge R)
    \end{equation*}
    with AST
    \begin{equation*}
      \includegraphics[page=2]{output/ex__def__propositional_formula_ast}
    \end{equation*}
    and the formula
    \begin{equation*}
      ((P \synwedge Q) \synwedge R)
    \end{equation*}
    with AST
    \begin{equation*}
      \includegraphics[page=3]{output/ex__def__propositional_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:propositional_formula_balanced_parentheses}
  Propositional formulas have \hyperref[ex:thm:regular_pumping_lemma/balanced_parentheses]{balanced parentheses}, that is, for any formula there are as many left parentheses as there are right parentheses.
\end{proposition}
\begin{proof}
  Denote by \( l_\varphi \) and \( r_\varphi \) the number of left and right parentheses in the formula \( \varphi \).

  We will use \fullref{thm:induction_on_syntax_trees} on \( \varphi \) to prove that \( l_\varphi = r_\varphi \).
  \begin{itemize}
    \item If \( \varphi \) is a constant or variable, there are no parentheses, and \( l_\varphi = r_\varphi = 0 \).
    \item If \( \varphi = \synneg \psi \) and if the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      l_\varphi = l_\psi \reloset{\T{ind.}} = r_\psi = r_\varphi
    \end{equation*}

    \item If \( \varphi = (\psi \syncirc \theta) \) and if the hypothesis holds for \( \psi \) and \( \theta \), then
    \begin{equation*}
      l_\varphi = l_\psi + l_\theta + 1 \reloset{\T{ind.}} = r_\psi + r_\theta + 1 = r_\varphi.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{remark}\label{rem:propositional_formula_parentheses}
  We use several following \enquote{abuse-of-notation} conventions regarding parentheses. These are only notations shortcuts in the \hyperref[rem:metalogic]{metalanguage} and the formulas themselves (as abstract mathematical objects) are still assumed to contain parentheses that help them avoid syntactic ambiguity.

  \begin{thmenum}
    \thmitem{rem:propositional_formula_parentheses/outermost} We may skip the outermost parentheses in formulas with top-level \hyperref[def:propositional_alphabet/connectives]{connectives}, e.g. we may write \( P \synwedge Q \) rather than \( (P \synwedge Q) \).

    \thmitem{rem:propositional_formula_parentheses/associative} Because of the associativity of \( \synwedge \) and \( \synvee \), which is implied by \fullref{def:propositional_valuation/valuation_function} and \fullref{def:standard_boolean_functions}, we may skip the parentheses in chains like
    \begin{equation*}
      ( \ldots ((P_1 \synwedge P_2) \synwedge P_3) \synwedge \ldots \synwedge P_{n-1} ) \synwedge P_n.
    \end{equation*}
    and instead write
    \begin{equation*}
      P_1 \synwedge P_2 \synwedge \ldots \synwedge P_{n-1} \synwedge P_n.
    \end{equation*}

    \thmitem{rem:propositional_formula_parentheses/additional} Although not formally necessary, for the sake of readability we may choose to add parentheses around certain formulas like
    \begin{equation*}
      \synneg P \synvee \synneg Q.
    \end{equation*}
    and instead write
    \begin{equation*}
      (\synneg P) \synvee (\synneg Q).
    \end{equation*}

    This latter convention is more useful for quantifiers in \hyperref[def:first_order_syntax/formula]{first-order formulas}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:propositional_subformula}
  For every \hyperref[def:propositional_grammar_schema/formula]{propositional formula}, we define the set of \term{subformulas} as follows:
  \begin{equation*}
    \boldop{Subform}(\varphi) \coloneqq \begin{cases}
      \set{ \varphi },                                                            &\varphi \in \set{ \syntop, \synbot } \T{or} P \in \boldop{Prop}, \\
      \set{ \varphi } \bigcup \boldop{Subform}(\psi),                             &\varphi = \synneg \psi, \\
      \set{ \varphi } \bigcup \boldop{Subform}(\psi) \cup \boldop{Subform}(\psi), &\varphi = \psi \syncirc \theta, {\syncirc} \in \Sigma.
    \end{cases}
  \end{equation*}
\end{definition}

\begin{lemma}\label{thm:propositional_subformula_lemma}
  If the formula \( \psi \) is a \hyperref[def:formal_language/subword]{subword} of the formula \( \varphi \), then we have the following possibilities:
  \begin{thmenum}
    \thmitem{thm:propositional_subformula/variable} \( \varphi \) is a variable or constant and \( \psi = \varphi \).
    \thmitem{thm:propositional_subformula/negation_self} \( \varphi = \neg \theta \) and \( \psi \) coincides with \( \varphi \).
    \thmitem{thm:propositional_subformula/negation} \( \varphi = \neg \theta \) and \( \psi \) is a subformula of \( \theta \).
    \thmitem{thm:propositional_subformula/connective_self} \( \varphi = (\theta \syncirc \chi) \) and \( \psi \) coincides with \( \varphi \).
    \thmitem{thm:propositional_subformula/connective_left} \( \varphi = (\theta \syncirc \chi) \) and \( \psi \) is a subformula of \( \theta \).
    \thmitem{thm:propositional_subformula/connective_right} \( \varphi = (\theta \syncirc \chi) \) and \( \psi \) is a subformula of \( \chi \) but not \( \theta \).
  \end{thmenum}
\end{lemma}
\begin{proof}
  We use \fullref{thm:induction_on_syntax_trees} on \( \varphi \):
  \begin{itemize}
    \item If \( \varphi \) is a variable or constant, it is a single lexeme, and the only possible subword that is a formula is \( \varphi \) itself. This corresponds to \fullref{thm:propositional_subformula/variable}.
    \item If \( \varphi = \neg \theta \) and if the inductive hypothesis holds for \( \theta \), we have the following possibilities:
    \begin{itemize}
      \item If \( \psi = \varphi \), then \fullref{thm:propositional_subformula/negation_self} holds.
      \item If \( \psi = \neg \), it is a subword of \( \varphi \), but not itself a formula.
      \item If \( \psi \) is a subword of \( \theta \), we apply the inductive hypothesis --- then \fullref{thm:propositional_subformula/negation} holds.
    \end{itemize}

    \item If \( \varphi = (\theta \syncirc \chi) \), where the inductive hypothesis holds for \( \theta \) and \( \chi \), we have the following possibilities:
    \begin{itemize}
      \item If \( \psi = \varphi \), then \fullref{thm:propositional_subformula/connective_self} holds.
      \item If \( \psi \) is a subword of \( \theta \), then \fullref{thm:propositional_subformula/connective_left} holds.
      \item If \( \psi \) is a subword of \( \chi \) but not of \( \theta \), then \fullref{thm:propositional_subformula/connective_right} holds.
      \item If \( \psi = (\theta \syncirc \psi_\chi \), where \( \psi_\chi \) is a prefix of \( \chi \), then \( \psi \) has unbalanced parentheses, which contradicts \fullref{thm:propositional_formula_balanced_parentheses}, and thus \( \psi \) is not a formula.
      \item Similarly, if \( \psi = \psi_\theta \syncirc \chi) \), where \( \psi_\theta \) is a suffix of \( \theta \), then again \( \psi \) has unbalanced parentheses.
      \item If \( \psi = \psi_\theta \syncirc \psi_\chi \), where \( \psi_\theta \) is a suffix of \( \theta \) and \( \psi_\chi \) is a prefix of \( \chi \), then \( \psi \) is again not a formula because it is not wrapped in parentheses.
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:propositional_formula_characterization}
  The \hyperref[def:formal_language/subword]{subword} \( \psi \) of the formula \( \varphi \) is a \hyperref[def:propositional_subformula]{subformula} of \( \varphi \) if and only if \( \psi \) is itself a formula.
\end{proposition}
\begin{proof}
  \SufficiencySubProof Straightforward.
  \NecessitySubProof Suppose that \( \psi \) is itself a formula. Then \fullref{thm:propositional_subformula_lemma} implies that it falls into one of the cases of \fullref{def:propositional_subformula}, and is thus a subformula of \( \varphi \).
\end{proof}

\paragraph{Implications and entailment}

\begin{definition}\label{def:conditional_formula}
  For a given \hyperref[def:propositional_grammar_schema/formula]{conditional formula} \( \varphi \synimplies \psi \), we introduce the following terminology:
  \begin{thmenum}
    \thmitem{def:conditional_formula/sufficient_condition}\mcite[def. I.4.1]{Эдельман1975} \( \varphi \) is a \term[ru=достаточное условие]{sufficient condition} for \( \psi \).

    \thmitem{def:conditional_formula/necessary_condition}\mcite[def. I.4.1]{Эдельман1975} \( \psi \) is a \term[ru=необходимое условие]{necessary condition} for \( \varphi \).

    \thmitem{def:conditional_formula/antecedent}\mcite[16]{Эдельман1975} \( \varphi \) is the \term[ru=посылка, en=antecedent (\cite[35]{Rosen1999})]{antecedent} of the conditional \( \varphi \synimplies \psi \).

    \thmitem{def:conditional_formula/consequent}\mcite[16]{Эдельман1975} \( \psi \) is the \term[ru=следствие, en=consequent (\cite[37]{Rosen1999})]{consequent} of \( \varphi \synimplies \psi \).

    \thmitem{def:conditional_formula/inverse}\mcite[def. I.4.3]{Эдельман1975} We call the formula \( \synneg \varphi \synimplies \synneg \psi \) the \term[ru=противоположная (теорема), en=inverse (\cite[49]{Rosen1999})]{inverse} of \( \varphi \).

    \thmitem{def:conditional_formula/converse}\mcite[13]{Kleene2002Logic} We call the formula \( \psi \synimplies \varphi \) the \term[ru=обратная (теорема) (\cite[def. I.4.2]{Эдельман1975})]{converse} of \( \varphi \).

    \thmitem{def:conditional_formula/contrapositive}\mcite[13]{Kleene2002Logic} The formula \( \synneg \psi \synimplies \synneg \varphi \) is the \term[ru=контрапозиция (\cite[26]{Эдельман1975})]{contrapositive} of \( \varphi \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item In \hyperref[rem:classical_logic]{classical logic}, the contrapositive is \hyperref[def:propositional_entailment/equivalence]{equivalent} to the original formula due to \fullref{thm:boolean_equivalences/contrapositive}.
\end{comments}

\begin{remark}\label{rem:material_implication}
  There are different ways in which one can interpret the conditional formula \( \varphi \synimplies \psi \). Following Philo of Megara, we will use what is called \term[ru=материальная импликация (\cite[74]{КолмогоровДрагалин2006}), en=material implication (\cite[6]{VanDalen2004})]{material implication}:
  \begin{displayquote}
    The formula \( \varphi \synimplies \psi \) holds unless the antecedent \( \varphi \) holds and the consequent \( \psi \) doesn't.
  \end{displayquote}

  Thus, material implication resembles the Boolean function \( {\rightarrow} \) defined in \fullref{def:standard_boolean_functions}. The adjective \enquote{material} is used to distinguish it from \enquote{strict} and \enquote{relevant} implications, as well as \enquote{assertions} and other possibilities that try to avoid the so-called \enquote{paradoxes of material implication}. A survey of the aforementioned concepts has been written by \incite{StanfordPlato:logic_of_conditionals}.

  Material implication fits naturally in \hyperref[rem:classical_logic]{classical} \hyperref[rem:metalogic]{metalogic} due to \fullref{thm:semantic_deduction_theorem}, although \fullref{rem:first_order_entailment_without_closed_formulas} highlights possible complications with arbitrary \hyperref[def:first_order_syntax/formula]{first-order formulas}.
\end{remark}

\begin{definition}\label{def:propositional_formula_variables}\mimprovised
  For each formula \( \varphi \), we \hyperref[rem:evaluation]{recursively define} the set of variables occurring in the \hyperref[def:propositional_grammar_schema/formula]{propositional formulas}:
  \begin{equation*}
    \boldop{Var}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                  &\varphi \in \set{ \syntop, \synbot }, \\
      \set{ P },                                    &\varphi = P \in \boldop{Prop}, \\
      \boldop{Var}(\psi),                           &\varphi = \synneg \psi, \\
      \boldop{Var}(\psi) \cup \boldop{Var}(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \Sigma.
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}\label{def:propositional_valuation}\mimprovised
  We define (\hyperref[rem:classical_logic]{classical}) \term[ru=значение истинности (формулы) (\cite[8]{Эдельман1975}), en=valuation \cite[def. 1.2.1]{VanDalen2004}]{valuation} for propositional formulas.

  \begin{thmenum}
    \thmitem{def:propositional_valuation/interpretation} A \term{propositional interpretation} is a function with signature \( I: \boldop{Prop} \to \set{ T, F } \).

    \thmitem{def:propositional_valuation/formula_valuation} Given an interpretation \( I \), we define the \term{valuation} of a formula \( \varphi \) inductively as follows:
    \begin{equation}\label{eq:def:propositional_valuation/formula_valuation}
      \Bracks{\varphi}_I \coloneqq \begin{cases}
        T,                                         &\varphi = \syntop \\
        F,                                         &\varphi = \synbot \\
        I(P),                                      &\varphi = P \in \boldop{Prop} \\
        \oline{\Bracks{\psi}_I},                   &\varphi = \synneg \psi \\
        \Bracks{\psi}_I \relcirc \Bracks{\theta}_I &\varphi = \psi \syncirc \theta, {\syncirc} \in \Sigma,
      \end{cases}
    \end{equation}
    where \( \relcirc \) denotes \hyperref[def:standard_boolean_functions]{Boolean function} corresponding to the connective \( \syncirc \).

    \thmitem{def:propositional_valuation/valuation_function} If \( \boldop{Var}(\varphi) \subseteq \set{ P_1, \ldots, P_n } \), the valuation \( \Bracks{\varphi}_I \) only depends on the particular values \( I(P_1), \ldots, I(P_n) \) of \( I \). Hence, if the variables are clear from the context, we obtain a Boolean function
    \begin{equation*}
      \begin{aligned}
        &\Bracks{\varphi}: \set{ T, F }^n \to \set{ T, F }, \\
        &\Bracks{\varphi}(x_1, \ldots, x_n) \coloneqq \Bracks{\varphi}_I,
      \end{aligned}
    \end{equation*}
    where \( I \) is any interpretation such that \( I(P_k) = x_k \) for \( k = 1, \ldots, n \).

    Unless otherwise noted, we assume that \( P_1, \ldots, P_n \) are precisely the variables of \( \varphi \), ordered lexicographically as discussed in \fullref{rem:grammar_rules_for_variables}. We will call this the \term{valuation function} of \( \varphi \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition implicitly depends on the two-element \hyperref[def:boolean_algebra]{Boolean algebra} discussed in \fullref{def:boolean_value}. When dealing with \hyperref[def:propositional_heyting_algebra_semantics]{Heyting semantics} for \hyperref[rem:intuitionistic_logic]{intuitionistic logic}, we can use the \hyperref[def:heyting_algebra]{relative pseudocomplement} and \hyperref[def:heyting_algebra/pseudocomplement]{pseudocomplement} rather than the Boolean implication and complement.
\end{comments}

\begin{definition}\label{def:propositional_entailment}\mcite[26]{Kleene2002Logic}
  We say that the set \( \Gamma \) of \hyperref[def:propositional_grammar_schema/formula]{propositional formulas} \term{entails} \( \psi \) and write \( \Gamma \vDash \psi \) if, for every \hyperref[def:propositional_valuation/interpretation]{interpretation} \( I \), whenever \( \Bracks{\varphi}_I = T \) for every \( \varphi \in \Gamma \), it follows that \( \Bracks{\psi}_I = T \).

  We prefer the notation \( \gamma_1, \ldots, \gamma_n \vDash \psi \) to \( \set{ \gamma_1, \ldots, \gamma_n } \vDash \psi \). In particular, we write \( \varphi \vDash \psi \) in case of one formula \( \vDash \psi \) in case of zero formulas.

  \begin{thmenum}
    \thmitem{def:propositional_entailment/equivalence} We say that \( \varphi \) and \( \psi \) are \term[ru=равносильные / эквивалентные (формулы) (\cite[44]{КолмогоровДрагалин2006})]{semantically equivalent} and write \( \varphi \gleichstark \psi \) if either:
    \begin{thmenum}
      \thmitem{def:propositional_entailment/equivalence/interpretations}\mcite[def. 1.3.2(ii)]{Hinman2005} We have \( \Bracks{\varphi}_I = \Bracks{\psi}_I \) for every interpretation \( I \).
      \thmitem{def:propositional_entailment/equivalence/entailment} Both \( \varphi \vDash \psi \) and \( \psi \vDash \varphi \).
    \end{thmenum}

    \thmitem{def:propositional_entailment/tautology} We say that \( \varphi \) is a \term[ru=пропозициональная тавтология (\cite[44]{КолмогоровДрагалин2006})]{propositional tautology} if any of the following equivalent conditions hold:
    \begin{thmenum}
      \thmitem{def:propositional_entailment/tautology/interpretations}\mcite[def. 1.4.1(i)]{Hinman2005} We have \( \Bracks{\varphi}_I = T \) for every interpretation \( I \).
      \thmitem{def:propositional_entailment/tautology/entailment} We have the entailment \( \vDash \varphi \).
      \thmitem{def:propositional_entailment/tautology/equivalence} We have the equivalence \( \varphi \gleichstark \syntop \).
    \end{thmenum}

    \thmitem{def:propositional_entailment/contradiction} Dually, we say that \( \varphi \) is a \term[en=contradictory (formula) (\cite[28]{Kleene2002Logic})]{propositional contradiction} if any of the following equivalent conditions hold:
    \begin{thmenum}
      \thmitem{def:propositional_entailment/contradiction/interpretations}\mcite[def. 1.4.1(i)]{Hinman2005} We have \( \Bracks{\varphi}_I = F \) for every interpretation \( I \).
      \thmitem{def:propositional_entailment/contradiction/entailment} We have the entailment \( \varphi \vDash \synbot \).
      \thmitem{def:propositional_entailment/contradiction/equivalence} We have the equivalence \( \varphi \gleichstark \synbot \).
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item As shown in \fullref{thm:semantic_deduction_theorem}, \( \varphi \vDash \psi \) if and only if \( \vDash \varphi \synimplies \psi \).
\end{comments}

\begin{proposition}\label{thm:def:propositional_entailment}
  \hyperref[def:propositional_entailment]{Propositional entailment} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:propositional_entailment/transitivity} It is \hyperref[def:binary_relation/transitive]{transitive} in the following sense: if \( \varphi \vDash \psi \) and \( \psi \vDash \theta \), then \( \varphi \vDash \theta \).

    \thmitem{thm:def:propositional_entailment/more_on_left} If \( \Gamma \vDash \varphi \), then \( \Gamma, \Delta \vDash \varphi \) for any set of formulas \( \Delta \).

    \thmitem{thm:def:propositional_entailment/top} \( \varphi \vDash \syntop \) for every formula \( \varphi \).

    \thmitem{thm:def:propositional_entailment/bot} \( \synbot \vDash \varphi \) for every formula \( \varphi \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:propositional_entailment/transitivity} Trivial.

  \SubProofOf{thm:def:propositional_entailment/more_on_left} Trivial.

  \SubProofOf{thm:def:propositional_entailment/top} For any interpretation \( I \), \( \Bracks{\syntop}_I = T \) regardless of the value of \( \Bracks{\varphi}_I \).

  \SubProofOf{thm:def:propositional_entailment/bot} For any interpretation \( I \), since \( \Bracks{\synbot}_I = F \), everything is vacuously true regarding the \hyperref[def:conditional_formula/consequent]{consequent} \( \varphi \) because \eqref{eq:def:intuitionistic_propositional_deductive_systems/rules/efq} holds in \hyperref[rem:classical_logic]{classical} \hyperref[rem:metalogic]{metalogic}. In particular, \( \synbot \) entails \( \varphi \) under \( I \).
\end{proof}

\begin{proposition}\label{thm:boolean_equivalences}
  We will list some \hyperref[def:propositional_entailment/equivalence]{propositional equivalences}. We will call them \enquote{Boolean equivalences} because they are actually statements about \hyperref[def:standard_boolean_functions]{standard Boolean functions}, but nevertheless we find propositional logic more convenient for stating the equivalences.

  For arbitrary propositional formulas \( \varphi \), \( \psi \) and \( \theta \), the following semantic equivalences hold:
  \begin{thmenum}
    \thmitem{thm:boolean_equivalences/negation_bottom} Negation can be expressed as a conditional formula whose \hyperref[def:conditional_formula/consequent]{consequent} is the falsum:
    \begin{equation}\label{eq:thm:boolean_equivalences/negation_bottom}
      \mathllap{\synneg \varphi} \gleichstark \mathrlap{\varphi \synimplies \synbot.}
    \end{equation}

    This equivalence motivates the axioms \eqref{eq:def:minimal_propositional_hilbert_system/neg/elim} and \eqref{eq:def:minimal_propositional_hilbert_system/neg/intro} for the \hyperref[def:minimal_propositional_hilbert_system]{minimal propositional Hilbert system}.

    \thmitem{thm:boolean_equivalences/double_negation} Negation is an \hyperref[def:involution]{involution}:
    \begin{equation}\label{eq:thm:boolean_equivalences/double_negation}
      \mathllap{\synneg \synneg \varphi} \gleichstark \mathrlap{\varphi.}
    \end{equation}

    This equivalence motivates the infamous law \eqref{eq:thm:minimal_propositional_negation_laws/dne} of double negation elimination.

    \thmitem{thm:boolean_equivalences/self_conditional} Every formula implies itself:
    \begin{equation}\label{eq:thm:boolean_equivalences/self_conditional}
      \mathllap{\varphi \synimplies \varphi} \gleichstark \mathrlap{\syntop.}
    \end{equation}

    This equivalence motivates the axiom \eqref{eq:def:heyting_algebra/axioms/self} for \hyperref[def:heyting_algebra]{Heyting algebras}.

    \thmitem{thm:boolean_equivalences/contrapositive} A conditional formula is equivalent to its \hyperref[def:conditional_formula/contrapositive]{contrapositive}:
    \begin{equation}\label{eq:thm:boolean_equivalences/contrapositive}
      \mathllap{\varphi \synimplies \psi} \gleichstark \mathrlap{\synneg \psi \synimplies \synneg \varphi.}
    \end{equation}

    \thmitem{thm:boolean_equivalences/conditional_as_disjunction} A conditional formula is a disjunction with the \hyperref[def:conditional_formula/antecedent]{antecedent} negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/conditional_as_disjunction}
      \mathllap{\varphi \synimplies \psi} \gleichstark \mathrlap{ \synneg \varphi \synvee \psi. }
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_via_conditionals} A biconditional formula is a conjunction of conditionals:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_via_conditionals}
      \mathllap{\varphi \syniff \psi} \gleichstark \mathrlap{(\varphi \synimplies \psi) \synwedge (\psi \synimplies \varphi).}
    \end{equation}

    \thmitem{thm:boolean_equivalences/distributivity} Disjunctions and conjunctions distribute over each other:
    \begin{subequations}
      \begin{align}
        \mathllap{\varphi \synvee (\psi \synwedge \theta)} &\gleichstark \mathrlap{(\varphi \synvee \psi) \synwedge (\varphi \synvee \theta),}   \label{eq:thm:boolean_equivalences/distributivity/join_over_meet} \\
        \mathllap{\varphi \synwedge (\psi \synvee \theta)} &\gleichstark \mathrlap{(\varphi \synwedge \psi) \synvee (\varphi \synwedge \theta).} \label{eq:thm:boolean_equivalences/distributivity/meet_over_join}
      \end{align}
    \end{subequations}

    This equivalence motivates axioms \eqref{eq:def:distributive_lattice/join_over_meet} and \eqref{eq:def:distributive_lattice/meet_over_join} for \hyperref[def:distributive_lattice]{distributive lattices}.

    \thmitem{thm:boolean_equivalences/de_morgan} Disjunctions and conjunctions distribute over each other:
    \begin{subequations}
      \begin{align}
        \mathllap{\synneg (\varphi \synvee \psi)}   &\gleichstark \mathrlap{\synneg \varphi \synwedge \synneg \psi,} \label{eq:thm:boolean_equivalences/de_morgan/complement_of_join} \\
        \mathllap{\synneg (\varphi \synwedge \psi)} &\gleichstark \mathrlap{\synneg \varphi \synvee \synneg \psi.}   \label{eq:thm:boolean_equivalences/de_morgan/complement_of_meet}
      \end{align}
    \end{subequations}

    This equivalence motivates \fullref{thm:de_morgans_laws}.

    \thmitem{thm:boolean_equivalences/biconditional_member_negation} A biconditional formula is equivalent to its termwise negation:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_member_negation}
      \mathllap{\varphi \syniff \psi} \gleichstark \mathrlap{\synneg \varphi \syniff \synneg \psi.}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_negation} A negation of a biconditional formula is again a biconditional with one of the terms negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_negation}
      \begin{aligned}
        \mathllap{\synneg \parens{\varphi \syniff \psi}}
        &\gleichstark
        \mathrlap{\synneg \varphi \syniff \psi \gleichstark}
        \\ &\gleichstark
        \mathrlap{\varphi \syniff \synneg \psi.}
      \end{aligned}
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item Most of these equivalences fail in \hyperref[rem:intuitionistic_logic]{intuitionistic logic}.
\end{comments}
\begin{proof}
  The proofs follow directly from the table in \fullref{def:standard_boolean_functions}.
\end{proof}

\paragraph{Substitution}

\begin{definition}\label{def:propositional_substitution}
  We sometimes want to substitute a propositional variable with another variable or even with a formula. This is akin to applying a \hyperref[def:boolean_function]{Boolean function} like \( x \synvee y \) to different variables (e.g. to obtain \( x \synvee x \)) or even concrete values (e.g. \( F \synvee T \)), except that it is done on a purely syntactic level without involving any semantics involved.

  \begin{thmenum}
    \thmitem{def:propositional_substitution/single}\mcite[def. 1.3.13]{Hinman2005} We define the \term[ru=подстановка (\cite[66]{КолмогоровДрагалин2006})]{substitution} of the propositional formula \( \chi \) with \( \omega \) in \( \varphi \) as follows:
    \begin{equation}\label{eq:def:propositional_substitution/single}
      \varphi[\chi \mapsto \omega] \coloneqq \begin{cases}
        \omega,                                                         &\varphi = \chi \\
        \varphi,                                                        &\varphi \neq \chi \T{and} \varphi \in \set{ \syntop, \synbot } \cup \boldop{Prop} \\
        \synneg \psi[\chi \mapsto \omega],                              &\varphi \neq \chi \T{and} \varphi = \synneg \psi \\
        \psi[\chi \mapsto \omega] \syncirc \theta[\chi \mapsto \omega], &\varphi \neq \chi \T{and} \varphi = \psi \syncirc \theta, \circ \in \Sigma.
      \end{cases}
    \end{equation}

    Note that it is not necessary for \( \chi \) to be a subformula of \( \varphi \) --- the substitution simply does nothing otherwise.

    In the case where \( \chi \) is a single variable \( P \), we say that \( \varphi[P \mapsto \omega] \) is an \term[en=substitution instance (\cite[67]{VanDalen2004})]{instance} of \( \varphi \).

    \thmitem{def:propositional_substitution/simultaneous}\mimprovised We will now define \term[en=simultaneous substitution (\cite[exer. 2.2.50]{Hinman2005})]{simultaneous substitution} of \( \chi_1, \ldots, \chi_n \) with \( \omega_1, \ldots, \omega_n \). A small complication arises because we wish to avoid the case where \( \chi_k \) is a subformula of \( \omega_{k-1} \) that accidentally gets replaced during \( \varphi[\chi_{k-1} \mapsto \omega_{k-1}][\chi_k \mapsto \omega_k] \).

    Let
    \begin{equation*}
      \cat{Bound} \coloneqq \boldop{Var}(\omega_1) \cup \ldots \cup \boldop{Var}(\omega_n).
    \end{equation*}
    and, for each variable \( P_k \) in \( \cat{Bound} \), pick a variable \( Q_k \) from \( \boldop{Prop} \setminus \boldop{Bound} \). We are able to do a deterministic choice of new variables due to our well-ordering of identifiers discussed in \fullref{rem:grammar_rules_for_variables}. Let \( m \) be the \hyperref[def:cardinal]{cardinality} of \( \boldop{Bound} \). The simultaneous substitution can now be defined as follows:
    \begin{align*}
      \varphi[\chi_1 \mapsto \omega_1, \ldots, \chi_n \mapsto \omega_n] \coloneqq \varphi
      [\chi_1 \mapsto \omega_1[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      \vdots \hspace{3cm} \\
      [\chi_n \mapsto \omega_n[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      [Q_1 \mapsto P_1, \ldots, Q_m \mapsto P_m].
    \end{align*}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  If \( \chi \gleichstark \omega \), then \( \varphi[\chi \mapsto \omega] \gleichstark \varphi \).
\end{proposition}
\begin{comments}
  \item By induction, this also holds for \hyperref[def:propositional_substitution/simultaneous]{simultaneous substitution}.
\end{comments}
\begin{proof}
  Suppose that \( \chi \gleichstark \omega \). We use \fullref{thm:induction_on_syntax_trees} on \( \varphi \) to show that
  \begin{equation}\label{eq:thm:propositional_substitution_equivalence/proof}
    \varphi[\chi \mapsto \omega] \gleichstark \varphi.
  \end{equation}

  \begin{itemize}
    \item If \( \varphi = \chi \), then \( \varphi[\chi \mapsto \omega] = \omega \) and, by definition,
    \begin{equation*}
      \varphi = \chi \gleichstark \omega = \varphi[\chi \mapsto \omega].
    \end{equation*}

    \item If \( \varphi \neq \chi \) and \( \varphi \in \set{ \syntop, \synbot } \cup \boldop{Prop} \), then \( \varphi[\chi \mapsto \omega] = \varphi \) and \eqref{eq:thm:propositional_substitution_equivalence/proof} again holds trivially.

    \item If \( \varphi \neq \chi \) and \( \varphi = \synneg \omega \) and if the inductive hypothesis holds for \( \omega \), then
    \begin{equation*}
      \varphi[\chi \mapsto \omega] = \synneg \psi[\chi \mapsto \omega].
    \end{equation*}

    For any interpretation \( I \),
    \begin{equation*}
      \Bracks[\Big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \oline{\Bracks[\Big]{\psi[\chi \mapsto \omega] }_I}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi}_I}
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    Generalizing on \( I \), we conclude that \eqref{eq:thm:propositional_substitution_equivalence/proof} holds in this case.

    \item If \( \varphi \neq \chi \) and \( \varphi = \psi \syncirc \theta, {\syncirc} \in \Sigma \) and if the inductive hypothesis holds for both \( \psi \) and \( \theta \), then for any interpretation \( I \),
    \begin{equation*}
      \Bracks[\Big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \Bracks[\Big]{ \psi[\chi \mapsto \omega] }_I \relcirc \Bracks[\Big]{ \theta[\chi \mapsto \omega] }_I
      \reloset {\T{ind.}} =
      \Bracks[\Big]{\psi}_I \relcirc \Bracks[\Big]{\theta}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    Again, generalizing on \( I \), we conclude that \eqref{eq:thm:propositional_substitution_equivalence/proof} holds.
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_substitution_equivalence/proof} holds in all cases.
\end{proof}

\begin{remark}\label{rem:substitution_shorthand_notation}
  In order to simplify notation for substitution, when the variables \( P_1, \ldots, P_n \) are clear from the context, we use the notation
  \begin{equation*}
    \varphi[\omega_1, \cdots, \omega_n]
  \end{equation*}
  as a shorthand for
  \begin{equation*}
    \varphi[P_1 \to \omega_1, \cdots, P_n \to \omega_n].
  \end{equation*}

  This also applies to the different kinds of first-order substitution defined in \fullref{def:first_order_substitution}, where the notation also allows us to use predicate formulas discussed in \fullref{rem:substitution_shorthand_notation}.
\end{remark}

\paragraph{Conjunctive and disjunctive normal forms}

\begin{definition}\label{def:cnf_and_dnf}\mimprovised
  We will now introduce \term[ru=конъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975}), en=conjunctive normal form (\cite[def. 1.3.10]{Hinman2005})]{conjunctive normal forms} (CNF) and \term[ru=дизъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975}), en=disjunctive normal form (\cite[def. 1.3.10]{Hinman2005})]{disjunctive normal forms} (DNF) for propositional formulas.

  The structure of these formulas is best described by the following extension of the \hyperref[def:propositional_grammar_schema_schema]{propositional syntax grammar schema}:
  \begin{bnf*}
    \bnfprod{positive literal}       {\bnfpn{variable}} \\
    \bnfprod{negative literal}       {\synneg \bnfpn{variable}} \\
    \bnfprod{literal}                {\bnfpn{positive literal}       \bnfor \bnfpn{negative literal}} \\
    \bnfprod{elementary disjunction} {\bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{CNF}                    {\bnfpn{elementary disjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{CNF}              \bnfsp \bnftsq{\( \synwedge \)} \bnfsp \bnfpn{CNF}             \bnfsp \bnftsq{)}} \\
    \bnfprod{elementary conjunction} {\bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{DNF}                    {\bnfpn{elementary conjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{DNF}              \bnfsp \bnftsq{\( \synvee \)}   \bnfsp \bnfpn{DNF}             \bnfsp \bnftsq{)}}
  \end{bnf*}
\end{definition}
\begin{comments}
  \item The terms \enquote{literal}, \enquote{positive literal} and \enquote{negative literal} are used by \incite[40; 108]{Rosen1999}. The adjective \enquote{elementary} for conjunctions and disjunctions is based on \cite[36]{Эдельман1975}.
  \item The concepts are related but distinct from that of \hyperref[rem:lattice_polynomials]{lattice polynomials}.
  \item As usual, we utilize the convention in \fullref{rem:propositional_formula_parentheses} and avoid excessive parentheses.
\end{comments}

\begin{theorem}[Principle of duality for CNF and DNF]\label{thm:cnf_and_dnf_duality}
  Fix a propositional formula \( \varphi \) in \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}). Consider its opposite \( \varphi^\oppos \), in which we swap all conjunctions and disjunctions, then make all positive literals negative and vice versa. Obviously \( \varphi^\oppos \) is in DNF (resp. CNF).

  Then \( \neg \varphi \) is \hyperref[def:propositional_entailment/equivalence]{semantically equivalent} to \( \varphi^\oppos \).

  More generally, for every \hyperref[def:propositional_valuation/interpretation]{interpretation} \( I \), we have \( \Bracks{\neg \varphi}_I = \Bracks{\varphi^\oppos}_I \).
\end{theorem}
\begin{proof}
  Consider an elementary disjunction
  \begin{equation*}
    \psi = L_1 \synvee L_2 \synvee \cdots \synvee L_n,
  \end{equation*}
  where, for every \( k = 1, \ldots, n \), \( L_k \) is either \( P_k \) or \( \neg P_k \).

  We have
  \begin{equation*}
    \psi^\oppos = L_1^\oppos \synwedge L_2^\oppos \synwedge \cdots \synwedge L_n^\oppos.
  \end{equation*}

  Then, for any interpretation \( I \),
  \begin{equation*}
    \Bracks{\psi^\oppos}_I
    =
    \Bracks{L_1^\oppos}_I \wedge \cdots \wedge \Bracks{L_n^\oppos}_I
    =
    \oline{\Bracks{L_1}_I} \wedge \cdots \wedge \oline{\Bracks{L_n}_I}
    \reloset {\ref{thm:boolean_equivalences/de_morgan}} =
    \oline{ \Bracks{L_1}_I \vee \cdots \vee \Bracks{L_n}_I }
    =
    \oline{ \Bracks{\psi}_I }
    =
    \Bracks{\neg \psi}_I.
  \end{equation*}

  Now consider a formula in CNF
  \begin{equation*}
    \varphi = \psi_1 \synwedge \psi_2 \synwedge \cdots \synwedge \psi_m,
  \end{equation*}
  where, for every \( k = 1, \ldots, m \), \( \psi_k \) is an elementary disjunction.

  Then
  \begin{equation*}
    \Bracks{\varphi^\oppos}_I
    =
    \Bracks{\psi_1^\oppos}_I \vee \cdots \vee \Bracks{\psi_m^\oppos}_I
    =
    \oline{\Bracks{\psi_1}_I} \vee \cdots \vee \oline{\Bracks{\psi_m}_I}
    \reloset {\ref{thm:boolean_equivalences/de_morgan}} =
    \oline{ \Bracks{\psi_1}_I \wedge \cdots \wedge \Bracks{\psi_m}_I }
    =
    \oline{ \Bracks{\varphi}_I }
    =
    \Bracks{\neg \varphi}_I.
  \end{equation*}
\end{proof}

\begin{remark}\label{rem:straightforward_traversal}
  Consider the identity operator for formulas:
  \begin{equation*}
    \begin{aligned}
      \id(\varphi) \coloneqq \begin{cases}
        \varphi,                        &\varphi \in \set{ \syntop, \synbot } \\
        \varphi,                        &\varphi = P \in \boldop{Prop} \\
        \synneg \id(\psi),              &\varphi = \synneg \psi, \\
        \id(\psi) \syncirc \id(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \Sigma, \\
      \end{cases}
    \end{aligned}
  \end{equation*}

  When defining an operator acting on formulas, we usually handle only a few cases, and the others become straightforward. For example, replacing \( \synneg \varphi \) with \( \varphi \synimplies \synbot \), as justified by \fullref{thm:boolean_equivalences/negation_bottom}, can be achieved via
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        \varphi,                     &\varphi \in \set{ \syntop, \synbot } \\
        \varphi,                     &\varphi = P \in \boldop{Prop} \\
        R(\psi) \synimplies \synbot, &\varphi = \synneg \psi, \\
        R(\psi) \syncirc R(\theta),  &\varphi = \psi \syncirc \theta, {\syncirc} \in \Sigma, \\
      \end{cases}
    \end{aligned}
  \end{equation*}

  We can instead use the notational shorthand
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        R(\psi) \synimplies \synbot,                                             &\varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{aligned}
  \end{equation*}

  In computer programming, this exact problem is solved via the visitor design pattern --- visitors for formulas of first-order logic can be found in \cite{code}.
\end{remark}

\begin{algorithm}[Formula to CNF or DNF]\label{alg:cnf_and_dnf}
  We will define four operators, \( C_1 \) through \( C_4 \), such that, for a \hyperref[def:propositional_grammar_schema/formula]{propositional formula} \( \varphi \)
  \begin{equation*}
    [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\varphi)
  \end{equation*}
  is a formula in \hyperref[def:cnf_and_dnf]{conjunctive normal form} that is \hyperref[def:propositional_entailment/equivalence]{semantically equivalent} to \( \varphi \).

  In order to obtain a \hyperref[def:cnf_and_dnf]{disjunctive normal form} instead, we will need to use \( C_4^\oppos \) rather than \( C_4 \).

  \begin{thmenum}
    \thmitem{alg:cnf_and_dnf/constants} First, we remove the propositional constants. Let \( P \) be any propositional variable and
    \begin{equation*}
      C_1(\varphi) \coloneqq \begin{cases}
        P \vee \synneg P,                                                        &\varphi = \top, \\
        P \wedge \synneg P,                                                      &\varphi = \bot, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Fullref{thm:propositional_substitution_equivalence} implies that, since \( P \vee \synneg P \gleichstark \top \) and \( P \wedge \synneg P \gleichstark \bot \), then \( C_1(\varphi) \gleichstark \varphi \).

    \thmitem{alg:cnf_and_dnf/conditional} Next, we remove the conditional \( \synimplies \) and biconditional \( \syniff \). Let
    \begin{equation*}
      C_2(\varphi) \coloneqq \begin{cases}
        \synneg C_2(\psi) \synvee C_2(\theta),                                   &\varphi = \psi \synimplies \theta, \\
        C_2(\psi \synimplies \theta) \synwedge C_2(\theta \synimplies \psi),     &\varphi = \psi \syniff \theta, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Fullref{thm:boolean_equivalences/conditional_as_disjunction} and \fullref{thm:boolean_equivalences/biconditional_via_conditionals} justify the substitutions and ensure that \( C_2(\varphi) \gleichstark \varphi \).

    \thmitem{alg:cnf_and_dnf/negation} We \enquote{push} negations inwards. Let
    \begin{equation*}
      C_3(\varphi) \coloneqq \begin{cases}
        C_3(\synneg \psi) \synwedge C_3(\synneg \theta),                         &\varphi = \synneg (\psi \synvee \theta), \\
        C_3(\synneg \psi) \synvee C_3(\synneg \theta),                           &\varphi = \synneg (\psi \synwedge \theta), \\
        C_3(\psi),                                                               &\varphi = \synneg \synneg \psi, \\
        \synneg C_3(\psi),                                                       &\T{otherwise if} \varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Fullref{thm:boolean_equivalences/de_morgan} and \fullref{thm:boolean_equivalences/double_negation} ensure that \( C_3(\varphi) \gleichstark \varphi \) for any formula \( \varphi \).

    If case \( \varphi \) has no (bi)conditionals (e.g. due to \( C_2 \)), the result \( C_3(\varphi) \) has negations only before propositional variables.

    \thmitem{alg:cnf_and_dnf/distributive} Finally, we \enquote{pull} conjunctions outwards. Let
    \begin{equation*}
      C_4(\varphi) \coloneqq \begin{cases}
        C_4(\psi_1 \synvee \theta) \synwedge C_4(\psi_1 \synvee \theta),         &\varphi = \psi \synvee \theta \T{and} C_4(\psi) = \psi_1 \synwedge \psi_2, \\
        C_4(\psi \synvee \theta_1) \synwedge C_4(\psi \synvee \theta_2),         &\T{otherwise if} \varphi = \psi \synvee \theta \T{and} C_4(\theta) = \theta_1 \synwedge \theta_2, \\
        C_4(\psi) \synvee C_4(\theta),                                           &\T{otherwise if} \varphi = \psi \synvee \theta, \\
        C_4(\psi) \synwedge C_4(\theta),                                         &\varphi = \psi \synwedge \theta, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The last case is due to the usual traversal rules, and we could avoid writing it, but we wanted to be explicit about how conjunction behaves with \( C_4 \).

    \Fullref{thm:boolean_equivalences/distributivity} ensures that \( C_4(\varphi) \gleichstark \varphi \) for any formula \( \varphi \).

    To \enquote{pull} out disjunctions instead, we will need the operator \( C_4^\oppos \), which is defined like \( C_4 \) but with \( \synvee \) and \( \synwedge \) swapped.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \texttt{fol.cnf.to\_cnf} in \cite{code}.
\end{comments}
\begin{defproof}
  It is obvious from our comments that
  \begin{equation*}
    \varphi' \coloneqq [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\varphi)
  \end{equation*}
  is equivalent to \( \varphi \). We will use \hyperref[rem:induction/peano_arithmetic]{natural number induction} on the length of \( \varphi \) to show that it is in conjunctive normal form.

  \begin{itemize}
    \item If \( \varphi = \syntop \), then \( \varphi' = C_1(\varphi) = P \synvee \synneg P \), which is a disjunction of literals.
    \item If \( \varphi = \synbot \), then \( \varphi' = C_1(\varphi) = P \synwedge \synneg P \), which is a conjunction of \enquote{unary} disjuncts of literals.
    \item If \( \varphi \) is a propositional variable, then \( \varphi' = \varphi \) is a literal.

    \item If \( \varphi = \psi_1 \synvee \psi_2 \), then
    \begin{equation*}
      \varphi'
      =
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \synvee \psi_2)
      =
      C_4\parens[\Big]{ [C_3 \bincirc C_2 \bincirc C_1](\psi_1) \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) }
    \end{equation*}

    The result of applying \( C_4 \) depends on \( \psi_1' \) and \( \psi_2' \). Note that both are shorter than \( \varphi \), so both must be in CNF.
    \begin{itemize}
      \item If \( (\synneg \theta_1)' = \chi_1 \synwedge \chi_2 \), then
      \begin{balign*}
        \varphi'
        &=
        C_4\parens[\bigg]{ \parens[\Big]{ \chi_1 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } \synwedge \parens[\Big]{ \chi_2 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } }
        = \\ &=
        C_4\parens[\Big]{ \chi_1 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } \synwedge C_4\parens[\Big]{ \chi_2 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) }
        = \\ &=
        (\chi_1 \synvee \psi_2)' \synwedge (\chi_2 \synvee \psi_2)'.
      \end{balign*}

      Since both \( (\chi_1 \synvee \psi_2)' \) and \( (\chi_2 \synvee \psi_2)' \) are shorter than \( \varphi \), the inductive hypothesis implies that they are in CNF. Then \( \varphi' \) itself is also in CNF.

      \item If \( \psi_1' \) is not a conjunction and if \( \psi_2' = \chi_1 \synwedge \chi_2 \), then, by analogy with the case above, we conclude that \( \varphi' \) is in CNF.

      \item If neither \( \psi_1' \) nor \( \psi_2' \) are conjunctions, then they must be disjunctions of literals, and hence \( \varphi' \) is also a disjunction of literals.
    \end{itemize}

    \item If \( \varphi = \psi_1 \synwedge \psi_2 \), the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), hence \( \varphi' = \psi_1' \synwedge \psi_2' \) is in CNF.

    \item If \( \varphi = \psi_1 \synimplies \psi_2 \), then
    \begin{balign*}
      \varphi'
      &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \synimplies \psi_2)
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2]\parens[\Big]{ C_1(\psi_1) \synimplies C_1(\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3]\parens[\Big]{ [C_2 \bincirc C_1](\synneg \psi_1) \synvee [C_2 \bincirc C_1](\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\synneg \psi_1 \synvee \psi_2).
    \end{balign*}

    This reduces to the case where \( \varphi \) is a disjunction, hence we can conclude that \( \varphi' \) is in CNF.

    \item If \( \varphi = \psi_1 \syniff \psi_1 \), then
    \small
    \begin{balign*}
      \varphi'
      &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \syniff \psi_2)
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2]\parens[\Big]{ C_1(\psi_1) \syniff C_1(\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3]\parens[\bigg]{ \parens[\Big]{\synneg [C_2 \bincirc C_1](\psi_1) \synvee [C_2 \bincirc C_1](\psi_2)} \synwedge \parens[\Big]{ [C_2 \bincirc C_1](\psi_1) \synvee \synneg [C_2 \bincirc C_1](\psi_2) } }
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1]\parens[\Big]{ (\synneg \psi_1 \synvee \psi_2) \synwedge (\psi_1 \synvee \synneg \psi_2) },
    \end{balign*}
    \normalsize
    which reduces to the case where \( \varphi \) is a conjunction.

    \item If \( \varphi = \synneg \psi \), where \( \psi' \) is in CNF, then we must use nested induction on \( \psi' \):
    \begin{itemize}
      \item If \( \psi = \syntop \), then
      \begin{multline*}
        \varphi'
        =
        C_3(C_1(\synneg \syntop))
        =
        C_3(\synneg C_1(\syntop))
        =
        C_3(\synneg (P \synvee \synneg P))
        = \\ =
        C_3(\synneg P) \synvee C_3(\synneg \synneg P)
        =
        \synneg C_3(P) \synwedge C_3(P)
        =
        \synneg P \synwedge P,
      \end{multline*}
      which is again a conjunction of unary disjuncts of literals.

      \item Dually, if \( \psi = \synbot \), then
      \begin{equation*}
        \varphi'
        =
        C_3(C_1(\synneg \synbot))
        =
        C_3(\synneg (P \synwedge \synneg P))
        =
        \synneg P \synvee P,
      \end{equation*}
      which is a disjunction of literals.

      \item If \( \psi = \synneg \theta \), we have \( \varphi' = \theta' \). Furthermore, since \( \theta \) is shorter than \( \varphi \), \( \theta' \) is in CNF, and hence so is.

      \item If \( \psi = \theta_1 \synvee \theta_2 \), then
      \begin{balign*}
        \varphi'
        &=
        [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1]\parens[\Big]{\synneg (\theta_1 \synvee \theta_2) }
        = \\ &=
        [C_4 \bincirc C_3]\parens[\Big]{ \synneg \parens[\Big]{ [C_2 \bincirc C_1](\theta_1) \synvee [C_2 \bincirc C_1](\theta_2) } }
        = \\ &=
        C_4\parens[\Big]{ C_3\parens[\Big]{ \synneg [C_2 \bincirc C_1](\theta_1) } \synwedge C_3\parens[\Big]{ \synneg [C_2 \bincirc C_1](\theta_2) } }
        = \\ &=
        C_4\parens[\Big]{ [C_3 \bincirc C_2 \bincirc C_1](\synneg \theta_1) \synwedge [C_3 \bincirc C_2 \bincirc C_1](\synneg \theta_2) }
        = \\ &=
        (\synneg \theta_1 \synwedge \synneg \theta_2)'
      \end{balign*}

      This reduces to the case where \( \varphi' \) is a conjunction.

      \item If \( \psi = \theta_1 \synwedge \theta_2 \), then
      \begin{align*}
        \varphi'
        =
        (\synneg \theta_1 \synvee \synneg \theta_2)',
      \end{align*}
      which reduces to the case where \( \varphi \) is a disjunction.

      \item If \( \psi = \theta_1 \synimplies \theta_2 \), this reduces to the case where \( \psi \) is a disjunction and \( \varphi \) is a conjunction.
      \item If \( \psi = \theta_1 \syniff \theta_2 \), this reduces to the case where \( \psi \) is a conjunction and \( \varphi \) is a disjunction.
    \end{itemize}

    In all cases for \( \psi \) in \( \varphi = \synneg \psi \), we have shown that \( \varphi' \) is in CNF.
  \end{itemize}

  We have finished the inductive proof that, for any formula \( \varphi \), the result \( \varphi' \) of applying the transformations \( C_1 \) through \( C_4 \) is a formula in CNF.
\end{defproof}

\begin{definition}\label{def:perfect_cnf_and_dnf}\mimprovised
  We say that the \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}) is \term[ru=совершенная (\cite[def. 6.3; def. 6.4]{Эдельман1975}), en=full (\cite[38]{Rosen1999}) / strict (\cite[def. 1.3.10]{Hinman2005})]{perfect} if the following hold:
  \begin{thmenum}
    \thmitem{def:perfect_cnf_and_dnf/literals} Every elementary disjunction (resp. conjunction) contains exactly one literal for each variable encountered in the formula, and these variables are ordered as per \fullref{rem:grammar_rules_for_variables}.

    More explicitly, if the variables are \( P_1, \ldots, P_n \), every elementary disjunction has the form
    \begin{equation*}
      L_1 \synvee L_2 \synvee \cdots \synvee L_n,
    \end{equation*}
    where, for every \( k = 1, \ldots, n \), \( L_k \) is either \( P_k \) or \( \neg P_k \).

    \thmitem{def:perfect_cnf_and_dnf/elementary} The elementary disjunctions (resp. conjunctions) are ordered \hyperref[def:lexicographic_order]{lexicographically} so that \( P_k < \neg P_k \) for every variable \( P_k \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is based on \cite[def. 6.3; def. 6.4]{Эдельман1975}, but with adjustments made in order to improve rigor.
\end{comments}

\begin{proposition}\label{thm:perfect_cnf_and_dnf_uniqueness}
  A \hyperref[def:perfect_cnf_and_dnf]{perfect} \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}) is unique.
\end{proposition}
\begin{proof}
  Trivial.
\end{proof}

\begin{example}\label{ex:def:cnf_and_dnf}
  We list examples of formulas in \hyperref[def:cnf_and_dnf]{conjunctive and disjunctive normal forms}:
  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/perfect_cnf} The \hyperref[thm:boolean_equivalences]{Boolean equivalence} \eqref{eq:thm:boolean_equivalences/conditional_as_disjunction} allows us to represent convert the \hyperref[def:propositional_alphabet/connectives/conditional]{conditional} \( P \synimplies Q \) to \( \synneg P \synvee Q \), which is both in CNF and in DNF.

    It is an elementary disjunction, hence it is vacuously in perfect CNF.

    The DNF is not perfect, however, because the condition \fullref{def:perfect_cnf_and_dnf/literals} is not satisfied.

    \thmitem{def:cnf_and_dnf/perfect_dnf} Consider instead the formula
    \begin{equation*}
      (P \synwedge Q) \synvee (\synneg P \synwedge Q) \synvee (\synneg P \synwedge \synneg Q)
    \end{equation*}

    It is in perfect DNF, and it is equivalent to \( P \synimplies Q \).
  \end{thmenum}
\end{example}

\begin{algorithm}[Boolean function to perfect CNF or DNF]\label{alg:perfect_cnf_and_dnf}\mcite[thm. I.1.3]{Яблонский2003}
  Let \( f(x_1, \ldots, x_n) \) be an arbitrary \hyperref[def:boolean_function]{Boolean function}.

  We will build a formula \( \varphi \) in \hyperref[def:perfect_cnf_and_dnf]{perfect} \hyperref[def:cnf_and_dnf]{conjunctive normal form} whose \hyperref[def:propositional_valuation/valuation_function]{induced function} will be \( f \).

  \begin{thmenum}
    \thmitem{alg:perfect_cnf_and_dnf/true} If \( f \) is canonically true, let \( \varphi \coloneqq P \synvee \neg P \).

    \thmitem{alg:perfect_cnf_and_dnf/false} If \( n = 0 \) and \( f = F \), let \( \varphi \coloneqq P \synwedge \neg P \).

    \thmitem{alg:perfect_cnf_and_dnf/elementary} Otherwise, fix some propositional variables \( P_1, \ldots, P_n \). Given a tuple \( x_1, \ldots, x_n \) of Boolean values, we can construct the following elementary disjunction:
    \begin{equation}\label{alg:perfect_cnf_and_dnf/cnf}
      P_1^{x_1} \synvee \cdots \synvee P_n^{x_n},
    \end{equation}
    where
    \begin{equation*}
      P_k^{x_k} \coloneqq \begin{cases}
        P_k,      &x_k = F, \\
        \neg P_k, &x_k = T.
      \end{cases}
    \end{equation*}

    \thmitem{alg:perfect_cnf_and_dnf/total} Finally, order the disjunctions with respect to the \hyperref[def:lexicographic_order]{lexicographic order} on the set \( \set{ T, F }^n \) (\( F < T \)) to which the tuples of Boolean values \( (x_1, \ldots, x_n) \) belong. Then let \( \varphi \) be the conjunction of the corresponding elementary disjunctions for which
    \begin{equation*}
      f(x_1, \ldots, x_n) = F.
    \end{equation*}

    \thmitem{alg:perfect_cnf_and_dnf/dual} In order to obtain a perfect DNF instead, we can utilize \fullref{thm:cnf_and_dnf_duality} by instead considering the function
    \begin{equation*}
      \oline{f(x_1, \ldots, x_n)},
    \end{equation*}
    obtaining a formula \( \varphi \) in CNF and then using the dual formula \( \varphi^\oppos \).
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \texttt{fol.cnf.function\_to\_cnf} in \cite{code}.
\end{comments}
\begin{defproof}
  We will use induction on \( n \) to show that
  \begin{equation*}
    \Bracks{\varphi}(x_1, \ldots, x_n) = f(x_1, \ldots, x_n).
  \end{equation*}

  \begin{itemize}
    \item The case \( n = 0 \) is special.
    \begin{itemize}
      \item If \( f = T \), then, by \fullref{alg:perfect_cnf_and_dnf/true}, \( \varphi = P \synvee \neg P \), which is a tautology.
      \item If \( f = F \), then, by \fullref{alg:perfect_cnf_and_dnf/false}, \( \varphi = P \synwedge \neg P \), which is a contradictory formula.
    \end{itemize}

    \item Let \( n = 1 \).
    \begin{itemize}
      \item If \( f(x) = T \), then again by \fullref{alg:perfect_cnf_and_dnf/true}, \( \varphi = P \synvee \neg P \) is a tautology.
      \item If \( f(x) = F \), then \fullref{alg:perfect_cnf_and_dnf/elementary} provides us with the elementary disjunctions \( P^F = P \) and \( P^T = \neg P \) and \fullref{alg:perfect_cnf_and_dnf/total} gives us \( \varphi = P \wedge \neg P \).
      \item If \( f(x) = x \), then we only consider the elementary disjunction \( P^F = P \), which leads us to \( \varphi = P \).
      \item If \( f(x) = \oline{x} \), then \( \varphi = \neg P \).
    \end{itemize}

    Therefore, if \( f \) is unary, the formula \( \varphi \) constructed via this algorithm satisfies \( \Bracks{\varphi}(x) = f(x) \).

    \item Consider the function \( f(x_1, \ldots, x_n, x_{n+1}) \) and suppose that, for any \( n \)-ary Boolean function \( g \), the interpretation of its corresponding formula coincides with \( g \).

    Let \( \varphi_F \) be the formula obtained for \( f(x_1, \ldots, x_n, F) \) and let \( \varphi_F' \) be the formula obtained from \( \varphi_F \) by adding the literal \( P_{n+1} \) to each elementary disjunction.

    Dually, let \( \varphi_T \) be the formula for \( f(x_1, \ldots, x_n, T) \) and let \( \varphi_T' \) be the formula obtained by adding the literal \( \neg P_{n+1} \) to each elementary disjunction.

    Then
    \begin{equation*}
      \Bracks{\varphi_F' \wedge \varphi_T'}(x_1, \ldots, x_n, F)
      =
      \underbrace{\Bracks{\varphi_F'}(x_1, \ldots, x_n, F)}_{\mathclap{\Bracks{\varphi_F}(x_1, \ldots, x_n) \T*{because} \Bracks{P_{n+1}}(F) = F}} \wedge \overbrace{\Bracks{\varphi_T'}(x_1, \ldots, x_n, F)}^{T \T*{because} \Bracks{\neg P_{n+1}}(F) = T}
      =
      \underbrace{\Bracks{\varphi_F}(x_1, \ldots, x_n)}_{f(x_1, \ldots, x_n, F)}
    \end{equation*}
    and similarly
    \begin{equation*}
      \Bracks{\varphi_F' \wedge \varphi_T'}(x_1, \ldots, x_n, T)
      =
      \Bracks{\varphi_T}(x_1, \ldots, x_n)
      =
      f(x_1, \ldots, x_n, T).
    \end{equation*}
  \end{itemize}

  We conclude that the interpretation of a formula obtained through this algorithm is the initial function.
\end{defproof}

\paragraph{Equivalence of propositional formulas and Boolean functions}

\begin{proposition}\label{thm:propositional_formulas_and_boolean_functions}
  \hyperref[def:propositional_grammar_schema/formula]{Propositional formulas} have the following structural properties when treated as \hyperref[def:boolean_function]{Boolean functions}:

  \begin{thmenum}
    \thmitem{thm:propositional_formulas_and_boolean_functions/equivalence_classes} \hyperref[def:propositional_entailment/equivalence]{Semantic equivalence} \( \gleichstark \) is an \hyperref[def:equivalence_relation]{equivalence relation} on the set \( \boldop{Form} \) of all propositional formulas.

    \thmitem{thm:propositional_formulas_and_boolean_functions/bijection} Given the set \( \mscrB \) of all \hyperref[def:boolean_function]{Boolean functions} of arbitrary arity, the following map is bijective:
    \begin{equation*}
      \begin{aligned}
        &\Phi: \boldop{Form} / {\gleichstark} \to \mscrB \\
        &\Phi([\varphi]) \coloneqq \Bracks{\varphi}.
      \end{aligned}
    \end{equation*}
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item This is one of the motivations for studying \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebras}.
  \item Both \( \boldop{Form} / {\gleichstark} \) and \( \mscrB \) are provably Boolean algebras, but we give very different proofs --- the former is a Boolean algebra due to the syntactic \fullref{thm:intuitionistic_lindenbaum_tarski_algebra}, and the latter is a Boolean algebra due to the semantic \fullref{thm:functions_over_model_form_model}. This is another demonstration of the soundness and completeness stated in \fullref{thm:classical_first_order_logic_is_sound_and_complete}. See also \fullref{rem:thm:intuitionistic_lindenbaum_tarski_algebra/syntactic_proof}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:propositional_formulas_and_boolean_functions/equivalence_classes} Straightforward.

  \SubProofOf{thm:propositional_formulas_and_boolean_functions/bijection} The map \( \Phi \) is well-defined since, by definition of semantic equivalence, \( \varphi \gleichstark \psi \) whenever \( \Bracks{\varphi}_I = \Bracks{\psi}_I \) for every interpretation \( I \).

  Injectivity of \( \Phi \) is also obvious from the definition of semantic equivalence, while surjectivity is given by \fullref{alg:perfect_cnf_and_dnf}.
\end{proof}
