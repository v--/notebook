\subsection{Propositional logic}\label{subsec:propositional_logic}

\begin{remark}\label{rem:propositional_language_is_alphabet}
  The \hyperref[def:propositional_language]{language of propositional logic} is, strictly speaking, an \hyperref[def:formal_language/alphabet]{alphabet} rather than a \hyperref[def:formal_language/language]{language}. Nonetheless, this is the established terminology.
\end{remark}

\begin{definition}\label{def:propositional_language}\mcite[sec. 7.2]{OpenLogicFull}
  The \term{language of propositional logic} consists of:

  \begin{thmenum}
    \thmitem{def:propositional_language/prop} A nonempty, \hyperref[def:set_countability/at_most_countable]{at most countable} set \( \boldop{Prop} \) of \term{propositional variables}. Technically, we can have different languages with different variables, but it is safe to assume that there is only one single language of propositional language.

    \thmitem{def:propositional_language/constants} Two \term{propositional constants} (also known as \term{truth values}):
    \begin{thmenum}
      \thmitem{def:propositional_language/constants/verum} The \term{verum} \( \top \).
      \thmitem{def:propositional_language/constants/falsum} The \term{falsum} \( \bot \).
    \end{thmenum}

    \thmitem{def:propositional_language/negation} \term{Negation} \( \neg \).
    \thmitem{def:propositional_language/connectives} The set \( \Sigma \) of \term{propositional connectives}, namely
    \begin{thmenum}
      \thmitem{def:propositional_language/connectives/conjunction} \term{Conjunction} \( \wedge \) (also known as \hyperref[def:standard_boolean_operators]{\term{and}} and \hyperref[def:semilattice/meet]{\term{meet}}).
      \thmitem{def:propositional_language/connectives/disjunction} \term{Disjunction} \( \vee \) (also known as \hyperref[def:standard_boolean_operators]{\term{or}} and \hyperref[def:semilattice/join]{\term{join}}).
      \thmitem{def:propositional_language/connectives/conditional} \term{Conditional} \( \rightarrow \) (also known as \term{if\ldots then} and \hyperref[def:material_implication]{\term{material implication}}).
      \thmitem{def:propositional_language/connectives/biconditional} \term{Biconditional} \( \leftrightarrow \) (also known as \term{iff} and \term{material equivalence}).
    \end{thmenum}

     Note that \enquote{conditional} and \enquote{biconditional} are nouns in this context.

    \thmitem{def:propositional_language/parentheses} Parentheses \( ( \) and \( ) \) for defining the order of operations unambiguously (see \fullref{rem:propositional_formula_parentheses} for a further discussion).
  \end{thmenum}

  \Fullref{rem:smaller_propositional_language} shows we can actually utilize a smaller propositional language without losing any of its semantics.
\end{definition}

\begin{definition}\label{def:propositional_syntax}
  The following related definitions constitute what is called the \term{syntax of propositional logic}.

  \begin{thmenum}
    \thmitem{def:propositional_syntax/grammar_schema} Consider the following \hyperref[rem:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}   {P \in \boldop{Prop}} \\
      \bnfprod{connective} {\circ \in \Sigma} \\
      \bnfprod{formula}    {\bnfpn{variable} \bnfor} \\
      \bnfmore             {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore             {\bnfts{\( \neg \)} \bnfpn{formula} \bnfor} \\
      \bnfmore             {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)}}
    \end{bnf*}

    Note that \( \boldop{Prop} \) may be infinite, in which case the grammars may have infinitely many rules. If needed, we can circumvent this by introducing an appropriate naming convention for variables, for example by allowing arbitrary strings of alphanumeric characters for variable names.

    For the sake of readability, we will be using the conventions in \fullref{rem:propositional_formula_parentheses} regarding parentheses.

    \thmitem{def:propositional_syntax/formula} The set \( \boldop{Form} \) of \term{propositional formulas} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{formula} \) as a starting rule. Propositional formulas are also called sentenced unlike in first-order logic where only specific formulas are called sentences --- see \fullref{def:first_order_syntax/ground_formula}.

    The grammar of propositional formulas is unambiguous as shown by \fullref{thm:propositional_formulas_are_unambiguous}, which makes it possible to perform proofs via \fullref{thm:structural_induction_on_unambiguous_grammars}.

    \thmitem{def:propositional_syntax/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:formal_language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \term{subformula} of \( \varphi \).

    \thmitem{def:propositional_syntax/variables} For each formula \( \varphi \), we inductively define its \term{variables} to be elements of the set
    \begin{equation}\label{eq:def:propositional_syntax/varables}
      \boldop{Var}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                  &\varphi \in \set{ \top, \bot } \\
        \set{ P },                                    &\varphi = P \in \boldop{Prop} \\
        \boldop{Var}(\psi),                           &\varphi = \neg \psi \\
        \boldop{Var}(\psi) \cup \boldop{Var}(\theta), &\varphi = \psi \bincirc \theta, \bincirc \in \Sigma.
      \end{cases}
    \end{equation}

    Note that \( \boldop{Var}(\varphi) \) can naturally be totally ordered by the position of the first occurrence of a variable.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The grammar of \hyperref[def:propositional_syntax/formula]{propositional formulas} is \hyperref[def:grammar_derivation/unambiguous]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is analogous to \fullref{ex:natural_number_arithmetic_grammar/derivation}.
\end{proof}

\begin{remark}\label{rem:propositional_formula_parentheses}
  We use the following two \enquote{abuse-of-notation} conventions regarding parentheses:
  \begin{thmenum}
    \thmitem{rem:propositional_formula_parentheses/outermost} We may skip the outermost parentheses in formulas with top-level \hyperref[def:propositional_language/connectives]{connectives}, e.g. we may write \( P \wedge Q \) rather than \( (P \wedge Q) \).

    \thmitem{rem:propositional_formula_parentheses/associative} Because of the associativity of \( \wedge \) and \( \vee \), which is implied by \fullref{def:propositional_formula_induced_function} and \fullref{def:standard_boolean_operators}, we may skip the parentheses in chains like
    \begin{equation*}
      ( \ldots ((P_1 \wedge P_2) \wedge P_3) \wedge \ldots \wedge P_{n-1} ) \wedge P_n.
    \end{equation*}
    and instead write
    \begin{equation*}
      P_1 \wedge P_2 \wedge \ldots \wedge P_{n-1} \wedge P_n.
    \end{equation*}

    \thmitem{rem:first_order_formula_parentheses/additional} Although not formally necessary, for the sake of readability we may choose to add parentheses around certain formulas like
    \begin{equation*}
      \neg P \vee \neg Q.
    \end{equation*}
    and instead write
    \begin{equation*}
      (\neg P) \vee \neg Q.
    \end{equation*}

    This latter convention is more useful for quantifiers in \hyperref[def:first_order_syntax/formula]{first-order formulas}.
  \end{thmenum}

  These are only notations shortcuts in the \hyperref[rem:metalogic]{metalanguage} and the formulas themselves (as abstract mathematical objects) are still assumed to contain parentheses that help them avoid syntactic ambiguity.
\end{remark}

\begin{definition}\label{def:material_implication}
  Theorems in mathematics usually have the form \( P \rightarrow Q \). Formulas of this form are called \term{material implications} in order to distinguish them from logical implication, which relates to the metatheoretic concept of \hyperref[def:propositional_semantics/entailment]{entailment}. This is further discussed in \cite{MathSE:material_vs_logical_implication}. Note that the term \enquote{material implication} sometimes also refers to the \hyperref[def:propositional_language/connectives/conditional]{conditional connective \( \rightarrow \)} itself.

  We introduce terminology that is conventionally used when dealing with theorems.

  \begin{thmenum}
    \thmitem{def:material_implication/sufficient_condition} \( P \) is a \term{sufficient condition} for \( Q \).

    \thmitem{def:material_implication/necessary_condition} \( Q \) is a \term{necessary condition} for \( P \).

    \thmitem{def:material_implication/antecedent} \( P \) the \term{antecedent} of \( \varphi \).

    \thmitem{def:material_implication/consequent} \( Q \) the \term{consequent} of \( \varphi \).

    \thmitem{def:material_implication/inverse} The formula \( \neg P \rightarrow \neg Q \) is the \term[bg=противоположна,ru=противоположная]{inverse} of \( \varphi \).

    \thmitem{def:material_implication/converse} The formula \( Q \rightarrow P \) is the \term[bg=обратна,ru=обратная]{converse} of \( \varphi \).

    \thmitem{def:material_implication/contrapositive} The formula \( \neg Q \rightarrow \neg P \) is the \term{contrapositive} of \( \varphi \). In classical logic, it is \hyperref[def:propositional_semantics/equivalence]{equivalent} to the original formula due to \fullref{thm:boolean_equivalences/contrapositive}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:propositional_valuation}
  We define \term[bg=оценка,ru=оценка]{valuations} for propositional formulas. It is possible to define different valuations, so in case of doubt, we will refer to the one defined here as the \term{classical valuation} giving \term{classical semantics}.

  This valuation implicitly depends on the \hyperref[def:boolean_algebra]{Boolean algebra} fixed in \fullref{def:boolean_function}. When dealing with \hyperref[def:propositional_heyting_algebra_semantics]{Heyting semantics}, we use more general Heyting algebras where not only the top and bottom, but also other values are utilized.

  \begin{thmenum}
    \thmitem{def:propositional_valuation/interpretation} A \term{propositional interpretation} is a function with signature \( I: \boldop{Prop} \to \set{ T, F } \). See \fullref{def:boolean_value} for remarks regarding the \hyperref[def:boolean_algebra]{Boolean algebra} \( \set{ T, F } \) and the \fullref{def:standard_boolean_operators} for a list of some standard Boolean operators.

    \thmitem{def:propositional_valuation/formula_valuation} Given an interpretation \( I \), we define the \term{valuation} of a formula \( \varphi \) inductively as
    \begin{equation}\label{eq:def:propositional_valuation/formula_interpretation}
      \varphi\Bracks{I} \coloneqq \begin{cases}
        T,                                         &\varphi = \top \\
        F,                                         &\varphi = \bot \\
        I(P),                                      &\varphi = P \in \boldop{Prop} \\
        \overline{\psi\Bracks{I}},                 &\varphi = \neg \psi \\
        \psi_1\Bracks{I} \bincirc \psi_2\Bracks{I} &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma,
      \end{cases}
    \end{equation}
  \end{thmenum}
  where \( \bincirc \) on the left denotes the \hyperref[def:standard_boolean_operators]{Boolean operator} corresponding to the connective \( \bincirc \) on the right.
\end{definition}

\begin{remark}\label{rem:propositional_formula_valuation_without_variable_assignment}
  If we know that \( \boldop{Var}(\varphi) \subseteq \{ P_1, \ldots, P_n \} \), it follows that the \hyperref[def:first_order_valuation/formula_valuation]{valuation} \( \varphi\Bracks{I} \) only depends on the particular values \( I(P_1), \ldots, I(P_n) \) of \( I \).

  Let \( x_1, \ldots, x_n \in \set{ F, T } \) and let \( I \) be such that \( I(P_k) = x_k \) for \( k = 1, \ldots, n \). We introduce the notation
  \begin{equation}\label{eq:rem:propositional_formula_valuation_without_variable_assignment/short_semantic}
    \varphi\Bracks{x_1, \ldots, x_n}
  \end{equation}
  for \( \varphi\Bracks{I} \) because the rest of the interpretation \( I \) plays no role here. We may also use
  \begin{equation}\label{eq:rem:propositional_formula_valuation_without_variable_assignment/short_syntactic}
    \varphi[\psi_1, \ldots, \psi_n]
  \end{equation}
  to denote \hyperref[def:propositional_substitution]{substitution}.

  When using this notation, we implicitly assume that \( \boldop{Var}(\varphi) \subseteq \set{ P_1, \ldots, P_n } \).
\end{remark}

\begin{definition}\label{def:propositional_formula_induced_function}
  Let \( \varphi \) be a propositional formula and let \( \boldop{Var}(\varphi) = \set{ P_1, \ldots, P_n } \) be an ordering of the free variables of \( \varphi \). We define the \hyperref[def:boolean_function]{Boolean function}
  \begin{equation}\label{eq:def:propositional_formula_induced_function}
    \begin{split}
      &\fun_\varphi: \set{ T, F }^n \to \set{ T, F } \\
      &\fun_\varphi(x_1, \ldots, x_n) \coloneqq \varphi\Bracks{x_1, \ldots, x_n}.
    \end{split}
  \end{equation}
\end{definition}

\begin{definition}\label{def:propositional_semantics}
  We now define \term{semantical} properties of propositional formulas. Because of the connection with \hyperref[def:boolean_function]{Boolean functions} given in \fullref{def:propositional_formula_induced_function}, we also formulate some of the properties using Boolean functions.

  \begin{thmenum}
    \thmitem{def:propositional_semantics/satisfiability}\mcite[def. 7.14]{OpenLogicFull} Given an interpretation \( I \) and a set \( \Gamma \) of formulas, we say that \( I \) \term{satisfies} \( \Gamma \) if, for every formula \( \varphi \in \Gamma \) we have \( \varphi\Bracks{I} = T \).

    We also say that \( I \) is a \term{model} of \( \Gamma \) and write \( I \vDash \Gamma \).

    If \( \Gamma = \set{ \gamma_1, \ldots, \gamma_n } \) is a finite ordered set, we use the shorthand \( I \vDash \gamma_1, \ldots, \gamma_n \) rather than \( I \vDash \set{ \gamma_1, \ldots, \gamma_n } \). In particular, if \( \Gamma = \set{ \varphi } \) we write \( I \vDash \varphi \).

    Note that every interpretation vacuously satisfies the empty set \( \Gamma = \varnothing \) of formulas.

    We say that \( \Gamma \) is \term{satisfiable} if there exists a model for \( \Gamma \).

    \thmitem{def:propositional_semantics/entailment} We say that the set of formulas \( \Gamma \) \term{entails} the set of formulas \( \Delta \) and write \( \Gamma \vDash \Delta \) if either of the following hold:
    \begin{itemize}
      \thmitem{def:propositional_semantics/entailment/direct} Every model of \( \Gamma \) is also a model of \( \Delta \).
      \thmitem{def:propositional_semantics/entailment/functional} The following \hyperref[thm:def:function/preimage]{preimage} inclusion holds:
      \begin{equation*}
        \bigcap_{\varphi \in \Gamma} \fun_\varphi^{-1}(T) \subseteq \bigcap_{\psi \in \Delta} \fun_\psi^{-1}(T).
      \end{equation*}
    \end{itemize}

    \thmitem{def:propositional_semantics/tautology} The formula \( \varphi \) is a (semantic) \term{tautology} if either:
    \begin{itemize}
      \thmitem{def:propositional_semantics/tautology/interpretations} Every interpretation satisfies \( \varphi \).
      \thmitem{def:propositional_semantics/tautology/entailment} The empty set \( \Gamma = \varnothing \) of formulas entails \( \varphi \), i.e. \( \vDash \varphi \).
      \thmitem{def:propositional_semantics/tautology/functional} The function \( \fun_\varphi \) is canonically true.
    \end{itemize}

    We also say that \( \varphi \) is \term{valid}.

    \thmitem{def:propositional_semantics/contradiction} Dually, \( \varphi \) is a (semantic) \term{contradiction} if either:
    \begin{itemize}
      \thmitem{def:propositional_semantics/contradiction/interpretations} No interpretation satisfies \( \varphi \).
      \thmitem{def:propositional_semantics/contradiction/entailment} The formula \( \varphi \) entails \( \bot \), i.e. \( \varphi \vDash \bot \).
      \thmitem{def:propositional_semantics/contradiction/functional} The function \( \fun_\varphi \) is canonically false.
    \end{itemize}

    \thmitem{def:propositional_semantics/equivalence} We say that \( \varphi \) and \( \psi \) are \term{semantically equivalent} and write \( \varphi \gleichstark \psi \) if either:
    \begin{itemize}
      \thmitem{def:propositional_semantics/equivalence/interpretations} We have \( \varphi\Bracks{I} = \psi\Bracks{I} \) for every interpretation \( I \).
      \thmitem{def:propositional_semantics/equivalence/entailment} Both \( \varphi \vDash \psi \) and \( \psi \vDash \varphi \).
    \end{itemize}

    \thmitem{def:propositional_semantics/equisatisfiability} A weaker notion than that of semantic equivalence is that of \term{equisatisfiability}. We say that the families \( \Gamma \) and \( \Delta \) are equisatisfiable if the following holds: \enquote{\( \Gamma \) is satisfiable if and only if \( \Delta \) is satisfiable}. For single-formula families \( \Gamma = \set{ \varphi } \) and \( \Delta = \set{ \psi } \), the following are equivalent conditions for equisatisfiability:
    \begin{itemize}
      \thmitem{def:propositional_semantics/equisatisfiability/interpretations} There exist interpretations \( I \) and \( J \) such that \( \varphi\Bracks{I} = \psi\Bracks{J} \).
      \thmitem{def:propositional_semantics/equisatisfiability/functional} We have \( \fun_\varphi = \fun_\psi \) for the induced functions.
    \end{itemize}

    A trivial example of equisatisfiable, but not equivalent formulas are \( \varphi = P \) and \( \psi = Q \) for \( P \neq Q \).
  \end{thmenum}
\end{definition}

\begin{theorem}\label{thm:lindenmaum_tarski_algebra_of_full_propositional_logic}
  We give an explicit connection between \hyperref[def:propositional_syntax/formula]{propositional formulas} and \hyperref[def:boolean_function]{Boolean functions}.

  \begin{thmenum}
    \thmitem{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/equivalence_classes} The \hyperref[def:propositional_semantics/equivalence]{semantic equivalence} \( \gleichstark \) is an equivalence relation on the set \( \boldop{Form} \) of all propositional formulas.

    \thmitem{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/bijection} The \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebra}  \( \boldop{Form} / {{}\gleichstark} \) of all propositional formulas with respect to semantic equivalence is bijective with the set of all \hyperref[def:boolean_function]{Boolean functions} of arbitrary arity.

    Both are provably Boolean algebras, but with very different proofs --- the Lindenbaum-Tarski algebra is Boolean due to the purely syntactic \fullref{thm:intuitionistic_lindenbaum_tarski_algebra} and the set of all Boolean functions is a Boolean algebra due to the semantic \fullref{thm:functions_over_model_form_model}. This is another demonstration of \fullref{thm:classical_propositional_logic_is_sound_and_complete}.

    See \fullref{rem:thm:intuitionistic_lindenbaum_tarski_algebra/syntactic_proof}.
  \end{thmenum}
\end{theorem}
\begin{proof}
  \SubProofOf{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/equivalence_classes} Follows from the equivalences in \fullref{def:equivalence_relation}.

  \SubProofOf{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/bijection} Follows from the equivalences in \fullref{def:propositional_semantics/equivalence}.
\end{proof}

\begin{proposition}\label{thm:boolean_equivalences}
  The following (and many more) are called \term{Boolean equivalences} because they are actually statements about our choice of \hyperref[def:standard_boolean_operators]{standard Boolean operators}. They are formulated here because the framework of propositional logic is more convenient for stating the equivalences. Note that most of these equivalences fail in \hyperref[def:intuitionistic_propositional_deductive_systems]{intuitionistic logic}.

  For arbitrary propositional formulas \( \varphi \) and \( \psi \), the following semantic equivalences hold:
  \begin{thmenum}
    \thmitem{thm:boolean_equivalences/negation_bottom} \hyperref[def:propositional_language/negation]{Negation} can be expressed via the \hyperref[def:propositional_language/constants/falsum]{falsum}:
    \begin{equation}\label{eq:thm:boolean_equivalences/negation_bottom}
      \begin{split}
        \mathllap{\neg \varphi} &\gleichstark \mathrlap{\varphi \rightarrow \bot}.
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/double_negation} \hyperref[def:propositional_language/negation]{Negation} is an \hyperref[def:set_with_involution]{involution}:
    \begin{equation}\label{eq:thm:boolean_equivalences/double_negation}
      \begin{split}
        \mathllap{\neg \neg \varphi} &\gleichstark \mathrlap{\varphi}.
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/contrapositive} A \hyperref[def:material_implication]{material implication} is equivalent to its \hyperref[def:material_implication/contrapositive]{contrapositive}:
    \begin{equation}\label{eq:thm:boolean_equivalences/contrapositive}
      \begin{split}
        \mathllap{\varphi \rightarrow \psi} &\gleichstark \mathrlap{\neg \psi \rightarrow \neg \varphi.}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/conditional_as_disjunction} A \hyperref[def:propositional_language/connectives/conditional]{conditional} is a \hyperref[def:propositional_language/connectives/disjunction]{disjunction} with the \hyperref[def:material_implication/antecedent]{antecedent} negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/conditional_as_disjunction}
      \begin{split}
        \mathllap{\varphi \rightarrow \psi} &\gleichstark \mathrlap{ \neg \varphi \vee \psi. }
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_via_conditionals} A \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is a \hyperref[def:propositional_language/connectives/conjunction]{conjunction} of \hyperref[def:propositional_language/connectives]{conditionals}:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_via_conditionals}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{(\varphi \rightarrow \psi) \wedge (\psi \rightarrow \varphi).}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_as_conjunction} The \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is a \hyperref[def:propositional_language/connectives/disjunction]{conjunction} of \hyperref[def:propositional_language/connectives/conjunction]{disjunctions}:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_as_conjunction}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{(\neg \varphi \vee \psi) \wedge (\neg \varphi \vee \psi).}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_as_disjunction} The \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is a \hyperref[def:propositional_language/connectives/disjunction]{disjunction} of \hyperref[def:propositional_language/connectives/conjunction]{conjunctions}:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_as_disjunction}
      \begin{split}
        \mathllap{\varphi \leftrightarrow \psi} &\gleichstark \mathrlap{(\varphi \wedge \psi) \vee (\neg \varphi \wedge \neg \psi).}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_member_negation} A \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is equivalent its termwise negation:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_member_negation}
      \begin{split}
        \mathllap{\neg \varphi \leftrightarrow \neg \psi} &\gleichstark \mathrlap{\varphi \leftrightarrow \psi.}
      \end{split}
    \end{equation}

    \thmitem{thm:boolean_equivalences/biconditional_negation} A negation of a \hyperref[def:propositional_language/connectives/biconditional]{biconditional} is again a biconditional with one of the terms negated:
    \begin{equation}\label{eq:thm:boolean_equivalences/biconditional_negation}
      \begin{split}
        \mathllap{\neg \parens{\varphi \leftrightarrow \psi}}
        &\gleichstark
        \mathrlap{\neg \varphi \leftrightarrow \psi \gleichstark}
        \\ &\gleichstark
        \mathrlap{\varphi \leftrightarrow \neg \psi.}
      \end{split}
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  The proofs follow directly from the table in \fullref{def:standard_boolean_operators}.
\end{proof}

\begin{definition}\label{def:propositional_substitution}
  We sometimes want to substitute a propositional variable with another variable or even with a formula. This is akin to applying a \hyperref[def:boolean_function]{Boolean function} like \( x \vee y \) to different variables (e.g. to obtain \( x \vee x \)) or even concrete values (e.g. \( F \vee T \)), except that it is done on a purely syntactic level without involving any semantics involved.

  It does not pose any technical difficulty to extend this definition beyond replacing a variable like it is usually done (e.g. \cite[def. 7.8]{OpenLogicFull}). Not only that, we can then use this mechanism to define complicated rewriting rules as in \fullref{alg:perfect_cnf_and_dnf} and have semantic equivalence automatically follow from \fullref{thm:propositional_substitution_equivalence}.

  \begin{thmenum}
    \thmitem{def:propositional_substitution/single} We define the \term{substitution} of the propositional formula \( \theta \) with \( \chi \) in \( \varphi \) as
    \begin{equation}\label{eq:def:propositional_substitution/single}
      \varphi[\theta \mapsto \chi] \coloneqq \begin{cases}
        \chi,                                                             &\varphi = \theta \\
        \varphi,                                                          &\varphi \neq \theta \T{and} \varphi \in \set{ \top, \bot } \cup \boldop{Prop} \\
        \neg \psi[\theta \mapsto \chi],                                   &\varphi \neq \theta \T{and} \varphi = \neg \psi \\
        \psi_1[\theta \mapsto \chi] \bincirc \psi_2[\theta \mapsto \chi], &\varphi \neq \theta \T{and} \varphi = \psi_1 \bincirc \psi_2, \circ \in \Sigma.
      \end{cases}
    \end{equation}

    Note that it is not strictly necessary for \( \theta \) to be a subformula of \( \varphi \).

    In the case where \( \theta \) is a single variable, if \( P \in \boldop{Var}(\varphi) \), then \( \varphi[P \mapsto \chi] \) is said to be an \term{instance} of \( \varphi \).

    \thmitem{def:propositional_substitution/simultaneous} We will now define \term{simultaneous substitution} of \( \theta_1, \ldots, \theta_n \) with \( \chi_1, \ldots, \chi_n \). We wish to avoid the case where \( \theta_k \) is a subformula of \( \chi_{k-1} \) and it accidentally gets replaced during \( \varphi[\theta_{k-1} \mapsto \chi_{k-1}][\theta_k \mapsto \chi_k] \).

    Define
    \begin{equation*}
      \cat{Bound} \coloneqq \boldop{Var}(\chi_1) \cup \ldots \cup \boldop{Var}(\chi_n).
    \end{equation*}
    and, for each variable \( P_k \) in \( \cat{Bound} \), pick a variable \( Q_k \) from \( \boldop{Prop} \setminus \boldop{Bound} \) (we implicitly assume the existence of enough variables in \( \boldop{Prop} \)). Let \( m \) be the \hyperref[def:cardinal]{cardinality} of \( \boldop{Bound} \). The simultaneous substitution can now be defined as
    \begin{align*}
      \varphi[\theta_1 \mapsto \chi_1, \ldots, \theta_n \mapsto \chi_n] \coloneqq \varphi
      [\theta_1 \mapsto \chi_1[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      \vdots \hspace{3cm} \\
      [\theta_n \mapsto \chi_n[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      [Q_1 \mapsto P_1, \ldots, Q_m \mapsto P_m].
    \end{align*}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  If \( \theta \) is a subformula of \( \varphi \) and if \( \theta \gleichstark \chi \), then
  \begin{equation}\label{eq:thm:propositional_substitution_equivalence}
    \varphi[\theta \mapsto \chi] \gleichstark \varphi.
  \end{equation}

  By induction, this also holds for \hyperref[def:propositional_substitution/simultaneous]{simultaneous substitution}.
\end{proposition}
\begin{proof}
  We use structural induction on \( \varphi \):

  \begin{itemize}
    \item If \( \varphi = \theta \), then \( \varphi[\theta \mapsto \chi] = \chi \) and, by definition,
    \begin{equation*}
      \varphi = \theta \gleichstark \chi = \varphi[\theta \mapsto \chi].
    \end{equation*}

    \item If \( \varphi \neq \theta \) and \( \varphi \in \set{ \top, \bot } \cup \boldop{Prop} \), then \( \varphi[\theta \mapsto \chi] = \varphi \) and \eqref{eq:thm:propositional_substitution_equivalence} again holds trivially.

    \item If \( \varphi \neq \theta \) and \( \varphi = \neg \chi \) and if the inductive hypothesis holds for \( \chi \), then \( \varphi[\theta \mapsto \chi] = \neg \psi[\theta \mapsto \chi] \). For any interpretation \( I \),
    \begin{equation*}
      \parens[\Big]{ \varphi[\theta \mapsto \chi] }\Bracks{I}
      =
      \overline{\parens[\Big]{ \psi[\theta \mapsto \chi] }\Bracks{I}}
      \reloset {\T{ind.}} =
      \overline{\psi\Bracks{I}}
      =
      \varphi\Bracks{I}.
    \end{equation*}

    Therefore, \eqref{eq:thm:propositional_substitution_equivalence} holds in this case.

    \item If \( \varphi \neq \theta \) and \( \varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma \) and if the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), then for any interpretation \( I \),
    \begin{equation*}
      \parens[\Big]{ \varphi[\theta \mapsto \chi] }\Bracks{I}
      =
      \parens[\Big]{ \psi_1[\theta \mapsto \chi] }\Bracks{I} \bincirc \parens[\Big]{ \psi_2[\theta \mapsto \chi] }\Bracks{I}
      \reloset {\T{ind.}} =
      \psi_1\Bracks{I} \bincirc \psi_2\Bracks{I}
      =
      \varphi\Bracks{I}.
    \end{equation*}

    Therefore, \eqref{eq:thm:propositional_substitution_equivalence} holds in this case also.
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_substitution_equivalence} holds in all cases.
\end{proof}

\begin{remark}\label{rem:smaller_propositional_language}
  For \hyperref[def:propositional_semantics]{semantical} concepts, it is immaterial which element of an equivalence class we consider. \hyperref[def:boolean_closure]{Complete sets of Boolean operations} allow us to represent each formula using a strict subset of the \hyperref[def:propositional_language/constants]{propositional constants}, \hyperref[def:propositional_language/negation]{negation} and \hyperref[def:propositional_language/connectives]{connectives}. \Fullref{ex:thm:posts_completeness_theorem} shows some concrete commonly used complete sets of Boolean operations. This is also the motivation for studying \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebras}.

  This is useful in
  \begin{itemize}
    \item Reduction to normal forms such as the \hyperref[def:cnf_and_dnf]{conjunctive normal form} in \fullref{alg:perfect_cnf_and_dnf}.

    \item \hyperref[def:propositional_semantics/satisfiability]{Satisfiability} proofs that rely on \hyperref[rem:structural_recursion_and_induction]{structural induction} because it allows us to consider less cases in the induction.

    \item Having fewer rules in \hyperref[alg:perfect_cnf_and_dnf]{deductive systems}. For example, we may choose to add \eqref{eq:thm:minimal_propositional_negation_laws/pierce} to the axioms of the \hyperref[def:positive_implicational_deductive_system]{positive implicational derivation system} and due to \fullref{thm:minimal_propositional_negation_laws} this derivation system would be able to emulate the \hyperref[def:classical_propositional_deductive_systems]{classical derivation system}.
  \end{itemize}
\end{remark}

\begin{definition}\label{def:cnf_and_dnf}\mcite[I.1.\S4]{Яблонский1986}
  We will now introduce \term{conjunctive normal forms} (CNF) and \term{disjunctive normal forms} (DNF) for propositional formulas. The concepts are related but distinct from that of \hyperref[rem:lattice_polynomials]{lattice polynomials}.

  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/grammar} The structure of these formulas is best described by the \hyperref[rem:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{positive literal}     {P \in \boldop{Prop}} \\
      \bnfprod{negative literal}     {\neg \bnfpn{positive literal}} \\
      \bnfprod{literal}              {\bnfpn{positive literal} \bnfor \bnfpn{negative literal}} \\
      \bnfprod{disjunct}             {\bnfpn{literal} \bnfor \bnfts{(} \bnfsp \bnfpn{literal}  \bnfsp \bnfts{\( \vee \)}   \bnfsp \bnfpn{disjunct} \bnfsp \bnfts{)}} \\
      \bnfprod{CNF}                  {\bnfpn{CNF}     \bnfor \bnfts{(} \bnfsp \bnfpn{disjunct} \bnfsp \bnfts{\( \wedge \)} \bnfsp \bnfpn{CNF}      \bnfsp \bnfts{)}} \\
      \bnfprod{conjunct}             {\bnfpn{literal} \bnfor \bnfts{(} \bnfsp \bnfpn{literal}  \bnfsp \bnfts{\( \wedge \)} \bnfsp \bnfpn{conjunct} \bnfsp \bnfts{)}} \\
      \bnfprod{DNF}                  {\bnfpn{DNF}     \bnfor \bnfts{(} \bnfsp \bnfpn{conjunct} \bnfsp \bnfts{\( \vee \)}   \bnfsp \bnfpn{DNF}      \bnfsp \bnfts{)}}
    \end{bnf*}

    As usual, we utilize the convention in \fullref{rem:propositional_formula_parentheses} and avoid excessive parentheses.

    In this context, the terms \term{conjunct} and \term{disjunct} are commonly used to refer to sets of literals rather than the formulas containing them.

    \thmitem{def:cnf_and_dnf/variable_power} Given a variable \( P \) and a \hyperref[def:boolean_value]{Boolean value} \( x \in \set{ T, F } \), define
    \begin{equation*}
      P^x \coloneqq \begin{cases}
        P      &x = T, \\
        \neg P &x = F.
      \end{cases}
    \end{equation*}

    \thmitem{def:cnf_and_dnf/perfect} Given a finite sequence of distinct variables \( P_1, \ldots, P_n \), we say that a formula is in \term{perfect} CNF with respect to them if the following conditions hold:
    \begin{thmenum}
      \thmitem{def:cnf_and_dnf/perfect/fullness} Every disjunct contains \( n \) literals and the \( k \)-th literal is either \( P_k \) or \( \neg P_k \).
      \thmitem{def:cnf_and_dnf/perfect/ordering} The disjuncts are ordered \hyperref[def:lexicographic_order]{lexicographically} so that, for the \( k \)-th literals, \( L_k \leq R_k \) if either \( L_k \) is a negative literal or if both literals are positive.
    \end{thmenum}

    A formula in perfect conjunctive normal form can be written as
    \begin{equation*}
      \bigwedge_{(x_1, \ldots, x_n) \in B} P_1^{x_1} \vee \cdots \vee P_n^{x_n}.
    \end{equation*}

    Perfect DNFs are defined analogously. These additional conditions ensure uniqueness --- see \fullref{alg:perfect_cnf_and_dnf}.
  \end{thmenum}
\end{definition}

\begin{example}\label{ex:def:cnf_and_dnf}
  We list examples of formulas in \hyperref[def:cnf_and_dnf]{conjunctive and disjunctive normal forms}:
  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/perfect_cnf} The \hyperref[thm:boolean_equivalences]{Boolean equivalence} \eqref{eq:thm:boolean_equivalences/conditional_as_disjunction} allows us to convert the \hyperref[def:propositional_language/connectives/conditional]{conditional} \( P \to Q \) to \( \neg P \vee Q \), which is both in CNF and in DNF.

    It is its own only disjunct, and it contains both variable, hence it is in perfect CNF.

    The DNF is not perfect, however. because neither conditions \fullref{def:cnf_and_dnf/perfect/fullness} nor \fullref{def:cnf_and_dnf/perfect/ordering} are satisfied.

    \thmitem{def:cnf_and_dnf/perfect_dnf} Consider instead the formula
    \begin{equation*}
      (\neg P \wedge \neg Q) \vee (\neg P \wedge Q) \vee (P \wedge Q).
    \end{equation*}

    It is in perfect DNF, and it is equivalent to \( P \to Q \).
  \end{thmenum}
\end{example}

\begin{algorithm}[Perfect CNFs and DNFs]\label{alg:perfect_cnf_and_dnf}\mcite[thm. I.1.3]{Яблонский1986}
  Let \( f(x_1, \ldots, x_n) \) be an arbitrary \hyperref[def:boolean_function]{Boolean function}. We will build a formula in \hyperref[def:cnf_and_dnf/perfect]{perfect disjunctive normal form} and one in \hyperref[def:cnf_and_dnf/perfect]{perfect conjunctive normal form}. The \hyperref[def:propositional_formula_induced_function]{induced function} of both of these formulas will be \( f \). Both formulas are unique, as we will show.

  \begin{thmenum}
    \thmitem{alg:perfect_cnf_and_dnf/guard} If \( f \) is constant, the constant itself is both a perfect CNF and DNF.

    \thmitem{alg:perfect_cnf_and_dnf/algorithm} Suppose that \( f \) is nonconstant and fix some propositional variables \( P_1, \ldots, P_n \). The following is a formula in perfect CNF whose \hyperref[def:propositional_formula_induced_function]{induced function} is \( f \):
    \begin{equation}\label{alg:perfect_cnf_and_dnf/cnf}
      \bigwedge_{f(x_1, \ldots, x_n) = F} P_1^{x_1} \vee \cdots \vee P_n^{x_n}.
    \end{equation}

    Assuming that \( F < T \), we order the disjuncts with respect to the \hyperref[def:lexicographic_order]{lexicographic order} on the set \( \set{ T, F }^n \) to which the tuples of Boolean values \( (x_1, \ldots, x_n) \) belong.

    \hyperref[def:semilattice/duality]{Dually}, we construct the perfect DNF as
    \begin{equation}\label{alg:perfect_cnf_and_dnf/dnf}
      \bigvee_{f(x_1, \ldots, x_n) = T} P_1^{\overline{x_1}} \wedge \cdots \wedge P_n^{\overline{x_n}},
    \end{equation}
  \end{thmenum}
\end{algorithm}
\begin{defproof}
  We will derive existence and uniqueness of perfect DNFs simultaneously from first principles. The derivation for CNFs is dual, but is more convoluted conceptually.

  Fix sequences of Boolean values \( a_1, \ldots, a_n \) and \( x_1, \ldots, x_n \). Then
  \begin{center}
    \begin{tabular}{c c | c}
      \( x_k \) & \( a_k \) & \( P_k^{\overline{x_k}}\Bracks{a_k} \) \\
      \hline
      \( F \)   & \( F \)   & \( T \) \\
      \( F \)   & \( T \)   & \( F \) \\
      \( T \)   & \( F \)   & \( F \) \\
      \( T \)   & \( T \)   & \( T \)
    \end{tabular}
  \end{center}

  Therefore, \( P_k^{\overline{x_1}}\Bracks{a_k} = T \) if and only if \( x_k = a_k \). Then
  \begin{equation*}
    \parens*{ P_1^{\overline{x_1}} \vee \cdots \vee P_n^{\overline{x_1}} }\bracks{ a_1, \ldots, a_n }
    =
    \begin{cases}
      T, &a_k = x_k \T{for all} k = 1, \ldots, n, \\
      F, &\T{otherwise.}
    \end{cases}
  \end{equation*}

  Given some set \( B \subseteq \set{ T, F }^n \), we have
  \begin{equation*}
    \parens*{ \bigvee_{(x_1, \ldots, x_n) \in B} P_1^{\overline{x_1}} \vee \cdots \vee P_n^{\overline{x_n}} }\bracks{ a_1, \ldots, a_n } = T
  \end{equation*}
  if and only if there exists some tuple \( (x_1, \ldots, x_n) \in B \) such that \( x_k = a_k \) for every index \( k \). That is, if the tuple \( (a_1, \ldots, a_n) \) belongs to the complement \( B \). This leads us to the only possible definition
  \begin{equation*}
    B \coloneqq \set{ (x_1, \ldots, x_n) \given f(x_1, \ldots, x_n) = T }.
  \end{equation*}
\end{defproof}
