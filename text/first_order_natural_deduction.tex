\section{First-order natural deduction}\label{sec:first_order_natural_deduction}

\paragraph{Simultaneous substitution}

\begin{algorithm}[First-order formula substitution]\label{alg:fol_formula_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to arbitrary \hyperref[def:fol_formula]{first-order formulas} as follows:
  \begin{empheq}[left={\varphi[\Bbbs]} \coloneqq \empheqlbrace]{align}
    &\varphi,                                                    &&\varphi \in \op*{PConst},                                                                      \label{eq:alg:fol_formula_substitution/const}         \\
    &\tau[\Bbbs] \syneq \sigma[\Bbbs],                           &&\varphi = (\tau \syneq \sigma),                                                                \label{eq:alg:fol_formula_substitution/eq} \\
    &p\parens[\big]{ \sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs] }, &&\varphi = p(\sigma_1, \ldots, \sigma_n),                                                       \label{eq:alg:fol_formula_substitution/pred} \\
    &\synneg \psi[\Bbbs],                                        &&\varphi = \synneg \psi,                                                                        \label{eq:alg:fol_formula_substitution/neg} \\
    &\psi[\Bbbs] \syncirc \theta[\Bbbs],                         &&\varphi = (\psi \syncirc \theta), {\syncirc} \in \op*{Conn},                                   \label{eq:alg:fol_formula_substitution/conn} \\
    &\quantifier Q x \psi[\Bbbs_{x \mapsto x}],                  &&\varphi = \quantifier Q x \psi, Q \in \op*{Quant} \T{and} x \not\in \op*{Free}_\Bbbs(\varphi), \label{eq:alg:fol_formula_substitution/quant/direct} \\
    &\quantifier Q x \psi[\Bbbs_{x \mapsto n}],                  &&\varphi = \quantifier Q x \psi, Q \in \op*{Quant} \T{and} x \in \op*{Free}_\Bbbs(\varphi)      \label{eq:alg:fol_formula_substitution/quant/renaming}
  \end{empheq}
  where \( n = \sharp(\op*{Free}_\Bbbs(\varphi)) \).
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.substitution.apply_substitution_to_formula} in \cite{notebook:code}.
  \item This substitution is defined as to have the properties listed in \cref{rem:variable_binding_properties}; we elaborate on this in \fullref{thm:alg:fol_formula_substitution}.
\end{comments}

\begin{proposition}\label{thm:alg:fol_formula_substitution}
  \Fullref{alg:fol_formula_substitution} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:alg:fol_formula_substitution/free} For any formula \( \varphi \) and any atomic substitution \( \Bbbs \), we have
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free}
      \op*{Free}( \varphi[\Bbbs] ) = \overbrace{\bigcup_{\mathclap{v \in \op*{Free}(\varphi)}} \op*{Free}(\Bbbs(v))}^{\op*{Free}_\Bbbs(\varphi)}.
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/free_single} For any terms \( \varphi \) and \( \psi \) and any variable \( x \), we have
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free_single}
      \op*{Free}( \varphi[x \mapsto \psi] ) = \begin{cases}
        (\op*{Free}(\varphi) \setminus \set{ x }) \cup \op*{Free}(\psi), &x \in \op*{Free}(\varphi) \\
        \op*{Free}(\varphi),                                             &\T{otherwise.}
      \end{cases}
    \end{equation}

    In both cases,
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free_single/subset}
      \op*{Free}( \varphi[x \mapsto \psi] ) \subseteq (\op*{Free}(\varphi) \setminus \set{ x }) \cup \op*{Free}(\psi).
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/quant_single_rule} For any quantifier formula \( \varphi = \quantifier Q x \psi \) and any substitution \( \Bbbs \), there exists a variable \( v \not\in \op*{Free}_\Bbbs(\varphi) \) such that
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/quant_single_rule}
      \varphi[\Bbbs] = \quantifier Q v \psi[\Bbbs_{x \mapsto v}].
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/substitutions_agree} If the substitutions \( \Bbbs \) and \( \Bbbt \) agree on the free variables of \( \varphi \), then \( M[\Bbbs] = M[\Bbbt] \).

    \thmitem{thm:alg:fol_formula_substitution/noop} We have \( \varphi[\Bbbs] = \varphi \) if and only if the free variables of \( \varphi \) are fixed by the substitution \( \Bbbs \).

    \thmitem{thm:alg:fol_formula_substitution/identity} For any formula \( \varphi \), we have \( \varphi[\id] = \varphi \) for the identity substitution.

    \thmitem{thm:alg:fol_formula_substitution/closed} For any closed formula \( \varphi \) and any atomic substitution \( \Bbbs \), we have \( \varphi[\Bbbs] = \varphi \).

    \thmitem{thm:alg:fol_formula_substitution/composition} Fix a formula \( \varphi \) and two substitutions \( \Bbbs \) and \( \Bbbt \).

    Suppose that, for every variable \( x \) of \( \varphi \), the variables of \( \varphi \) and \( \Bbbs(x) \) are disjoint. Similarly, suppose that, for every variable \( y \) of \( \varphi[\Bbbs] \), the variables of \( \varphi[\Bbbs] \) and \( \Bbbt\Bbbs(y) \) are disjoint. Then
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/composition}
      \varphi[\Bbbt\Bbbs] = \varphi[\Bbbs][\Bbbt].
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:alg:fol_formula_substitution/free} Can be proven as in \cref{thm:lambda_substitution_free_variables}.
  \SubProofOf{thm:alg:fol_formula_substitution/free_single} Follows from \cref{thm:lambda_substitution_free_variables}, similarly to \cref{thm:lambda_substitution_free_variables_single}.
  \SubProofOf{thm:alg:fol_formula_substitution/quant_single_rule} Can be proven as in \cref{thm:lambda_substitution_single_rule}.
  \SubProofOf{thm:alg:fol_formula_substitution/substitutions_agree} Can be proven as in \cref{thm:lambda_substitutions_agree}.
  \SubProofOf{thm:alg:fol_formula_substitution/noop} Can be proven as in \cref{thm:lambda_substitution_noop}.
  \SubProofOf{thm:alg:fol_formula_substitution/identity} Follows from \cref{thm:alg:fol_formula_substitution/noop}.
  \SubProofOf{thm:alg:fol_formula_substitution/closed} Vacuously follows from \cref{thm:lambda_substitution_identity} since combinators simply have no free variables.
  \SubProofOf{thm:alg:fol_formula_substitution/composition} Can be proven as in \cref{thm:lambda_substitution_composition_term_equality}.
\end{proof}

\begin{proposition}\label{thm:fol_formula_semantics_of_compatible_substitutions}
  Fix a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) and \hyperref[def:atomic_fol_substitution]{atomic substitutions} \( \Bbbs \) and \( \Bbbt \). Fix also \hyperref[def:fol_variable_assignment]{variable assignments} \( v \) and \( w \) in some \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \).

  If \( \Bracks{\Bbbs(x)}_\mscrX^v = \Bracks{\Bbbt(x)}_\mscrX^w \) for every \hi{free} variable \( x \) in \( \varphi \), then \( \Bracks{\varphi[\Bbbs]}_\mscrX^v = \Bracks{\varphi[\Bbbt]}_\mscrX^w \).
\end{proposition}
\begin{comments}
  \item An analogous statement holds for terms --- see \cref{thm:fol_term_semantics_of_compatible_substitutions}.
\end{comments}
\begin{proof}
  We will use \fullref{thm:induction_on_rooted_trees} on \( \varphi \), simultaneously on all substitutions and assignments.

  \begin{itemize}
    \item If \( \varphi \) is a propositional constant, there is nothing to show since both substitutions and the denotation is invariant.

    \item If \( \varphi = (\tau \syneq \sigma) \), then
    \begin{equation*}
      \Bracks{\varphi[\Bbbs]}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_substitution/eq}} =
      \delta\parens[\big]{ \Bracks{\tau[\Bbbs]}_\mscrX^v, \Bracks{\sigma[\Bbbs}_\mscrX^v }
      \reloset {\eqref{eq:thm:fol_term_semantics_of_assignment_substitution}} =
      \delta\parens[\big]{ \Bracks{\tau[\Bbbt]}_\mscrX^w, \Bracks{\sigma[\Bbbt]}_\mscrX^w }
      \reloset {\eqref{eq:alg:fol_formula_substitution/eq}} =
      \Bracks{\varphi[\Bbbt]}_\mscrX^w
    \end{equation*}

    \item If \( \varphi = p(\tau_1, \ldots, \tau_n) \), we proceed analogously.

    \item If \( \varphi = \synneg \psi \), where the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Bracks{\varphi[\Bbbs]}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_substitution/neg}} =
      \oline{\Bracks{\psi[\Bbbs]}_\mscrX^v}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi[\Bbbt]}_\mscrX^w}
      \reloset {\eqref{eq:alg:fol_formula_substitution/neg}} =
      \Bracks{\varphi[\Bbbt]}_\mscrX^w
    \end{equation*}

    \item If \( \varphi = \psi \syncirc \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), we proceed similarly.

    \item Suppose that \( \varphi = \quantifier Q x \psi \), where the inductive hypothesis holds for \( \psi \).

    We have two possibilities:
    \begin{itemize}
      \item If \( x \) is not in \( \op*{Free}_\Bbbs(\varphi) \), we must use the direct substitution rule \eqref{eq:alg:fol_formula_substitution/quant/direct}:
      \begin{equation*}
        \varphi[\Bbbs] = \quantifier Q x \psi[\Bbbs_{x \mapsto x}].
      \end{equation*}

      Since \( \op*{Free}_\Bbbs(\varphi) = \op*{Free}_\Bbbt(\varphi) \), we also have
      \begin{equation*}
        \varphi[\Bbbt] = \quantifier Q x \psi[\Bbbt_{x \mapsto y}].
      \end{equation*}

      It remains to show that \( \Bbbs_{x \mapsto x} \) agrees with \( \Bbbt_{x \mapsto x} \) on the free variables of \( \phi \). This is obvious for the variables that are free in \( \varphi \). The only other possibility is \( x \), on which we modify the substitutions. Thus,
      \begin{equation*}
        \Bracks{\varphi[\Bbbs]}_\mscrX^v
        =
        \Bracks{\quantifier Q x \psi[\Bbbs_{x \mapsto x}]}_\mscrX^v
        \reloset {\T{ind.}} =
        \Bracks{\quantifier Q x \psi[\Bbbt_{x \mapsto x}]}_\mscrX^w
        =
        \Bracks{\varphi[\Bbbt]}_\mscrX^w.
      \end{equation*}

      \item If \( x \) is in \( \op*{Free}_\Bbbs(\varphi) \), we use the renaming rule \eqref{eq:alg:fol_formula_substitution/quant/renaming} instead:
      \begin{equation*}
        \varphi[\Bbbs] = \quantifier Q n \psi[\Bbbs_{x \mapsto n}],
      \end{equation*}
      where \( n = \sharp(\op*{Free}_\Bbbs(\varphi)) \).

      Clearly
      \begin{equation*}
        \varphi[\Bbbt] = \quantifier Q n \psi[\Bbbt_{x \mapsto n}].
      \end{equation*}

      Also, since we modify both substitutions at \( x \), the modified substitutions agree on the free variables of \( \psi \), thus
      \begin{equation*}
        \Bracks{\varphi[\Bbbs]}_\mscrX^v
        =
        \Bracks{\quantifier Q n \psi[\Bbbs_{x \mapsto n}]}_\mscrX^v
        \reloset {\T{ind.}} =
        \Bracks{\quantifier Q n \psi[\Bbbt_{x \mapsto n}]}_\mscrX^w
        =
        \Bracks{\varphi[\Bbbt]}_\mscrX^w.
      \end{equation*}
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{corollary}\label{thm:fol_formula_semantics_of_assignment_substitution}
  \Fullref{alg:fol_formula_substitution} and \fullref{alg:fol_assignment_substitution} are compatible for \hi{quantifierless} formulas:
  \begin{equation}\label{eq:thm:fol_formula_semantics_of_assignment_substitution}
    \Bracks{\varphi}_\mscrX^{v[\Bbbs]} = \Bracks{\varphi[\Bbbs]}_\mscrX^v
  \end{equation}
\end{corollary}
\begin{comments}
  \item An analogous statement holds for terms --- see \cref{thm:fol_term_semantics_of_assignment_substitution}.
\end{comments}
\begin{proof}
  Follows from \cref{thm:fol_term_semantics_of_compatible_substitutions} with \( \Bbbt = \id \).
\end{proof}

\begin{remark}\label{rem:fol_exists_unique_abbreviation}
  Based on \hyperref[def:atomic_fol_substitution]{syntactic substitution}, we can introduce the \hyperref[con:description_operator/unique_existence]{unique existence quantifier} \( \qExists x \varphi \) into first-order logic via the \hyperref[con:syntactic_abbreviation]{metalingual abbreviation}
  \begin{equation}\label{eq:rem:fol_formula_conventions/unique_existence}
    \qexists x \parens[\big]{ \varphi \synwedge \qforall y (\varphi[x \mapsto y] \synimplies y \syneq x) },
  \end{equation}
  where \( y = \sharp(\op*{Free}(\varphi) \cup \set{ x }) \).

  Although we allow the function \( \sharp(V) \) to vary in \cref{def:atomic_fol_substitution/sharp}, by default it gives the smallest, with respect to the \hyperref[def:variable_identifier]{identifier order}, variable not in \( V \).
\end{remark}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:fol_formula_alpha_equivalence}\mimprovised
  Based on how we defined \( \alpha \)-equivalence of \hyperref[def:lambda_term]{\( \muplambda \)-terms} in \cref{def:lambda_term_alpha_equivalence}, we will define \term{\( \alpha \)-equivalence} between \hyperref[def:fol_formula]{first-order formulas} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \):

  \columnratio{0.25,0.25,0.5}
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Atom}_\alpha }]{inf:def:fol_formula_alpha_equivalence/atom}
        \begin{prooftree}
          \hypo{ \varphi \in \op*{Atom}_\Sigma }
          \infer1[\ref{inf:def:fol_formula_alpha_equivalence/atom}]{ \varphi \aequiv \varphi }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Neg}_\alpha }]{inf:def:fol_formula_alpha_equivalence/neg}
        \begin{prooftree}
          \hypo{ \varphi \aequiv \psi }
          \infer1[\ref{inf:def:fol_formula_alpha_equivalence/neg}]{ \synneg \varphi \aequiv \synneg \psi }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Conn}_\alpha }]{inf:def:fol_formula_alpha_equivalence/conn}
        \begin{prooftree}
          \hypo{ \varphi_1 \aequiv \psi_1 }
          \hypo{ \varphi_2 \aequiv \psi_1 }
          \hypo{ {\syncirc} \in \op*{Conn} }
          \infer3[\ref{inf:def:fol_formula_alpha_equivalence/conn}]{ (\varphi_1 \syncirc \varphi_2) \aequiv (\psi_1 \syncirc \psi_2) }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
  \columnratio{}

  For quantifiers, we can either use the single rule
  \begin{equation*}\taglabel[\ensuremath{ \logic{Quant}_\alpha }]{inf:def:fol_formula_alpha_equivalence/quant}
    \begin{prooftree}
      \hypo{ Q \in \op*{Quant} }
      \hypo{ \varphi[x \mapsto n] \aequiv \psi[y \mapsto n] \T{for every} n \not\in \op*{Free}(\quantifier Q x \varphi) }
      \infer2[\ref{inf:def:fol_formula_alpha_equivalence/quant}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) }
    \end{prooftree}
  \end{equation*}
  or the following pair of rules based on \cref{thm:alpha_equivalence_simplified}:
  \columnratio{0.325,0.675}
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Lift}_\alpha }]{inf:def:fol_formula_alpha_equivalence/lift}
        \begin{prooftree}[separation=1.1em]
          \hypo{ Q \in \op*{Quant} }
          \hypo{ \varphi \aequiv \psi }
          \infer2[\ref{inf:def:fol_formula_alpha_equivalence/lift}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q x \psi) }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha }]{inf:def:fol_formula_alpha_equivalence/ren}
        \begin{prooftree}[separation=1.1em]
          \hypo{ Q \in \op*{Quant} }
          \hypo{ x \neq y }
          \hypo{ x \not\in \op*{Free}(\psi) }
          \hypo{ \varphi \aequiv \psi[y \mapsto x] }
          \infer4[\ref{inf:def:fol_formula_alpha_equivalence/ren}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
  \columnratio{}
\end{definition}
\begin{comments}
  \item We can prove that the quantifier rules are interchangeable similarly to the case of \( \muplambda \)-terms. In fact, with the properties from \cref{thm:def:fol_formula_alpha_equivalence}, the proof becomes analogous.
\end{comments}

\begin{proposition}\label{thm:def:fol_formula_alpha_equivalence}
  \hyperref[thm:def:fol_formula_alpha_equivalence]{\( \alpha \)-equivalence} of \hyperref[def:fol_formula]{first-order formulas} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_formula_alpha_equivalence/ast} If two formulas are \( \alpha \)-equivalent, their \hyperref[def:fol_formula_ast]{abstract syntax trees} are isomorphic as \hyperref[def:ordered_tree]{ordered trees} and have matching \hyperref[def:predicate_logic_alphabet]{improper} and \hyperref[def:fol_signature]{signature symbols}, but may differ in their variables.

    In particular, they have the same kind, i.e. both are verum, falsum, equality formulas, predicate formulas of same predicate symbol, negation formulas, connective formulas of the same connective or quantifier formulas of the same quantifier.

    \thmitem{thm:def:fol_formula_alpha_equivalence/free} The free variables of \( \alpha \)-equivalent formulas coincide.

    \thmitem{thm:def:fol_formula_alpha_equivalence/quantifier_body_free} If \( (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) \), then
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/abstraction_body_free}
      \op*{Free}(\varphi) \setminus \set{ x } = \op*{Free}(\psi) \setminus \set{ y }.
    \end{equation}

    In particular, \( x \) is free in \( \varphi \) if and only if \( y \) is free in \( \psi \). Unless \( x = y \), however, \( x \) is never free in \( \psi \), nor \( y \) --- in \( \varphi \).

    \thmitem{thm:def:fol_formula_alpha_equivalence/equivalence} \( \alpha \)-equivalence is an \hyperref[def:equivalence_relation]{equivalence relation}.

    \thmitem{thm:def:fol_formula_alpha_equivalence/substitution_composition} For the \hyperref[def:fol_substitution_composition]{composition} \( \Bbbt \Bbbs \) of the \hyperref[def:fol_substitution]{substitutions} \( \Bbbt \Bbbs \), we have
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/composition}
      \varphi[\Bbbt\Bbbs] \aequiv \varphi[\Bbbs][\Bbbt]
    \end{equation}
    for any formula \( \varphi \)

    \thmitem{thm:def:fol_formula_alpha_equivalence/contraction} For every formula \( \varphi \), every term \( \psi \) and any variable \( y \) not in \( \op*{Free}(\varphi) \), we have
    \begin{equation}\label{thm:def:fol_formula_alpha_equivalence/contraction/precomposition}
      \varphi[x \mapsto y][\Bbbs_{y \mapsto \tau}]
      \aequiv
      \varphi[\Bbbs_{x \mapsto \tau}]
    \end{equation}
    and
    \begin{equation}\label{thm:def:fol_formula_alpha_equivalence/contraction/composition}
      \varphi[\Bbbs_{x \mapsto y}][y \mapsto \tau]
      \aequiv
      \varphi[\Bbbs_{x \mapsto \tau}].
    \end{equation}

    \thmitem{thm:def:fol_formula_alpha_equivalence/substitution} If \( \varphi \aequiv \psi \), for any substitution \( \Bbbs \) we have \( \varphi[\Bbbs] \aequiv \psi[\Bbbs] \).

    \thmitem{thm:def:fol_formula_alpha_equivalence/conversion} If \( y \) and \( z \) are not free in \( \varphi \), then
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/conversion}
      \quantifier Q y \varphi[x \mapsto y] \aequiv \quantifier Q z \varphi[x \mapsto z].
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_formula_alpha_equivalence/ast} Trivial.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/free} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/free}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/quantifier_body_free} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/abstraction_body_free}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/equivalence} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/equivalence}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/substitution_composition} Unlike the rest, this one is more subtle and requires a lengthy proof. We handle the interesting cases when dealing with \( \muplambda \)-terms in \cref{thm:nary_lambda_substitution_composition_is_alpha_equivalent}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/contraction} Analogous to \cref{thm:lambda_substitution_chain_contraction}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/substitution} Analogous to \cref{thm:substitution_on_alpha_equivalent_terms}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/conversion} Analogous to \cref{thm:alpha_conversion_modified}.
\end{proof}

\begin{proposition}\label{thm:alpha_equivalent_fol_formulas_are_semantic_equivalent}
  \hyperref[thm:def:fol_formula_alpha_equivalence]{\( \alpha \)-equivalent} \hyperref[def:fol_formula]{first-order formulas} are also \hyperref[def:fol_semantics/equivalence]{semantically equivalent}.
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_recursively_defined_relations} on \( \varphi \aequiv \psi \) to show, simultaneously on all assignments \( v \) in \( \mscrX = (X, I) \), that \( \Bracks{\varphi}_\mscrX^v = \Bracks{\psi}_\mscrX^v \).

  \begin{itemize}
    \item If \( \varphi \aequiv \psi \) due to \ref{inf:def:fol_formula_alpha_equivalence/atom}, then \( \psi = \varphi \), so there is nothing to show.

    \item If \( \varphi \aequiv \psi \) due to \ref{inf:def:fol_formula_alpha_equivalence/neg}, then \( \varphi = \synneg \varphi' \) and \( \psi = \synneg \psi' \), where \( \varphi' \aequiv \psi' \).

    Then
    \begin{equation*}
      \Bracks{\varphi}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/neg}} =
      \oline{\Bracks{\varphi'}_\mscrX^v}
      \reloset{\T{ind.}} =
      \oline{\Bracks{\psi'}_\mscrX^v}
      \reloset {\eqref{eq:alg:fol_formula_denotation/neg}} =
      \Bracks{\psi}_\mscrX^v.
    \end{equation*}

    \item If \( \varphi \aequiv \psi \) due to \ref{inf:def:fol_formula_alpha_equivalence/conn}, we proceed similarly.

    \item Finally, if \( \varphi \aequiv \psi \) due to \ref{inf:def:fol_formula_alpha_equivalence/quant}, then \( \varphi = \quantifier Q x \varphi' \) and \( \psi = \quantifier Q y \psi' \), where we have \( \varphi'[x \mapsto n] \aequiv \psi'[y \mapsto n] \) for every variable \( n \) not free in \( \varphi \).

    In particular, \cref{thm:alg:fol_formula_substitution/noop} implies that \( \varphi'[x \mapsto x] = \varphi' \), so \( \varphi' \aequiv \psi'[y \mapsto x] \).

    If \( Q = \synforall \), the inductive hypothesis gives
    \begin{equation*}
      \Bracks{\varphi}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/forall}} =
      \bigwedge_{a \in X} \Bracks{\varphi'}_\mscrX^{v_{x \mapsto a}}
      \reloset{\T{ind.}} =
      \bigwedge_{a \in X} \Bracks{\psi'[y \mapsto x]}_\mscrX^{v_{x \mapsto a}}.
      \reloset{\ref{thm:fol_formula_semantics_of_compatible_substitutions}} =
      \bigwedge_{a \in X} \Bracks{\psi'}_\mscrX^{v_{y \mapsto a}}.
      \reloset {\eqref{eq:alg:fol_formula_denotation/forall}} =
      \Bracks{\psi}_\mscrX^v
    \end{equation*}

    The case \( Q = \synexists \) is analogous.
  \end{itemize}
\end{proof}

\paragraph{Schemas}

\begin{definition}\label{def:fol_term_schema}\mimprovised
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:fol_term]{first-order terms} as follows:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Small Greek identifier}}, \\
    \bnfprod{term schema}          {\bnfpn{variable placeholder} \bnfor \bnfpn{term placeholder} \bnfor} \\
    \bnfmore                       {\bnfpn{function application schema}},
  \end{bnf*}
  where the rules for \( \bnfpn{function application schema} \) are defined as in \cref{def:fol_term}, where we have a distinct rule for every function symbol in the signature.

  We have also used the variable identifier rules from \cref{def:variable_identifier}.
\end{definition}
\begin{comments}
  \item Term schemas are implemented in \identifier{math.logic.formulas} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:fol_formula_schema}\mimprovised
  We will define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:fol_formula]{first-order formulas} based on \hyperref[def:fol_term_schema]{term schemas} instead of \hyperref[def:fol_term]{terms}. We avoid writing the obvious rules in detail, but there are new important novelties:
  \begin{longbnf*}
    \bnfprod{eigenvariable schema}    {\bnfpn{variable placeholder} \bnfsp \bnftsq{\( \ast \)}} \\
    \bnfprod{formula placeholder}     {\bnfpn{Small Greek identifier}} \\
    \bnfprod{formula schema}          {\bnfpn{formula placeholder} \bnfor \cdots} \\
    \bnfprod{substitution target}    {\bnfpn{term schema} \bnfor \bnfpn{eigenvariable schema}} \\
    \bnfprod{extended formula schema} {\bnfpn{formula schema} \bnfor} \\
    \bnfmore                          {\bnfpn{formula schema} \bnfsp \bnfpn{substitution}}
  \end{longbnf*}

  \begin{itemize}
    \item For the placeholders we have used the identifier rules from \cref{def:variable_identifier}.
    \item For the substitutions we have used the rule from \cref{def:substitution_schema}, with the appropriate variable placeholders and subjects.
  \end{itemize}
\end{definition}
\begin{comments}
  \item Eigenvariables and extended schemas are needed to formalize the established natural deduction rules in \cref{def:fol_natural_deduction}.
  \item Small Greek identifiers are used for both term and formula placeholders, but in practice they do not cause confusion.
  \item First-order formula schemas directly extend their \hyperref[def:propositional_formula_schema]{propositional counterparts}.
  \item Formulas schemas are implemented in \identifier{math.logic.formulas} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:atomic_fol_instantiation}\mimprovised
  We define \hyperref[con:schemas_and_instances]{atomic instantiations} for \hyperref[def:fol_formula_schema]{first-order formula schemas} as \hyperref[def:set_valued_map/partial]{partial maps} \( \BbbI \) sending \hyperref[def:fol_term_schema]{variable placeholders} to \hyperref[def:fol_term]{variables}, \hyperref[def:fol_term_schema]{term placeholders} to \hyperref[def:fol_term]{terms} and \hyperref[def:fol_formula_schema]{formula placeholders} to \hyperref[def:fol_formula]{formulas}.
\end{definition}

\begin{algorithm}[First-order term instantiation]\label{alg:fol_term_schema_instantiation}
  We extend the \hyperref[def:atomic_fol_instantiation]{atomic first-order instantiation} \( \BbbI \) to all \hyperref[def:fol_term_schema]{term schemas} straightforwardly:
  \begin{equation}\label{eq:alg:fol_term_schema_instantiation}
    \Tau[\BbbI] \coloneqq \begin{cases}
      \BbbI(\Tau),                                 &\Tau \T{is a variable placeholder},   \\
      \BbbI(\Tau),                                 &\Tau \T{is a term placeholder},       \\
      f(\Sigma_1[\BbbI], \ldots, \Sigma_n[\BbbI]), &\Tau = f(\Sigma_1, \ldots, \Sigma_n), \\
    \end{cases}
  \end{equation}
\end{algorithm}
\begin{comments}
  \item Of course, an application of an instantiation is only valid if the placeholders are in its domain.
  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_term_schema} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[First-order formula instantiation]\label{alg:fol_formula_schema_instantiation}
  We will extend the \hyperref[def:atomic_fol_instantiation]{atomic first-order instantiation} \( \BbbI \) to all \hyperref[def:fol_formula_schema]{extended formula schemas} with the aid of \fullref{alg:fol_term_schema_instantiation}:
  \begin{equation}\label{eq:alg:fol_formula_schema_instantiation}
    \Phi[\BbbI] \coloneqq \begin{cases}
      \Phi,                                        &\Phi \T{is a propositional constant},             \\
      \BbbI(\Phi),                                 &\Phi \T{is a formula placeholder},                \\
                                                   &\vdots                                            \\
      \quantifier Q {\BbbI(\xi)} \Psi[\BbbI],      &\Phi = \quantifier Q \xi \Psi, Q \in \op*{Quant}, \\
      \Psi[\BbbI][\BbbI(\xi) \mapsto \BbbI(\eta)], &\Phi = \Psi[\xi \synsubst \eta^\ast],             \\
      \Psi[\BbbI][\BbbI(\xi) \mapsto \Tau[\BbbI]], &\Phi = \Psi[\xi \synsubst \Tau] \T{and} \Tau \T{is a term schema.}
    \end{cases}
  \end{equation}

  We have skipped half of the cases because they are obvious. The last two cases are notable because they require using \fullref{alg:fol_formula_substitution}.
\end{algorithm}
\begin{comments}
  \item As in \fullref{alg:lambda_term_schema_instantiation}, we do not distinguish between with free and bound variable schemas.

  \item Eigenvariables do not affect the instantiation itself; they will play an important role in restrict certain constructions when defining proof trees in \cref{def:fol_natural_deduction_proof_tree}.

  \item A variant of this algorithm, in which certain instantiations are considered invalid, is presented in \cref{rem:sequent_calculus_eigenvariables}.

  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_substitution} in \cite{notebook:code}.
\end{comments}

\paragraph{Abstract natural deduction}

\begin{definition}\label{def:fol_natural_deduction_system}\mimprovised
  An \term{abstract first-order natural deduction system} consists of a nonempty collection of \hyperref[def:natural_deduction_rule]{natural deduction rules} for \hyperref[def:fol_formula_schema]{extended first-order formula schemas} over the same \hyperref[def:fol_signature]{signature}. We require the rules to have distinct names, but otherwise impose no restrictions on them.
\end{definition}
\begin{comments}
  \item This definition extends \hyperref[def:propositional_natural_deduction_system]{propositional natural deduction systems}, because the first-order formula schemas are direct generalizations of their propositional counterparts.
\end{comments}

\begin{definition}\label{def:fol_natural_deduction_proof_tree}
  We will extend to \hyperref[def:first_order_logic]{first-order logic} the \hyperref[def:proof_tree]{proof trees} that we defined for propositional logic defined in \cref{def:propositional_natural_deduction_proof_tree}. Fix a \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}.

  In addition to the conclusion, rule name, open assumptions and implicit open premises, we will also need several sets of variables:
  \begin{thmenum}[series=def:fol_natural_deduction_proof_tree]
    \thmitem{def:fol_natural_deduction_proof_tree/eigenvariables} Most importantly, we will associate with every tree a set of variables called \term[ru=собственная переменная (\cite[145]{Герасимов2014Вычислимость}), en=eigenvariable (\cite[\S 5.1.10]{Mimram2020ProgramEqualsProof}); proper variable (\cite[38]{TroelstraSchwichtenberg2000BasicProofTheory})]{eigenvariable}. These are local to the root and are analogues of discharged assumptions.

    These obey some specific restrictions listed below. We try to justify these conditions using similar rules in \cref{rem:dependent_products_and_forall_quantifier_rules} and \cref{rem:sequent_calculus_eigenvariables}.

    \thmitem{def:fol_natural_deduction_proof_tree/open_variables} Dually, we will also need a set of \term{open free variables} of the proof tree. Similarly to the open assumptions, they will be cumulative for the entire tree and not just local to the root.

    Actually, we will need a more elaborate construction --- a function \( F(D, E) \) depending on a set \( D \) of discharged markers and a set \( E \) of discharged eigenvariables. We call \( F(\varnothing, \varnothing) \) \enquote{the} set of open free variables of the tree.

    \thmitem{def:fol_natural_deduction_proof_tree/implicit_variables} Similarly to implicit open premises, we may also have \term{implicit free variables}.
  \end{thmenum}

  Just as with assumption discharging, binding variables is also delicate to handle:
  \begin{thmenum}[resume=def:fol_natural_deduction_proof_tree]
    \thmitem{def:fol_natural_deduction_proof_tree/assumption} An assumption tree for a first-order formula \( \varphi \) with marker \( u \) is defined analogously to the propositional case.
    \begin{thmenum}
      \thmitem{def:fol_natural_deduction_proof_tree/assumption/eigenvariables} There are no eigenvariables.
      \thmitem{def:fol_natural_deduction_proof_tree/assumption/open_variables} The open variables of the tree are the free variables of \( \varphi \). More generally,
      \begin{equation*}
        F(D, E) \coloneqq \begin{cases}
          \varnothing,                     &u \in D, \\
          \op*{Free}(\varphi) \setminus E, &\T{otherwise.}
        \end{cases}
      \end{equation*}

      \thmitem{def:fol_natural_deduction_proof_tree/assumption/implicit_variables} There are no implicit variables.
    \end{thmenum}

    \thmitem{def:fol_natural_deduction_proof_tree/application} A rule application tree operates similarly to its propositional counterpart, but binding open variables has some important caveats.

    Consider the rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Phi_1 }
        \hypo{ \cdots }

        \hypo{ [\Theta_{k,1}] }
        \hypo{ \cdots }
        \hypo{ [\Theta_{k,m_k}] }
        \infer[dashed]3{ \Phi_k }

        \hypo{ \cdots }
        \hypo{ \Phi_n }
        \infer[left label={\( [\Omega_1] \cdots [\Omega_m] \)}]5[\logic{R}]{ \Psi }
      \end{prooftree}
    \end{equation*}

    Fix an \hyperref[def:atomic_fol_instantiation]{atomic schema instantiation} \( \BbbI \) and a list \( (P_1, \ldots, P_n) \) of proof trees such that, for \( i = 1, \ldots, n \), the conclusion of \( P_k \) is \( \Phi_k[\BbbI] \). As in the propositional case, for a suitable choice \( d \) of dischargeable assumptions, we have a unique rule application tree \( P_d \).

    Describing the eigenvariables of \( P_d \) requires additional coherence conditions. They are enforced programmatically in the function \identifier{math.logic.deduction.proof_tree.apply} in \cite{notebook:code}:
    \begin{thmenum}[series=def:fol_natural_deduction_proof_tree/application]
      \thmitem{def:fol_natural_deduction_proof_tree/application/main} If the rule premise \( \Phi_k \) has a substitution schema with an eigenvariable, then \( \Phi_k = \Lambda[\xi \synsubst \eta^*] \) for some formula schema \( \Lambda \) and variable placeholders \( \xi \) and \( \eta \). For convenience, denote \( \BbbI(\xi) \) and \( \BbbI(\eta) \) by \( x \) and \( y \).

      We impose the following restrictions:
      \begin{thmenum}
        \thmitem{def:fol_natural_deduction_proof_tree/application/main/variable} Either \( y \) must coincide with \( x \) or otherwise \( y \) must not be free in \( \Lambda[\BbbI] \) (the unsubstituted conclusion of \( P_k \)).

        \thmitem{def:fol_natural_deduction_proof_tree/application/main/conclusion} The variable \( y \) must not be free in \( \Psi[\BbbI] \) (the conclusion of the entire application).

        This condition will automatically be satisfied for the only rule, \ref{inf:def:fol_natural_deduction/exists/intro}, in which we will have such a situation. We list the condition here only for completeness, since a similar condition is listed in the other case below.

        \thmitem{def:fol_natural_deduction_proof_tree/application/main/assumptions} Additionally, \( y \) must not be open in \( P_k \).
      \end{thmenum}

      \thmitem{def:fol_natural_deduction_proof_tree/application/attached} If the premise \( \Phi_k \) has a dischargeable schema \( \Theta_{k,i} \) attached, and if \( \Theta_{k,i} \) has a substitution schema with an eigenvariable, then, as above, \( \Theta_{k,i} = \Lambda[\xi \synsubst \eta^*] \). Again, denote \( \BbbI(\xi) \) and \( \BbbI(\eta) \) by \( x \) and \( y \).

      It is possible that there is no dischargeable assumption. If \( [\varphi[x \mapsto y]]^u \) is an open assumption in \( P_k \) and \( \varphi[x \mapsto y] = \Theta_{k,i}[\BbbI] \), we impose the following restrictions:
      \begin{thmenum}
        \thmitem{def:fol_natural_deduction_proof_tree/application/attached/variable} Either \( y \) must coincide with \( x \) or otherwise \( y \) must not be free in \( \varphi = \Lambda[\BbbI] \) (the unsubstituted dischargeable premise).

        \thmitem{def:fol_natural_deduction_proof_tree/application/attached/conclusion} The variable \( y \) must not be free in \( \Phi_k[\BbbI] \) (the conclusion of \( P_k \)).

        \thmitem{def:fol_natural_deduction_proof_tree/application/attached/assumptions} Additionally, \( y \) must not be open in \( P_k \), except possibly in \( \varphi[x \mapsto y] = \Theta_{k,i}[\BbbI] \) (the substituted dischargeable premise).

        More precisely, \( y \) must not belong to \( F_k(\set{ u }, \varnothing) \), where \( F_k(D, E) \) is the parameterized set of open variable of \( P_k \).

        Note that the previous condition forbids \( y \) to be free in \( \varphi \) if \( \varphi \) is the conclusion of \( P_k \).
      \end{thmenum}
    \end{thmenum}

    It remains to describe the set of open free variables in the application tree \( P_d \):
    \begin{thmenum}[resume=def:fol_natural_deduction_proof_tree/application]
      \thmitem{def:fol_natural_deduction_proof_tree/application/eigenvariables} If either \cref{def:fol_natural_deduction_proof_tree/application/main} or \cref{def:fol_natural_deduction_proof_tree/application/attached} are satisfied, we proclaim \( y \) an eigenvariable.

      We denote the set of all eigenvariables of \( P_d \) by \( E_d \).

      \thmitem{def:fol_natural_deduction_proof_tree/application/open_variables} We will now utilize the set \( I_d \) of implicit open premises and the set \( D_d \) of discharged assumption markers.

      Denote by \( F_k(D, E) \) the open variable function of the premise subtree \( P_k \). For \( P_d \) itself, we define the corresponding function as follows:
      \begin{equation*}
        F_d(D, E) \coloneqq \bigcup_{k=1}^n F_k(D \cup D_d, E \cup E_d) \cup \parens{ \bigcup_{\varphi \in I_d} \op*{Free}(\varphi) \setminus (E \cup E_d) }.
      \end{equation*}

      Thus, have taken the union of all open variables of the subtrees and all free variables of the implicit premises, excluding those discharged at the current application.

      \thmitem{def:fol_natural_deduction_proof_tree/application/implicit_variables} If the conclusion schema features a substitution, i.e. if \( \Psi = \Lambda[\xi \mapsto \Tau] \), let the set of implicit free variables be the set of variables of the term \( \Tau[\BbbI] \). Otherwise, let \( C_d \) be the empty set.
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The handling of eigenvariables is needed to formalize the established natural deduction rules in \cref{def:fol_natural_deduction}.

  Their treatment is generalized from the two quantifier rules discussed in detail in \cite[\S 2.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

  In addition to allowing us to prove \fullref{thm:fol_natural_deduction_soundness}, our construction satisfies some coherence properties in \cref{thm:def:fol_natural_deduction_proof_tree}.

  \item Even though we do not disallow eigenvariables in the conclusion, they would be treated the same as regular variables.

  \item Implicit variables are not an established concept. Placing restrictions on them allows us to mitigate some debatable proof trees --- see \cref{rem:fol_empty_universe/natural_deduction} for a broader discussion.

  \item The term \enquote{eigenvariable} comes from \tcite{#2, where #1}{Gentzen1935LogischeSchließen} introduces natural deduction. In the corresponding English translation, \cite[293]{Gentzen1964LogicalDeduction}, eigenvariables are instead called \enquote{proper variables}. Both terms are currently used in English (e.g. \incite[\S 5.1.10]{Mimram2020ProgramEqualsProof} uses \enquote{eigenvariable}, while \incite[38]{TroelstraSchwichtenberg2000BasicProofTheory} uses \enquote{proper variable}).

  Gentzen presents only two rules featuring eigenvariables, in which the variables must satisfy slightly differing constraints. We restate Gentzen's rules in \cref{def:fol_natural_deduction} and adapt them for \hyperref[def:higher_order_logic]{higher-order logic} in \cref{def:hol_quantifier_rules/eigenvariables}.

  \item Natural deduction proof trees are implemented in the module \identifier{math.logic.deduction.proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:def:fol_natural_deduction_proof_tree}
  \hyperref[def:fol_natural_deduction_proof_tree]{First-order natural deduction trees} have the following properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_natural_deduction_proof_tree/open_var_antitone} The parameterized set \( F(D, E) \) of open variables in a tree \( P \) is antitone both arguments. That is, if \( D' \subseteq D \), then \( F(D, E) \subseteq F(D', E) \), and similarly for its second argument.

    \thmitem{thm:def:fol_natural_deduction_proof_tree/open_var_no_eigen} The set \( F(\varnothing, E) \) contains no variables from \( E \).

    \thmitem{thm:def:fol_natural_deduction_proof_tree/open_var_no_discharge} If among the open assumptions of \( P \), the variable \( v \) occurs in \( [\varphi_1]^{u_1}, \ldots, [\varphi_n]^{u_n} \), then \( v \) is not in \( F(\set{ u_1, \ldots, u_n }, \varnothing) \).

    \thmitem{thm:def:fol_natural_deduction_proof_tree/not_open_var} If the variable \( v \) is \hi{not} in \( F(D, \varnothing) \), it is not free in any open assumption of \( P \) except those with markers in \( D \).

    If \( D = \varnothing \), this amounts to saying that if \( v \) is not open in \( P \), it is not free in any open assumption of \( P \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_natural_deduction_proof_tree/open_var_antitone} Trivial.
  \SubProofOf{thm:def:fol_natural_deduction_proof_tree/open_var_no_eigen} Trivial.
  \SubProofOf{thm:def:fol_natural_deduction_proof_tree/open_var_no_discharge} Trivial.
  \SubProofOf{thm:def:fol_natural_deduction_proof_tree/not_open_var} We will use \fullref{thm:induction_on_rooted_trees} on \( P \).
  \begin{itemize}
    \item If \( P \) is an assumption tree for \( [\varphi]^u \), the open variables are precisely the free variables of \( \varphi \), and the only assumption of \( P \) is \( [\varphi]^u \).

    Hence, if a variable \( v \) is not in \( F(D, \varnothing) \), there are two cases:
    \begin{itemize}
      \item If \( u \) is in \( D \), then \( F(D, \varnothing) = \varnothing \), so \( v \) is unrestricted.
      \item Otherwise \( F(D, \varnothing) = \op*{Free}(\varphi) \), so \( v \) is not free in the only assumption \( \varphi \) of \( P \).
    \end{itemize}

    \item Suppose that \( P = P_d \) is a rule application tree and that the inductive hypothesis holds for its premises \( P_1, \ldots, P_n \).

    If a variable \( v \) is not in \( F_d(D, \varnothing) \), it is by definition not in the set \( F_k(D \cup D_d, E_d) \) for \( k = 1, \ldots, n \). Here \( D_d \) are the markers of formulas discharged in \( P_d \), while \( E_d \) are the eigenvariables discharged in \( P_d \).

    \Cref{thm:def:fol_natural_deduction_proof_tree/open_var_antitone} implies that \( F_k(D \cup D_d, E_d) \subseteq F_k(D \cup D_d, \varnothing) \). We can apply the inductive hypothesis to the latter to conclude that, if \( v \) is not in \( F_k(D \cup D_d, E_d) \), it is not free in any open assumption of \( P_k \) except those whose marker is in \( D \cup D_d \).

    Generalizing on \( k \), and accounting for the discharged assumptions in \( P \), we conclude that it is not open in any open assumption of \( P_d \) itself, with the exception of those in \( D \).
  \end{itemize}
\end{proof}

\begin{definition}\label{def:fol_natural_deduction_consequence}\mimprovised
  For every \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}, we define a \hyperref[def:consequence_relation]{consequence relation} as follows: we let \( \Gamma \vdash \varphi \) if there exists a \hyperref[def:fol_natural_deduction_proof_tree]{proof tree} with conclusion \( \varphi \) whose \hyperref[def:propositional_natural_deduction_proof_tree/open_assumptions]{open assumptions} are all in \( \Gamma \). Note that \( \varphi \), as well as all formulas in \( \Gamma \), are implicitly assumed to be closed.

  We may write \( \Gamma \vdash_\Sigma \varphi \) to highlight that all formulas in the proof tree are over the same \hyperref[def:fol_signature]{signature} \( \Sigma \).

  In accordance with \cref{def:general_logic}, we say that \( \varphi \) is \term{derivable} from \( \Gamma \) if this relation holds.
\end{definition}
\begin{defproof}
  We can prove that \( {\vdash} \) is indeed a consequence relation in complete analogy with the propositional case --- see \cref{def:propositional_natural_deduction_consequence}.
\end{defproof}

\begin{proposition}\label{thm:fol_natural_deduction_derivation_compact}
  Every \hyperref[def:fol_natural_deduction_consequence]{natural deduction entailment relation} is \hyperref[def:consequence_relation/compactness]{compact}.
\end{proposition}
\begin{comments}
  \item This is one of several compactness theorems presented here --- see \cref{rem:logical_compactness_theorems}.
\end{comments}
\begin{proof}
  A proof tree is can have at most finitely many assumptions.
\end{proof}

\begin{algorithm}[Propositional proof tree translation]\label{alg:fol_propositional_proof_tree_translation}
  Fix an \hyperref[def:atomic_fol_propositional_formula_translation]{atomic translation} \( \Bbbt \) of \hyperref[def:propositional_formula]{propositional formulas} into \hyperref[def:fol_formula]{first-order formulas}.

  Fix also a \hyperref[def:propositional_natural_deduction_system]{propositional natural deduction system}. \hyperref[def:propositional_formula_schema]{Propositional schemas} are valid \hyperref[def:fol_formula_schema]{first-order schemas}, so we can regard it as a \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}.

  Let \( P \) be a \hyperref[def:propositional_natural_deduction_proof_tree]{propositional proof tree} in this system. Assuming \( \Bbbt \) is defined for the formulas in \( P \), we can recursively translate \( P \) into a \hyperref[def:fol_natural_deduction_proof_tree]{first-order proof tree} \( P[\Bbbt] \) as follows:
  \begin{thmenum}
    \thmitem{alg:fol_propositional_proof_tree_translation/assumption} If \( P \) is an assumption tree for \( \varphi \) with marker \( u \), let \( P[\Bbbt] \) be an assumption tree for \( \varphi[\Bbbt] \) with the same marker.

    \thmitem{alg:fol_propositional_proof_tree_translation/application} Otherwise, \( P \) is an application tree for some rule \( \logic{R} \).

    Let \( \BbbI \) be the \hyperref[def:atomic_propositional_instantiation]{propositional schema instantiation} used in \( P \), and let \( \BbbI[\Bbbt] \) be the \hyperref[def:atomic_fol_instantiation]{first-order schema instantiation} that maps every formula placeholder \( \Phi \) to \( \BbbI(\Phi)[\Bbbt] \). There are no variable nor term placeholders in the propositional schemas.

    Let \( d \) be the \hyperref[def:propositional_natural_deduction_proof_tree/application/dischargeable]{dischargeable assumption choice} used in \( P \), and let \( d[\Bbbt] \) be the choice function for first-order assumptions with the same markers.

    Finally, let \( P_1, \ldots, P_n \) be the premise subtrees of \( P \). We define \( P[\Bbbt] \) as an application of \( \logic{R} \), with \( P_1[\BbbT], \ldots, P_n[\BbbT] \) as premises, with \( \BbbI[\Bbbt] \) as an instantiation and with \( d[\Bbbt] \) as a choice of dischargeable assumptions.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item We will use this algorithm to show compatibility of propositional and first-order derivation relations in \cref{thm:fol_propositional_formula_translation_entailment}.

  \item This algorithm can be found as \identifier{math.logic.propositional.apply_prop_proof_tree_translation} in \cite{notebook:code}.
\end{comments}

\paragraph{Concrete natural deduction}

\begin{definition}\label{def:fol_natural_deduction}\mimprovised
  We will now extend the rules for minimal, intuitionistic and classical systems for propositional natural deduction from \cref{def:propositional_natural_deduction}.

  \begin{thmenum}
    \thmitem{def:fol_natural_deduction/equality} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ =_+ }]{inf:def:fol_natural_deduction/equality/intro}
          \begin{prooftree}
            \infer0[\ref{inf:def:fol_natural_deduction/equality/intro}]{ \syn\tau \syneq \syn\tau }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ =_- }]{inf:def:fol_natural_deduction/equality/elim}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syn\tau] }
            \hypo{ \syn\tau \syneq \syn\sigma }
            \infer2[\ref{inf:def:hol_equality_rules/elim}]{ \syn\varphi[\synx \synsubst \syn\sigma] }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:fol_natural_deduction/forall}\mcite[36]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \forall_+ }]{inf:def:fol_natural_deduction/forall/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syny^*] }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall \synx \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \forall_- }]{inf:def:fol_natural_deduction/forall/elim}
          \begin{prooftree}
            \hypo{ \qforall \synx \syn\varphi }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ \syn\varphi[\synx \synsubst \syn\tau] }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:fol_natural_deduction/exists}\mcite[36]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \exists_+ }]{inf:def:fol_natural_deduction/exists/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syn\tau] }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists \synx \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \exists_- }]{inf:def:fol_natural_deduction/exists/elim}
          \begin{prooftree}
            \hypo{ \qexists \synx \syn\varphi }

            \hypo{ \syn\varphi[\synx \mapsto \syny^*] }
            \infer[dashed]1{ \syn\psi }

            \infer2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The quantifier rules are justified by rules for dependent types via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}; see \cref{rem:dependent_products_and_forall_quantifier_rules}.

  \item The two equality rules are more concise and flexible, but less explicit than those from \cref{thm:fol_natural_deduction_equality}.

  \item These precise rules are used in the module \identifier{logic.classical_logic} in \cite{notebook:code}.
\end{comments}

\begin{example}\label{ex:def:fol_natural_deduction}
  We list examples of the natural deduction rules from \cref{def:fol_natural_deduction}:
  \begin{thmenum}
    \thmitem{ex:def:fol_natural_deduction/verum} We can build the following simple proof trees via the quantifier rules:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:propositional_natural_deduction/top/intro}]{ \syntop }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall \synx \syntop }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:propositional_natural_deduction/top/intro}]{ \syntop }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists \synx \syntop }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    There are no free variables involved, so the eigenvariable conditions are satisfied vacuously.

    \thmitem{ex:def:fol_natural_deduction/reintroduction} The following tree, which reintroduces \( \synforall \), is slightly more complicated:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(y) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall x p(x) }
      \end{prooftree}
    \end{equation*}

    Here \( y \) is an eigenvariable. It cannot occur freely in the derivation of \( p(y) \). This condition is satisfied since we start with a closed formula. Note that \( y \) can be any variable, including \( x \).

    \thmitem{ex:def:fol_natural_deduction/forall_to_exists} Somewhat similarly, we can introduce \( \synexists \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(\tau) }
        \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }
      \end{prooftree}
    \end{equation*}

    Neither rule supports eigenvariables, so the application is straightforward. Here \( \tau \) can be an arbitrary term.

    This derivation is sound only if there is something to quantify over. We discuss this in \cref{rem:fol_empty_universe/natural_deduction}.

    \thmitem{ex:def:fol_natural_deduction/implicit_premise} Without implicit premises, the free variables of the following proof trees would differ:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [p(x) \synvee p(y)]^u }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [p(x)]^u }
            \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_left}]{ p(x) \synvee p(y) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    In the first case, the free variables would be \( x \) and \( y \), while in the second \( y \) would be ignored.

    \thmitem{ex:def:fol_natural_deduction/exists_elimination} Consider the following proof tree:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qexists x p(x)]^u }
        \hypo{ [\qforall x (p(x) \synimplies q(z))]^v }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(y) \synimplies q(z) }
        \hypo{ [p(y)]^w }
        \infer2[\ref{inf:def:propositional_natural_deduction/imp/elim}]{ q(z) }
        \infer[left label=\( w \)]2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ q(z) }
      \end{prooftree}
    \end{equation*}

    In short, we simply replaced the assumption \( [p(y)]^w \) with the weaker \( [\qexists x p(x)]^u \).

    Here we renamed \( x \) to \( y \) when eliminating \( \synforall \). Then we matched the two instances of \( p(y) \) and used conditional connective elimination. This allowed us to derive \( q(z) \) from \( p(y) \), thus also enabling us to eliminate \( p(y) \) due to \cref{def:fol_natural_deduction_proof_tree/application/attached/assumptions}.

    Compared to the above, the following proof tree is not valid:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qexists x p(x)]^u }
        \hypo{ [p(y)]^v }
        \infer[left label=\( v \)]2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ p(y) }
      \end{prooftree}
    \end{equation*}

    The problem here is that \( p(y) \) is the conclusion of the subtree, and this falls into the case \cref{def:fol_natural_deduction_proof_tree/application/attached/conclusion}.

    \thmitem{ex:def:fol_natural_deduction/quantifier_duality}\mcite[example 2.1.4]{TroelstraSchwichtenberg2000BasicProofTheory} Via \fullref{thm:fol_semantic_deduction_theorem}, we can restate a special case of \eqref{thm:fol_quantifier_duality} as
    \begin{equation*}
      \synneg \qforall x \synneg p(x) \synimplies \qexists x p(x).
    \end{equation*}

    We can build a proof tree for this as follows:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\synneg \qforall x \synneg p(x)]^u }

        \hypo{ [\synneg \qexists x p(x)]^v }

        \hypo{ [p(x)]^w }
        \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }

        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
        \infer[left label=\( w \)]1[\ref{inf:def:propositional_natural_deduction/neg/intro}]{ \synneg p(x) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall x \synneg p(x) }
        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
        \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction/bot/raa}]{ \qexists x p(x) }

        \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \synneg \qforall x \synneg p(x) \synimplies \qexists x p(x) }
      \end{prooftree}
    \end{equation*}

    The introduction rule for \( \synforall \) is applicable because at that point \( x \) is no longer free in any open assumption --- even though it was initially free in \( [p(x)]^w \), this assumption was discharged.
  \end{thmenum}
\end{example}
\begin{comments}
  \item Many of these examples are verified programmatically in the module \identifier{math.logic.deduction.test_proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:dependent_products_and_forall_quantifier_rules}
  We will show how the universal quantifier introduction rule \ref{inf:def:fol_natural_deduction/forall/intro} corresponds, via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, to the introduction rule \ref{inf:def:dependent_product/intro} for \hyperref[def:dependent_product]{dependent products}.

  Generally, in \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}, we must be careful not to allow \hyperref[def:mltt_well_formed_context/derivation]{ill-formed derivations}. There can be situations where an assumption \( x: \tau \) cannot be discharged because the types of other open assumptions depend on \( x \).

  We will restate the rule here with some types renamed:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ x: \tau }
      \infer[dashed]1{ M: \varphi }
      \infer1[\ensuremath{ \Pi_+' }]{ \qabs {x^\tau} M: \qprod {x^\tau} \varphi }
    \end{prooftree}
  \end{equation*}

  We are only interested in the existence of the terms \( M \) and \( \qabs {x^\tau} M \), but not in the terms themselves. So we may rewrite the above to resemble a natural deduction rule (with \( \synforall \) used instead of \( \synprod \)):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ x: \tau }
      \infer[dashed]1{ \varphi }
      \infer1[\ensuremath{ \forall_+' }]{ \qforall {x^\tau} \varphi }
    \end{prooftree}
  \end{equation*}

  We showed in \cref{ex:def:mltt_well_formed_context/discharging} how, if some open assumption of a type derivation tree depends on \( x \), applying the rule and discharging \( x: \tau \) will make the derivation ill-formed.

  For the purposes of predicate logic, it will suffice, instead of dealing with explicit type contexts, we instead enforce the constraints given in \cref{def:fol_natural_deduction_proof_tree/application/main}.

  It is important here to note that \( \qforall x \varphi \) and \( \qforall y \varphi[x \mapsto y] \) are considered different formulas. This contrasts with Martin-L\"of type theory, where, due to the rule \ref{rem:type_theory_rule_classification/equality/alpha}, \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent} \( \muplambda \)-terms are assumed to be \hyperref[con:equality]{judgmentally equal}. Making \( \alpha \)-conversion explicit leads to \ref{inf:def:fol_natural_deduction/forall/intro} .
\end{remark}

\begin{remark}\label{rem:fol_empty_universe/natural_deduction}
  We discussed in \cref{rem:fol_empty_universe/semantics} how a \hyperref[def:fol_structure]{first-order structure} with an empty universe may cause issues with semantical concepts.

  As similar issue can be observed in the derivation tree from \cref{ex:def:fol_natural_deduction/forall_to_exists}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\qforall x p(x)]^u }
      \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(\tau) }
      \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }
    \end{prooftree}
  \end{equation*}

  This derivation is not sound in an empty universe where nothing exists. Nevertheless, the standard treatment of natural deduction ignores this issue --- starting from Gentzen's \cite[186]{Gentzen1935LogischeSchließen}, and including \cite[ch. 2]{TroelstraSchwichtenberg2000BasicProofTheory}, \cite[\S 2.8]{VanDalen2004LogicAndStructure} and \cite[97]{КолмогоровДрагалин2006Логика}.

  There are some ad-hoc ways to prevent the above rule applications:
  \begin{thmenum}
    \thmitem{rem:fol_empty_universe/restricted_implicit} We may require all \hyperref[def:fol_natural_deduction_proof_tree/implicit_variables]{implicit free variables} to belong to the existing \hyperref[def:fol_natural_deduction_proof_tree/open_variables]{open free variables}. This would affect the rule \ref{inf:def:fol_natural_deduction/forall/elim}. It would be possible to derive \( \varphi[x \mapsto \tau] \) from \( \qforall x \varphi \), but only if the free variables of \( \tau \) are open in the proof tree.

    In our example, the proof tree has no variables open, thus \( \tau \) must use constants rather than variables. But if the signature has an individual constant, its domain cannot be empty. If, on the other hand, the domain is empty, the rule becomes inapplicable.

    On the other hand, this restriction would prevent the following sound proof:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(y) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall z p(z) }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:fol_empty_universe/non_eigenvariable} An alternative is suggested by \incite[\S 5.1.10]{Mimram2020ProgramEqualsProof}. He suggests keeping an explicit \hyperref[def:logical_context]{context} of variables that are allowed to be used in term substitutions (i.e. in \( \tau \) in \ref{inf:def:fol_natural_deduction/forall/elim} and \ref{inf:def:fol_natural_deduction/exists/intro}). Discharging an eigenvariable removes it from this context.

    Our example becomes
    \begin{equation*}
      \begin{prooftree}
        \hypo{ x &\given\enspace [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ x &\given\enspace p(x) }
        \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ x &\given\enspace \qexists x p(x) }
      \end{prooftree}
    \end{equation*}

    If we disallow derivations ending with a nonempty variable context, this proof becomes invalid. On the other hand, the following is valid:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ y &\given\enspace [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ y &\given\enspace p(y) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ &\given\enspace \qexists z p(z) }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{remark}

\begin{remark}\label{rem:sequent_calculus_eigenvariables}
  \incite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory} give the following \hyperref[def:sequent_calculus_rule]{sequent calculus rule} for \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifiers}:
  \begin{equation*}\taglabel[\ensuremath{ \forall_R }]{inf:rem:sequent_calculus_eigenvariables/forall_right}
    \begin{prooftree}
      \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi[\synx \synsubst \syny^*] }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \syn\Gamma \synvdash \syn\Delta, \qforall \synx \syn\varphi }
    \end{prooftree}
  \end{equation*}

  We have reused the extended first-order formula schemas from \cref{def:fol_formula_schema}. Instantiation could be done via \fullref{alg:fol_formula_schema_instantiation}, however the rule features an eigenvariable schema \( \syny^* \). The authors give a side condition for eigenvariables to not be free in the rule's conclusion.

  Rather than introducing all the machinery for variable binding from \cref{def:fol_natural_deduction_proof_tree}, we could modify \fullref{alg:fol_formula_schema_instantiation}. For this, we package an atomic instantiation \( \BbbI \) and a set \( E \) of eigenvariables into \( \BbbE = (\BbbI, E) \), and restrict the algorithm based on \( E \):
  \begin{thmenum}
    \thmitem{rem:sequent_calculus_eigenvariables/atomic} If \( \Phi \) is an atomic schema, we define \( \Phi[\BbbI, E] \) as \( \Phi[\BbbI] \), but let it fail if some of the free variables of \( \Phi[\BbbI] \) are in \( E \).

    This condition ensures that no eigenvariable can occur free.

    \thmitem{rem:sequent_calculus_eigenvariables/quantifier} If \( \Phi = \quantifier Q \xi \Psi \) for a quantifier \( Q \), we define \( \Phi[\BbbI, E] \) as
    \begin{equation*}
      \quantifier Q {\BbbI(\xi)} \Psi[\BbbI, E \setminus \set{\BbbI(\xi)}].
    \end{equation*}

    Thus, we allow bound occurrences of eigenvariables.

    \thmitem{rem:sequent_calculus_eigenvariables/eigen} If \( \Phi = \Psi[\xi \synsubst \eta^\ast] \), we define \( \Phi[\BbbI, E] \) as
    \begin{equation*}
      \Psi[\BbbI, E \setminus \set{\BbbI(\eta)}][\BbbI(\xi) \mapsto \BbbI(\eta)],
    \end{equation*}
    but let it fail if \( \BbbI(\eta) \) is \hi{not} in \( E \).

    This ensures that all eigenvariables must be in \( E \). The reason we remove \( \BbbI(\eta) \) from \( \Psi \) it to allow the case where \( \BbbI(\xi) \) and \( \BbbI(\eta) \) coincide.

    If \( \Psi \) occurs elsewhere in the rule, its instantiation will fail unless it is within the scope of a quantifier or an eigenvariable substitution.

    \thmitem{rem:sequent_calculus_eigenvariables/other} In all other cases, we recurse into subformulas as in the unmodified algorithm.
  \end{thmenum}

  We will give an example based on the proof of \fullref{thm:propositional_semantic_lem} in \cref{ex:def:classical_propositional_sequent_calculus/lem}. Suppose the signature contains a unary predicate \( \synp \) and consider the invalid derivation
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \synp(\syny) \synvdash \synp(\syny) }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \synp(\syny) \synvdash \qforall \syny \synp(\syny) }
    \end{prooftree}
  \end{equation*}

  In an extended atomic instantiation \( \BbbE = (\BbbI, E) \), \( \BbbI \) must send the formula placeholder \( \syn\varphi \) to \( \synp(\synx) \) and both variable placeholders \( \synx \) and \( \syny \) to their eponymous variables. However, we have conflicting restrictions:
  \begin{itemize}
    \item In its first occurrence, due to \ref{rem:sequent_calculus_eigenvariables/atomic}, \( \synp(\syny) \) requires \( \syny \) to \hi{not} be in \( E \).
    \item In its second occurrence, due to \ref{rem:sequent_calculus_eigenvariables/eigen}, \( \synp(\syny) = \synp(\synx)[\synx \mapsto \syny] \) requires \( \syny \) to be in \( E \).
  \end{itemize}

  Thus, the above application fails. So does the following:
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \synp(\syny) \synvdash \synp(\syny) }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \synvdash \synp(\syny), \synneg \synp(\syny) }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \synvdash \synp(\syny), \qforall \synx \synneg \synp(\synx)) }
    \end{prooftree}
  \end{equation*}

  The problem in the final condition here is again due to a conflict of the two conditions.

  The following is valid, however:
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \synp(\syny) \synvdash \synp(\syny) }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \synvdash \synp(\syny), \synneg \synp(\syny) }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \synvdash \synp(\syny) \synvee \synneg \synp(\syny) }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \synvdash \qforall \synx (\synp(\synx) \synvee \synneg \synp(\synx)) }
    \end{prooftree}
  \end{equation*}

  In the final application, \( \BbbI \) maps the formula placeholder \( \syn\varphi \) to \( \synp(\synx) \synvee \synneg \synp(\synx) \) and the variable placeholders \( \synx \) and \( \syny \) to the eponymous variables.

  Not only do the above conditions not conflict with each other, but \( \BbbI \) could even map \( \synx \) to \( \syny \) because \ref{rem:sequent_calculus_eigenvariables/quantifier} allows eigenvariables as bound variables.
\end{remark}

\begin{proposition}\label{thm:fol_propositional_formula_translation_derivation}
  Fix an \hyperref[def:atomic_fol_propositional_formula_translation]{atomic translation} \( \Bbbt \) of \hyperref[def:propositional_formula]{propositional formulas} into \hyperref[def:fol_formula]{first-order formulas}.

  If the set \( \Gamma \) of \hyperref[def:propositional_natural_deduction]{propositional formulas} derives \( \varphi \) via \hyperref[def:propositional_natural_deduction_consequence]{propositional natural deduction}, then the \hyperref[def:fol_quantifier_closure]{universal closures} \( \cl_\forall \Gamma[\Bbbt] \) of the formulas translated via \fullref{alg:fol_propositional_formula_translation} derive \( \cl_\forall \varphi[\Bbbt] \) via \hyperref[def:fol_natural_deduction]{first-order natural deduction}.
\end{proposition}
\begin{comments}
  \item This is the syntactic counterpart to \cref{thm:fol_propositional_formula_translation_entailment}.
\end{comments}
\begin{proof}
  Fix a propositional proof tree \( P \) with consequence \( \varphi \) whose open assumptions are in \( \Gamma \).

  \Fullref{alg:fol_propositional_proof_tree_translation} gives us a first-order proof tree \( P[\Bbbt] \) deriving \( \varphi[\Bbbt] \) from \( \Gamma[\Bbbt] \). Denote by \( R \) the tree obtained from \( P[\Bbbt] \) in which we replace every assumption
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\psi[\Bbbt]]^u }
    \end{prooftree}
  \end{equation*}
  with
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\qforall {x_1} \qforall {x_2} \cdots \qforall {x_n} \psi[\Bbbt]]^u }
      \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ \qforall {x_2} \cdots \qforall {x_n} \psi[\Bbbt] }
      \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ }
      \ellipsis {} {}
      \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ \psi[\Bbbt] }
    \end{prooftree}
  \end{equation*}

  It derives \( \varphi[\Bbbt] \) from \( \cl_\forall \Gamma[\Bbbt] \). It remains to add to \( R \) all free variables of \( \varphi \) via repeated applications of \ref{inf:def:fol_natural_deduction/forall/intro}. The eigenvariable conditions are trivially satisfied since \( R \) has no open variables.
\end{proof}

\begin{proposition}\label{thm:fol_natural_deduction_equality}
  In \hyperref[def:fol_natural_deduction]{minimal first-order natural deduction}, equality acts like an \hyperref[def:fol_congruence]{congruence}. More precisely, the following rules are \hyperref[con:inference_rule_admissibility]{admissible}:

  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ =_R }]{inf:thm:fol_natural_deduction_equality/refl}
        \begin{prooftree}
          \infer0[\ref{inf:thm:fol_natural_deduction_equality/refl}]{ \syn\tau \syneq \syn\tau }.
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ =_S }]{inf:thm:fol_natural_deduction_equality/symm}
        \begin{prooftree}
          \hypo{ \syn\tau \syneq \syn\sigma }
          \infer1[\ref{inf:thm:fol_natural_deduction_equality/symm}]{ \syn\sigma \syneq \syn\tau }.
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ =_T }]{inf:thm:fol_natural_deduction_equality/trans}
        \begin{prooftree}
          \hypo{ \syn\tau \syneq \syn\sigma }
          \hypo{ \syn\sigma \syneq \syn\rho }
          \infer2[\ref{inf:thm:fol_natural_deduction_equality/trans}]{ \syn\tau \syneq \syn\rho }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}

  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ =_f }]{inf:thm:fol_natural_deduction_equality/fun}
        \begin{prooftree}
          \hypo{ \syn\tau_1 \syneq \syn\sigma_1 }.
          \hypo{ \ldots }
          \hypo{ \syn\tau_1 \syneq \syn\sigma_n }.
          \infer3[\ref{inf:thm:fol_natural_deduction_equality/fun}]{ f(\syn\tau_1, \ldots, \syn\tau_n) \syneq f(\syn\sigma_1, \ldots, \syn\sigma_n) }.
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ =_p }]{inf:thm:fol_natural_deduction_equality/pred}
        \begin{prooftree}
          \hypo{ \syn\tau_1 \syneq \syn\sigma_1 }.
          \hypo{ \ldots }
          \hypo{ \syn\tau_1 \syneq \syn\sigma_n }.
          \hypo{ p(\syn\tau_1, \ldots, \syn\tau_n) }
          \infer4[\ref{inf:thm:fol_natural_deduction_equality/pred}]{ p(\syn\sigma_1, \ldots, \syn\sigma_n) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  We need a distinct rule for every function symbol \( f \) and every predicate symbol \( p \).
\end{proposition}
\begin{comments}
  \item Conversely, these rules can be used to emulate those from \cref{def:fol_natural_deduction/equality} that we use for our natural deduction systems.
\end{comments}
\begin{proof}
  \SubProofOf{inf:thm:fol_natural_deduction_equality/refl} This is literally the same rule as \ref{inf:def:fol_natural_deduction/equality/intro}.

  \SubProofOf{inf:thm:fol_natural_deduction_equality/symm} Let \( \varphi \coloneqq (x \syneq \tau) \) for some variable \( x \) not free in \( \tau \). Then
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:fol_natural_deduction/equality/intro}]{ \varphi[x \mapsto \tau] }
      \hypo{ [\tau \syneq \sigma]^u }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ \underbrace{\varphi[x \mapsto \sigma]}_{N^\tau \syneq M^\tau} }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{inf:thm:fol_natural_deduction_equality/trans}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\tau \syneq \sigma]^u }
      \hypo{ [\sigma \syneq \rho]^v }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ \tau \syneq \rho }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{inf:thm:fol_natural_deduction_equality/fun}
  \small
  \begin{equation*}
    \begin{prooftree}[separation=1em]
      \hypo{ [\tau_1 \syneq \sigma_1]^{u_1} }.
      \infer0[\ref{inf:def:fol_natural_deduction/equality/intro}]{ f(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) \syneq f(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ f(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) \syneq f(\sigma_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) }

      \hypo{ [\tau_2 \syneq \sigma_2]^{u_2} }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ f(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) \syneq f(\sigma_1, \sigma_2, \ldots, \tau_{n-1}, \tau_n) }
      \ellipsis{} { f(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) \syneq f(\sigma_1, \sigma_2, \ldots, \sigma_{n-1}, \tau_n) }

      \hypo{ [\tau_n \syneq \sigma_n]^{u_n} }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ f(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) \syneq f(\sigma_1, \sigma_2, \ldots, \sigma_{n-1}, \sigma_n) }
    \end{prooftree}
  \end{equation*}
  \normalsize

  \SubProofOf{inf:thm:fol_natural_deduction_equality/pred}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\tau_1 \syneq \sigma_1]^{u_1} }.
      \hypo{ [p(\tau_1, \tau_2, \ldots, \tau_{n-1}, \tau_n)]^v }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ p(\sigma_1, \tau_2, \ldots, \tau_{n-1}, \tau_n) }

      \hypo{ [\tau_2 \syneq \sigma_2]^{u_2} }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ p(\sigma_1, \sigma_2, \ldots, \tau_{n-1}, \tau_n) }
      \ellipsis{} { p(\sigma_1, \sigma_2, \ldots, \sigma_{n-1}, \tau_n) }

      \hypo{ [\tau_n \syneq \sigma_n]^{u_n} }
      \infer2[\ref{inf:def:fol_natural_deduction/equality/elim}]{ p(\sigma_1, \sigma_2, \ldots, \sigma_{n-1}, \sigma_n) }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{theorem}[First-order syntactic deduction theorem]\label{thm:fol_natural_deduction_deduction_theorem}
  With respect to \hyperref[def:fol_natural_deduction]{minimal first-order natural deduction}, for arbitrary formulas we have
  \begin{equation*}
    \Gamma, \varphi \vdash \psi \T{if and only if} \Gamma \vdash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item This is one of several deduction theorems presented here --- see \cref{rem:deduction_theorem_list}.
\end{comments}
\begin{proof}
  Follows by direct reuse of the proof trees from \fullref{thm:propositional_syntactic_deduction_theorem}.
\end{proof}

\begin{theorem}[First-order natural deduction soundness]\label{thm:fol_natural_deduction_soundness}
  \hyperref[def:fol_natural_deduction]{Classical first-order natural deduction} is \hyperref[def:general_logic]{sound} with respect to \hyperref[def:truth_value_algebra/classical]{classical} \hyperref[def:fol_semantics]{semantics}.
\end{theorem}
\begin{comments}
  \item This provides a proof that the first-order general logic in \cref{def:first_order_logic} is well-defined.
  \item See \cref{rem:soundness_and_completeness_theorem_list} for a list of soundness and completeness theorems.
\end{comments}
\begin{proof}
  For the induction, will need a generalization of the statement to \hyperref[def:fol_universal_validity]{universally valid} formulas.

  Fix also a proof tree \( P \) whose open assumptions are universally valid in some \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \). We will use \fullref{thm:induction_on_rooted_trees} on \( P \) to show that its conclusion is also universally valid in \( \mscrX \).

  For definiteness, fix a variable assignment \( v \) that satisfies all open assumptions of \( P \). We must show that \( v \) satisfies its conclusion.

  The case where \( P \) is an assumption tree is vacuous, so suppose that \( P \) is a rule application tree. Let \( P_1, \ldots, P_n \) be the premise subtrees of \( P \) and suppose that the statement holds for them. We will perform case analysis by the rule used.

  For the propositional rules from \cref{def:propositional_natural_deduction}, this follows from \fullref{thm:propositional_natural_deduction_soundness} via \fullref{alg:fol_propositional_formula_translation}. We will focus on the first-order rules from \cref{def:fol_natural_deduction}.

  \SubProofOf{inf:def:fol_natural_deduction/equality/intro} Let \( \tau \syneq \tau \) be the conclusion of \( P \). Then \cref{thm:fol_equality_characterization} implies that every variable assignment \( v \) satisfies \( \tau \syneq \tau \).

  \SubProofOf{inf:def:fol_natural_deduction/equality/elim} If \( \varphi[x \mapsto \tau] \) and \( \tau \syneq \sigma \) are the conclusions of \( P_1 \) and \( P_2 \), then \( \varphi[x \mapsto \sigma] \) is the conclusion of \( P \).

  Fix a variable assignment \( v \) that satisfies the open assumptions of \( P \). Since \( P \) does not discharge formulas, it also satisfies the assumptions of \( P_1 \) and \( P_1 \). Thus, by the inductive hypothesis, \( v \) satisfies \( \varphi[x \mapsto \tau] \) and \( (\tau \syneq \sigma) \). \Cref{thm:fol_equality_characterization} implies that \( \Bracks{\tau}_\mscrX^v = \Bracks{\sigma}_\mscrX^v \).

  Then \cref{thm:fol_formula_semantics_of_compatible_substitutions} implies that
  \begin{equation*}
    \Bracks{\varphi[x \mapsto \sigma]}_\mscrX^v = \underbrace{\Bracks{\varphi[x \mapsto \tau]}_\mscrX^v}_{\semtop}.
  \end{equation*}

  \SubProofOf{inf:def:fol_natural_deduction/forall/intro} If \( \qforall x \varphi \) is the conclusion of \( P \), then \( \varphi[x \mapsto y] \) is the conclusion of \( P_1 \), where \( y \) is an eigenvariable.

  Fix an assignment \( v \) that satisfies the open assumptions of \( P \). \Fullref{alg:fol_formula_denotation} implies that
  \begin{equation*}
    \Bracks{\qforall x \varphi}_\mscrX^v
    =
    \bigwedge_{a \in X} \Bracks{\varphi}_\mscrX^{v_{x \mapsto a}}.
  \end{equation*}

  Our goal is to show that, for every value \( a \) in \( X \), the modified assignment \( v_{x \mapsto a} \) satisfies \( \varphi \).

  The inductive hypothesis implies that the modified assignment \( v_{y \mapsto a} \) satisfies \( \varphi[x \mapsto y] \), and \cref{thm:fol_formula_semantics_of_assignment_substitution} implies that the assignment \( v_{y \mapsto a, x \mapsto a} \) satisfies \( \varphi \).

  Since \( y \) is an eigenvariable, the condition \cref{def:fol_natural_deduction_proof_tree/application/main/variable} holds, i.e. either \( y = x \) or \( y \) is not free in \( \varphi \).
  \begin{itemize}
    \item If \( y = x \), clearly \( v_{y \mapsto a, x \mapsto a} = v_{x \mapsto a} \) satisfies \( \varphi \).

    \item Otherwise, \( y \) is not free in \( \varphi \). \Cref{thm:fol_formula_semantics_of_compatible_substitutions} implies that \( v_{x \mapsto a} \) satisfies \( \varphi \).
  \end{itemize}

  It follows that \( v \) satisfies \( \qforall x \varphi \).

  \SubProofOf{inf:def:fol_natural_deduction/forall/elim} If \( \varphi[x \mapsto \tau] \) is the conclusion of \( P \), then \( \qforall x \varphi \) is the conclusion of \( P_1 \).

  Fix an assignment \( v \) that satisfies the open assumptions of \( P \). \Cref{thm:fol_formula_semantics_of_assignment_substitution} implies that
  \begin{equation*}
    \Bracks{\varphi[x \mapsto \tau]}_\mscrX^v
    =
    \Bracks{\varphi}_\mscrX^{v_{x \mapsto \Bracks{\tau}_\mscrX^v}}.
  \end{equation*}

  By the inductive hypothesis, \( v \) satisfies \( \qforall x \varphi \), hence \( v_{x \mapsto a} \) satisfies \( \varphi \) for every \( a \) in \( X \); we can take \( a = \Bracks{\tau}_\mscrX^v \) in particular to show that \( v \) satisfies \( \varphi[x \mapsto \tau] \) due to \cref{thm:fol_formula_semantics_of_compatible_substitutions}.

  \SubProofOf{inf:def:fol_natural_deduction/exists/intro} If \( \qexists x \varphi \) is the conclusion of \( P \), then, for some term \( \tau \), the conclusion of \( P_1 \) is \( \varphi[x \mapsto \tau] \).

  Fix an assignment \( v \) that satisfies the open assumptions of \( P \). \Fullref{alg:fol_formula_denotation} implies that
  \begin{equation*}
    \Bracks{\qexists x \varphi}_\mscrX^v
    =
    \bigvee_{a \in X} \Bracks{\varphi}_\mscrX^{v_{x \mapsto a}}.
  \end{equation*}

  To show that \( v \) satisfies \( \qexists x \varphi \), it is sufficient to find a value \( a \) such that \( v_{x \mapsto a} \) satisfies \( \varphi \). We can take \( a \coloneqq \Bracks{\tau}_\mscrX^v \) since, by the inductive hypothesis, \( v \) satisfies \( \varphi[x \mapsto \tau] \).

  \SubProofOf{inf:def:fol_natural_deduction/exists/elim} We have two cases to consider.
  \SubProof*{Proof if \( P \) discharges no assumption} In this case \( P \) has the form
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis { \( P_1 \) } { \qexists x \varphi }

      \hypo{}
      \ellipsis { \( P_2 \) } { \psi }

      \infer2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ \psi }
    \end{prooftree}
  \end{equation*}

  In this case we directly use the inductive hypothesis on \( P_2 \) to conclude that every variable assignment that satisfies the open assumptions of \( P \) also satisfies \( \psi \).

  \SubProof*{Proof if \( P \) discharges an assumption} If \( P \) discharges \( [\varphi[x \mapsto y]]^u \), it has the form
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis { \( P_1 \) } { \qexists x \varphi }

      \hypo{ [\varphi[x \mapsto y]]^u }
      \ellipsis { \( P_2 \) } { \psi }

      \infer[left label=\( u \)]2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ \psi }
    \end{prooftree}
  \end{equation*}

  Fix an assignment \( v \) that satisfies the open assumptions of \( P \). We will again utilize the inductive hypothesis on \( P_2 \), but using it is tricky since \( \varphi[x \mapsto y] \) is not automatically satisfied by \( v \).

  First, we use the inductive hypothesis on \( P_1 \) to conclude that \( v \) satisfies \( \qexists x \varphi \). Then there exists a value \( a \) such that \( v_{x \mapsto a} \) satisfies \( \varphi \).

  Now we must justify using the modified assignment \( v_{y \mapsto a} \) instead of \( v \) for \( P_2 \).

  As an eigenvariable, \( y \) satisfies the condition \cref{def:fol_natural_deduction_proof_tree/application/attached/assumptions}, which requires it to not be in \( F_2(\set{ u }, \varnothing) \). In particular, \cref{thm:def:fol_natural_deduction_proof_tree/not_open_var} implies that \( y \) is not free in any open assumption of \( P_2 \), except possibly \( [\varphi[x \mapsto y]]^u \).

  Since \( v \) satisfies the open assumptions of \( P \), it satisfies those of \( P_2 \) (except the one discharged); but \( v_{y \mapsto a} \) also satisfies those same assumptions because we just showed that the value of \( y \) is irrelevant for them.

  As for \( \varphi[x \mapsto y] \) itself, \cref{thm:fol_formula_semantics_of_assignment_substitution} implies that
  \begin{equation*}
    \Bracks{\varphi[x \mapsto y]}_\mscrX^{v_{y \mapsto a}} = \Bracks{\varphi}_\mscrX^{v_{y \mapsto a, x \mapsto a}}.
  \end{equation*}

  Again, since \( y \) is an eigenvariable, it satisfies \cref{def:fol_natural_deduction_proof_tree/application/attached/variable}. Thus, either \( x = y \) or otherwise \( y \) is not free in \( \varphi \). In either case, we can extend the above equality to
  \begin{equation*}
    \Bracks{\varphi[x \mapsto y]}_\mscrX^{v_{y \mapsto a}} = \Bracks{\varphi}_\mscrX^{v_{y \mapsto a, x \mapsto a}} = \underbrace{\Bracks{\varphi}_\mscrX^{v_{x \mapsto a}}}_{\semtop}.
  \end{equation*}

  Therefore, we have just shown that \( v_{y \mapsto a} \) satisfies all open assumptions of \( P_2 \). The inductive hypothesis allows us to conclude that it also satisfies the conclusion \( \phi \).

  Finally, \( y \) also satisfies \cref{def:fol_natural_deduction_proof_tree/application/attached/conclusion}, so it is not free in \( \psi \). Since \( v_{y \mapsto a} \) satisfies \( \psi \), so does \( v \).

  This concludes the proof.
\end{proof}
