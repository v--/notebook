\section{First-order natural deduction}\label{sec:first_order_natural_deduction}

\paragraph{Simultaneous substitution}

\begin{algorithm}[First-order formula substitution]\label{alg:fol_formula_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to arbitrary \hyperref[def:fol_formula]{first-order formulas} as follows:
  \begin{empheq}[left={\varphi[\Bbbs]} \coloneqq \empheqlbrace]{align}
    &\varphi,                                                    &&\varphi \in \op*{PConst},                                                                      \label{eq:alg:fol_formula_substitution/const}         \\
    &\tau[\Bbbs] \syneq \sigma[\Bbbs],                           &&\varphi = (\tau \syneq \sigma),                                                                \label{eq:alg:fol_formula_substitution/eq} \\
    &p\parens[\big]{ \sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs] }, &&\varphi = p(\sigma_1, \ldots, \sigma_n),                                                       \label{eq:alg:fol_formula_substitution/application} \\
    &\synneg \psi[\Bbbs],                                        &&\varphi = \synneg \psi,                                                                        \label{eq:alg:fol_formula_substitution/neg} \\
    &\psi[\Bbbs] \syncirc \theta[\Bbbs],                         &&\varphi = (\psi \syncirc \theta), {\syncirc} \in \op*{Conn},                                   \label{eq:alg:fol_formula_substitution/conn} \\
    &\quantifier Q x \psi[\Bbbs_{x \mapsto x}],                  &&\varphi = \quantifier Q x \psi, Q \in \op*{Quant} \T{and} x \not\in \op*{Free}_\Bbbs(\varphi), \label{eq:alg:fol_formula_substitution/quant/direct} \\
    &\quantifier Q x \psi[\Bbbs_{x \mapsto n}],                  &&\varphi = \quantifier Q x \psi, Q \in \op*{Quant} \T{and} x \in \op*{Free}_\Bbbs(\varphi)      \label{eq:alg:fol_formula_substitution/quant/renaming}
  \end{empheq}
  where \( n = \sharp(\op*{Free}_\Bbbs(\varphi)) \).
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.substitution.apply_substitution_to_formula} in \cite{notebook:code}.
  \item This substitution is defined as to have the properties listed in \cref{rem:variable_binding_properties}; we elaborate on this in \fullref{thm:alg:fol_formula_substitution}.
\end{comments}

\begin{proposition}\label{thm:alg:fol_formula_substitution}
  \Fullref{alg:fol_formula_substitution} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:alg:fol_formula_substitution/free} For any formula \( \varphi \) and any atomic substitution \( \Bbbs \), we have
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free}
      \op*{Free}( \varphi[\Bbbs] ) = \overbrace{\bigcup_{\mathclap{v \in \op*{Free}(\varphi)}} \op*{Free}(\Bbbs(v))}^{\op*{Free}_\Bbbs(\varphi)}.
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/free_single} For any terms \( \varphi \) and \( \psi \) and any variable \( x \), we have
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free_single}
      \op*{Free}( \varphi[x \mapsto \psi] ) = \begin{cases}
        (\op*{Free}(\varphi) \setminus \set{ x }) \cup \op*{Free}(\psi), &x \in \op*{Free}(\varphi) \\
        \op*{Free}(\varphi),                                             &\T{otherwise.}
      \end{cases}
    \end{equation}

    In both cases,
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free_single/subset}
      \op*{Free}( \varphi[x \mapsto \psi] ) \subseteq (\op*{Free}(\varphi) \setminus \set{ x }) \cup \op*{Free}(\psi).
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/quant_single_rule} For any quantifier formula \( \varphi = \quantifier Q x \psi \) and any substitution \( \Bbbs \), there exists a variable \( v \not\in \op*{Free}_\Bbbs(\varphi) \) such that
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/quant_single_rule}
      \varphi[\Bbbs] = \quantifier Q v \psi[\Bbbs_{x \mapsto v}].
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/substitutions_agree} If the substitutions \( \Bbbs \) and \( \Bbbt \) agree on the free variables of \( \varphi \), then \( M[\Bbbs] = M[\Bbbt] \).
    \thmitem{thm:alg:fol_formula_substitution/noop} We have \( \varphi[\Bbbs] = \varphi \) if and only if the free variables of \( \varphi \) are fixed by the substitution \( \Bbbs \).
    \thmitem{thm:alg:fol_formula_substitution/identity} For any formula \( \varphi \), we have \( \varphi[\id] = \varphi \) for the identity substitution.
    \thmitem{thm:alg:fol_formula_substitution/closed} For any closed formula \( \varphi \) and any atomic substitution \( \Bbbs \), we have \( \varphi[\Bbbs] = \varphi \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:alg:fol_formula_substitution/free} Can be proven as in \cref{thm:lambda_substitution_free_variables}.
  \SubProofOf{thm:alg:fol_formula_substitution/free_single} Follows from \cref{thm:lambda_substitution_free_variables}, similarly to \cref{thm:lambda_substitution_free_variables_single}.
  \SubProofOf{thm:alg:fol_formula_substitution/quant_single_rule} Can be proven as in \cref{thm:lambda_substitution_single_rule}.
  \SubProofOf{thm:alg:fol_formula_substitution/substitutions_agree} Can be proven as in \cref{thm:lambda_substitutions_agree}.
  \SubProofOf{thm:alg:fol_formula_substitution/noop} Can be proven as in \cref{thm:lambda_substitution_noop}.
  \SubProofOf{thm:alg:fol_formula_substitution/identity} Follows from \cref{thm:alg:fol_formula_substitution/noop}.
  \SubProofOf{thm:alg:fol_formula_substitution/closed} Vacuously follows from \cref{thm:lambda_substitution_identity} since combinators simply have no free variables.
\end{proof}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:fol_formula_alpha_equivalence}\mimprovised
  Based on how we defined \( \alpha \)-equivalence of \hyperref[def:lambda_term]{\( \muplambda \)-terms} in \cref{def:lambda_term_alpha_equivalence}, we will define \term{\( \alpha \)-equivalence} between \hyperref[def:fol_formula]{first-order formulas} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \):

  \columnratio{0.25,0.25,0.5}
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Atom}_\alpha }]{inf:def:fol_formula_alpha_equivalence/atom}
        \begin{prooftree}
          \hypo{ \varphi \in \op*{Atom}_\Sigma }
          \infer1[\ref{inf:def:fol_formula_alpha_equivalence/atom}]{ \varphi \aequiv \varphi }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Neg}_\alpha }]{inf:def:fol_formula_alpha_equivalence/neg}
        \begin{prooftree}
          \hypo{ \varphi \aequiv \psi }
          \infer1[\ref{inf:def:fol_formula_alpha_equivalence/neg}]{ \synneg \varphi \aequiv \synneg \psi }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Conn}_\alpha }]{inf:def:fol_formula_alpha_equivalence/conn}
        \begin{prooftree}
          \hypo{ \varphi_1 \aequiv \psi_1 }
          \hypo{ \varphi_2 \aequiv \psi_1 }
          \hypo{ {\syncirc} \in \op*{Conn} }
          \infer3[\ref{inf:def:fol_formula_alpha_equivalence/conn}]{ (\varphi_1 \syncirc \varphi_2) \aequiv (\psi_1 \syncirc \psi_2) }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
  \columnratio{}

  For quantifiers, we can either use the single rule
  \begin{equation*}\taglabel[\ensuremath{ \logic{Quant}_\alpha }]{inf:def:fol_formula_alpha_equivalence/quant}
    \begin{prooftree}
      \hypo{ Q \in \op*{Quant} }
      \hypo{ \varphi[x \mapsto n] \aequiv \psi[y \mapsto n] \T{for every} n \not\in \op*{Free}(\quantifier Q x \varphi) }
      \infer2[\ref{inf:def:fol_formula_alpha_equivalence/quant}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) }
    \end{prooftree}
  \end{equation*}
  or the following pair of rules based on \cref{thm:alpha_equivalence_simplified}:
  \columnratio{0.325,0.675}
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Lift}_\alpha }]{inf:def:fol_formula_alpha_equivalence/lift}
        \begin{prooftree}[separation=1.1em]
          \hypo{ Q \in \op*{Quant} }
          \hypo{ \varphi \aequiv \psi }
          \infer2[\ref{inf:def:fol_formula_alpha_equivalence/lift}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q x \psi) }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha }]{inf:def:fol_formula_alpha_equivalence/ren}
        \begin{prooftree}[separation=1.1em]
          \hypo{ Q \in \op*{Quant} }
          \hypo{ x \neq y }
          \hypo{ x \not\in \op*{Free}(\psi) }
          \hypo{ \varphi \aequiv \psi[y \mapsto x] }
          \infer4[\ref{inf:def:fol_formula_alpha_equivalence/ren}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
  \columnratio{}
\end{definition}
\begin{comments}
  \item We can prove that the quantifier rules are interchangeable similarly to the case of \( \muplambda \)-terms. In fact, with the properties from \cref{thm:def:fol_formula_alpha_equivalence}, the proof becomes analogous.
\end{comments}

\begin{proposition}\label{thm:def:fol_formula_alpha_equivalence}
  \hyperref[thm:def:fol_formula_alpha_equivalence]{\( \alpha \)-equivalence} of \hyperref[def:fol_formula]{first-order formulas} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_formula_alpha_equivalence/same_kind} If two formulas are \( \alpha \)-equivalent, they have the same kind: both are either atomic formulas (in which case they are equal), negation formulas, connective formulas with the same connective or quantifier formulas with the same quantifier.

    \thmitem{thm:def:fol_formula_alpha_equivalence/free} The free variables of \( \alpha \)-equivalent formulas coincide.

    \thmitem{thm:def:fol_formula_alpha_equivalence/quantifier_body_free} If \( (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) \), then
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/abstraction_body_free}
      \op*{Free}(\varphi) \setminus \set{ x } = \op*{Free}(\psi) \setminus \set{ y }.
    \end{equation}

    In particular, \( x \) is free in \( \varphi \) if and only if \( y \) is free in \( \psi \). Unless \( x = y \), however, \( x \) is never free in \( \psi \), nor \( y \) --- in \( \varphi \).

    \thmitem{thm:def:fol_formula_alpha_equivalence/equivalence} \( \alpha \)-equivalence is an \hyperref[def:equivalence_relation]{equivalence relation}.

    \thmitem{thm:def:fol_formula_alpha_equivalence/substitution_composition} For the \hyperref[def:fol_substitution_composition]{composition} \( \Bbbt \Bbbs \) of the \hyperref[def:fol_substitution]{substitutions} \( \Bbbt \Bbbs \), we have
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/composition}
      \varphi[\Bbbt\Bbbs] \aequiv \varphi[\Bbbs][\Bbbt]
    \end{equation}
    for any formula \( \varphi \)

    \thmitem{thm:def:fol_formula_alpha_equivalence/contraction} For every formula \( \varphi \), every term \( \psi \) and any variable \( y \) not in \( \op*{Free}(\varphi) \), we have
    \begin{equation}\label{thm:def:fol_formula_alpha_equivalence/contraction/precomposition}
      \varphi[x \mapsto y][\Bbbs_{y \mapsto \tau}]
      \aequiv
      \varphi[\Bbbs_{x \mapsto \tau}]
    \end{equation}
    and
    \begin{equation}\label{thm:def:fol_formula_alpha_equivalence/contraction/composition}
      \varphi[\Bbbs_{x \mapsto y}][y \mapsto \tau]
      \aequiv
      \varphi[\Bbbs_{x \mapsto \tau}].
    \end{equation}

    \thmitem{thm:def:fol_formula_alpha_equivalence/substitution} If \( \varphi \aequiv \psi \), for any substitution \( \Bbbs \) we have \( \varphi[\Bbbs] \aequiv \psi[\Bbbs] \).

    \thmitem{thm:def:fol_formula_alpha_equivalence/conversion} If \( y \) and \( z \) are not free in \( \varphi \), then
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/conversion}
      \quantifier Q y \varphi[x \mapsto y] \aequiv \quantifier Q z \varphi[x \mapsto z].
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_formula_alpha_equivalence/same_kind} Trivial.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/free} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/free}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/quantifier_body_free} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/abstraction_body_free}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/equivalence} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/equivalence}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/substitution_composition} Unlike the rest, this one is more subtle and requires a lengthy proof. We handle the interesting cases when dealing with \( \muplambda \)-terms in \cref{thm:nary_lambda_substitution_composition_is_alpha_equivalent}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/contraction} Analogous to \cref{thm:lambda_substitution_chain_contraction}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/substitution} Analogous to \cref{thm:substitution_on_alpha_equivalent_terms}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/conversion} Analogous to \cref{thm:alpha_conversion_modified}.
\end{proof}

\paragraph{Schemas}

\begin{definition}\label{def:fol_term_schema}\mimprovised
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:fol_term]{first-order terms} as follows:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Small Greek identifier}}, \\
    \bnfprod{term schema}          {\bnfpn{variable placeholder} \bnfor \bnfpn{term placeholder} \bnfor} \\
    \bnfmore                       {\bnfpn{function application schema}},
  \end{bnf*}
  where the rules for \( \bnfpn{function application schema} \) are defined as in \cref{def:fol_term}, where we have a distinct rule for every function symbol in the signature.

  We have also used the variable identifier rules from \cref{def:variable_identifier}.
\end{definition}
\begin{comments}
  \item Term schemas are implemented in \identifier{math.logic.formulas} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:fol_formula_schema}\mimprovised
  We will define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:fol_formula]{first-order formulas} based on \hyperref[def:fol_term_schema]{term schemas} instead of \hyperref[def:fol_term]{terms}. We avoid writing the obvious rules in detail, but there are new important novelties:
  \begin{longbnf*}
    \bnfprod{eigenvariable schema}    {\bnfpn{variable placeholder} \bnfsp \bnftsq{\( \ast \)}} \\
    \bnfprod{formula placeholder}     {\bnfpn{Small Greek identifier}} \\
    \bnfprod{formula schema}          {\bnfpn{formula placeholder} \bnfor \cdots} \\
    \bnfprod{substitution target}    {\bnfpn{term schema} \bnfor \bnfpn{eigenvariable schema}} \\
    \bnfprod{extended formula schema} {\bnfpn{formula schema} \bnfor} \\
    \bnfmore                          {\bnfpn{formula schema} \bnfsp \bnfpn{substitution}}
  \end{longbnf*}

  \begin{itemize}
    \item For the placeholders we have used the identifier rules from \cref{def:variable_identifier}.
    \item For the substitutions we have used the rule from \cref{def:substitution_schema}, with the appropriate variable placeholders and subjects.
  \end{itemize}
\end{definition}
\begin{comments}
  \item Eigenvariables and extended schemas are needed to formalize the established natural deduction rules in \cref{def:fol_natural_deduction}.
  \item Small Greek identifiers are used for both term and formula placeholders, but in practice they do not cause confusion.
  \item First-order formula schemas directly extend their \hyperref[def:propositional_formula_schema]{propositional counterparts}.
  \item Formulas schemas are implemented in \identifier{math.logic.formulas} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:atomic_fol_instantiation}\mimprovised
  We define \hyperref[con:schemas_and_instances]{atomic instantiations} for \hyperref[def:fol_formula_schema]{first-order formula schemas} as \hyperref[def:set_valued_map/partial]{partial maps} \( \BbbI \) sending \hyperref[def:fol_term_schema]{variable placeholders} to \hyperref[def:fol_term]{variables}, \hyperref[def:fol_term_schema]{term placeholders} to \hyperref[def:fol_term]{terms} and \hyperref[def:fol_formula_schema]{formula placeholders} to \hyperref[def:fol_formula]{formulas}.
\end{definition}

\begin{algorithm}[First-order term instantiation]\label{alg:fol_term_schema_instantiation}
  We extend the \hyperref[def:atomic_fol_instantiation]{atomic first-order instantiation} \( \BbbI \) to all \hyperref[def:fol_term_schema]{term schemas} straightforwardly:
  \begin{equation}\label{eq:alg:fol_term_schema_instantiation}
    \Tau[\BbbI] \coloneqq \begin{cases}
      \BbbI(\Tau),                                 &\Tau \T{is a variable placeholder},   \\
      \BbbI(\Tau),                                 &\Tau \T{is a term placeholder},       \\
      f(\Sigma_1[\BbbI], \ldots, \Sigma_n[\BbbI]), &\Tau = f(\Sigma_1, \ldots, \Sigma_n), \\
    \end{cases}
  \end{equation}
\end{algorithm}
\begin{comments}
  \item Of course, an application of an instantiation is only valid if the placeholders are in its domain.
  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_term_schema} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[First-order formula instantiation]\label{alg:fol_formula_schema_instantiation}
  We will extend the \hyperref[def:atomic_fol_instantiation]{atomic first-order instantiation} \( \BbbI \) to all \hyperref[def:fol_formula_schema]{extended formula schemas} with the aid of \fullref{alg:fol_term_schema_instantiation}:
  \begin{equation}\label{eq:alg:fol_formula_schema_instantiation}
    \Phi[\BbbI] \coloneqq \begin{cases}
      \Phi,                                        &\Phi \T{is a propositional constant},             \\
      \BbbI(\Phi),                                 &\Phi \T{is a formula placeholder},                \\
                                                   &\vdots                                            \\
      \quantifier Q {\BbbI(\xi)} \Psi[\BbbI],      &\Phi = \quantifier Q \xi \Psi, Q \in \op*{Quant}, \\
      \Psi[\BbbI][\BbbI(\xi) \mapsto \BbbI(\eta)], &\Phi = \Psi[\xi \synsubst \eta^\ast],             \\
      \Psi[\BbbI][\BbbI(\xi) \mapsto \Tau[\BbbI]], &\Phi = \Psi[\xi \synsubst \Tau] \T{and} \Tau \T{is a term schema.}
    \end{cases}
  \end{equation}

  We have skipped half of the cases because they are obvious. The last two cases are notable because they require using \fullref{alg:fol_formula_substitution}.
\end{algorithm}
\begin{comments}
  \item As in \fullref{alg:lambda_term_schema_instantiation}, we do not distinguish between with free and bound variable schemas.

  \item Eigenvariables do not affect the instantiation itself; they will play an important role in restrict certain constructions when defining proof trees in \cref{def:fol_natural_deduction_proof_tree}.

  \item A variant of this algorithm, in which certain instantiations are considered invalid, is presented in \cref{rem:sequent_calculus_eigenvariables}.

  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_substitution} in \cite{notebook:code}.
\end{comments}

\paragraph{Abstract natural deduction}

\begin{definition}\label{def:fol_natural_deduction_system}\mimprovised
  An \term{abstract first-order natural deduction system} consists of a nonempty collection of \hyperref[def:natural_deduction_rule]{natural deduction rules} for \hyperref[def:fol_formula_schema]{extended first-order formula schemas} over the same \hyperref[def:fol_signature]{signature}. We require the rules to have distinct names, but otherwise impose no restrictions on them.
\end{definition}
\begin{comments}
  \item This definition extends \hyperref[def:propositional_natural_deduction_system]{propositional natural deduction systems}, because the first-order formula schemas are direct generalizations of their propositional counterparts.
\end{comments}

\begin{definition}\label{def:fol_natural_deduction_proof_tree}
  We will extend to \hyperref[def:first_order_logic]{first-order logic} the \hyperref[def:proof_tree]{proof trees} that we defined for propositional logic defined in \cref{def:propositional_natural_deduction_proof_tree}. Fix a \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}.

  In addition to the conclusion, rule name, open assumptions and implicit open premises, we will also need several sets of variables:
  \begin{thmenum}[series=def:fol_natural_deduction_proof_tree]
    \thmitem{def:fol_natural_deduction_proof_tree/eigenvariables} Most importantly, we will associate with every tree a set of variables called \term[ru=собственная переменная (\cite[145]{Герасимов2014Вычислимость}), en=eigenvariable (\cite[\S 5.1.10]{Mimram2020ProgramEqualsProof}); proper variable (\cite[38]{TroelstraSchwichtenberg2000BasicProofTheory})]{eigenvariable}. These are local to the root and are analogues of discharged assumptions.

    These obey some specific restrictions listed below. We try to justify these conditions using similar rules in \cref{rem:dependent_products_and_forall_quantifier_rules} and \cref{rem:sequent_calculus_eigenvariables}.

    \thmitem{def:fol_natural_deduction_proof_tree/open_variables} Dually, we will also need a set of \term{open free variables} of the proof tree. Similarly to the open assumptions, they will be cumulative for the entire tree and not just local to the root.

    Actually, we will need a more elaborate construction --- a function \( F(D, E) \) depending on a set \( D \) of discharged markers and a set \( E \) of discharged eigenvariables. We call \( F(\varnothing, \varnothing) \) \enquote{the} set of open free variables of the tree.

    \thmitem{def:fol_natural_deduction_proof_tree/implicit_variables} Similarly to implicit open premises, we may also have \term{implicit open variables}. We will call the proof tree \term{strict} if all implicit variables are also explicit open free variables.
  \end{thmenum}

  Just as with assumption discharging, binding variables is also delicate to handle:
  \begin{thmenum}[resume=def:fol_natural_deduction_proof_tree]
    \thmitem{def:fol_natural_deduction_proof_tree/assumption} An assumption tree for a first-order formula \( \varphi \) with marker \( u \) is defined analogously to the propositional case.
    \begin{thmenum}
      \thmitem{def:fol_natural_deduction_proof_tree/assumption/eigenvariables} There are no eigenvariables.
      \thmitem{def:fol_natural_deduction_proof_tree/assumption/open_variables} The open variables of the tree are the free variables of \( \varphi \). More generally,
      \begin{equation*}
        F(D, E) \coloneqq \begin{cases}
          \varnothing,                     &u \in D, \\
          \op*{Free}(\varphi) \setminus E, &\T{otherwise.}
        \end{cases}
      \end{equation*}

      \thmitem{def:fol_natural_deduction_proof_tree/assumption/implicit_variables} There are no implicit variables.
    \end{thmenum}

    \thmitem{def:fol_natural_deduction_proof_tree/application} A rule application tree operates similarly to its propositional counterpart, but binding open variables has some important caveats.

    Consider the rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Phi_1 }
        \hypo{ \cdots }

        \hypo{ [\Theta_{k,1}] }
        \hypo{ \cdots }
        \hypo{ [\Theta_{k,m_k}] }
        \infer[dashed]3{ \Phi_k }

        \hypo{ \cdots }
        \hypo{ \Phi_n }
        \infer[left label={\( [\Omega_1] \cdots [\Omega_m] \)}]5[\logic{R}]{ \Psi }
      \end{prooftree}
    \end{equation*}

    Fix an \hyperref[def:atomic_fol_instantiation]{atomic schema instantiation} \( \BbbI \) and a list \( (P_1, \ldots, P_n) \) of proof trees such that, for \( i = 1, \ldots, n \), the conclusion of \( P_k \) is \( \Phi_k[\BbbI] \). As in the propositional case, for a suitable choice \( d \) of dischargeable assumptions, we have a unique rule application tree \( P_d \).

    Describing the eigenvariables of \( P_d \) requires additional coherence conditions. They are enforced programmatically in the function \identifier{math.logic.deduction.proof_tree.apply} in \cite{notebook:code}:
    \begin{thmenum}[series=def:fol_natural_deduction_proof_tree/application]
      \thmitem{def:fol_natural_deduction_proof_tree/application/main} If the rule premise \( \Phi_k \) has a substitution schema with an eigenvariable, then \( \Phi_k = \Lambda[\xi \synsubst \eta^*] \) for some formula schema \( \Lambda \) and variable placeholders \( \xi \) and \( \eta \). For convenience, denote \( \BbbI(\xi) \) and \( \BbbI(\eta) \) by \( x \) and \( y \).

      We impose the following restrictions:
      \begin{thmenum}
        \thmitem{def:fol_natural_deduction_proof_tree/application/main/variable} Either \( y \) must coincide with \( x \) or otherwise \( y \) must not be free in \( \Lambda[\BbbI] \) (the unsubstituted conclusion of \( P_k \)).

        \thmitem{def:fol_natural_deduction_proof_tree/application/main/assumptions} The variable \( y \) must not be open in \( P_k \).
      \end{thmenum}

      \thmitem{def:fol_natural_deduction_proof_tree/application/attached} If the premise \( \Phi_k \) has a dischargeable schema \( \Theta_{k,i} \) attached, and if \( \Theta_{k,i} \) has a substitution schema with an eigenvariable, then, as above, \( \Theta_{k,i} = \Lambda[\xi \synsubst \eta^*] \). Again, denote \( \BbbI(\xi) \) and \( \BbbI(\eta) \) by \( x \) and \( y \).

      We impose the following restrictions:
      \begin{thmenum}
        \thmitem{def:fol_natural_deduction_proof_tree/application/attached/variable} Either \( y \) must coincide with \( x \) or otherwise \( y \) must not be free in \( \Lambda[\BbbI] \) (the unsubstituted dischargeable premise).

        \thmitem{def:fol_natural_deduction_proof_tree/application/attached/assumptions} The variable \( y \) must not be open in \( P_k \), except possibly in \( [\varphi]^u \) if \( \varphi = \Theta_{k,i}[\BbbI] \) (the substituted dischargeable premise).

        To check whether \( y \) is not free in any open assumption of \( P_k \) except \( [\varphi]^u \), we must inspect whether it belongs to the corresponding set \( F_k(\set{ u }, \varnothing) \).

        \thmitem{def:fol_natural_deduction_proof_tree/application/attached/conclusion} Additionally, \( y \) must not be free in \( \Phi_k[\BbbI] \) (the conclusion of \( P_k \)).

        In particular, if \( \Phi_k[\BbbI] \) and \( \Theta_{k,i}[\BbbI] \) coincide, then \( y \) is not allowed to be free in them.
      \end{thmenum}
    \end{thmenum}

    It remains to describe the set of open free variables in the application tree \( P_d \):
    \begin{thmenum}[resume=def:fol_natural_deduction_proof_tree/application]
      \thmitem{def:fol_natural_deduction_proof_tree/application/eigenvariables} If either \cref{def:fol_natural_deduction_proof_tree/application/main} or \cref{def:fol_natural_deduction_proof_tree/application/attached} are satisfied, we proclaim \( y \) an eigenvariable.

      We denote the set of all eigenvariables of \( P_d \) by \( E_d \).

      \thmitem{def:fol_natural_deduction_proof_tree/application/open_variables} We will now utilize the set \( I_d \) of implicit open premises and the set \( D_d \) of discharged assumption markers.

      Denote by \( F_k(D, E) \) the open variable function of the premise subtree \( P_k \). For \( P_d \) itself, we define the corresponding function as follows:
      \begin{equation*}
        F_d(D, E) \coloneqq \bigcup_{k=1}^n F_k(D \cup D_d, E \cup E_d) \cup \parens{ \bigcup_{\varphi \in I_d} \op*{Free}(\varphi) \setminus (E \cup E_d) }.
      \end{equation*}

      Thus, have taken the union of all open variables of the subtrees and all free variables of the implicit premises, excluding those discharged at the current application.

      \thmitem{def:fol_natural_deduction_proof_tree/application/implicit_variables} If the conclusion schema features a substitution, i.e. if \( \Psi = \Lambda[\xi \mapsto \Tau] \), let the set of implicit open variables be the set of variables of the term \( \Tau[\BbbI] \). Otherwise, let \( C_d \) be the empty set.
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The handling of eigenvariables is needed to formalize the established natural deduction rules in \cref{def:fol_natural_deduction}.

  Their treatment is generalized from the two quantifier rules discussed in detail in \cite[\S 2.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

  \item Even though we do not disallow eigenvariables in the conclusion, they simply serve no purpose there.

  \item Implicit variables and strict proof trees are not established concepts. Nonstrict rule application trees, in which the conclusion may introduce new free variables, have some debatable aspects despite being the norm. See \cref{rem:fol_empty_universe/natural_deduction} for a broader discussion.

  \item The term \enquote{eigenvariable} comes from \tcite{#2, where #1}{Gentzen1935LogischeSchließen} introduces natural deduction. In the corresponding English translation, \cite[293]{Gentzen1964LogicalDeduction}, eigenvariables are instead called \enquote{proper variables}. Both terms are currently used in English (e.g. \incite[\S 5.1.10]{Mimram2020ProgramEqualsProof} uses \enquote{eigenvariable}, while \incite[38]{TroelstraSchwichtenberg2000BasicProofTheory} uses \enquote{proper variable}).

  Gentzen presents only two rules featuring eigenvariables, in which the variables must satisfy slightly differing constraints. We restate Gentzen's rules in \cref{def:fol_natural_deduction} and adapt them for \hyperref[def:higher_order_logic]{higher-order logic} in \cref{def:hol_quantifier_rules/eigenvariables}.

  \item Natural deduction proof trees are implemented in the module \identifier{math.logic.deduction.proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:fol_natural_deduction_consequence}\mimprovised
  For every \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}, we define a \hyperref[def:consequence_relation]{consequence relation} as follows: we let \( \Gamma \vdash \varphi \) if there exists a \hyperref[def:fol_natural_deduction_proof_tree]{proof tree} with conclusion \( \varphi \) whose \hyperref[def:propositional_natural_deduction_proof_tree/open_assumptions]{open assumptions} are all in \( \Gamma \).

  In accordance with \cref{def:general_logic}, we say that \( \varphi \) is \term{derivable} from \( \Gamma \) if this relation holds.
\end{definition}
\begin{defproof}
  We can prove that \( {\vdash} \) is indeed a consequence relation in complete analogy with the propositional case --- see \cref{def:propositional_natural_deduction_consequence}.
\end{defproof}

\begin{proposition}\label{thm:fol_natural_deduction_derivation_compact}
  Every \hyperref[def:fol_natural_deduction_consequence]{natural deduction entailment relation} is \hyperref[def:consequence_relation/compactness]{compact}.
\end{proposition}
\begin{comments}
  \item This is one of several compactness theorems presented here --- see \cref{rem:logical_compactness_theorems}.
\end{comments}
\begin{proof}
  A proof tree is can have at most finitely many assumptions.
\end{proof}

\paragraph{Concrete natural deduction}

\begin{definition}\label{def:fol_natural_deduction}\mimprovised
  We will now extend the rules for minimal, intuitionistic and classical systems for propositional natural deduction from \cref{def:propositional_natural_deduction}.

  \begin{thmenum}
    \thmitem{def:fol_natural_deduction/equality} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ =_+ }]{inf:def:fol_natural_deduction/equality/intro}
          \begin{prooftree}
            \infer0[\ref{inf:def:fol_natural_deduction/equality/intro}]{ \syn\tau \syneq \syn\tau }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ =_- }]{inf:def:fol_natural_deduction/equality/elim}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syn\tau] }
            \hypo{ \syn\tau \syneq \syn\sigma }
            \infer2[\ref{inf:def:hol_equality_rules/elim}]{ \syn\varphi[\synx \synsubst \syn\sigma] }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:fol_natural_deduction/forall}\mcite[36]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \forall_+ }]{inf:def:fol_natural_deduction/forall/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syny^*] }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall \synx \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \forall_- }]{inf:def:fol_natural_deduction/forall/elim}
          \begin{prooftree}
            \hypo{ \qforall \synx \syn\varphi }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ \syn\varphi[\synx \synsubst \syn\tau] }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:fol_natural_deduction/exists}\mcite[36]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \exists_+ }]{inf:def:fol_natural_deduction/exists/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syn\tau] }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists \synx \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \exists_- }]{inf:def:fol_natural_deduction/exists/elim}
          \begin{prooftree}
            \hypo{ \qexists \synx \syn\varphi }

            \hypo{ \syn\varphi[\synx \mapsto \syny^*] }
            \infer[dashed]1{ \syn\psi }

            \infer2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The quantifier rules are justified by rules for dependent types via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}; see \cref{rem:dependent_products_and_forall_quantifier_rules}.

  \item These precise rules are used in the module \identifier{logic.classical_logic} in \cite{notebook:code}.
\end{comments}

\begin{theorem}[First-order syntactic deduction theorem]\label{thm:fol_natural_deduction_deduction_theorem}
  With respect to \hyperref[def:fol_natural_deduction]{minimal first-order natural deduction}, for arbitrary formulas we have
  \begin{equation*}
    \Gamma, \varphi \vdash \psi \T{if and only if} \Gamma \vdash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item This is one of several deduction theorems presented here --- see \cref{rem:deduction_theorem_list}.
\end{comments}
\begin{proof}
  Follows by direct reuse of the proof trees from \fullref{thm:propositional_syntactic_deduction_theorem}.
\end{proof}

\begin{example}\label{ex:def:fol_natural_deduction}
  We list examples of the natural deduction rules from \cref{def:fol_natural_deduction}:
  \begin{thmenum}
    \thmitem{ex:def:fol_natural_deduction/verum} We can build the following simple proof trees via the quantifier rules:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:propositional_natural_deduction/top/intro}]{ \syntop }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall \synx \syntop }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:propositional_natural_deduction/top/intro}]{ \syntop }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists \synx \syntop }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    There are no free variables involved, so the eigenvariable conditions are satisfied vacuously.

    \thmitem{ex:def:fol_natural_deduction/reintroduction} The following tree, which reintroduces \( \synforall \), is slightly more complicated:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(y) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall x p(x) }
      \end{prooftree}
    \end{equation*}

    Here \( y \) is an eigenvariable. It cannot occur freely in the derivation of \( p(y) \). This condition is satisfied since we start with a closed formula. Note that \( y \) can be any variable, including \( x \).

    \thmitem{ex:def:fol_natural_deduction/forall_to_exists} Somewhat similarly, we can introduce \( \synexists \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qforall x p(x)]^u }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(\tau) }
        \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }
      \end{prooftree}
    \end{equation*}

    Neither rule supports eigenvariables, so the application is straightforward. Here \( \tau \) can be an arbitrary term.

    This derivation is sound only if there is something to quantify over. We discuss this in \cref{rem:fol_empty_universe/natural_deduction}.

    \thmitem{ex:def:fol_natural_deduction/implicit_premise} Without implicit premises, the free variables of the following proof trees would differ:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [p(x) \synvee p(y)]^u }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [p(x)]^u }
            \infer1[\ref{inf:def:propositional_natural_deduction/or/left}]{ p(x) \synvee p(y) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    In the first case, the free variables would be \( x \) and \( y \), while in the second \( y \) would be ignored.

    \thmitem{ex:def:fol_natural_deduction/exists_elimination} Consider the following proof tree:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qexists x p(x)]^u }
        \hypo{ [\qforall x (p(x) \synimplies q(z))]^v }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(y) \synimplies q(z) }
        \hypo{ [p(y)]^w }
        \infer2[\ref{inf:def:propositional_natural_deduction/imp/elim}]{ q(z) }
        \infer[left label=\( w \)]2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ q(z) }
      \end{prooftree}
    \end{equation*}

    In short, we simply replaced the assumption \( [p(y)]^w \) with the weaker \( [\qexists x p(x)]^u \).

    Here we renamed \( x \) to \( y \) when eliminating \( \synforall \). Then we matched the two instances of \( p(y) \) and used conditional connective elimination. This allowed us to derive \( q(z) \) from \( p(y) \), thus also enabling us to eliminate \( p(y) \) due to \cref{def:fol_natural_deduction_proof_tree/application/attached/assumptions}.

    Compared to the above, the following proof tree is not valid:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\qexists x p(x)]^u }
        \hypo{ [p(y)]^v }
        \infer[left label=\( v \)]2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ p(y) }
      \end{prooftree}
    \end{equation*}

    The problem here is that \( p(y) \) is the conclusion of the subtree, and this falls into the case \cref{def:fol_natural_deduction_proof_tree/application/attached/conclusion}.

    \thmitem{ex:def:fol_natural_deduction/quantifier_duality}\mcite[example 2.1.4]{TroelstraSchwichtenberg2000BasicProofTheory} Via \fullref{thm:fol_semantic_deduction_theorem}, we can restate a special case of \eqref{thm:fol_quantifier_duality} as
    \begin{equation*}
      \synneg \qforall x \synneg p(x) \synimplies \qexists x p(x).
    \end{equation*}

    We can build a proof tree for this as follows:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\synneg \qforall x \synneg p(x)]^u }

        \hypo{ [\synneg \qexists x p(x)]^v }

        \hypo{ [p(x)]^w }
        \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }

        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
        \infer[left label=\( w \)]1[\ref{inf:def:propositional_natural_deduction/neg/intro}]{ \synneg p(x) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall x \synneg p(x) }
        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
        \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction/bot/raa}]{ \qexists x p(x) }

        \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \synneg \qforall x \synneg p(x) \synimplies \qexists x p(x) }
      \end{prooftree}
    \end{equation*}

    The introduction rule for \( \synforall \) is applicable because at that point \( x \) is no longer free in any open assumption --- even though it was initially free in \( [p(x)]^w \), this assumption was discharged.
  \end{thmenum}
\end{example}
\begin{comments}
  \item Many of these examples are verified programmatically in the module \identifier{math.logic.deduction.test_proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:dependent_products_and_forall_quantifier_rules}
  We will show how the universal quantifier introduction rule \ref{inf:def:fol_natural_deduction/forall/intro} corresponds, via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, to the introduction rule \ref{inf:def:dependent_product/intro} for \hyperref[def:dependent_product]{dependent products}.

  Generally, in \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}, we must be careful not to allow \hyperref[def:mltt_well_formed_context/derivation]{ill-formed derivations}. There can be situations where an assumption \( x: \tau \) cannot be discharged because the types of other open assumptions depend on \( x \).

  We will restate the rule here with some types renamed:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ x: \tau }
      \infer[dashed]1{ M: \varphi }
      \infer1[\ensuremath{ \Pi_+' }]{ \qabs {x^\tau} M: \qprod {x^\tau} \varphi }
    \end{prooftree}
  \end{equation*}

  We are only interested in the existence of the terms \( M \) and \( \qabs {x^\tau} M \), but not in the terms themselves. So we may rewrite the above to resemble a natural deduction rule (with \( \synforall \) used instead of \( \synprod \)):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ x: \tau }
      \infer[dashed]1{ \varphi }
      \infer1[\ensuremath{ \forall_+' }]{ \qforall {x^\tau} \varphi }
    \end{prooftree}
  \end{equation*}

  We showed in \cref{ex:def:mltt_well_formed_context/discharging} how, if some open assumption of a type derivation tree depends on \( x \), applying the rule and discharging \( x: \tau \) will make the derivation ill-formed.

  For the purposes of predicate logic, it will suffice, instead of dealing with explicit type contexts, we instead enforce the constraints given in \cref{def:fol_natural_deduction_proof_tree/application/main}.

  It is important here to note that \( \qforall x \varphi \) and \( \qforall y \varphi[x \mapsto y] \) are considered different formulas. This contrasts with Martin-L\"of type theory, where, due to the rule \ref{rem:type_theory_rule_classification/equality/alpha}, \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent} \( \muplambda \)-terms are assumed to be \hyperref[con:equality]{judgmentally equal}. Making \( \alpha \)-conversion explicit leads to \ref{inf:def:fol_natural_deduction/forall/intro} .
\end{remark}

\begin{remark}\label{rem:fol_empty_universe/natural_deduction}
  We discussed in \cref{rem:fol_empty_universe/semantics} how a \hyperref[def:fol_structure]{first-order structure} with an empty universe may cause issues with a lot of semantical concepts.

  As similar issue can be observed in the derivation tree from \cref{ex:def:fol_natural_deduction/forall_to_exists}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\qforall x p(x)]^u }
      \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(\tau) }
      \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }
    \end{prooftree}
  \end{equation*}

  This derivation is not sound in an empty universe where nothing exists. Nevertheless, the standard treatment of natural deduction ignores this issue --- starting from Gentzen's \cite[186]{Gentzen1935LogischeSchließen}, and including \cite[ch. 2]{TroelstraSchwichtenberg2000BasicProofTheory}, \cite[\S 2.8]{VanDalen2004LogicAndStructure} and \cite[97]{КолмогоровДрагалин2006Логика}.

  \incite*[\S 5.1.10]{Mimram2020ProgramEqualsProof} provides a hint at how to handle this situation. We have adapted his remarks when introducing strict proof trees in \cref{def:fol_natural_deduction_proof_tree/implicit_variables}. Since the only open assumption above has no free variables, the application of \ref{inf:def:fol_natural_deduction/forall/elim} is strict only if \( \tau \) is closed. This is the case when \( \tau \) contains at least one individual constant. But if the signature has an individual constant, its domain cannot be empty.

  If, on the other hand, the domain is empty, the rule is inapplicable. Strict proof trees require us to be more careful with the choice of conclusion of \ref{inf:def:fol_natural_deduction/forall/elim}. However, this makes them compatible with empty universes.

  Due to the increased complexity, we will not further pursue this path.
\end{remark}

\begin{remark}\label{rem:sequent_calculus_eigenvariables}
  \incite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory} give the following \hyperref[def:sequent_calculus_rule]{sequent calculus rule} for \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifiers}:
  \begin{equation*}\taglabel[\ensuremath{ \forall_R }]{inf:rem:sequent_calculus_eigenvariables/forall_right}
    \begin{prooftree}
      \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi[\synx \synsubst \syny^*] }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \syn\Gamma \synvdash \syn\Delta, \qforall \synx \syn\varphi }
    \end{prooftree}
  \end{equation*}

  We have reused the extended first-order formula schemas from \cref{def:fol_formula_schema}. Instantiation could be done via \fullref{alg:fol_formula_schema_instantiation}, however the rule features an eigenvariable schema \( \syny^* \). The authors give a side condition for eigenvariables to not be free in the rule's conclusion.

  Rather than introducing all the machinery for variable binding from \cref{def:fol_natural_deduction_proof_tree}, we could modify \fullref{alg:fol_formula_schema_instantiation}. For this, we package an atomic instantiation \( \BbbI \) and a set \( E \) of eigenvariables into \( \BbbE = (\BbbI, E) \), and restrict the algorithm based on \( E \):
  \begin{thmenum}
    \thmitem{rem:sequent_calculus_eigenvariables/atomic} If \( \Phi \) is an atomic schema, we define \( \Phi[\BbbI, E] \) as \( \Phi[\BbbI] \), but let it fail if some of the free variables of \( \Phi[\BbbI] \) are in \( E \).

    This condition ensures that no eigenvariable can occur free.

    \thmitem{rem:sequent_calculus_eigenvariables/quantifier} If \( \Phi = \quantifier Q \xi \Psi \) for a quantifier \( Q \), we define \( \Phi[\BbbI, E] \) as
    \begin{equation*}
      \quantifier Q {\BbbI(\xi)} \Psi[\BbbI, E \setminus \set{\BbbI(\xi)}].
    \end{equation*}

    Thus, we allow bound occurrences of eigenvariables.

    \thmitem{rem:sequent_calculus_eigenvariables/eigen} If \( \Phi = \Psi[\xi \synsubst \eta^\ast] \), we define \( \Phi[\BbbI, E] \) as
    \begin{equation*}
      \Psi[\BbbI, E \setminus \set{\BbbI(\eta)}][\BbbI(\xi) \mapsto \BbbI(\eta)],
    \end{equation*}
    but let it fail if \( \BbbI(\eta) \) is \hi{not} in \( E \).

    This ensures that all eigenvariables must be in \( E \). The reason we remove \( \BbbI(\eta) \) from \( \Psi \) it to allow the case where \( \BbbI(\xi) \) and \( \BbbI(\eta) \) coincide.

    If \( \Psi \) occurs elsewhere in the rule, its instantiation will fail unless it is within the scope of a quantifier or an eigenvariable substitution.

    \thmitem{rem:sequent_calculus_eigenvariables/other} In all other cases, we recurse into subformulas as in the unmodified algorithm.
  \end{thmenum}

  We will give an example based on the proof of \fullref{thm:propositional_semantic_lem} in \cref{ex:def:classical_propositional_sequent_calculus/lem}. Suppose the signature contains a unary predicate \( \synp \) and consider the invalid derivation
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \synp(\syny) \synvdash \synp(\syny) }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \synp(\syny) \synvdash \qforall \syny \synp(\syny) }
    \end{prooftree}
  \end{equation*}

  In an extended atomic instantiation \( \BbbE = (\BbbI, E) \), \( \BbbI \) must send the formula placeholder \( \syn\varphi \) to \( \synp(\synx) \) and both variable placeholders \( \synx \) and \( \syny \) to their eponymous variables. However, we have conflicting restrictions:
  \begin{itemize}
    \item In its first occurrence, due to \ref{rem:sequent_calculus_eigenvariables/atomic}, \( \synp(\syny) \) requires \( \syny \) to \hi{not} be in \( E \).
    \item In its second occurrence, due to \ref{rem:sequent_calculus_eigenvariables/eigen}, \( \synp(\syny) = \synp(\synx)[\synx \mapsto \syny] \) requires \( \syny \) to be in \( E \).
  \end{itemize}

  Thus, the above application fails. So does the following:
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \synp(\syny) \synvdash \synp(\syny) }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \synvdash \synp(\syny), \synneg \synp(\syny) }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \synvdash \synp(\syny), \qforall \synx \synneg \synp(\synx)) }
    \end{prooftree}
  \end{equation*}

  The problem in the final condition here is again due to a conflict of the two conditions.

  The following is valid, however:
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \synp(\syny) \synvdash \synp(\syny) }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \synvdash \synp(\syny), \synneg \synp(\syny) }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \synvdash \synp(\syny) \synvee \synneg \synp(\syny) }
      \infer1[\ref{inf:rem:sequent_calculus_eigenvariables/forall_right}]{ \synvdash \qforall \synx (\synp(\synx) \synvee \synneg \synp(\synx)) }
    \end{prooftree}
  \end{equation*}

  In the final application, \( \BbbI \) maps the formula placeholder \( \syn\varphi \) to \( \synp(\synx) \synvee \synneg \synp(\synx) \) and the variable placeholders \( \synx \) and \( \syny \) to the eponymous variables.

  Not only do the above conditions not conflict with each other, but \( \BbbI \) could even map \( \synx \) to \( \syny \) because \ref{rem:sequent_calculus_eigenvariables/quantifier} allows eigenvariables as bound variables.
\end{remark}

\begin{proposition}\label{thm:alpha_equivalent_forulas_are_interderivable}
\end{proposition}
