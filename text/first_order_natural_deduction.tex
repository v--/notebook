\section{First-order natural deduction}\label{sec:first_order_natural_deduction}

\paragraph{Simultaneous substitution}

\begin{algorithm}[First-order formula substitution]\label{alg:fol_formula_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to arbitrary \hyperref[def:fol_formula]{first-order formulas} as follows:
  \begin{empheq}[left={\varphi[\Bbbs]} \coloneqq \empheqlbrace]{align}
    &\varphi,                                                    &&\varphi \in \op*{PConst},                                                                      \label{eq:alg:fol_formula_substitution/const}         \\
    &\tau[\Bbbs] \syneq \sigma[\Bbbs],                           &&\varphi = (\tau \syneq \sigma),                                                                \label{eq:alg:fol_formula_substitution/eq} \\
    &p\parens[\big]{ \sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs] }, &&\varphi = p(\sigma_1, \ldots, \sigma_n),                                                       \label{eq:alg:fol_formula_substitution/application} \\
    &\synneg \psi[\Bbbs],                                        &&\varphi = \synneg \psi,                                                                        \label{eq:alg:fol_formula_substitution/neg} \\
    &\psi[\Bbbs] \syncirc \theta[\Bbbs],                         &&\varphi = (\psi \syncirc \theta), {\syncirc} \in \op*{Conn},                                   \label{eq:alg:fol_formula_substitution/conn} \\
    &\quantifier Q x \psi[\Bbbs_{x \mapsto x}],                  &&\varphi = \quantifier Q x \psi, Q \in \op*{Quant} \T{and} x \not\in \op*{Free}_\Bbbs(\varphi), \label{eq:alg:fol_formula_substitution/quant/direct} \\
    &\quantifier Q x \psi[\Bbbs_{x \mapsto n}],                  &&\varphi = \quantifier Q x \psi, Q \in \op*{Quant} \T{and} x \in \op*{Free}_\Bbbs(\varphi)      \label{eq:alg:fol_formula_substitution/quant/renaming}
  \end{empheq}
  where \( n = \sharp(\op*{Free}_\Bbbs(\varphi)) \).
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.substitution.apply_substitution_to_formula} in \cite{notebook:code}.
  \item This substitution is defined as to have the properties listed in \cref{rem:variable_binding_properties}; we elaborate on this in \fullref{thm:alg:fol_formula_substitution}.
\end{comments}

\begin{proposition}\label{thm:alg:fol_formula_substitution}
  \Fullref{alg:fol_formula_substitution} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:alg:fol_formula_substitution/free} For any formula \( \varphi \) and any atomic substitution \( \Bbbs \), we have
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free}
      \op*{Free}( \varphi[\Bbbs] ) = \overbrace{\bigcup_{\mathclap{v \in \op*{Free}(\varphi)}} \op*{Free}(\Bbbs(v))}^{\op*{Free}_\Bbbs(\varphi)}.
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/free_single} For any terms \( \varphi \) and \( \psi \) and any variable \( x \), we have
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free_single}
      \op*{Free}( \varphi[x \mapsto \psi] ) = \begin{cases}
        (\op*{Free}(\varphi) \setminus \set{ x }) \cup \op*{Free}(\psi), &x \in \op*{Free}(\varphi) \\
        \op*{Free}(\varphi),                                             &\T{otherwise.}
      \end{cases}
    \end{equation}

    In both cases,
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/free_single/subset}
      \op*{Free}( \varphi[x \mapsto \psi] ) \subseteq (\op*{Free}(\varphi) \setminus \set{ x }) \cup \op*{Free}(\psi).
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/quant_single_rule} For any quantifier formula \( \varphi = \quantifier Q x \psi \) and any substitution \( \Bbbs \), there exists a variable \( v \not\in \op*{Free}_\Bbbs(\varphi) \) such that
    \begin{equation}\label{eq:thm:alg:fol_formula_substitution/quant_single_rule}
      \varphi[\Bbbs] = \quantifier Q v \psi[\Bbbs_{x \mapsto v}].
    \end{equation}

    \thmitem{thm:alg:fol_formula_substitution/substitutions_agree} If the substitutions \( \Bbbs \) and \( \Bbbt \) agree on the free variables of \( \varphi \), then \( M[\Bbbs] = M[\Bbbt] \).
    \thmitem{thm:alg:fol_formula_substitution/noop} We have \( \varphi[\Bbbs] = \varphi \) if and only if the free variables of \( \varphi \) are fixed by the substitution \( \Bbbs \).
    \thmitem{thm:alg:fol_formula_substitution/identity} For any formula \( \varphi \), we have \( \varphi[\id] = \varphi \) for the identity substitution.
    \thmitem{thm:alg:fol_formula_substitution/closed} For any closed formula \( \varphi \) and any atomic substitution \( \Bbbs \), we have \( \varphi[\Bbbs] = \varphi \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:alg:fol_formula_substitution/free} Can be proven as in \cref{thm:lambda_substitution_free_variables}.
  \SubProofOf{thm:alg:fol_formula_substitution/free_single} Follows from \cref{thm:lambda_substitution_free_variables}, similarly to \cref{thm:lambda_substitution_free_variables_single}.
  \SubProofOf{thm:alg:fol_formula_substitution/quant_single_rule} Can be proven as in \cref{thm:lambda_substitution_single_rule}.
  \SubProofOf{thm:alg:fol_formula_substitution/substitutions_agree} Can be proven as in \cref{thm:lambda_substitutions_agree}.
  \SubProofOf{thm:alg:fol_formula_substitution/noop} Can be proven as in \cref{thm:lambda_substitution_noop}.
  \SubProofOf{thm:alg:fol_formula_substitution/identity} Follows from \cref{thm:alg:fol_formula_substitution/noop}.
  \SubProofOf{thm:alg:fol_formula_substitution/closed} Vacuously follows from \cref{thm:lambda_substitution_identity} since combinators simply have no free variables.
\end{proof}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:fol_formula_alpha_equivalence}\mimprovised
  Based on how we defined \( \alpha \)-equivalence of \hyperref[def:lambda_term]{\( \muplambda \)-terms} in \cref{def:lambda_term_alpha_equivalence}, we will define \term{\( \alpha \)-equivalence} between \hyperref[def:fol_formula]{first-order formulas} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \):

  \columnratio{0.25,0.25,0.5}
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Atom}_\alpha }]{inf:def:fol_formula_alpha_equivalence/atom}
        \begin{prooftree}
          \hypo{ \varphi \in \op*{Atom}_\Sigma }
          \infer1[\ref{inf:def:fol_formula_alpha_equivalence/atom}]{ \varphi \aequiv \varphi }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Neg}_\alpha }]{inf:def:fol_formula_alpha_equivalence/neg}
        \begin{prooftree}
          \hypo{ \varphi \aequiv \psi }
          \infer1[\ref{inf:def:fol_formula_alpha_equivalence/neg}]{ \synneg \varphi \aequiv \synneg \psi }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Conn}_\alpha }]{inf:def:fol_formula_alpha_equivalence/conn}
        \begin{prooftree}
          \hypo{ \varphi_1 \aequiv \psi_1 }
          \hypo{ \varphi_2 \aequiv \psi_1 }
          \hypo{ {\syncirc} \in \op*{Conn} }
          \infer3[\ref{inf:def:fol_formula_alpha_equivalence/conn}]{ (\varphi_1 \syncirc \varphi_2) \aequiv (\psi_1 \syncirc \psi_2) }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
  \columnratio{}

  For quantifiers, we can either use the single rule
  \begin{equation*}\taglabel[\ensuremath{ \logic{Quant}_\alpha }]{inf:def:fol_formula_alpha_equivalence/quant}
    \begin{prooftree}
      \hypo{ Q \in \op*{Quant} }
      \hypo{ \varphi[x \mapsto n] \aequiv \psi[y \mapsto n] \T{for every} n \not\in \op*{Free}(\quantifier Q x \varphi) }
      \infer2[\ref{inf:def:fol_formula_alpha_equivalence/quant}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) }
    \end{prooftree}
  \end{equation*}
  or the following pair of rules based on \cref{thm:alpha_equivalence_simplified}:
  \columnratio{0.325,0.675}
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Lift}_\alpha }]{inf:def:fol_formula_alpha_equivalence/lift}
        \begin{prooftree}[separation=1.1em]
          \hypo{ Q \in \op*{Quant} }
          \hypo{ \varphi \aequiv \psi }
          \infer2[\ref{inf:def:fol_formula_alpha_equivalence/lift}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q x \psi) }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha }]{inf:def:fol_formula_alpha_equivalence/ren}
        \begin{prooftree}[separation=1.1em]
          \hypo{ Q \in \op*{Quant} }
          \hypo{ x \neq y }
          \hypo{ x \not\in \op*{Free}(\psi) }
          \hypo{ \varphi \aequiv \psi[y \mapsto x] }
          \infer4[\ref{inf:def:fol_formula_alpha_equivalence/ren}]{ (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
  \columnratio{}
\end{definition}
\begin{comments}
  \item We can prove that the quantifier rules are interchangeable similarly to the case of \( \muplambda \)-terms. In fact, with the properties from \cref{thm:def:fol_formula_alpha_equivalence}, the proof becomes analogous.
\end{comments}

\begin{proposition}\label{thm:def:fol_formula_alpha_equivalence}
  \hyperref[thm:def:fol_formula_alpha_equivalence]{\( \alpha \)-equivalence} of \hyperref[def:fol_formula]{first-order formulas} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_formula_alpha_equivalence/same_kind} If two formulas are \( \alpha \)-equivalent, they have the same kind: both are either atomic formulas (in which case they are equal), negation formulas, connective formulas with the same connective or quantifier formulas with the same quantifier.

    \thmitem{thm:def:fol_formula_alpha_equivalence/free} The free variables of \( \alpha \)-equivalent formulas coincide.

    \thmitem{thm:def:fol_formula_alpha_equivalence/quantifier_body_free} If \( (\quantifier Q x \varphi) \aequiv (\quantifier Q y \psi) \), then
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/abstraction_body_free}
      \op*{Free}(\varphi) \setminus \set{ x } = \op*{Free}(\psi) \setminus \set{ y }.
    \end{equation}

    In particular, \( x \) is free in \( \varphi \) if and only if \( y \) is free in \( \psi \). Unless \( x = y \), however, \( x \) is never free in \( \psi \), nor \( y \) --- in \( \varphi \).

    \thmitem{thm:def:fol_formula_alpha_equivalence/equivalence} \( \alpha \)-equivalence is an \hyperref[def:equivalence_relation]{equivalence relation}.

    \thmitem{thm:def:fol_formula_alpha_equivalence/substitution_composition} For the \hyperref[def:fol_substitution_composition]{composition} \( \Bbbt \Bbbs \) of the \hyperref[def:fol_substitution]{substitutions} \( \Bbbt \Bbbs \), we have
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/composition}
      \varphi[\Bbbt\Bbbs] \aequiv \varphi[\Bbbs][\Bbbt]
    \end{equation}
    for any formula \( \varphi \)

    \thmitem{thm:def:fol_formula_alpha_equivalence/contraction} For every formula \( \varphi \), every term \( \psi \) and any variable \( y \) not in \( \op*{Free}(\varphi) \), we have
    \begin{equation}\label{thm:def:fol_formula_alpha_equivalence/contraction/precomposition}
      \varphi[x \mapsto y][\Bbbs_{y \mapsto \tau}]
      \aequiv
      \varphi[\Bbbs_{x \mapsto \tau}]
    \end{equation}
    and
    \begin{equation}\label{thm:def:fol_formula_alpha_equivalence/contraction/composition}
      \varphi[\Bbbs_{x \mapsto y}][y \mapsto \tau]
      \aequiv
      \varphi[\Bbbs_{x \mapsto \tau}].
    \end{equation}

    \thmitem{thm:def:fol_formula_alpha_equivalence/substitution} If \( \varphi \aequiv \psi \), for any substitution \( \Bbbs \) we have \( \varphi[\Bbbs] \aequiv \psi[\Bbbs] \).

    \thmitem{thm:def:fol_formula_alpha_equivalence/conversion} If \( y \) and \( z \) are not free in \( \varphi \), then
    \begin{equation}\label{eq:thm:def:fol_formula_alpha_equivalence/conversion}
      \quantifier Q y \varphi[x \mapsto y] \aequiv \quantifier Q z \varphi[x \mapsto z].
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_formula_alpha_equivalence/same_kind} Trivial.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/free} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/free}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/quantifier_body_free} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/abstraction_body_free}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/equivalence} Analogous to \cref{thm:def:lambda_term_alpha_equivalence/equivalence}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/substitution_composition} Unlike the rest, this one is more subtle and requires a lengthy proof. We handle the interesting cases when dealing with \( \muplambda \)-terms in \cref{thm:nary_lambda_substitution_composition_is_alpha_equivalent}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/contraction} Analogous to \cref{thm:lambda_substitution_chain_contraction}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/substitution} Analogous to \cref{thm:substitution_on_alpha_equivalent_terms}.

  \SubProofOf{thm:def:fol_formula_alpha_equivalence/conversion} Analogous to \cref{thm:alpha_conversion_modified}.
\end{proof}

\paragraph{Schemas}

\begin{definition}\label{def:fol_term_schema}\mimprovised
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:fol_term]{first-order terms} as follows:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Small Greek identifier}}, \\
    \bnfprod{term schema}          {\bnfpn{variable placeholder} \bnfor \bnfpn{term placeholder} \bnfor} \\
    \bnfmore                       {\bnfpn{function application schema}},
  \end{bnf*}
  where the rules for \( \bnfpn{function application schema} \) are defined as in \cref{def:fol_term}, where we have a distinct rule for every function symbol in the signature.

  We have also used the variable identifier rules from \cref{def:variable_identifier}.
\end{definition}
\begin{comments}
  \item Term schemas are implemented in \identifier{math.logic.formulas} in \cite{notebook:code}.
\end{comments}

\begin{concept}\label{con:eigenvariable}
  When \hyperref[con:variable_binding]{binding} a variable in \hyperref[con:predicate_logic]{predicate logic}, we want to discharge it, similarly to how we discharge assumptions in \hyperref[def:propositional_natural_deduction_proof_tree]{natural deduction proof trees} for \hyperref[def:propositional_logic]{propositional logic}.

  We will call such a dischargeable variable an \term[ru=собственная переменная (\cite[145]{Герасимов2014Вычислимость}), en=eigenvariable (\cite[\S 5.1.10]{Mimram2020ProgramEqualsProof})]{eigenvariable}.
\end{concept}
\begin{comments}
  \item Discharging either variables or formulas reduces to discharging type assertions in \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} under the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}. We discuss this in \cref{ex:dependent_types_and_hol_quantifier_rules}.

  \item The term \enquote{eigenvariable} comes from \tcite{#2, where #1}{Gentzen1935LogischeSchließen} introduces natural deduction. In the corresponding English translation, \cite[293]{Gentzen1964LogicalDeduction}, eigenvariables are instead called \enquote{proper variables}. Both terms are currently used in English (e.g. \incite[\S 5.1.10]{Mimram2020ProgramEqualsProof} uses \enquote{eigenvariable}, while \incite[38]{TroelstraSchwichtenberg2000BasicProofTheory} uses \enquote{proper variable}).

  Gentzen presents only two rules featuring eigenvariables, in which the variables must satisfy slightly differing constraints. We restate Gentzen's rules in \cref{def:fol_natural_deduction} and adapt them for \hyperref[def:higher_order_logic]{higher-order logic} in \cref{def:hol_quantifier_rules/eigenvariables}.
\end{comments}

\begin{definition}\label{def:fol_formula_schema}\mimprovised
  We will define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:fol_formula]{first-order formulas} based on \hyperref[def:fol_term_schema]{term schemas} instead of \hyperref[def:fol_term]{terms}. We avoid writing the obvious rules in detail, but there are new important novelties:
  \begin{longbnf*}
    \bnfprod{eigenvariable schema}    {\bnfpn{variable placeholder} \bnfsp \bnftsq{\( \ast \)}} \\
    \bnfprod{formula placeholder}     {\bnfpn{Small Greek identifier}} \\
    \bnfprod{formula schema}          {\bnfpn{formula placeholder} \bnfor \cdots} \\
    \bnfprod{substitution subject}    {\bnfpn{term schema} \bnfor \bnfpn{eigenvariable schema}} \\
    \bnfprod{extended formula schema} {\bnfpn{formula schema} \bnfor} \\
    \bnfmore                          {\bnfpn{formula schema} \bnfsp \bnfpn{substitution}}
  \end{longbnf*}

  \begin{itemize}
    \item For the placeholders we have used the identifier rules from \cref{def:variable_identifier}.
    \item For the substitutions we have used the rule from \cref{def:substitution_schema}, with the appropriate variable placeholders and subjects.
  \end{itemize}
\end{definition}
\begin{comments}
  \item The extended schemas are needed to formalize the established natural deduction rules in \cref{def:fol_natural_deduction}.
  \item Small Greek identifiers are used for both term and formula placeholders, but in practice they do not cause confusion.
  \item First-order formula schemas directly extend their \hyperref[def:propositional_formula_schema]{propositional counterparts}.
  \item Formulas schemas are implemented in \identifier{math.logic.formulas} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:atomic_fol_instantiation}\mimprovised
  We define \hyperref[con:schemas_and_instances]{atomic instantiations} for \hyperref[def:fol_formula_schema]{first-order formula schemas} as \hyperref[def:set_valued_map/partial]{partial maps} \( \BbbI \) sending \hyperref[def:fol_term_schema]{variable placeholders} to \hyperref[def:fol_term]{variables}, \hyperref[def:fol_term_schema]{term placeholders} to \hyperref[def:fol_term]{terms} and \hyperref[def:fol_formula_schema]{formula placeholders} to \hyperref[def:fol_formula]{formulas}.
\end{definition}

\begin{algorithm}[First-order term instantiation]\label{alg:fol_term_schema_instantiation}
  We extend the \hyperref[def:atomic_fol_instantiation]{atomic first-order instantiation} \( \BbbI \) to all \hyperref[def:fol_term_schema]{term schemas} straightforwardly:
  \begin{equation}\label{eq:alg:fol_term_schema_instantiation}
    \Tau[\BbbI] \coloneqq \begin{cases}
      \BbbI(\Tau),                                 &\Tau \T{is a variable placeholder},   \\
      \BbbI(\Tau),                                 &\Tau \T{is a term placeholder},       \\
      f(\Sigma_1[\BbbI], \ldots, \Sigma_n[\BbbI]), &\Tau = f(\Sigma_1, \ldots, \Sigma_n), \\
    \end{cases}
  \end{equation}
\end{algorithm}
\begin{comments}
  \item Of course, an application of an instantiation is only valid if the placeholders are in its domain.
  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_term_schema} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[First-order formula instantiation]\label{alg:fol_formula_schema_instantiation}
  We will extend the \hyperref[def:atomic_fol_instantiation]{atomic first-order instantiation} \( \BbbI \) to all \hyperref[def:fol_formula_schema]{formula schemas} with the aid of \fullref{alg:fol_term_schema_instantiation}:
  \begin{equation}\label{eq:alg:fol_formula_schema_instantiation}
    \Phi[\BbbI] \coloneqq \begin{cases}
      \Phi,                                       &\Phi \T{is a propositional constant},                                   \\
      \BbbI(\Phi),                                &\Phi \T{is a formula placeholder},                                      \\
                                                  &\vdots                                                                  \\
      \quantifier Q {\BbbI(x)} \Psi[\BbbI],       &\Phi = \quantifier Q x \Psi, Q \in \op*{Quant},                         \\
      \Phi[\BbbI][\BbbI(x) \mapsto \BbbI(y)],     &\Phi = \Phi[x \synsubst y^\ast],                                        \\
      \Phi[\BbbI][\BbbI(x) \mapsto \tau[\BbbI]],  &\Phi = \Phi[x \synsubst \tau] \T{and} \tau \T{is a term schema.}
    \end{cases}
  \end{equation}

  We have skipped half of the cases because they are obvious.
\end{algorithm}
\begin{comments}
  \item As in \fullref{alg:lambda_term_schema_instantiation}, we do not distinguish between with free and bound variable schemas.

  \item Eigenvariables do not affect the instantiation itself; they will play an important role in restrict certain constructions when defining proof trees in \cref{def:fol_natural_deduction_proof_tree}.

  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_substitution_spec} in \cite{notebook:code}.
\end{comments}

\paragraph{Abstract natural deduction}

\begin{definition}\label{def:fol_natural_deduction_system}\mimprovised
  An \term{abstract first-order natural deduction system} consists of a nonempty collection of \hyperref[def:natural_deduction_rule]{natural deduction rules} for \hyperref[def:fol_formula_schema]{extended first-order formula schemas} over the same \hyperref[def:fol_signature]{signature}. We require the rules to have distinct names, but otherwise impose no restrictions on them.
\end{definition}
\begin{comments}
  \item This definition extends \hyperref[def:propositional_natural_deduction_system]{propositional natural deduction systems}, because the first-order formula schemas are direct generalizations of their propositional counterparts.
\end{comments}

\begin{definition}\label{def:fol_natural_deduction_proof_tree}
  We will define \hyperref[con:proof_tree]{proof trees} for a fixed \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}.

  In fact, we will extend the proof tree for propositional logic defined in \cref{def:propositional_natural_deduction_proof_tree}.
  \begin{thmenum}[series=def:fol_natural_deduction_proof_tree]
    \thmitem{def:fol_natural_deduction_proof_tree/variables} Except for the conclusion, rule name, and list of open formulas, we attach to a proof tree a list of variables.

    Because of their role, we will call them \term{free variables} of the proof tree.
  \end{thmenum}

  Just as with assumption discharging, binding variables is also delicate to handle:
  \begin{thmenum}[resume=def:fol_natural_deduction_proof_tree]
    \thmitem{def:fol_natural_deduction_proof_tree/assumption} An assumption tree for a first-order formula \( \varphi \) with marker \( u \) is defined analogously to the propositional case, except that we must also handle free variables.

    We let the free variables of the tree be the free variables (in the sense of \cref{def:fol_variable_freeness}) of \( \varphi \).

    \thmitem{def:fol_natural_deduction_proof_tree/application} A rule application tree operates similarly to its propositional counterpart, but binding free variables has some caveats.

    Consider the rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Phi_1 }
        \hypo{ \cdots }

        \hypo{ [\Theta_i] }
        \infer[dashed]1{ \Phi_i }

        \hypo{ \cdots }
        \hypo{ \Phi_n }
        \infer5[\logic{R}]{ \Psi }
      \end{prooftree}
    \end{equation*}

    Let \( \BbbI \) be an \hyperref[def:atomic_fol_instantiation]{atomic schema instantiation} and a list \( (P_1, \ldots, P_n) \) of proof trees such that, for \( i = 1, \ldots, n \), the conclusion of \( P_i \) is \( \Phi_i[\BbbI] \). Note that, if \( \Phi_i \) features a substitution, we consider the conclusion of \( P_i \) to be the substituted formula.

    If the rule contains no eigenvariable schemas, we define an application tree by \hyperref[def:ordered_tree_grafting_product]{grafting} \( P_1, \ldots, P_n \) to a new root, as in the propositional case, and take the union of the free variables of the premises.

    Otherwise, we have the following additional restrictions. These are implemented programmatically in the function \identifier{math.logic.deduction.proof_tree.apply} in \cite{notebook:code}:
    \begin{thmenum}
      \thmitem{def:fol_natural_deduction_proof_tree/application/premise} If the premise \( \Phi_i \) is a substitution schema, i.e. if \( \Phi_i = \Omega[x \synsubst y^*] \), we impose the following restrictions:
      \begin{thmenum}
        \thmitem{def:fol_natural_deduction_proof_tree/application/premise/variable} Either \( \BbbI(y) \) must coincide with \( \BbbI(y) \) or otherwise \( \BbbI(y) \) must not be free in the \hi{formula} \( \Psi_i[\BbbI] \) (the conclusion of \( P_i \)).

        \thmitem{def:fol_natural_deduction_proof_tree/application/premise/assumptions} The variable \( \BbbI(y) \) must not be free in the \hi{premise subtree} \( P_i \).
      \end{thmenum}

      \thmitem{def:fol_natural_deduction_proof_tree/application/discharge} If the premise \( \Phi_i \) has a dischargeable schema \( \Theta_i \) attached, and if \( \Theta_i = \Omega[x \synsubst y^*] \), we impose the following restrictions:
      \begin{thmenum}
        \thmitem{def:fol_natural_deduction_proof_tree/application/discharge/variable} Either \( \BbbI(y) \) must coincide with \( \BbbI(x) \) or otherwise \( \BbbI(y) \) must not be free in the \hi{formula} \( \Omega[\BbbI] \) (the unsubstituted dischargeable premise).

        \thmitem{def:fol_natural_deduction_proof_tree/application/discharge/assumptions} The variable \( \BbbI(y) \) must not be free in the \hi{premise subtree} \( P_i \), except possibly in \( \Theta_i[\BbbI] \) (the substituted dischargeable premise).

        \thmitem{def:fol_natural_deduction_proof_tree/application/discharge/conclusion} Additionally, \( \BbbI(y) \) must not be free in the \hi{formula} \( \Psi_i[\BbbI] \) (the conclusion of \( P_i \)).
      \end{thmenum}
    \end{thmenum}

    In either of these cases, we say that the application \term{binds} the variable \( \BbbI(y) \) and remove it from the free variables. We also refer to \( \BbbI(y) \) as an \term{eigenvariable}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The handling of eigenvariables is needed to formalize the established natural deduction rules in \cref{def:fol_natural_deduction}.

  Their treatment is generalized from the two quantifier rules discussed in detail in \cite[\S 2.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

  \item Even though we do not disallow eigenvariables in the conclusion, they simply serve no purpose there.

  \item Natural deduction proof trees are implemented in the module \identifier{math.logic.deduction.proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:fol_natural_deduction_consequence}\mimprovised
  For every \hyperref[def:fol_natural_deduction_system]{first-order natural deduction system}, we define a \hyperref[def:consequence_relation]{consequence relation} as follows: we let \( \Gamma \vdash \varphi \) if there exists a \hyperref[def:fol_natural_deduction_proof_tree]{proof tree} with conclusion \( \varphi \) whose \hyperref[def:propositional_natural_deduction_proof_tree/open]{open assumptions} are all in \( \Gamma \).

  In accordance with \cref{def:general_logic}, we say that \( \varphi \) is \term{derivable} from \( \Gamma \) if this relation holds.
\end{definition}
\begin{defproof}
  We can prove that \( {\vdash} \) is indeed a consequence relation in complete analogy with the propositional case --- see \cref{def:propositional_natural_deduction_consequence}.
\end{defproof}

\begin{proposition}\label{thm:fol_natural_deduction_derivation_compact}
  Every \hyperref[def:fol_natural_deduction_consequence]{natural deduction entailment relation} is \hyperref[def:consequence_relation/compactness]{compact}.
\end{proposition}
\begin{comments}
  \item This is one of several compactness theorems presented here --- see \cref{rem:logical_compactness_theorems}.
\end{comments}
\begin{proof}
  A proof tree is can have at most finitely many assumptions.
\end{proof}

\paragraph{Concrete natural deduction}

\begin{definition}\label{def:fol_natural_deduction}\mimprovised
  We will now extend the rules for minimal, intuitionistic and classical systems for propositional natural deduction from \cref{def:propositional_natural_deduction}.

  \begin{thmenum}
    \thmitem{def:fol_natural_deduction/equality} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ =_+ }]{inf:def:fol_natural_deduction/equality/intro}
          \begin{prooftree}
            \infer0[\ref{inf:def:fol_natural_deduction/equality/intro}]{ \syn\tau \syneq \syn\tau }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ =_- }]{inf:def:fol_natural_deduction/equality/elim}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syn\tau] }
            \hypo{ \syn\tau \syneq \syn\sigma }
            \infer2[\ref{inf:def:hol_equality_rules/elim}]{ \syn\varphi[\synx \synsubst \syn\sigma] }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:fol_natural_deduction/forall}\mcite[36]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \forall_+ }]{inf:def:fol_natural_deduction/forall/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syny^*] }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall \synx \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \forall_- }]{inf:def:fol_natural_deduction/forall/elim}
          \begin{prooftree}
            \hypo{ \qforall \synx \syn\varphi }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ \syn\varphi[\synx \synsubst \syn\tau] }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:fol_natural_deduction/exists}\mcite[36]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for introducing and eliminating the \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantifier}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \exists_+ }]{inf:def:fol_natural_deduction/exists/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi[\synx \synsubst \syn\tau] }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists \synx \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \exists_- }]{inf:def:fol_natural_deduction/exists/elim}
          \begin{prooftree}
            \hypo{ \qexists \synx \syn\varphi }

            \hypo{ \syn\varphi[\synx \mapsto \syny^*] }
            \infer[dashed]1{ \syn\psi }

            \infer2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The quantifier rules are justified by rules for dependent types via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}; see \cref{ex:dependent_types_and_hol_quantifier_rules}.

  \item These precise rules are used in the module \identifier{logic.classical_logic} in \cite{notebook:code}.
\end{comments}

\begin{theorem}[First-order syntactic deduction theorem]\label{thm:fol_natural_deduction_deduction_theorem}
  With respect to \hyperref[def:fol_natural_deduction]{minimal first-order natural deduction}, for arbitrary formulas we have
  \begin{equation*}
    \Gamma, \varphi \vdash \psi \T{if and only if} \Gamma \vdash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item This is one of several deduction theorems presented here --- see \cref{rem:deduction_theorem_list}.
\end{comments}
\begin{proof}
  Follows by direct reuse of the proof trees from \fullref{thm:propositional_syntactic_deduction_theorem}.
\end{proof}

\begin{example}\label{ex:def:fol_natural_deduction}
  We list examples of the natural deduction rules from \cref{def:fol_natural_deduction}:
  \begin{thmenum}
    \thmitem{ex:def:fol_natural_deduction/verum} We can build the following simple proof trees via the quantifier rules:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:propositional_natural_deduction/top/intro}]{ \syntop }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall \synx \syntop }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:propositional_natural_deduction/top/intro}]{ \syntop }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists \synx \syntop }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    There are no free variables involved, so the eigenvariable conditions are satisfied vacuously.

    \thmitem{ex:def:fol_natural_deduction/reintroduction} The following trees, which reconstruct quantifier formulas, are slightly more complicated:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [\qforall x p(x)]^u }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/elim}]{ p(y) }
            \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall x p(x) }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [\qexists x p(x)]^u }
            \hypo{ [p(y)]^v }
            \infer[left label=\( v \)]2[\ref{inf:def:fol_natural_deduction/exists/elim}]{ p(z) }
            \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    In the left tree, \( y \) is an eigenvariable. It cannot occur freely in the derivation of \( p(y) \). This condition is satisfied since we start with a closed formula. Note that \( y \) can be any variable, including \( x \).

    In the right tree, \( y \) is also an eigenvariable, but is treated slightly differently because it is part of a dischargeable assumption. Namely, it is allowed to be free, but must be renamed when applying the elimination rule. We can rename it to any other variable except \( y \). When applying the introduction rule, we can again rename it to our liking and even use \( y \).

    \thmitem{ex:def:fol_natural_deduction/quantifier_duality}\mcite[example 2.1.4]{TroelstraSchwichtenberg2000BasicProofTheory} Via \fullref{thm:fol_semantic_deduction_theorem}, we can restate a special case of \eqref{thm:fol_quantifier_duality} as
    \begin{equation*}
      \synneg \qforall x \synneg p(x) \synimplies \qexists x p(x).
    \end{equation*}

    We can build a proof tree for this as follows:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\synneg \qforall x \synneg p(x)]^u }

        \hypo{ [\synneg \qexists x p(x)]^v }

        \hypo{ [p(x)]^w }
        \infer1[\ref{inf:def:fol_natural_deduction/exists/intro}]{ \qexists x p(x) }

        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
        \infer[left label=\( w \)]1[\ref{inf:def:propositional_natural_deduction/neg/intro}]{ \synneg p(x) }
        \infer1[\ref{inf:def:fol_natural_deduction/forall/intro}]{ \qforall x \synneg p(x) }
        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
        \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction/bot/raa}]{ \qexists x p(x) }

        \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \synneg \qforall x \synneg p(x) \synimplies \qexists x p(x) }
      \end{prooftree}
    \end{equation*}

    The introduction rule for \( \synforall \) is applicable because at that point \( x \) is no longer free in any open assumption --- even though it was initially free in \( [p(x)]^w \), this assumption was discharged.
  \end{thmenum}
\end{example}
\begin{comments}
  \item Many of these examples are verified programmatically in the module \identifier{math.logic.deduction.test_proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{def:abstract_sequent_calculus_system_eigenvariables}
  % \hyperref[con:predicate_logic]{predicate logic}, the entries must also account for \hyperref[def:fol_schema/formula]{eigenvariables}
\end{remark}

\begin{proposition}\label{thm:alpha_equivalent_forulas_are_interderivable}
\end{proposition}
