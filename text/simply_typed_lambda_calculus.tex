\section{Simply typed lambda calculus}\label{sec:simply_typed_lambda_calculus}

Unlike untyped lambda calculus, whose presentation is mostly uniform across authors, type theory has many incompatible flavors. We restrict ourselves to simple types with only function type constructors (the adjective \enquote{simple} is discussed in \fullref{rem:dependent_types}) and we introduce support for different type systems through signatures as defined in \fullref{def:simple_type_system}.

\paragraph{Term schemas}\hfill

We begin by presenting a basis for \hyperref[def:simple_type_system]{type rules}.

\begin{definition}\label{def:lambda_term_schema}
  Similarly to \hyperref[def:propositional_formula_schema]{propositional formula schemas}, we define schemas for \hyperref[def:lambda_term]{\( \synlambda \)-terms}:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{atom schema}          {\bnfpn{variable placeholder} \bnfor \bnfpn{constant}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Capital Latin identifier}}, \\
    \bnfprod{application schema}   {\bnftsq{\( ( \)} \bnfsp \bnfpn{term schema} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{abstraction schema}   {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable schema} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term schema}          {\bnfpn{atom schema} \bnfor \bnfpn{application schema} \bnfor} \\
    \bnfmore                       {\bnfpn{abstraction schema}}.
  \end{bnf*}
\end{definition}
\begin{comments}
  \item See \fullref{con:schemas_and_instances} for a discussion of schemas in general.

  \item This syntax does not allow us to distinguish between variables and variable placeholders, however the distinction should be quite clear from the context.

  \item Similarly to propositional formula schemas, we will denote arbitrary schemas via capital Greek identifiers like \( \Phi \).
\end{comments}

\begin{definition}\label{def:lambda_term_schema_instantiation}
  We will define instantiations for \hyperref[def:lambda_term_schema]{\( \synlambda \)-term schemas} similarly to \hyperref[def:propositional_schema_instantiation]{propositional schema substitutions}, as a \hyperref[def:set_valued_map/partial]{partial map} \( \sigma \) from \hyperref[def:lambda_term_schema]{variable placeholders} to \hyperref[def:lambda_term]{variables} and from \hyperref[def:lambda_term_schema]{\( \synlambda \)-term placeholders} to \hyperref[def:lambda_term]{\( \synlambda \)-terms}.

  We will not concern ourselves with \hyperref[def:lambda_variable_occurrence]{free and bound occurrence} of variables as for \hyperref[def:lambda_term_schema_substitution]{substitution}, but extend this map to arbitrary \( \synlambda \)-term schemas straightforwardly:
  \begin{equation*}
    \Phi[\sigma] \coloneqq \begin{cases}
      M,                               &M \T{is a constant}, \\
      \sigma(M),                       &M \T{is a variable}, \\
      \sigma(M),                       &M \T{is a placeholder}, \\
      N[\sigma] \thinspace K[\sigma],  &M = NK,              \\
      \qabs {\sigma(x)} N[\sigma],       &M = \qabs x N.       \\
    \end{cases}
  \end{equation*}

  Of course, \( \Phi[\sigma] \) is only valid if the variables and placeholders of \( \Phi \) are in the domain of \( \sigma \).
\end{definition}

\paragraph{Simple type systems}\hfill

\begin{definition}\label{def:simple_type_system}\mimprovised
  We will define several concepts, which we will collectively call a \term{simple type system} based on a \term{signature} \( \Sigma \). We will be able to formally define a signature in \fullref{def:simple_type_system/signature}.

  \begin{thmenum}[resume=def:simple_type_system]
    \thmitem{def:simple_type_system/base} Fix a (finite) nonempty \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Base}_\Sigma \), whose elements we will call \term{base types}. Without further context, we may assume that \( \op*{Base}_\Sigma \) contains only the following:
    \begin{thmenum}[series=def:simple_type_system/base]
      \thmitem{def:simple_type_system/base/propositions}\mcite[57]{Church1940STT} The \term{type of propositions} \( \synomicron \).
      \thmitem{def:simple_type_system/base/iota}\mcite[57]{Church1940STT} The \term{type of individuals} \( \syniota \) (Small Greek iota \( \iota \) with a dot).
    \end{thmenum}

    Note that, in accordance with \fullref{rem:object_language_dots/terminals}, we place dots over symbols in the object logic.

    Other useful base types include:
    \begin{thmenum}[resume=def:simple_type_system/base]
      \thmitem{def:simple_type_system/base/empty}\mcite[\S 4.3.4]{Mimram2020Types} The \term{empty type} \( \syn\Bbbzero \).
      \thmitem{def:simple_type_system/base/unit}\mcite[\S 4.3.2]{Mimram2020Types} The \term{unit type} \( \syn\Bbbone \).
    \end{thmenum}

    \thmitem{def:simple_type_system/const} Fix another, possibly empty, alphabet \( \op*{Const}_\Sigma \), whose entries we will use as \hyperref[def:lambda_term/const]{constant \( \synlambda \)-terms}.

    We will need the following constants based on Andrews' system \( \logic{Q}_0 \):
    \begin{thmenum}
      \thmitem{def:simple_type_system/const/equality}\mcite[208]{Andrews2002STT} The \term{equality term} \( \synQ \).
      \thmitem{def:simple_type_system/const/description}\mcite[208]{Andrews2002STT} The \term{definite description term} \( \synI \).
    \end{thmenum}

    \thmitem{def:simple_type_system/grammar} We now introduce the following \hyperref[def:formal_grammar/schema]{grammar schema} for types and type assertions connecting types with untyped \( \synlambda \)-terms:
    \begin{bnf*}
      \bnfprod{arrow type}     {\bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type}} \\
      \bnfprod{type}           {\bnfpn{base type} \bnfor \bnfpn{arrow type}} \\
      \bnfprod{type assertion} {\bnfpn{term} \bnfsp \bnftsq{\( : \)} \bnfsp \bnfpn{type}}
    \end{bnf*}

    Additionally, we will need schemas for the above, based on \hyperref[def:lambda_term_schema]{\( \synlambda \)-term schemas}:
    \begin{bnf*}
      \bnfprod{type placeholder}      {\bnfpn{Small Greek identifier}} \\
      \bnfprod{arrow type schema}     {\bnfpn{type schema} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type schema}} \\
      \bnfprod{type schema}           {\bnfpn{base type} \bnfor \bnfpn{type placeholder} \bnfor \bnfpn{arrow type schema}} \\
      \bnfprod{type assertion schema} {\bnfpn{term schema} \bnfsp \bnftsq{\( : \)} \bnfsp \bnfpn{type schema}}
    \end{bnf*}

    \thmitem{def:simple_type_system/rules} We define a \term{type rule} as an \hyperref[def:inference_rule]{inference rule} whose entries are type assertion schemas with auxiliary dischargeable assertion schemas allowed on the premises. We can formalize these auxiliary assertions just like how we allowed formula schemas to be attached to natural deduction rules --- see \fullref{def:abstract_propositional_natural_deduction_system}

    \thmitem{def:simple_type_system/types} We will denote by \( \op*{Types}_\Sigma \) the set of all types generated from \( \op*{Base}_\Sigma \).

    \thmitem{def:simple_type_system/context}\mcite[def. 2A5]{Hindley1997STT} A \term[en=type-context (\cite[def. 2A5]{Hindley1997STT})]{type context} is a \hyperref[def:logical_context]{logical context} whose entries are type assertions for \hi{distinct} \hi{variables}.

    We say that the assertion \( x: \tau \) is \term{consistent} with the context \( \Gamma \) if \( \Gamma \) contains no type assertion for \( x \).

    \thmitem{def:simple_type_system/signature} We can now define a \term{signature} \( \Sigma \) as a triple \( (\op*{Base}_\Sigma, \op*{Const}_\Sigma, \op*{Rules}_\Sigma) \), where \( \op*{Rules}_\Sigma \) is a set of type rules.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Of course, we usually skip subscripts since the signature is clear from the context.

  \item The overall idea of simply typed \( \synlambda \)-calculus with constants comes from Alonzo Church's \cite{Church1940STT}. There are substantial differences, however.

  Our definition is an amalgamation of the above with the following:
  \begin{itemize}
    \item We use Curry-style typing, meaning that we consider types to be a property of terms rather than a part of them. The distinction with Church's approach is discussed in \fullref{rem:church_and_curry_typing}.

    \item Type assertions and contexts are based on \cite[def. 2A4]{Hindley1997STT}. We prefer however the term \enquote{type assertion} to Hindley's \enquote{type assignment}.

    \incite[159]{Mimram2020Types} allows contexts to contain more than one type assertion per term and only considers the last assertion.

    \item Different languages based on the constants used are based on \cite[5]{Farmer2008STTVirtues}. We extend this by also including the base types in the language's signature.

    \item Having only two constants is based on the \hyperref[rem:named_logical_systems/q0]{system \( \logic{Q}_0 \)} by Church's student Peter Andrews, which he describes in \cite[\S 51]{Andrews2002STT}. Because we use Curry-style typing, however, we only introduce two constant terms and use type rules to correctly handle how they are used.

    \item We denote by \enquote{\( \syn\tau \synimplies \syn\rho \)} the arrow type that Church would denote by \( (\syn\rho\syn\tau) \). Our preference comes from the Curry-Howard correspondence discussed in \fullref{con:curry_howard_correspondence}. Our notation is used by \incite[def. 2A1]{Hindley1997STT}, \incite[\S 4.1.1]{Mimram2020Types} and \incite[def. 1.2.1]{TroelstraSchwichtenberg2000Proofs}, while Church's notation used by \incite[\S 51]{Andrews2002STT}.

    Additionally, we have a dedicated term for such types --- \enquote{arrow type} --- that is also used by \incite[\S 4.1.1]{Mimram2020Types}. Another candidate is \enquote{function type} used by \incite[def. 1.2.1]{TroelstraSchwichtenberg2000Proofs}, which we avoid because sets of functions are only one possible interpretation.

    \item Type rules were not considered by Church. We instead base our rules on \cite[\S 4.4.1]{Mimram2020Types}, but adapted in a form highlighting the relation to natural deduction.
  \end{itemize}
\end{comments}

\begin{remark}\label{rem:church_and_curry_typing}

\end{remark}

\begin{remark}\label{rem:dependent_types}
  \todo{Discuss dependent types}
\end{remark}

\begin{concept}\label{con:curry_howard_correspondence}
  \incite[479]{Howard1980FormulasAsTypes} observes that
  \begin{displayquote}
    H. Curry (1958) has observed that there is a close correspondence between \textit{axioms} of positive implicational propositional logic, on the one hand, and \textit{basic combinators} on the other hand. For example, the combinator \( K = \qabs X \qabs Y X \) corresponds to the axiom \( a \rightimply (b \rightimply a) \).
  \end{displayquote}

  The publication he refers to is \cite[312]{CurryFeys1958CombinatoryLogic}, where Curry begins the section with
  \begin{displayquote}
    We shall study here a striking analogy between the theory of and the theory of functionality and the theory of implication in propositional algebra.
  \end{displayquote}

  The core idea is that the type \( \tau \synimplies \rho \) can be regarded as a propositional formula, and its \hyperref[def:type_derivation_tree]{type derivation trees} then correspond to \hyperref[def:natural_deduction_proof_tree]{natural deduction proof trees}.

  These ideas are later developed and vastly amplified by Per Martin-L\"of, whose publication \cite{MartinLöf1975TypeTheory} introduces \enquote{dependent types} (see \fullref{rem:dependent_types}) for handling higher-order logic, at which Howard only hints. Because of the latter development, \enquote{intuitionistic type theory}, \enquote{dependent type theory} and \enquote{Martin-L\"of type theory} refer to this more abstract setting. \enquote{Simple type theory} continues to refer to the theory with only arrow types. Accidentally, the adjective \enquote{simple} is a contradistinction with Russell's type theory rather than Martin-L\"of's.

  We will call the overall concept of identifying types with formulas the \term{Curry-Howard correspondence}. This phrase is used by \incite[def. 4.1.7]{Mimram2020Types} and \incite[74]{Hindley1997STT}. An alternative suggested by Howard himself is \enquote{formulas-as-types correspondence}, also used by \incite[74]{Hindley1997STT}, \incite[\S 1.3.4]{TroelstraSchwichtenberg2000Proofs} and \incite[572]{Barendregt1984LambdaCalculus}, with another variation used by \incite[def. 4.1.7]{Mimram2020Types} being the \enquote{propositions-as-types correspondence}.

  We formalize the base ideas via \fullref{alg:proof_tree_to_type_derivation} and \fullref{alg:type_derivation_to_proof_tree}.
\end{concept}
\begin{comments}
  \item From the perspective of first-order logic, the correspondence is described in \incite[def. 5.1.11]{Mimram2020Types}.
\end{comments}
