\section{Curry-Howard correspondence}\label{sec:curry_howard_correspondence}

\begin{concept}\label{con:curry_howard_correspondence}
  \incite[479]{Howard1980FormulasAsTypes} writes
  \begin{displayquote}
    H. Curry (1958) has observed that there is a close correspondence between \textit{axioms} of positive implicational propositional logic, on the one hand, and \textit{basic combinators} on the other hand. For example, the combinator \( K = \qabs X \qabs Y X \) corresponds to the axiom \( a \rightimply (b \rightimply a) \).
  \end{displayquote}

  The publication he refers to is \cite[312]{CurryFeysCraig1958CombinatoryLogicVol1}, where Curry begins the section with
  \begin{displayquote}
    We shall study here a striking analogy between the theory of and the theory of functionality and the theory of implication in propositional algebra.
  \end{displayquote}

  Haskell Curry is credited for the realization that, in modern terms, the \hyperref[def:simple_type]{arrow type} \( \alpha \synimplies \rho \) can be regarded as a \hyperref[def:propositional_alphabet/connectives/conditional]{conditional formula}, and its \hyperref[def:type_derivation_tree]{type derivation trees} then correspond to \hyperref[def:natural_deduction_proof_tree]{natural deduction proof trees}. In \fullref{alg:proof_tree_to_type_derivation} and \fullref{alg:type_derivation_to_proof_tree}, we will extend this to conjunctions via \hyperref[def:product_type]{product types} and to disjunctions via \hyperref[def:sum_type]{sum types}.

  William Howard is credited for extending this analogy to \hyperref[sec:first_order_logic]{first-order logic} via what are now called \enquote{dependent types} (see \fullref{con:dependent_types}).

  Honoring them, we will refer to the overall identification of types and formulas as the \term[en=Curry-Howard correspondence (\cite[def. 4.1.7]{Mimram2020ProgramEqualsProof})]{Curry-Howard correspondence}.
\end{concept}
\begin{comments}
  \item From the perspective of first-order logic, the correspondence is described in \incite[def. 5.1.11]{Mimram2020ProgramEqualsProof}.

  \item Different authors refer to this concept slightly differently:
  \begin{itemize}
    \item This phrase \enquote{Curry-Howard correspondence} is used by \incite[45]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020ProgramEqualsProof}.

    \item \incite[341]{BarendregtDekkersStatman2013LambdaCalculusWithTypes} extends this to \enquote{Curry-de Bruijn-Howard correspondence}.

    \item A variation, the \enquote{Curry-Howard isomorphism}, is used by \incite[74]{Hindley1997BasicSTT} and \incite[14]{GirardEtAl1989ProofsAndTypes}.

    \item  An alternative suggested by Howard himself is \enquote{formulas-as-types correspondence}, also used by \incite[74]{Hindley1997BasicSTT}, \incite[\S 1.3.4]{TroelstraSchwichtenberg2000BasicProofTheory} and \incite[572]{Barendregt1984LambdaCalculus}.

    \item Another variation, the \enquote{propositions-as-types correspondence}, is used by \incite[def. 5.4.14]{Barendregt1992LambdaCalculiWithTypes}, as well as by the aforementioned \incite[prop. 6.3.11]{BarendregtDekkersStatman2013LambdaCalculusWithTypes}, \incite[8]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020ProgramEqualsProof}.
  \end{itemize}
\end{comments}

\paragraph{Extended simple type theory}\hfill

\begin{remark}\label{rem:extended_simple_type_theory}
  We will now use the sum and product types defined in \fullref{def:simple_type}, as well as the unit type and the empty type. Our end goal is to establish the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for propositional logic.

  Introducing more complicated types, for example for handling first-order and higher-order logic, is often done, in the tradition established by Per Martin-L\"of, via a stout list of metatheoretic \hyperref[def:inference_rule]{inference rules}. We describe the classification of these rules, as well as a list of eight rules for arrow types in \fullref{rem:type_theory_rule_classification}.

  Fortunately, for the types we will consider, we will be able to easily reuse the machinery we have built for untyped and simply typed \( \synlambda \)-calculus, with some small adjustments. See \fullref{rem:product_type_equality_rules} for a more concrete discussion. Another reason we avoid such rules is that they assume implicit \hyperref[con:equality]{definitional equality} of distinct terms, while we have spent considerable effort dealing with even \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}.

  We will still find useful the classification of rules, mostly because of the respective terminology. We will however only limit ourselves to introduction and elimination rules since we will not need the rest.
\end{remark}

\begin{remark}\label{rem:type_theory_rule_classification}
  \incite[24]{MartinLÃ¶f1984IntuitionisticTypeTheory} uses (metatheoretic) \hyperref[def:inference_rule]{inference rules} to build his entire type theory, without an underlying \hyperref[con:logical_system]{logical system} (or, rather, with only a minimalist one), and hence without \( \synlambda \)-calculus available. He classifies the different rules for each family of types as follows:
  \begin{thmenum}
    \thmitem{rem:type_theory_rule_classification/formation} A \term[en=formation (rule) (\cite[\S 8.1.9]{Mimram2020ProgramEqualsProof})]{type formation} rule allows us to introduce a new type given some premises.

    For example, in \fullref{def:simple_type}, we have introduced arrow types via the \hyperref[def:formal_grammar/schema]{formal grammar} rule
    \begin{bnf*}
      \bnfprod{arrow type} {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}}
    \end{bnf*}
    which we can recast using \hyperref[rem:type_universes]{type universes} as the inference rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \tau: \op*{Type}_n }
        \hypo{ \sigma: \op*{Type}_n }
        \infer2{ \tau \synimplies \sigma: \op*{Type}_n }
      \end{prooftree}
    \end{equation*}

    Note that, since the rules are part of the metalanguage, we do not try to formalize them and hence do not use the dot convention from \fullref{rem:object_language_dots}.

    \thmitem{rem:type_theory_rule_classification/introduction} An \term{introduction rule} specifies which terms \hyperref[def:type_habitation]{inhabit} a type from the family. In the words of Martin-L\"of, \enquote{The introduction rules say what are the canonical elements}.

    We have already used such a rule for arrow types --- \ref{inf:def:arrow_typing_rules/intro/explicit} for typed and \ref{inf:def:arrow_typing_rules/intro/implicit} for untyped terms. Unlike type formation rules, we have completely formalized these with the aid of placeholders. In the metalanguage, where placeholders are not needed, the first of them becomes
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [x: \tau] }
        \ellipsis {} { M: \sigma }
        \infer1{ \qabs {x^{\tau}} M: \tau \synimplies \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:type_theory_rule_classification/elimination} Conversely, an \term{elimination rule} allows us to deconstruct a term. In the words of Martin-L\"of, \enquote{The elimination rule shows how we may define functions on the set defined by the introduction rules}.

    Again, we have already used such a rule, \ref{inf:def:arrow_typing_rules/elim}, which we defined as
    \begin{equation*}
      \begin{prooftree}
        \hypo{ M: \tau \synimplies \sigma }
        \hypo{ N: \tau }
        \infer2{ M N: \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:type_theory_rule_classification/equality} Finally, an \term{equality rule} demonstrates compatibility of \hyperref[con:equality]{definitional equality} with the other rules.

    To enable substituting definitionally equal terms and types and making type derivation \hyperref[con:extensionality]{extensional}, we must introduce two rules. If, in accordance with \fullref{con:equality}, we denote the equality judgment
    \begin{center}
      \( x \) and \( y \) are definitionally equal terms of type \( \tau \)
    \end{center}
    by
    \begin{equation*}
      x \coloneqq y: \tau,
    \end{equation*}
    we can formulate the rules as follows:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M: \tau }
            \hypo{ \tau \coloneqq \tau': \op*{Type}_n }
            \infer2{ M: \tau' }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M \coloneqq M': \tau }
            \hypo{ \tau \coloneqq \tau': \op*{Type}_n }
            \infer2{ M \coloneqq M': \tau' }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Furthermore, to ensure that \( {\coloneqq} \) is an \hyperref[def:equivalence_relation]{equivalence relation}, we need inferences rules resembling those from \fullref{ex:recursively_defined_relation}:
    \columnratio{0.25,0.25,0.5}
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M: \tau }
            \infer1{ M \coloneqq M: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M \coloneqq N: \tau }
            \infer1{ N \coloneqq M: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M \coloneqq N: \tau }
            \hypo{ N \coloneqq K: \tau }
            \infer2{ M \coloneqq K: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}
    \columnratio{}

    These five \enquote{common} equality rules are given in \cite[433]{UnivalentProject2024OctoberHoTT} and, in a less refined form, they are also discussed by \incite[14,15]{MartinLÃ¶f1984IntuitionisticTypeTheory}.

    Unlike in Martin-L\"of's presentation, in \cite[27]{UnivalentProject2024OctoberHoTT}, the other equality rules are split into two kinds. \incite[\S 8.1.9]{Mimram2020ProgramEqualsProof} also distinguishes congruence rules, which the Univalent Foundations Project assumes implicit:
    \begin{thmenum}
      \thmitem{rem:type_theory_rule_classification/equality/computation} A \term{computation rule} expresses how an elimination rule acts on the corresponding canonical objects obtained from introduction rules.

      Such rules generalize \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} of untyped \( \synlambda \)-terms. For example, for arrow types we have
      \begin{equation*}
        \begin{prooftree}
          \hypo{ [x: \tau] }
          \ellipsis {} { M: \sigma }

          \hypo{ N: \tau }
          \infer2{ (\qabs {x^\tau} M) N \coloneqq M[x \mapsto N]: \sigma }.
        \end{prooftree}
      \end{equation*}

      \thmitem{rem:type_theory_rule_classification/equality/uniqueness} A \term{uniqueness rule} expresses how an arbitrary term of a given type can be expressed in the canonical form given by introduction rules.

      Such rules generalize \hyperref[def:beta_eta_reduction]{\( \eta \)-expansion} of untyped \( \synlambda \)-terms. For example, for arrow types we have
      \begin{equation*}
        \begin{prooftree}
          \hypo{ M: \tau \synimplies \sigma }
          \hypo{ x \T{is not free in} M }
          \infer2{ M \coloneqq \qabs {x^\tau} M x: \tau \synimplies \sigma }.
        \end{prooftree}
      \end{equation*}

      Note how, even though we equate a term with its expanded form, we regard this as an expansion rule rather than a reduction rule. The reasoning for this is that we should regard \( M \) as a \( \synlambda \)-abstraction in the canonical form \( \qabs {x^\tau} M x \), not the other way around.

      \thmitem{rem:type_theory_rule_classification/equality/congruence} Finally, a \term{congruence rule} simply propagates definitional equality.

      For example, we can formulate the following congruence rules for arrow types:
      \begin{equation*}
        \begin{prooftree}
          \hypo{ \tau \coloneqq \tau': \op*{Type}_n }
          \hypo{ \sigma \coloneqq \sigma': \op*{Type}_n }
          \infer2{ \tau \synimplies \sigma \coloneqq \tau' \synimplies \sigma': \op*{Type}_n }
        \end{prooftree}
      \end{equation*}

      \begin{paracol}{2}
        \begin{leftcolumn}
          \ParacolAlignmentHack
          \begin{equation*}
            \begin{prooftree}
              \hypo{ M \coloneqq M': \sigma }
              \infer1{ \qabs {x^{\tau}} M \coloneqq \qabs {x^{\tau}} M': \tau \synimplies \sigma }
            \end{prooftree}
          \end{equation*}
        \end{leftcolumn}

        \begin{rightcolumn}
          \ParacolAlignmentHack
          \begin{equation*}
            \begin{prooftree}
              \hypo{ M \coloneqq M': \tau \synimplies \sigma }
              \hypo{ N \coloneqq N': \tau }
              \infer2{ M N \coloneqq M' N': \sigma }
            \end{prooftree}
          \end{equation*}
        \end{rightcolumn}
      \end{paracol}
    \end{thmenum}
  \end{thmenum}
\end{remark}
\begin{comments}
  \item Our list of rules is based on the corresponding rules for dependent products in \incite{MartinLÃ¶f1984IntuitionisticTypeTheory}, \cite[\S A.2]{UnivalentProject2024OctoberHoTT} and \cite[\S 8.1.10]{Mimram2020ProgramEqualsProof}.

  \item In the cited lectures, Martin-L\"of refers to types as \enquote{sets} and to the corresponding rules as \enquote{set formation} rules, but in later works like \cite{MartinLÃ¶f1994TypeJudgments} he already shifts to \enquote{types} and \enquote{type formation}.
\end{comments}

\begin{definition}\label{def:empty_type}\mimprovised
  We designate a unique \hyperref[def:type_habitation]{uninhabited} type and, unsurprisingly, call it the \term[en=empty type (\cite[\S 4.3.4]{Mimram2020ProgramEqualsProof})]{empty type}. We denote it by \( \syn\Bbbzero \) and introduce it as a \hyperref[def:simple_type]{base type} of the \hyperref[def:simple_type_signature]{signature}, along with the constant term \( \synE_- \) and the following \hyperref[rem:type_theory_rule_classification/elimination]{elimination rule} based on \ref{inf:def:propositional_natural_deduction_systems/bot/efq}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbzero_- }]{inf:def:empty_type/elim}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbzero }
      \infer1[\ref{inf:def:empty_type/elim}]{ \synE_- \synM: \syn\tau }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item We have formulated the rule so that it resembles \ref{inf:def:propositional_natural_deduction_systems/bot/efq}. We do not forbid a variable to have type \( \syn\Bbbzero \), but provide a term of arbitrary type given such a variable.

  Due to the availability of \ref{inf:def:arrow_typing_rules/elim}, we could have just as well introduced the rule
  \begin{equation*}
    \begin{prooftree}
      \infer0{ \synE_-: \syn\Bbbzero \synimplies \syn\tau }
    \end{prooftree}
  \end{equation*}

  Unfortunately, both break the type uniqueness for typed terms shown in \fullref{thm:typed_term_habitation_uniqueness}. One way to mitigate this is to introduce a distinct constant \( \synE_-^\tau \) and distinct rule \( \syn\Bbbzero_-^\tau \) for every type \( \tau \), which would unfortunately complicate our formalization efforts. Due to our limited interest in the empty type, we avoid doing this.

  \item A simpler definition would be
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbzero }
      \infer1{ \synE_-: \syn\tau }
    \end{prooftree}
  \end{equation*}

  It has the drawback of \( \synE_- \) possibly having multiple types in the type context \( \synx: \syn\Bbbzero, \syny: \syn\Bbbzero \).

  \item A treatment of the empty type within simple type theory can be found in \cite[\S 4.3.4]{Mimram2020ProgramEqualsProof}.
\end{comments}

\begin{definition}\label{def:unit_type}\mimprovised
  Dually to the \hyperref[def:empty_type]{empty type}, we introduce the \term[en=unit type (\cite[\S 4.3.4]{Mimram2020ProgramEqualsProof})]{unit type} \( \syn\Bbbone \) with a unique inhabitant, the constant term \( \synU_+ \).

  There is an \hyperref[rem:type_theory_rule_classification/introduction]{introduction rule} and an \hyperref[rem:type_theory_rule_classification/introduction]{elimination rule} resembling the verum rules from \ref{inf:def:propositional_natural_deduction_systems/top}:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Bbbone_+ }]{inf:def:unit_type/intro}
        \begin{prooftree}
          \infer0[\ref{inf:def:unit_type/intro}]{ \synU_+: \syn\Bbbone }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Bbbone_- }]{inf:def:unit_type/elim}
        \begin{prooftree}
          \hypo{ [\synU_+: \Bbbone] }
          \ellipsis {} { \synM: \syn\tau }
          \infer1[\ref{inf:def:unit_type/elim}]{ \synM: \syn\tau }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item A treatment of the unit type within simple type theory can be found in \cite[\S 4.3.2]{Mimram2020ProgramEqualsProof}.

  \item In a more complicated typing system, forcing uniqueness can be done via the \hyperref[rem:type_theory_rule_classification/equality/uniqueness]{uniqueness rule}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbone }
      \infer1{ \synM \coloneqq \synU_+: \syn\Bbbone }
    \end{prooftree}
  \end{equation*}
\end{comments}

\begin{definition}\label{def:product_type}\mimprovised
  When defining the syntax of simple types in \fullref{def:simple_type}, we have defined the product type of \( \tau \) and \( \sigma \) as \( \tau \syntimes \sigma \). We will now introduce rules based on the encoding of \hyperref[def:ordered_tuple]{ordered pairs} discussed in \fullref{ex:def:beta_eta_reduction/pairs} and \fullref{ex:def:type_derivation_tree/pairs}. For this, we will need constant terms \( \synP_+ \), \( \synP_{-L} \) and \( \synP_{-R} \).

  Based on the natural deduction rules for conjunction formulas from \fullref{def:propositional_natural_deduction_systems/and}, we state one \hyperref[rem:type_theory_rule_classification/introduction]{introduction rule} and two \hyperref[rem:type_theory_rule_classification/elimination]{elimination rules}:
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \times_+ }]{inf:def:product_type/intro}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau }
          \hypo{ \synN: \syn\sigma }
          \infer2[\ref{inf:def:product_type/intro}]{ \synP_+ \synM \synN: \syn\tau \syntimes \syn\sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \times_{-L} }]{inf:def:product_type/elim_left}
        \begin{prooftree}
          \hypo{ \synK: \syn\tau \syntimes \syn\sigma }
          \infer1[\ref{inf:def:product_type/elim_left}]{ \synP_{-L} \synK: \syn\tau }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \times_{-R} }]{inf:def:product_type/elim_right}
        \begin{prooftree}
          \hypo{ \synK: \syn\tau \syntimes \syn\sigma }
          \infer1[\ref{inf:def:product_type/elim_right}]{ \synP_{-R} \synK: \syn\tau }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item A treatment of product types within simple type theory can be found in \cite[\S 4.3.1]{Mimram2020ProgramEqualsProof}.

  \item We discuss how equality rules and \( \beta\eta \)-reduction are related in \fullref{rem:product_type_equality_rules}.
\end{comments}

\begin{remark}\label{rem:product_type_equality_rules}
  In \fullref{ex:def:beta_eta_reduction/pairs}, we have shown that the \( \synlambda \)-terms \ref{ex:def:beta_eta_reduction/pairs/intro}, \ref{ex:def:beta_eta_reduction/pairs/elim_left} and \ref{ex:def:beta_eta_reduction/pairs/elim_right} enable the following \( \beta \)-reductions:
  \begin{align}\label{eq:rem:product_type_equality_rules/beta}
    P_{-L} (P_+ A B) \bred* A
    &&
    \T{and}
    &&
    P_{-R} (P_+ A B) \bred* B.
  \end{align}

  In \fullref{rem:delta_reduction}, we have shown how \hyperref[def:delta_reduction]{\( \delta \)-reduction} rules replacing the constant term \( \synP_+ \) with the corresponding combinator \ref{ex:def:beta_eta_reduction/pairs/intro}, and similarly for \( \synP_{-L} \) and \( \synP_{-R} \), allows us to use \( \beta\delta \)-reduction to deduce
  \begin{align*}
    \synP_{-L} (\synP_+ A B) \redrel*{\beta\delta} A
    &&
    \T{and}
    &&
    \synP_{-R} (\synP_+ A B) \redrel*{\beta\delta} B.
  \end{align*}

  We have discussed in \fullref{ex:def:type_derivation_tree/pairs} how these combinators are not, in general, \hyperref[def:typability]{typable}, using only arrow types. Having the rules from \fullref{def:product_type}, however, we know the corresponding constants are typable, and we can easily derive
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {} { A: \tau }

      \hypo{}
      \ellipsis {} { B: \sigma }

      \infer2[\ref{inf:def:product_type/intro}]{ \synP_+ AB: \tau \syntimes \sigma }

      \infer1[\ref{inf:def:product_type/elim_left}]{ \synP_{-L} (\synP_+ AB): \tau }
    \end{prooftree}
  \end{equation*}

  Thus, \( \synP_{-L} (\synP_+ AB) \) has the same type as \( A \) and it \( \beta\delta \)-reduces to \( A \).

  This diminishes the utility of adding \hyperref[rem:type_theory_rule_classification/equality/computation]{computation rules} for product types, which, as suggested in \cite[\S 4.3.1]{Mimram2020ProgramEqualsProof}, would simply mimic \( \beta \)-reduction:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}
        \begin{prooftree}
          \hypo{ A: \tau }
          \hypo{ B: \sigma }
          \infer2{ \synP_{-L} (\synP_+ AB) \coloneqq A: \tau }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}
        \begin{prooftree}
          \hypo{ A: \tau }
          \hypo{ B: \sigma }
          \infer2{ \synP_{-L} (\synP_+ AB) \coloneqq B: \sigma }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  There is one important downside related to \( \eta \)-reduction and \hyperref[rem:type_theory_rule_classification/equality/uniqueness]{uniqueness rules}, however. We could expect that
  \begin{equation}\label{eq:rem:product_type_equality_rules/eta}
    P_+ (P_{-L} M) (P_{-R} A) \redrel*{\beta\eta} A.
  \end{equation}

  \incite*[corr. 1.23]{Barendregt1974SurjectivePairing} demonstrates that there is no triple of untyped \( \synlambda \)-terms \( P_+ \), \( P_{-L} \) and \( P_{+R} \) satisfying \eqref{eq:rem:product_type_equality_rules/eta}.

  Barendregt calls a triple satisfying \eqref{eq:rem:product_type_equality_rules/beta} a \enquote{pairing}, and a triple additionally satisfying \eqref{eq:rem:product_type_equality_rules/eta} --- a \enquote{surjective pairing}. Thus, his result states that untyped \( \synlambda \)-calculus does not admit a surjective pairing, despite the obvious pairing shown in \fullref{ex:def:beta_eta_reduction/pairs}.

  Thus, even for simple types, adding new rules for either \( \beta\eta \)-reduction or for judgmental equality cannot be circumvented by a simpler mechanism such as \( \delta \)-reduction. This will unfortunately require us to reprove all results involving either \( \beta\eta \)-reduction or only \( \alpha \)-equivalence. So, our decision is to avoid new rules and to sacrifice \hyperref[con:extensionality]{extensionality} for the sake of simplicity.
\end{remark}

\begin{definition}\label{def:sum_type}\mimprovised
  Similarly to \hyperref[def:product_type]{product types}, we will introduce rules for the sum type \( \tau \synplus \sigma \) based on the discussion in \fullref{ex:def:beta_eta_reduction/disjoint} and \fullref{ex:def:type_derivation_tree/disjoint}. We will need the constants \( \synS_{+L} \), \( \synS_{+R} \) and \( \synS_- \) and three rules resembling the disjunction rules from \fullref{def:propositional_natural_deduction_systems/or}:
  \columnratio{0.25,0.25,0.5}
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ +_{+L} }]{inf:def:sum_type/intro_left}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau }
          \infer1[\ref{inf:def:sum_type/intro_left}]{ \synS_{+L} \synM: \syn\tau \synplus \syn\sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ +_{+R} }]{inf:def:sum_type/intro_right}
        \begin{prooftree}
          \hypo{ \synN: \syn\sigma }
          \infer1[\ref{inf:def:sum_type/intro_left}]{ \synS_{+R} \synN: \syn\tau \synplus \syn\sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ +_- }]{inf:def:sum_type/elim}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau \synplus \syn\sigma }
          \hypo{ [\synx: \syn\tau] }
          \ellipsis {} { \synN: \syn\rho }
          \hypo{ [\syny: \syn\sigma] }
          \ellipsis {} { \synK: \syn\rho }
          \infer3[\ref{inf:def:sum_type/elim}]{ \synS_- (\qabs {\synx^{\syn\tau}} \synN) (\qabs {\syny^{\syn\sigma}} \synK) \synM: \syn\rho }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
  \columnratio{}
\end{definition}
\begin{comments}
  \item A treatment of sum types within simple type theory can be found in \cite[\S 4.3.3]{Mimram2020ProgramEqualsProof}.

  \item As with the \hyperref[def:empty_type]{empty type}, unless we make the constants \( \synS_{+L} \) and \( \synS_{+R} \) depend on the types of the terms, we break the type uniqueness for typed terms shown in \fullref{thm:typed_term_habitation_uniqueness}. Again, this is a sacrifice for the sake of simplicity of our formalized system.

  \item We discuss how equality rules and \( \beta\eta \)-reduction are related in \fullref{rem:sum_type_equality_rules}.
\end{comments}

\begin{remark}\label{rem:sum_type_equality_rules}
  Similarly to product types, we can use \( \beta\delta \)-reduction to emulate \hyperref[rem:type_theory_rule_classification/equality/computation]{computation rules}. See \fullref{rem:product_type_equality_rules} for a broader discussion of the general idea.

  In our case, given \( M: \tau \), we have
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {} { M: \tau }
      \infer1[\ref{inf:def:sum_type/intro_left}]{ \synS_{+L} M: \tau \syntimes \rho }

      \hypo{ [x: \tau] }
      \ellipsis {} { N: \rho }

      \hypo{ [y: \sigma] }
      \ellipsis {} { K: \rho }

      \infer3[\ref{inf:def:sum_type/elim}]{ \synS_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) (\synS_{+L} M): \rho }
    \end{prooftree}
  \end{equation*}

  We can reduce the latter based on our discussion in \fullref{ex:def:beta_eta_reduction/disjoint}:
  \begin{align*}
    &\phantom{{}\bred*{}}
    \synS_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) (\synS_{+L} M)
    \dred* \\ &\dred*
    S_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) (S_{+L} M)
    \bred* \\ &\bred*
    (\qabs {x^\tau} N) M
    \bred \\ &\bred
    N[x \mapsto M].
  \end{align*}

  \Fullref{alg:simply_typed_reduction} allows deriving the same type \( \rho \) for \( N \) and \( N[x \mapsto M] \) from the derivation of \( \tau \) for \( M \). Thus, again, we can emulate computation rules via reduction.

  Unlike for product types, a \hyperref[rem:type_theory_rule_classification/equality/uniqueness]{uniqueness rule} here is more complicated conceptually:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ M: \tau \synplus \sigma }
      \infer1{ M \coloneqq \synS_- \synS_{+L} \synS_{+R} M }
    \end{prooftree}
  \end{equation*}

  We can regard the positive constants as inclusion terms with types \( \synS_{+L}: \tau \synimplies (\tau \synplus \sigma) \) and \( \synS_{+R}: \sigma \synimplies (\tau \synplus \sigma) \), and the entire term as a conditional based on \( M \).
\end{remark}

\begin{concept}\label{con:identity_types}
  \todo{Identity types}

  Martin-L\"of distinguishes between several kinds of equality and introduces \enquote{identity types} (see \fullref{con:identity_types}), allowing him to develop his \enquote{intuitionistic type theory} --- a fusion of type theory and higher-order logic based on the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}. His theory first appears as \cite{MartinLÃ¶f1975IntuitionisticTypeTheory} and, in a more refined later form, can be found in \cite{MartinLÃ¶f1984IntuitionisticTypeTheory}.
\end{concept}

\begin{concept}\label{con:dependent_types}
  \todo{Discuss dependent types}

  \Fullref{thm:set_of_all_functions_via_cartesian_product}.
\end{concept}

\begin{remark}\label{rem:dependent_type_theory}
  Because of this latter development, \enquote{intuitionistic type theory}, \enquote{dependent type theory} and \enquote{Martin-L\"of type theory} refer to this more abstract setting. \enquote{Simple type theory} continues to refer to the theory with only arrow types. Accidentally, the adjective \enquote{simple} is a contradistinction with Russell's type theory rather than Martin-L\"of's.
\end{remark}

\paragraph{Curry-Howard correspondence}\hfill

\begin{example}\label{ex:con:curry_howard_correspondence}
  We list examples related to the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}:
  \begin{thmenum}
    \thmitem{ex:con:curry_howard_correspondence/minimal_implicational}
  \end{thmenum}
\end{example}

\begin{algorithm}\label{alg:type_derivation_to_proof_tree}
\end{algorithm}

\begin{algorithm}\label{alg:proof_tree_to_type_derivation}
\end{algorithm}
