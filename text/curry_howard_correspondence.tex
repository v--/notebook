\section{Curry-Howard correspondence}\label{sec:curry_howard_correspondence}

\begin{concept}\label{con:curry_howard_correspondence}
  \incite[479]{Howard1980FormulasAsTypes} writes
  \begin{displayquote}
    H. Curry (1958) has observed that there is a close correspondence between \textit{axioms} of positive implicational propositional logic, on the one hand, and \textit{basic combinators} on the other hand. For example, the combinator \( K = \qabs X \qabs Y X \) corresponds to the axiom \( a \rightimply (b \rightimply a) \).
  \end{displayquote}

  The publication he refers to is \cite[312]{CurryFeysCraig1958CombinatoryLogicVol1}, where Curry begins the section with
  \begin{displayquote}
    We shall study here a striking analogy between the theory of and the theory of functionality and the theory of implication in propositional algebra.
  \end{displayquote}

  Haskell Curry is credited for the realization that, in modern terms, the \hyperref[def:simple_type]{arrow type} \( \alpha \synimplies \rho \) can be regarded as a \hyperref[def:propositional_alphabet/connectives/conditional]{conditional formula}, and its \hyperref[def:type_derivation_tree]{type derivation trees} then correspond to \hyperref[def:natural_deduction_proof_tree]{natural deduction proof trees}. In \fullref{alg:proof_tree_to_type_derivation} and \fullref{alg:type_derivation_to_proof_tree}, we will extend this to conjunctions via \hyperref[def:product_type]{product types} and to disjunctions via \hyperref[def:sum_type]{sum types}.

  William Howard is credited for extending this analogy to \hyperref[sec:first_order_logic]{first-order logic} via what are now called \enquote{dependent types} (see \fullref{con:dependent_types}).

  Honoring them, we will refer to the overall identification of types and formulas as the \term[en=Curry-Howard correspondence (\cite[def. 4.1.7]{Mimram2020ProgramEqualsProof})]{Curry-Howard correspondence}.
\end{concept}
\begin{comments}
  \item From the perspective of first-order logic, the correspondence is described in \incite[def. 5.1.11]{Mimram2020ProgramEqualsProof}.

  \item Different authors refer to this concept slightly differently:
  \begin{itemize}
    \item This phrase \enquote{Curry-Howard correspondence} is used by \incite[45]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020ProgramEqualsProof}.

    \item \incite[341]{BarendregtDekkersStatman2013LambdaCalculusWithTypes} extends this to \enquote{Curry-de Bruijn-Howard correspondence}.

    \item A variation, the \enquote{Curry-Howard isomorphism}, is used by \incite[74]{Hindley1997BasicSTT} and \incite[14]{GirardEtAl1989ProofsAndTypes}.

    \item  An alternative suggested by Howard himself is \enquote{formulas-as-types correspondence}, also used by \incite[74]{Hindley1997BasicSTT}, \incite[\S 1.3.4]{TroelstraSchwichtenberg2000BasicProofTheory} and \incite[572]{Barendregt1984LambdaCalculus}.

    \item Another variation, the \enquote{propositions-as-types correspondence}, is used by \incite[def. 5.4.14]{Barendregt1992LambdaCalculiWithTypes}, as well as by the aforementioned \incite[prop. 6.3.11]{BarendregtDekkersStatman2013LambdaCalculusWithTypes}, \incite[8]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020ProgramEqualsProof}.
  \end{itemize}
\end{comments}

\paragraph{Extended simple type theory}\hfill

\begin{remark}\label{rem:extended_simple_type_theory}
  We will now use the sum and product types defined in \fullref{def:simple_type}, as well as the unit type and the empty type. Our end goal is to establish the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for propositional logic.

  Introducing more complicated types, for example for handling first-order and higher-order logic, is often done, in the tradition established by Per Martin-L\"of, via a stout list of metatheoretic \hyperref[def:inference_rule]{inference rules}. We describe the classification of these rules, as well as a list of eight rules for arrow types in \fullref{rem:type_theory_rule_classification}.

  Fortunately, for the types we will consider, it will be sufficient to reuse the machinery we have built for untyped and simply typed \( \synlambda \)-calculus, with some small adjustments. We will still find useful the classification of rules, mostly because of the respective terminology. We will however only limit ourselves to introduction and elimination rules since we will not need the rest.
\end{remark}

\begin{remark}\label{rem:type_theory_rule_classification}
  \incite[24]{MartinLöf1984IntuitionisticTypeTheory} uses (metatheoretic) \hyperref[def:inference_rule]{inference rules} to build his entire type theory. He classifies the different rules for each family of types as follows:
  \begin{thmenum}
    \thmitem{rem:type_theory_rule_classification/formation} A \term[en=formation (rule) (\cite[\S 8.1.9]{Mimram2020ProgramEqualsProof})]{type formation} rule allows us to introduce a new type given some premises.

    For example, in \fullref{def:simple_type}, we have introduced arrow types via the \hyperref[def:formal_grammar/schema]{formal grammar} rule
    \begin{bnf*}
      \bnfprod{arrow type} {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}}
    \end{bnf*}
    which we can recast using \hyperref[rem:type_universes]{type universes} as the inference rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \tau: \op*{Type}_n }
        \hypo{ \sigma: \op*{Type}_n }
        \infer2{ \tau \synimplies \sigma: \op*{Type}_n }
      \end{prooftree}
    \end{equation*}

    Note that, since the rules are part of the metalanguage, we do not try to formalize them and hence do not use the dot convention from \fullref{rem:object_language_dots}.

    \thmitem{rem:type_theory_rule_classification/introduction} An \term{introduction rule} specifies which terms \hyperref[def:type_habitation]{inhabit} a type from the family. In the words of Martin-L\"of, \enquote{The introduction rules say what are the canonical elements}.

    We have already used such a rule for arrow types --- \ref{inf:def:arrow_typing_rules/intro/explicit} for typed and \ref{inf:def:arrow_typing_rules/intro/implicit} for untyped terms. Unlike type formation rules, we have completely formalized these with the aid of placeholders. In the metalanguage, where placeholders are not needed, the first of them becomes
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [x: \tau] }
        \ellipsis {} { M: \sigma }
        \infer1{ \qabs {x^{\tau}} M: \tau \synimplies \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:type_theory_rule_classification/elimination} Conversely, an \term{elimination rule} allows us to deconstruct a term. In the words of Martin-L\"of, \enquote{The elimination rule shows how we may define functions on the set defined by the introduction rules}.

    Again, we have already used such a rule, \ref{inf:def:arrow_typing_rules/elim}, which we defined as
    \begin{equation*}
      \begin{prooftree}
        \hypo{ M: \tau \synimplies \sigma }
        \hypo{ N: \tau }
        \infer2{ M N: \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:type_theory_rule_classification/equality} Finally, an \term{equality rule} demonstrates compatibility of \hyperref[con:equality]{definitional equality} with the other rules.

    To enable substituting definitionally equal terms and types and making type derivation \hyperref[con:extensionality]{extensional}, we must introduce two rules. If, in accordance with \fullref{con:equality}, we denote the equality judgment
    \begin{center}
      \( x \) and \( y \) are definitionally equal terms of type \( \tau \)
    \end{center}
    by
    \begin{equation*}
      x \coloneqq y: \tau,
    \end{equation*}
    we can formulate the rules as follows:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M: \tau }
            \hypo{ \tau \coloneqq \tau': \op*{Type}_n }
            \infer2{ M: \tau' }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M \coloneqq M': \tau }
            \hypo{ \tau \coloneqq \tau': \op*{Type}_n }
            \infer2{ M \coloneqq M': \tau' }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Furthermore, to ensure that \( {\coloneqq} \) is an \hyperref[def:equivalence_relation]{equivalence relation}, we need inferences rules resembling those from \fullref{ex:recursively_defined_relation}:
    \columnratio{0.25,0.25,0.5}
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M: \tau }
            \infer1{ M \coloneqq M: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M \coloneqq N: \tau }
            \infer1{ N \coloneqq M: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ M \coloneqq N: \tau }
            \hypo{ N \coloneqq K: \tau }
            \infer2{ M \coloneqq K: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}
    \columnratio{}

    These five \enquote{common} equality rules are given in \cite[433]{UnivalentProject2024OctoberHoTT} and, in a less refined form, they are also discussed by \incite[14,15]{MartinLöf1984IntuitionisticTypeTheory}.

    Unlike in Martin-L\"of's presentation, in \cite[27]{UnivalentProject2024OctoberHoTT}, the other equality rules are split into two kinds. \incite[\S 8.1.9]{Mimram2020ProgramEqualsProof} also distinguishes congruence rules, which the Univalent Foundations Project assumes implicit:
    \begin{thmenum}
      \thmitem{rem:type_theory_rule_classification/equality/computation} A \term{computation rule} expresses how an elimination rule acts on the corresponding canonical objects obtained from introduction rules.

      Such rules generalize \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} of untyped \( \synlambda \)-terms. For example, for arrow types we have
      \begin{equation*}
        \begin{prooftree}
          \hypo{ [x: \tau] }
          \ellipsis {} { M: \sigma }

          \hypo{ N: \tau }
          \infer2{ (\qabs {x^\tau} M) N \coloneqq M[x \mapsto N]: \sigma }.
        \end{prooftree}
      \end{equation*}

      \thmitem{rem:type_theory_rule_classification/equality/uniqueness} A \term{uniqueness rule} expresses how an arbitrary term of a given type can be expressed in the canonical form given by introduction rules.

      Such rules generalize \hyperref[def:beta_eta_reduction]{\( \eta \)-expansion} of untyped \( \synlambda \)-terms. For example, for arrow types we have
      \begin{equation*}
        \begin{prooftree}
          \hypo{ M: \tau \synimplies \sigma }
          \hypo{ x \T{is not free in} M }
          \infer2{ M \coloneqq \qabs {x^\tau} M x: \tau \synimplies \sigma }.
        \end{prooftree}
      \end{equation*}

      Note how, even though we equate a term with its expanded form, we regard this as an expansion rule rather than a reduction rule. The reasoning for this is that we should regard \( M \) as an \( \synlambda \)-abstraction in the canonical form \( \qabs {x^\tau} M x \), not the other way around.

      \thmitem{rem:type_theory_rule_classification/equality/congruence} Finally, a \term{congruence rule} simply propagates definitional equality.

      For example, we can formulate the following congruence rules for arrow types:
      \begin{equation*}
        \begin{prooftree}
          \hypo{ \tau \coloneqq \tau': \op*{Type}_n }
          \hypo{ \sigma \coloneqq \sigma': \op*{Type}_n }
          \infer2{ \tau \synimplies \sigma \coloneqq \tau' \synimplies \sigma': \op*{Type}_n }
        \end{prooftree}
      \end{equation*}

      \begin{paracol}{2}
        \begin{leftcolumn}
          \ParacolAlignmentHack
          \begin{equation*}
            \begin{prooftree}
              \hypo{ M \coloneqq M': \sigma }
              \infer1{ \qabs {x^{\tau}} M \coloneqq \qabs {x^{\tau}} M': \tau \synimplies \sigma }
            \end{prooftree}
          \end{equation*}
        \end{leftcolumn}

        \begin{rightcolumn}
          \ParacolAlignmentHack
          \begin{equation*}
            \begin{prooftree}
              \hypo{ M \coloneqq M': \tau \synimplies \sigma }
              \hypo{ N \coloneqq N': \tau }
              \infer2{ M N \coloneqq M' N': \sigma }
            \end{prooftree}
          \end{equation*}
        \end{rightcolumn}
      \end{paracol}
    \end{thmenum}
  \end{thmenum}
\end{remark}
\begin{comments}
  \item Our list of rules is based on the corresponding rules for dependent products in \incite{MartinLöf1984IntuitionisticTypeTheory}, \cite[\S A.2]{UnivalentProject2024OctoberHoTT} and \cite[\S 8.1.10]{Mimram2020ProgramEqualsProof}.

  \item In the cited lectures, Martin-L\"of refers to types as \enquote{sets} and to the corresponding rules as \enquote{set formation} rules, but in later works like \cite{MartinLöf1994TypeJudgments} he already shifts to \enquote{types} and \enquote{type formation}.
\end{comments}

\begin{definition}\label{def:empty_type}\mimprovised
  We designate a unique \hyperref[def:type_habitation]{uninhabited} type and, unsurprisingly, call it the \term[en=empty type (\cite[\S 4.3.4]{Mimram2020ProgramEqualsProof})]{empty type}. We denote it by \( \syn\Bbbzero \) and, if needed, we introduce it as a \hyperref[def:simple_type]{base type} of the \hyperref[def:simple_type_signature]{signature}, along with the constant term \( \synA_- \), and the following \hyperref[rem:type_theory_rule_classification/elimination]{elimination rule}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbzero_- }]{inf:def:empty_type/elim}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbzero }
      \infer1[\ref{inf:def:empty_type/elim}]{ \synA_- \synM: \syn\tau }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item We have formulated the rule so that it resembles \ref{inf:def:propositional_natural_deduction_systems/bot/efq}. Due to the availability of \ref{inf:def:arrow_typing_rules/elim}, we could have just as well introduced the rule
  \begin{equation*}
    \begin{prooftree}
      \infer0{ \synA_-: \syn\Bbbzero \synimplies \syn\tau }
    \end{prooftree}
  \end{equation*}

  Another possibility is
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbzero }
      \infer1{ \synA_-: \syn\tau }
    \end{prooftree}
  \end{equation*}

  Unfortunately, all of those break the uniqueness for simple types shown in \fullref{thm:typed_term_habitation_uniqueness}. One way to mitigate this is to introduce a distinct constant \( \synA_-^\tau \) and distinct rule \( \Bbbzero_-^\tau \) for every type \( \tau \), which would unfortunately complicate our formalization efforts. Due to our limited interest in the empty type, we avoid doing so.

  \item A treatment of the empty type within simple type theory can be found in \cite[\S 4.3.4]{Mimram2020ProgramEqualsProof}.
\end{comments}

\begin{definition}\label{def:unit_type}\mcite[\S 4.3.2]{Mimram2020ProgramEqualsProof}
  The \term{unit type} \( \syn\Bbbone \).
\end{definition}

\begin{definition}\label{def:product_type}
\end{definition}

\begin{definition}\label{def:sum_type}
\end{definition}

\begin{concept}\label{con:identity_types}
  \todo{Identity types}

  Martin-L\"of distinguishes between several kinds of equality and introduces \enquote{identity types} (see \fullref{con:identity_types}), allowing him to develop his \enquote{intuitionistic type theory} --- a fusion of type theory and higher-order logic based on the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}. His theory first appears as \cite{MartinLöf1975IntuitionisticTypeTheory} and, in a more refined later form, can be found in \cite{MartinLöf1984IntuitionisticTypeTheory}.
\end{concept}

\begin{concept}\label{con:homotopy_type_theory}
  \todo{Homotopy type theory}
\end{concept}

\begin{concept}\label{con:dependent_types}
  \todo{Discuss dependent types}

  \Fullref{thm:set_of_all_functions_via_cartesian_product}.
\end{concept}

\begin{remark}\label{rem:dependent_type_theory}
  Because of this latter development, \enquote{intuitionistic type theory}, \enquote{dependent type theory} and \enquote{Martin-L\"of type theory} refer to this more abstract setting. \enquote{Simple type theory} continues to refer to the theory with only arrow types. Accidentally, the adjective \enquote{simple} is a contradistinction with Russell's type theory rather than Martin-L\"of's.
\end{remark}

\paragraph{Curry-Howard correspondence}\hfill

\begin{example}\label{ex:con:curry_howard_correspondence}
  We list examples related to the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}:
  \begin{thmenum}
    \thmitem{ex:con:curry_howard_correspondence/minimal_implicational}
  \end{thmenum}
\end{example}

\begin{algorithm}\label{alg:type_derivation_to_proof_tree}
\end{algorithm}

\begin{algorithm}\label{alg:proof_tree_to_type_derivation}
\end{algorithm}
