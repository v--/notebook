\section{Curry-Howard correspondence}\label{sec:curry_howard_correspondence}

\begin{concept}\label{con:curry_howard_correspondence}
  \incite[479]{Howard1980FormulasAsTypes} writes
  \begin{displayquote}
    H. Curry (1958) has observed that there is a close correspondence between \textit{axioms} of positive implicational propositional logic, on the one hand, and \textit{basic combinators} on the other hand. For example, the combinator \( K = \qabs X \qabs Y X \) corresponds to the axiom \( a \rightimply (b \rightimply a) \).
  \end{displayquote}

  The publication he refers to is \cite[312]{CurryFeysCraig1958CombinatoryLogicVol1}, where Curry begins the section with
  \begin{displayquote}
    We shall study here a striking analogy between the theory of and the theory of functionality and the theory of implication in propositional algebra.
  \end{displayquote}

  Haskell Curry is credited for the realization that, in modern terms, the \hyperref[def:arrow_type]{arrow type} \( \tau \synimplies \rho \) can be regarded as a \hyperref[def:propositional_alphabet/connectives/conditional]{conditional formula}. In this section will extend this to \hyperref[def:simple_algebraic_types]{simple algebraic types}.

  William Howard is credited for extending this analogy to \hyperref[sec:first_order_logic]{first-order logic} via what are now called \enquote{dependent types}. We discuss these extensions in \fullref{rem:mltt_hol}.

  Honoring Curry and Howard, we will refer to the overall identification of types and formulas as the \term[en=Curry-Howard correspondence (\cite[def. 4.1.7]{Mimram2020ProgramEqualsProof})]{Curry-Howard correspondence}.

  An even deeper connection comes from the realization that \hyperref[def:type_derivation_tree]{type derivation trees} correspond to \hyperref[def:natural_deduction_proof_tree]{natural deduction proof trees}. This idea was investigated briefly by both Curry and Haskell, and later developed by Per Martin-L\"of, who, when discussing \hyperref[con:proposition]{propositions} in \cite[76]{MartinLöf1975IntuitionisticTypeTheory}, states that
  \begin{displayquote}
    In the present context, however, it will not be necessary to introduce the notion of proposition as a separate notion because we can represent each proposition by a certain type, namely, the type of proofs of that proposition.
  \end{displayquote}
\end{concept}
\begin{comments}
  \item From the perspective of first-order logic, the correspondence is described in \incite[def. 5.1.11]{Mimram2020ProgramEqualsProof}.

  \item Different authors refer to this concept slightly differently:
  \begin{itemize}
    \item This phrase \enquote{Curry-Howard correspondence} is used by \incite[45]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020ProgramEqualsProof}.

    \item A variation, the \enquote{Curry-Howard isomorphism}, is used by \incite[74]{Hindley1997BasicSTT} and \incite[14]{GirardEtAl1989ProofsAndTypes}.

    \item An alternative suggested by Howard himself is \enquote{formulas-as-types correspondence}, also used by \incite[74]{Hindley1997BasicSTT}, \incite[\S 1.3.4]{TroelstraSchwichtenberg2000BasicProofTheory} and \incite[572]{Barendregt1984LambdaCalculus}.

    \item Another variation, the \enquote{propositions-as-types correspondence}, is used by \incite[def. 5.4.14]{Barendregt1992LambdaCalculiWithTypes}, as well as by the aforementioned \incite[8]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020ProgramEqualsProof}.
  \end{itemize}
\end{comments}

\begin{remark}\label{rem:type_theory_rule_classification}
  \incite[24]{MartinLöf1984IntuitionisticTypeTheory} uses (metatheoretic) \hyperref[def:inference_rule]{inference rules} to build his entire type theory, without an underlying \hyperref[con:logical_system]{logical system} (or, rather, with only a minimalist one), and hence without \( \muplambda \)-calculus available.

  He associates with each distinguished family of types (except the variables) a symbol, which induces a type forming operation (type constructor) in the sense of \fullref{con:type_constructor}.

  Martin-L\"of classifies the different rules for each family as follows:
  \begin{thmenum}
    \thmitem{rem:type_theory_rule_classification/form} A \term[en=formation (rule) (\cite[\S 8.1.9]{Mimram2020ProgramEqualsProof})]{type formation} rule allows us to introduce a new type given some premises by describing \enquote{how to use} the type forming operation.

    For example, in \fullref{def:simple_type}, we have introduced arrow types via the \hyperref[def:formal_grammar/schema]{formal grammar} rule
    \begin{bnf*}
      \bnfprod{arrow type} {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}}
    \end{bnf*}
    which we can recast as the inference rule using a fixed \hyperref[con:type_universe]{type universe} \( \BbbT \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \tau: \BbbT }
        \hypo{ \sigma: \BbbT }
        \infer2[\ensuremath{ \rightarrow_{\logic{form}} }]{ \tau \synimplies \sigma: \BbbT }
      \end{prooftree}
    \end{equation*}

    Note that, since the rules are part of the metalanguage, we do not try to formalize them and hence do not use formalized schemas. Here \( \tau \) and \( \sigma \) are metalogical variables.

    \thmitem{rem:type_theory_rule_classification/intro} An \term{introduction rule} specifies which terms \hyperref[def:type_habitation]{inhabit} a type from the family. In the words of Martin-L\"of, \enquote{The introduction rules say what are the canonical elements}.

    We have already used such a rule for arrow types --- \ref{inf:def:arrow_type/intro/explicit} for typed and \ref{inf:def:arrow_type/intro/implicit} for untyped terms. Unlike type formation rules, we have completely formalized these with the aid of placeholders. When encoded informally in the metalanguage, the first of them becomes
    \begin{equation*}
      \begin{prooftree}
        \hypo{ x: \tau }
        \infer[dashed]1{ M: \sigma }
        \infer1[\ensuremath{ \rightarrow_+ }]{ \qabs {x^{\tau}} M: \tau \synimplies \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:type_theory_rule_classification/elim} Conversely, an \term{elimination rule} allows us to deconstruct a term. In the words of Martin-L\"of, \enquote{The elimination rule shows how we may define functions on the set defined by the introduction rules}.

    Again, we have already used such a rule, \ref{inf:def:arrow_type/elim}, which we defined as
    \begin{equation*}
      \begin{prooftree}
        \hypo{ M: \tau \synimplies \sigma }
        \hypo{ N: \tau }
        \infer2[\ensuremath{ \rightarrow_- }]{ M N: \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{rem:type_theory_rule_classification/equality} Finally, an \term{equality rule} demonstrates compatibility of \hyperref[con:equality]{definitional equality} with the other rules.

    To enable substituting definitionally equal terms and types and making type derivation \hyperref[con:extensionality]{extensional}, we must introduce two rules. If, in accordance with \fullref{con:equality}, we denote the equality judgment
    \begin{center}
      \( x \) and \( y \) are definitionally equal terms of type \( \tau \)
    \end{center}
    by
    \begin{equation*}
      x \syndefeq y: \tau,
    \end{equation*}
    we can formulate the rules as follows:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_{\logic{type}} }]{rem:type_theory_rule_classification/equality/type}
          \begin{prooftree}
            \hypo{ M: \tau }
            \hypo{ \tau \syndefeq \tau': \BbbT }
            \infer2[\ref{rem:type_theory_rule_classification/equality/type}]{ M: \tau' }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_{\logic{term}} }]{rem:type_theory_rule_classification/equality/term}
          \begin{prooftree}
            \hypo{ M \syndefeq M': \tau }
            \hypo{ \tau \syndefeq \tau': \BbbT }
            \infer2[\ref{rem:type_theory_rule_classification/equality/term}]{ M \syndefeq M': \tau' }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Furthermore, to ensure that \( {\syndefeq} \) is an \hyperref[def:equivalence_relation]{equivalence relation}, we need inference rules resembling those from \fullref{ex:recursively_defined_relation}:
    \columnratio{0.25,0.25,0.5}
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_{\logic{refl}} }]{rem:type_theory_rule_classification/equality/refl}
          \begin{prooftree}
            \hypo{ M: \tau }
            \infer1[\ref{rem:type_theory_rule_classification/equality/refl}]{ M \syndefeq M: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_{\logic{symm}} }]{rem:type_theory_rule_classification/equality/symm}
          \begin{prooftree}
            \hypo{ M \syndefeq N: \tau }
            \infer1[\ref{rem:type_theory_rule_classification/equality/symm}]{ N \syndefeq M: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_{\logic{trans}} }]{rem:type_theory_rule_classification/equality/trans}
          \begin{prooftree}
            \hypo{ M \syndefeq N: \tau }
            \hypo{ N \syndefeq K: \tau }
            \infer2[\ref{rem:type_theory_rule_classification/equality/trans}]{ M \syndefeq K: \tau }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}
    \columnratio{}

    These five \enquote{common} equality rules are given in \cite[433]{UnivalentFoundationsProgram2024OctoberHoTT} and, in a less refined form, they are also discussed by \incite[14,15]{MartinLöf1984IntuitionisticTypeTheory}.

    Finally, since we use \hyperref[def:lambda_term_substitution]{substitution}, and since we are explicit about \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}, we must also add the following rules mimicking \fullref{alg:simply_typed_substitution} and \fullref{alg:simply_typed_alpha_conversion}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_\mapsto }]{rem:type_theory_rule_classification/equality/subst}
          \begin{prooftree}
            \hypo{ x: \tau }
            \infer[dashed]1{ M: \sigma }

            \hypo{ N: \tau }
            \infer2[\ref{rem:type_theory_rule_classification/equality/subst}]{ M[x \syndefeq N]: \sigma }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \coloneqq_\alpha }]{rem:type_theory_rule_classification/equality/alpha}
          \begin{prooftree}
            \hypo{ M: \tau }
            \hypo{ N: \tau }
            \hypo{ M \aequiv N }
            \infer3[\ref{rem:type_theory_rule_classification/equality/alpha}]{ M \syndefeq N: \tau }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Unlike in Martin-L\"of's presentation, in \cite[27]{UnivalentFoundationsProgram2024OctoberHoTT}, the other equality rules are split into two kinds. Additionally, they implicitly assume the presence of congruence rules, which \incite[\S 8.1.9]{Mimram2020ProgramEqualsProof} makes explicit.

    \begin{thmenum}
      \thmitem{rem:type_theory_rule_classification/equality/comp} A \term{computation rule} expresses how an elimination rule acts on the corresponding canonical objects obtained from introduction rules.

      Such rules generalize \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} of untyped \( \muplambda \)-terms. For example, for arrow types we have
      \begin{equation*}
        \begin{prooftree}
          \hypo{ x: \tau }
          \infer[dashed]1{ M: \sigma }

          \hypo{ N: \tau }
          \infer2[\ensuremath{ \rightarrow_\beta }]{ (\qabs {x^\tau} M) N \syndefeq M[x \mapsto N]: \sigma }.
        \end{prooftree}
      \end{equation*}

      \thmitem{rem:type_theory_rule_classification/equality/uniq} A \term{uniqueness rule} expresses how an arbitrary term of a given type can be expressed in the canonical form given by introduction rules.

      Such rules generalize \hyperref[def:beta_eta_reduction]{\( \eta \)-expansion} of untyped \( \muplambda \)-terms. For example, for arrow types we have
      \begin{equation*}
        \begin{prooftree}
          \hypo{ M: \tau \synimplies \sigma }
          \infer1[\ensuremath{ \rightarrow_\eta }]{ M \syndefeq \qabs {x^\tau} M x: \tau \synimplies \sigma },
        \end{prooftree}
      \end{equation*}
      where we require \( x: \tau \) to not be an open assumption. This requirement is a restatement of the \( \eta \)-reduction side condition from \ref{inf:def:beta_eta_reduction/eta}, adapted to a situation where, as described in \fullref{rem:beta_equivalence_and_free_variables}, the set of free variables of a \( \muplambda \)-term is ill-defined. This is discussed in \cite{MathSE:dependent_type_theory_and_free_variables}.

      This side condition resembles the eigenvariable condition from \fullref{con:eigenvariable}.

      Even though we equate a term with its expanded form, we regard this as an expansion rule rather than a reduction rule. The reasoning for this is that we should regard \( M \) as a \( \muplambda \)-abstraction with canonical form \( \qabs {x^\tau} M x \), not the other way around.

      \thmitem{rem:type_theory_rule_classification/equality/cong} Finally, a \term{congruence rule} simply propagates definitional equality.

      For example, we can formulate the following congruence rules for arrow types:
      \begin{equation*}
        \begin{prooftree}
          \hypo{ \tau \syndefeq \tau': \BbbT }
          \hypo{ \sigma \syndefeq \sigma': \BbbT }
          \infer2{ \tau \synimplies \sigma \syndefeq \tau' \synimplies \sigma': \BbbT }
        \end{prooftree}
      \end{equation*}

      \columnratio{0.45,0.55}
      \begin{paracol}{2}
        \begin{leftcolumn}
          \ParacolAlignmentHack
          \begin{equation*}
            \begin{prooftree}
              \hypo{ M \syndefeq M': \sigma }
              \infer1{ \qabs {x^{\tau}} M \syndefeq \qabs {x^{\tau}} M': \tau \synimplies \sigma }
            \end{prooftree}
          \end{equation*}
        \end{leftcolumn}

        \begin{rightcolumn}
          \ParacolAlignmentHack
          \begin{equation*}
            \begin{prooftree}
              \hypo{ M \syndefeq M': \tau \synimplies \sigma }
              \hypo{ N \syndefeq N': \tau }
              \infer2{ M N \syndefeq M' N': \sigma }
            \end{prooftree}
          \end{equation*}
        \end{rightcolumn}
      \end{paracol}
      \columnratio{}

      Congruence rules are repetitive, so, following \cite[\S A.2]{UnivalentFoundationsProgram2024OctoberHoTT}, we will not specify them explicitly.
    \end{thmenum}
  \end{thmenum}
\end{remark}
\begin{comments}
  \item Our list of rules is based on the corresponding rules for dependent products in \incite{MartinLöf1984IntuitionisticTypeTheory}, \cite[\S A.2.4]{UnivalentFoundationsProgram2024OctoberHoTT} and \cite[\S 8.1.10]{Mimram2020ProgramEqualsProof}.

  \item In the cited lectures, Martin-L\"of refers to types as \enquote{sets} and to the corresponding rules as \enquote{set formation} rules, but in later works like \cite{MartinLöf1994TypeJudgments} he already shifts to \enquote{types} and \enquote{type formation}.
\end{comments}

\paragraph{Simple algebraic types}

\begin{remark}\label{rem:extended_simple_type_theory}
  We will now use the sum and product types defined in \fullref{def:simple_type}, and also introduce a unit type and an empty type. Our end goal is to establish the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for propositional logic. We will collectively refer to these types as \enquote{algebraic} due to the relation to natural numbers established in \fullref{thm:simple_algebraic_type_arithmetic}.

  Introducing more complicated types, for example for handling first-order and higher-order logic, is often done, in the tradition established by Per Martin-L\"of, via a stout list of metatheoretic \hyperref[def:inference_rule]{inference rules}. The classification of these rules is described in \fullref{rem:type_theory_rule_classification}, and concrete rules extending the Curry-Howard correspondence to higher-order logic are presented in \fullref{sec:dependent_types}.

  Fortunately, for the types we will consider in this section, we will be able to easily reuse the machinery we have built for untyped and simply typed (with only arrow types) \( \muplambda \)-calculus, with some small adjustments. See \fullref{rem:product_type_equality_rules} for a more concrete discussion. We will however only limit ourselves to introduction and elimination rules since we will not need the rest. We will avoid introducing judgmental equality rules because we have spent considerable effort ensuring correctness of even \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}.

  Still, we will still find useful the classification of rules, mostly because of the respective terminology.
\end{remark}

\begin{definition}\label{def:simple_empty_type}\mimprovised
  We designate a special \hyperref[def:type_habitation]{uninhabited} type and, unsurprisingly, call it the \term[en=empty type (\cite[\S 4.3.4]{Mimram2020ProgramEqualsProof})]{empty type}. We denote it by \( \syn\Bbbzero \) and introduce it as a \hyperref[def:simple_type]{base type} of the \hyperref[def:simple_type_signature]{signature}, along with the constant term \( \synE_- \) and the following \hyperref[rem:type_theory_rule_classification/elim]{elimination rule} based on \ref{inf:def:propositional_natural_deduction_systems/bot/efq}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbzero_- }]{inf:def:simple_empty_type/elim}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbzero }
      \infer1[\ref{inf:def:simple_empty_type/elim}]{ \synE_- \synM: \syn\tau }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item A treatment of the empty type within simple type theory can be found in \cite[\S 4.3.4]{Mimram2020ProgramEqualsProof}.

  \item We have formulated the rule so that it resembles \ref{inf:def:propositional_natural_deduction_systems/bot/efq}. We do not forbid a variable to have type \( \syn\Bbbzero \), but provide a term of arbitrary type given such a variable.

  \item \hyperref[con:dependent_type]{Dependent types} allow stating a more involved introduction rule, as well as an \hyperref[rem:type_theory_rule_classification/intro]{elimination rule} and \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rule} for the empty type. See \Fullref{def:dependent_empty_type}.

  For disambiguation, we will refer to this definition as the \enquote{simple empty type}.

  \item Due to the availability of \ref{inf:def:arrow_type/elim}, we could have just as well introduced the rule
  \begin{equation*}
    \begin{prooftree}
      \infer0{ \synE_-: \syn\Bbbzero \synimplies \syn\tau }
    \end{prooftree}
  \end{equation*}

  Another simpler definition would be
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synM: \syn\Bbbzero }
      \infer1{ \synE_-: \syn\tau }
    \end{prooftree}
  \end{equation*}

  Unfortunately, both this rule and break the type uniqueness for typed terms shown in \fullref{thm:typed_term_habitation_uniqueness}. One way to mitigate this is to introduce a distinct constant \( \synE_-^\tau \) and distinct rule \( \syn\Bbbzero_-^\tau \) for every type \( \tau \), which would unfortunately complicate our formalization efforts.
\end{comments}

\begin{definition}\label{def:simple_unit_type}\mimprovised
  Dually to the \hyperref[def:simple_empty_type]{empty type}, we introduce the \term[en=unit type (\cite[\S 4.3.4]{Mimram2020ProgramEqualsProof})]{unit type} \( \syn\Bbbone \) with a unique inhabitant, the constant term \( \synU_+ \).

  There is an \hyperref[rem:type_theory_rule_classification/intro]{introduction rule} resembling the verum rule \ref{inf:def:propositional_natural_deduction_systems/top/intro}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbone_+ }]{inf:def:simple_unit_type/intro}
    \begin{prooftree}
      \infer0[\ref{inf:def:simple_unit_type/intro}]{ \synU_+: \syn\Bbbone }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item A treatment of the unit type within simple type theory can be found in \cite[\S 4.3.2]{Mimram2020ProgramEqualsProof}.

  \item \hyperref[con:dependent_type]{Dependent types} allow stating an \hyperref[rem:type_theory_rule_classification/intro]{elimination rule} and \hyperref[rem:type_theory_rule_classification/equality/uniq]{uniqueness rule} for the unit type. See \fullref{def:dependent_unit_type}.

  A simple uniqueness rule can be stated using only simple types:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ M: \Bbbone }
      \infer1{ M \coloneqq U_+: \Bbbone }
    \end{prooftree}
  \end{equation*}
\end{comments}

\begin{definition}\label{def:simple_product_type}\mimprovised
  When defining the syntax of simple types in \fullref{def:simple_type}, we have stated the \( \bnfpn{product type} \) grammar rule, which allows combining the types \( \tau \) and \( \sigma \) into the compound type \( \tau \syntimes \sigma \).

  We will now introduce rules based on the encoding of \hyperref[def:ordered_tuple]{ordered pairs} discussed in \fullref{ex:def:beta_eta_reduction/pairs} and \fullref{ex:def:type_derivation_tree/pairs}. For this, we will need constant terms \( \synP_+ \), \( \synP_{-L} \) and \( \synP_{-R} \).

  Based on the natural deduction rules for conjunction formulas from \fullref{def:propositional_natural_deduction_systems/and}, we state one \hyperref[rem:type_theory_rule_classification/intro]{introduction rule} and two \hyperref[rem:type_theory_rule_classification/elim]{elimination rules}:
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \times_+ }]{inf:def:simple_product_type/intro}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau }
          \hypo{ \synN: \syn\sigma }
          \infer2[\ref{inf:def:simple_product_type/intro}]{ \synP_+ \synM \synN: \syn\tau \syntimes \syn\sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \times_{-L} }]{inf:def:simple_product_type/elim_left}
        \begin{prooftree}
          \hypo{ \synK: \syn\tau \syntimes \syn\sigma }
          \infer1[\ref{inf:def:simple_product_type/elim_left}]{ \synP_{-L} \synK: \syn\tau }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \times_{-R} }]{inf:def:simple_product_type/elim_right}
        \begin{prooftree}
          \hypo{ \synK: \syn\tau \syntimes \syn\sigma }
          \infer1[\ref{inf:def:simple_product_type/elim_right}]{ \synP_{-R} \synK: \syn\tau }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item A treatment of product types within simple type theory can be found in \cite[\S 4.3.1]{Mimram2020ProgramEqualsProof}.

  \item We discuss how equality rules and \( \beta\eta \)-reduction are related in \fullref{rem:product_type_equality_rules}.

  \item This is a binary analogue to the dependent products defined in \fullref{def:dependent_product}.
\end{comments}

\begin{remark}\label{rem:product_type_equality_rules}
  In \fullref{ex:def:beta_eta_reduction/pairs}, we have shown that the \( \muplambda \)-terms \ref{ex:def:beta_eta_reduction/pairs/intro}, \ref{ex:def:beta_eta_reduction/pairs/elim_left} and \ref{ex:def:beta_eta_reduction/pairs/elim_right} enable the following \( \beta \)-reductions:
  \begin{align}\label{eq:rem:product_type_equality_rules/beta}
    P_{-L} (P_+ A B) \bred* A
    &&
    \T{and}
    &&
    P_{-R} (P_+ A B) \bred* B.
  \end{align}

  In \fullref{rem:delta_reduction}, we have shown how \hyperref[def:delta_reduction]{\( \delta \)-reduction} rules replacing the constant term \( \synP_+ \) with the corresponding combinator \ref{ex:def:beta_eta_reduction/pairs/intro}, and similarly for \( \synP_{-L} \) and \( \synP_{-R} \), allows us to use \( \beta\delta \)-reduction to deduce
  \begin{align*}
    \synP_{-L} (\synP_+ A B) \redrel*{\beta\delta} A
    &&
    \T{and}
    &&
    \synP_{-R} (\synP_+ A B) \redrel*{\beta\delta} B.
  \end{align*}

  We have discussed in \fullref{ex:def:type_derivation_tree/pairs} how these combinators are not, in general, \hyperref[def:typability]{typable}, using only arrow types. Having the rules from \fullref{def:simple_product_type}, however, we know the corresponding constants are typable, and we can easily derive
  \begin{equation*}
    \begin{prooftree}
      \hypo {}
      \ellipsis {} { A: \tau }

      \hypo {}
      \ellipsis {} { B: \sigma }

      \infer2[\ref{inf:def:simple_product_type/intro}]{ \synP_+ AB: \tau \syntimes \sigma }

      \infer1[\ref{inf:def:simple_product_type/elim_left}]{ \synP_{-L} (\synP_+ AB): \tau }
    \end{prooftree}
  \end{equation*}

  Thus, \( \synP_{-L} (\synP_+ AB) \) has the same type as \( A \) and it \( \beta\delta \)-reduces to \( A \).

  This diminishes the utility of adding \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rules} for product types, which, as suggested in \cite[\S 4.3.1]{Mimram2020ProgramEqualsProof}, would simply mimic \( \beta \)-reduction:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}
        \begin{prooftree}
          \hypo{ A: \tau }
          \hypo{ B: \sigma }
          \infer2{ \synP_{-L} (\synP_+ AB) \coloneqq A: \tau }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}
        \begin{prooftree}
          \hypo{ A: \tau }
          \hypo{ B: \sigma }
          \infer2{ \synP_{-L} (\synP_+ AB) \coloneqq B: \sigma }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  There is one important downside related to \( \eta \)-reduction and \hyperref[rem:type_theory_rule_classification/equality/uniq]{uniqueness rules}, however. We could expect that
  \begin{equation}\label{eq:rem:product_type_equality_rules/eta}
    P_+ (P_{-L} M) (P_{-R} A) \redrel*{\beta\eta} A.
  \end{equation}

  \incite*[corr. 1.23]{Barendregt1974SurjectivePairing} demonstrates that there is no triple of untyped \( \muplambda \)-terms \( P_+ \), \( P_{-L} \) and \( P_{+R} \) satisfying \eqref{eq:rem:product_type_equality_rules/eta}.

  Barendregt calls a triple satisfying \eqref{eq:rem:product_type_equality_rules/beta} a \enquote{pairing}, and a triple additionally satisfying \eqref{eq:rem:product_type_equality_rules/eta} --- a \enquote{surjective pairing}. Thus, his result states that untyped \( \muplambda \)-calculus does not admit a surjective pairing, despite the obvious pairing shown in \fullref{ex:def:beta_eta_reduction/pairs}.

  Thus, even for simple types, adding new congruence and uniqueness rules cannot be circumvented by a simpler mechanism such as \( \delta \)-reduction. This will unfortunately require us to reprove all results involving either \( \beta\eta \)-reduction or only \( \alpha \)-equivalence. So, our decision is to avoid new rules and to sacrifice \hyperref[con:extensionality]{extensionality} for the sake of simplicity.
\end{remark}
\begin{comments}
  \item Within a richer framework, product types are discussed in \fullref{rem:product_type_via_dependent_product}.
\end{comments}

\begin{definition}\label{def:simple_sum_type}\mimprovised
  Similarly to \hyperref[def:simple_product_type]{product types}, we will introduce rules for the sum type \( \tau \synplus \sigma \) based on the discussion in \fullref{ex:def:beta_eta_reduction/disjoint} and \fullref{ex:def:type_derivation_tree/disjoint}. We will need the constants \( \synS_{+L} \), \( \synS_{+R} \) and \( \synS_- \) and three rules resembling the disjunction rules from \fullref{def:propositional_natural_deduction_systems/or}:
  \columnratio{0.25,0.25,0.5}
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ +_{+L} }]{inf:def:simple_sum_type/intro_left}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau }
          \infer1[\ref{inf:def:simple_sum_type/intro_left}]{ \synS_{+L} \synM: \syn\tau \synplus \syn\sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ +_{+R} }]{inf:def:simple_sum_type/intro_right}
        \begin{prooftree}
          \hypo{ \synN: \syn\sigma }
          \infer1[\ref{inf:def:simple_sum_type/intro_right}]{ \synS_{+R} \synN: \syn\tau \synplus \syn\sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ +_- }]{inf:def:simple_sum_type/elim}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau \synplus \syn\sigma }
          \hypo{ [\synx: \syn\tau] }
          \infer[dashed]1{ \synN: \syn\rho }
          \hypo{ [\syny: \syn\sigma] }
          \infer[dashed]1{ \synK: \syn\rho }
          \infer3[\ref{inf:def:simple_sum_type/elim}]{ \synS_- (\qabs {\synx^{\syn\tau}} \synN) (\qabs {\syny^{\syn\sigma}} \synK) \synM: \syn\rho }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}
  \columnratio{}
\end{definition}
\begin{comments}
  \item A treatment of sum types within simple type theory can be found in \cite[\S 4.3.3]{Mimram2020ProgramEqualsProof}.

  \item As with the \hyperref[def:simple_empty_type]{empty type}, unless we make the constants \( \synS_{+L} \) and \( \synS_{+R} \) depend on the types of the terms, we break the type uniqueness for typed terms shown in \fullref{thm:typed_term_habitation_uniqueness}. Again, this is a sacrifice for the sake of simplicity of our formalized system.

  \item We discuss how equality rules and \( \beta\eta \)-reduction are related in \fullref{rem:sum_type_equality_rules}.

  \item This is a binary analogue to the dependent sums defined in \fullref{def:dependent_sum}.
\end{comments}

\begin{remark}\label{rem:binders_in_type_theory_terms}
  In \ref{inf:def:simple_sum_type/elim} we have constructed the term
  \begin{equation*}
    \synS_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) M: \rho.
  \end{equation*}

  The same rule is also presented in \cite[\S 4.3.3]{Mimram2020ProgramEqualsProof}, where this term has a dedicated syntactic rule, and the above term becomes
  \begin{equation*}
    \op{case}(M, x \mapsto N, y \mapsto K): \rho,
  \end{equation*}
  where it is highlighted that \( \op{case} \) acts as a \hyperref[con:variable_binding]{binder} for both \( x \) and \( y \).

  Such a dedicated grammar rule enforces syntactically valid terms, while our approach relies on a convention. This is not a problem, however, because we have no rules that allow constructing syntactically invalid terms. We prefer not to extend the base syntax of terms.
\end{remark}
\begin{comments}
  \item One downside of our approach is that some recursive tree traversals like that in \fullref{alg:simply_typed_reduction} become much more involved because application terms (i.e. \( M = NK \)) can be produced by a variety of rules. With a dedicated syntax, only \ref{inf:def:arrow_type/elim} is able to produce such terms.
\end{comments}

\begin{remark}\label{rem:sum_type_equality_rules}
  Similarly to product types, we can use \( \beta\delta \)-reduction to emulate \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rules}. See \fullref{rem:product_type_equality_rules} for a broader discussion of the general idea.

  In our case, given \( M: \tau \), we have
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {} { M: \tau }
      \infer1[\ref{inf:def:simple_sum_type/intro_left}]{ \synS_{+L} M: \tau \syntimes \rho }

      \hypo{ x: \tau }
      \ellipsis {} { N: \rho }

      \hypo{ y: \sigma }
      \ellipsis {} { K: \rho }

      \infer3[\ref{inf:def:simple_sum_type/elim}]{ \synS_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) (\synS_{+L} M): \rho }
    \end{prooftree}
  \end{equation*}

  We can reduce the latter based on our discussion in \fullref{ex:def:beta_eta_reduction/disjoint}:
  \begin{align*}
    &\phantom{{}\bred*{}}
    \synS_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) (\synS_{+L} M)
    \dred* \\ &\dred*
    S_- (\qabs {x^\tau} N) (\qabs {y^\sigma} K) (S_{+L} M)
    \bred* \\ &\bred*
    (\qabs {x^\tau} N) M
    \bred \\ &\bred
    N[x \mapsto M].
  \end{align*}

  \Fullref{alg:simply_typed_reduction} allows deriving the same type \( \rho \) for \( N \) and \( N[x \mapsto M] \) from the derivation of \( \tau \) for \( M \). Thus, again, we can emulate computation rules via reduction.

  Unlike for product types, a \hyperref[rem:type_theory_rule_classification/equality/uniq]{uniqueness rule} here is more complicated conceptually:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ M: \tau \synplus \sigma }
      \infer1{ M \coloneqq \synS_- (\qabs {\synx^\tau} \synS_{+L} \synx) (\qabs {\syny^\sigma} \synS_{+R} \syny) M }
    \end{prooftree}
  \end{equation*}

  We can regard the positive constants as inclusion terms with types \( \synS_{+L}: \tau \synimplies (\tau \synplus \sigma) \) and \( \synS_{+R}: \sigma \synimplies (\tau \synplus \sigma) \), and the entire term as a conditional based on \( M \).
\end{remark}

\begin{definition}\label{def:simple_algebraic_types}\mimprovised
  Consider the \hyperref[def:simple_type_system]{simple type system} featuring, along with the corresponding rules, \hyperref[def:arrow_type]{arrow types}, \hyperref[def:simple_product_type]{product types}, \hyperref[def:simple_product_type]{sum types}, as well as the \hyperref[def:simple_empty_type]{empty type} and \hyperref[def:simple_unit_type]{unit type}.

  We will call this the system of \term{simple algebraic types}.
\end{definition}

\paragraph{Curry-Howard correspondence}

\begin{remark}\label{rem:curry_howard_variables}
  When mechanizing the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} in \fullref{alg:type_derivation_to_proof_tree} and \fullref{alg:proof_tree_to_type_derivation}, there is a nuance we must handle when dealing with variables.

  We have defined propositional variables in \fullref{def:propositional_syntax} as small Latin identifiers, and type variables in \fullref{def:simple_type} as small Greek identifiers. We must find a way to unify the two when translating between types and formulas.

  A simple (albeit not a very elegant) solution that we will use is to treat Latin and Greek identifiers interchangeably, so that type variables correspond exactly to type variables.
\end{remark}

\begin{algorithm}[Type derivation to proof tree]\label{alg:type_derivation_to_proof_tree}
  Consider the \hyperref[def:abstract_type_system]{type system} of \hyperref[def:simple_algebraic_types]{simple algebraic types}.

  We give a straightforward algorithm for converting a \hyperref[def:type_derivation_tree]{type derivation tree} in this system into a \hyperref[def:natural_deduction_proof_tree]{proof tree} for the \hyperref[def:propositional_natural_deduction_systems]{propositional intuitionistic natural deduction system}.

  \begin{thmenum}
    \thmitem{alg:type_derivation_to_proof_tree/form} First, via \hyperref[con:evaluation]{pattern matching} on the type \( \tau \), we define an operator for converting types into \hyperref[def:propositional_syntax/formula]{propositional formulas}:
    \begin{equation*}
      \op*{Form}(\tau) \coloneqq \begin{cases}
        \top,                                            &\tau = \syn\Bbbone, \\
        \bot,                                            &\tau = \syn\Bbbzero, \\
        \tau,                                            &\tau \T{is a type variable}, \\
        \op*{Form}(\sigma) \synimplies \op*{Form}(\rho), &\tau = \sigma \synimplies \rho, \\
        \op*{Form}(\sigma) \synwedge \op*{Form}(\rho),   &\tau = \sigma \syntimes \rho, \\
        \op*{Form}(\sigma) \synvee \op*{Form}(\rho),     &\tau = \sigma \synplus \rho. \\
      \end{cases}
    \end{equation*}

    If \( \tau \) is a type variable, \( \op*{Form}(\tau) \) is the propositional variable with the same identifier. Variable interoperability is discussed in \fullref{rem:curry_howard_variables}. The other transformations are straightforward.

    \thmitem{alg:type_derivation_to_proof_tree/rule} Similarly, we map \hyperref[def:simple_typing_rule]{typing rules} to \hyperref[def:natural_deduction_rule]{natural deduction rules} by name:
    \begin{equation*}
      \op*{Rule}(R) \coloneqq \begin{cases}
        \logic{EFQ},         &R = \Bbbzero_-, \\
        \top_{\Anon},        &R = \Bbbone_{\Anon}, \\
        \rightarrow_{\Anon}, &R = \rightarrow_{\Anon}, \\
        \wedge_{\Anon},      &R = \times_{\Anon}, \\
        \vee_{\Anon},        &R = +_{\Anon}, \\
      \end{cases}
    \end{equation*}

    \thmitem{alg:type_derivation_to_proof_tree/instantiation} As discussed in \fullref{rem:natural_deduction_rule_application}, the application of some rules of natural deduction like \ref{inf:def:propositional_natural_deduction_systems/bot/efq}, \ref{inf:def:propositional_natural_deduction_systems/or/intro_left} and \ref{inf:def:propositional_natural_deduction_systems/or/intro_right} requires an explicit \hyperref[def:propositional_schema_instantiation]{propositional schema instantiation}.

    Each derivation tree has an associated \hyperref[def:lambda_schema_instantiation]{\( \muplambda \)-schema instantiation} from which we can infer the required propositional instantiation.

    It will be sufficient to specify how the instantiation acts on formula placeholders --- the rest can be inferred from the premises. Given a \( \muplambda \)-schema instantiation \( \BbbI \), we define the propositional instantiation \( \op*{Inst}(\BbbI) \) by matching, in order, the formula placeholders of the \( k \)-th premise of \( R \) to the type placeholder of the \( k \)-th premise of \( \op*{Rule}(R) \).

    For example, consider the following application tree of \ref{inf:def:simple_sum_type/intro_left}:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ M: \tau }
        \infer1[\ref{inf:def:simple_sum_type/intro_left}]{ \synS_{+L} \synx: \tau \synplus \sigma }
      \end{prooftree}
    \end{equation*}

    Here \( \BbbI \) maps the type placeholder \( \syn\tau \) to \( \tau \) and \( \syn\sigma \) to \( \sigma \). For the corresponding rule \ref{inf:def:propositional_natural_deduction_systems/or/intro_left}, \( \op*{Inst}(\BbbI) \) maps \( \syn\varphi \) to \( \tau \) and \( \syn\psi \) to \( \sigma \).

    This allows us to unambiguously apply the rule \ref{inf:def:propositional_natural_deduction_systems/or/intro_left} with \( \op*{Inst}(\BbbI) \) and obtain
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \tau }
        \infer1[\ref{inf:def:propositional_natural_deduction_systems/or/intro_left}]{ \tau \synvee \sigma }
      \end{prooftree}
    \end{equation*}

    \thmitem{alg:type_derivation_to_proof_tree/tree} Finally, we define a proof tree \( \op*{Proof}(D) \) for every derivation tree \( D \) in our system:
    \begin{thmenum}
      \thmitem{alg:type_derivation_to_proof_tree/tree/assumption} Suppose first that \( D \) is an assumption tree for the type assertion \( x: \tau \).

      Then we define \( \op*{Proof}(D) \) as the assumption tree for the formula \( \op*{Form}(\tau) \) with assumption marker \( x \).

      \thmitem{alg:type_derivation_to_proof_tree/tree/application} Otherwise, \( D \) is an application tree, in which case we define \( \op*{Proof}(D) \) via straightforward recursion on the premises of \( D \).

      Correctness is straightforward. Let \( R \) be the (name of the) applied rule and let \( M: \tau \) be the conclusion. We have adjusted our rules so that \( \op*{Rule}(R) \) has the same amount of premises as \( R \), with discharge assertions in the same places, and with the types in \( R \) corresponding via \( \op*{Form} \) to the formulas in \( \op*{Rule}(R) \), with details filled in by the translated instantiation \( \op*{Inst}(\BbbI) \). It follows that the conclusion of \( \op*{Proof}(D) \) is the transformation via \( \op*{Form} \) of the conclusion of \( D \).
    \end{thmenum}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.curry_howard.derivation_to_proof.type_derivation_to_proof_tree} in \cite{notebook:code}.

  \item When restricted to arrow types, this algorithm works just as well for \hyperref[def:lambda_term]{untyped} or even \hyperref[rem:mixed_lambda_term]{mixed} \( \muplambda \)-terms.
\end{comments}

\begin{algorithm}[Proof tree to type derivation]\label{alg:proof_tree_to_type_derivation}
  Dually to \fullref{alg:type_derivation_to_proof_tree}, we can convert a \hyperref[def:natural_deduction_proof_tree]{proof tree} in the \hyperref[def:propositional_natural_deduction_systems]{propositional intuitionistic natural deduction system} into a \hyperref[def:type_derivation_tree]{type derivation tree}. We must, however, due to the lack of established type-theoretic alternatives, restrict ourselves to formulas featuring no negation or equivalence, and disallow the rule \ref{inf:def:propositional_natural_deduction_systems/bot/dne}.

  \begin{thmenum}
    \thmitem{alg:proof_tree_to_type_derivation/type} We define the operator \( \op*{Type}(\varphi) \) as the partial inverse of the operator \( \op*{Form}(\tau) \) from \fullref{alg:type_derivation_to_proof_tree/form}, with no types corresponding to negation and equivalence.

    Propositional variables get mapped to type variables with the same name. Variable interoperability is discussed in \fullref{rem:curry_howard_variables}.

    \thmitem{alg:proof_tree_to_type_derivation/rule} We define \( \op*{Rule}(R) \) as the inverse of the eponymous operator from \fullref{alg:type_derivation_to_proof_tree/rule}.

    \thmitem{alg:proof_tree_to_type_derivation/instantiation} Conversely to \fullref{alg:type_derivation_to_proof_tree/instantiation}, we must translate the \hyperref[def:propositional_schema_instantiation]{propositional schema instantiation} \( \mscrI \) to a \hyperref[def:lambda_schema_instantiation]{\( \muplambda \)-schema instantiation} \( \op*{Inst}(\mscrI) \).

    Fortunately, it is sufficient to only match formula placeholders to type placeholders since the rest can be inferred from the premises. Thus \( \op*{Inst} \) must be the inverse of the eponymous operator in \fullref{alg:type_derivation_to_proof_tree/instantiation}.

    \thmitem{alg:proof_tree_to_type_derivation/tree} Finally, we define a derivation tree \( \op*{Deriv}(P) \) for every admissible proof tree \( P \):
    \begin{thmenum}
      \thmitem{alg:proof_tree_to_type_derivation/tree/assumption} Suppose first that \( P \) is an assumption tree for \( \varphi \) with marker \( x \).

      Then we regard \( x \) as a variable \( \muplambda \)-term, and define \( \op*{Deriv}(P) \) as the assumption tree for the type assertion \( x: \op*{Type}(\varphi) \).

      \thmitem{alg:proof_tree_to_type_derivation/tree/application} Otherwise, \( P \) is an application tree. As in \fullref{alg:type_derivation_to_proof_tree/tree/application}, we define \( \op*{Deriv}(P) \) by straightforward recursion on the premises of \( P \), with details filled by the translated instantiation \fullref{alg:proof_tree_to_type_derivation/instantiation}.

      We thus conjure up a (typed) \( \muplambda \)-term in the conclusion of \( \op*{Deriv}(P) \), which is uniquely determined by the assumption markers in \( P \) and the typing rules we have crafted.
    \end{thmenum}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.curry_howard.proof_to_derivation.proof_tree_to_type_derivation} in \cite{notebook:code}.
\end{comments}

\begin{example}\label{ex:con:curry_howard_correspondence}
  We list examples related to the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}:
  \begin{thmenum}
    \thmitem{ex:con:curry_howard_correspondence/minimal_implicational} We have shown in \fullref{ex:def:type_derivation_tree/i} how, for a fixed type \( \tau \), the combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) inhabits \( \tau \synimplies \tau \).

    \Fullref{alg:type_derivation_to_proof_tree} allows transforming the derivation tree
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \synx: \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}
    into the \hyperref[def:natural_deduction_proof_tree]{proof tree}
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\tau]^\synx }
        \infer[left label=\( \synx \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    It is slightly more interesting to consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \synx \), whose derivation tree
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syny \synx: \sigma \synimplies \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \qabs \syny \synx: \tau \synimplies \sigma \synimplies \tau }
      \end{prooftree}
    \end{equation*}
    is transformed into
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\tau]^\synx }
        \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \sigma \synimplies \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \tau \synimplies (\sigma \synimplies \tau) }
      \end{prooftree}
    \end{equation*}

    We can recognize the axiom schema \eqref{eq:def:minimal_implication_logic/intro} from \hyperref[def:minimal_implication_logic]{minimal implicational logic}.

    For the combinator \( \ref{eq:ex:def:lambda_term/combinator/s} = \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz) \) we have a more complicated derivation tree shown in \fullref{ex:def:type_derivation_tree/s}. Transforming it, we obtain a proof tree for
    \begin{equation*}
      \parens[\Big]{ \tau \synimplies (\sigma \synimplies \rho) } \synimplies \parens[\Big]{ (\tau \synimplies \sigma) \synimplies (\tau \synimplies \rho)},
    \end{equation*}
    which is an instance of the axiom schema \eqref{eq:def:minimal_implication_logic/dist} from minimal implicational logic.

    \thmitem{ex:con:curry_howard_correspondence/algebraic_types} We will show in \fullref{thm:simple_algebraic_type_arithmetic} how a certain quotient set of simple algebraic types is a distributive lattice. Under the identification given by the Curry-Howard correspondence, this quotient corresponds to a \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebra}, which for intuitionistic natural deduction is, as shown in \fullref{thm:lindenbaum_tarski_algebras/intuitionistic}, a \hyperref[def:heyting_algebra]{Heyting algebra}.

    Unlike in Lindenbaum-Tarski algebras, here we are mostly interested in the algebraic, and not the order-theoretic properties. We don't even show that the arrow type constructor acts as a relative pseudocomplement.

    We prove the algebraic properties directly by giving proof derivation trees. Via \fullref{alg:type_derivation_to_proof_tree}, however, these derivation trees can be converted to proof trees that demonstrate some of the properties of the Lindenbaum-Tarski algebra that we show in \fullref{thm:lindenbaum_tarski_algebras/intuitionistic}.

    \thmitem{ex:con:curry_howard_correspondence/beta_reduction} We will show in \fullref{rem:beta_reduction_and_cut_elimination} how \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} corresponds to a special case of \hyperref[rem:sequent_calculus]{cut elimination}.
  \end{thmenum}
\end{example}
