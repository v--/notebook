\subsection{Simple type theory}\label{subsec:simple_type_theory}

\paragraph{Untyped lambda terms}

\begin{definition}\label{def:lambda_term}\mimprovised
  Consider the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{variable}    {\bnfpn{Latin identifier}} \\
    \bnfprod{application} {\bnftsq{\( ( \)} \bnfsp \bnfpn{term} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}} \\
    \bnfprod{abstraction} {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}} \\
    \bnfprod{term}        {\bnfpn{variable} \bnfor \bnfpn{application} \bnfor \bnfpn{abstraction}}
  \end{bnf*}

  When introducing what is now known as \( \synlambda \)-calculus, \incite[352]{Church1932} used \( \synlambda \) as part of the grammar. We will henceforth refer to \( \synlambda \)-\term[ru=апликация (\cite[188]{Герасимов2011})]{applications}, \( \synlambda \)-\term[ru=абстракция (\cite[188]{Герасимов2011})]{abstractions} and \( \synlambda \)-\term[ru=терм (\cite[188]{Герасимов2011})]{terms}.

  \begin{thmenum}
    \thmitem{def:lambda_term/subterm}\mcite[def. 1A3]{Hindley1997} We define the set of all \term[ru=подтерм (\cite[189]{Герасимов2011})]{subterms} of a term \( M \) as
    \begin{equation*}
      \boldop{Subterm}(M) \coloneqq \begin{cases}
        \set{ x },                                    &M = x, \\
        \boldop{Subterm}(N) \cup \boldop{Subterm}(K), &M = N K, \\
        \boldop{Subterm}(N),                          &M = \qabs x N.
      \end{cases}
    \end{equation*}

    See \fullref{ex:def:lambda_term/naive_subterm} for a subtlety regarding this definition.

    \thmitem{def:lambda_term/bound}\mcite[def. 1A6]{Hindley1997} For each term \( M \), we define its set of \term[ru=связанные (переменные) (\cite[188]{Герасимов2011})]{bound variables} as
    \begin{equation*}
      \boldop{Bound}(M) \coloneqq \begin{cases}
        \varnothing,                              &M = x, \\
        \boldop{Bound}(N) \cup \boldop{Bound}(K), &M = N K, \\
        \boldop{Bound}(N) \cup \set{ x },         &M = \qabs x N. \\
      \end{cases}
    \end{equation*}

    \thmitem{def:lambda_term/free}\mcite[def. 1A6]{Hindley1997} We also define the set of \term[ru=свободные (переменные) (\cite[189]{Герасимов2011})]{free variables} as
    \begin{equation*}
      \boldop{Free}(M) \coloneqq \begin{cases}
        \varnothing,                            &M = x, \\
        \boldop{Free}(N) \cup \boldop{Free}(K), &M = N K, \\
        \boldop{Free}(N) \setminus \set{ x },   &M = \qabs x N. \\
      \end{cases}
    \end{equation*}

    \thmitem{def:lambda_term/closed}\mcite[def. 1A10]{Hindley1997} We say that a term is \term{closed} if it has no bound variables. Closed terms are also called \term[ru=комбинаторы (\cite[188]{Герасимов2011})]{combinators}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item We need the parentheses so that we can prove unambiguity in \fullref{thm:lambda_terms_are_unambiguous}. Informally, we will use the conventions from \fullref{rem:propositional_formula_parentheses} regarding parentheses.
\end{comments}

\begin{proposition}\label{thm:lambda_terms_are_unambiguous}
  The grammar of \hyperref[def:lambda_term]{\( \synlambda \)-terms} is \hyperref[def:grammar_ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  Similarly to \fullref{thm:propositional_formulas_are_unambiguous}, the proof is again based on \fullref{ex:natural_number_arithmetic_grammar/unambiguous}.
\end{proof}

\begin{remark}\label{rem:lambda_term_ast}
  For a given \( \synlambda \)-term \( M \), we can build a \hyperref[rem:abstract_syntax_tree]{abstract syntax tree} as follows:
  \begin{itemize}
    \item If \( M \) is a variable, build a tree with a single node labeled by \( M \).
    \item If \( M = (NK) \), build the following binary tree:
    \begin{equation*}
      \begin{aligned}
        \includegraphics[page=1]{output/rem__lambda_term_ast}
      \end{aligned}
    \end{equation*}

    \item If \( M = (\synlambda x N) \), build the following binary tree:
    \begin{equation*}
      \begin{aligned}
        \includegraphics[page=2]{output/rem__lambda_term_ast}
      \end{aligned}
    \end{equation*}
  \end{itemize}
\end{remark}

\begin{remark}\label{rem:lambda_term_parentheses}
  We use some \enquote{abuse-of-notation} syntactic conventions somewhat resembling \fullref{rem:propositional_formula_parentheses}:
  \begin{thmenum}
    \thmitem{rem:lambda_term_parentheses/outermost} As in \fullref{rem:propositional_formula_parentheses/outermost}, we avoid writing the outermost parentheses in terms like \( (xy) \) or \( ((xy)z) \).

    \thmitem{rem:lambda_term_parentheses/abstraction} We generally avoid writing parentheses around \( \synlambda \)-abstractions.

    Actually, it is not necessary to put parentheses around \( \synlambda \)-abstractions in order for the grammar to be unambiguous. Not requiring them, however, leads to the following unintuitive artifact.

    Consider the term \( \qabs x y z \). If parentheses are required only for \( \synlambda \)-abstractions but not for \( \synlambda \)-applications, it would unambiguously correspond to the following \hyperref[rem:lambda_term_ast]{abstract syntax tree}:
    \begin{equation*}
      \begin{aligned}
        \includegraphics[page=1]{output/rem__lambda_term_parentheses}
      \end{aligned}
    \end{equation*}

    But it is reasonable to expect instead the following tree:
    \begin{equation*}
      \begin{aligned}
        \includegraphics[page=2]{output/rem__lambda_term_parentheses}
      \end{aligned}
    \end{equation*}

    Since we will generally expect the latter, it is simpler to require parentheses around \( \synlambda \)-abstractions in the formal syntax and then, when convenient, avoid writing them within the metalogic.

    \thmitem{rem:lambda_term_parentheses/right_associative} We suppose that \( \synlambda \)-application is \hyperref[rem:binary_operation_syntax_trees/associativity]{right-associative}, which allows us to vastly simplify notation in some cases like \eqref{eq:ex:def:lambda_term/combinator/s} where we use \( xzyz \) rather than \( x(z(yz)) \).
  \end{thmenum}
\end{remark}

\begin{example}\label{ex:def:lambda_term}
  We list examples of \hyperref[def:lambda_term]{\( \synlambda \)-terms}:
  \begin{thmenum}
    \thmitem{ex:def:lambda_term/var} The simplest \( \synlambda \)-terms are the variables themselves, for example \( x \) or \( y \).
    \thmitem{ex:def:lambda_term/naive_subterm} Suppose that, as in \fullref{def:propositional_syntax/subformula} for propositional subformulas, we say that \( N \) is a subterm of \( M \) if it is itself a \hyperref[def:formal_language/subword]{subword} of \( M \).

    Then the term \( \qabs x y \) would have both \( x \) and \( y \) as subterms, while according to \fullref{def:lambda_term/subterm}, only \( y \) is a subterm.

    \thmitem{ex:def:lambda_term/combinator}\mcite[def. 1A10.1]{Hindley1997} The following \hyperref[def:lambda_term/closed]{combinators} have established names:
    \begin{align}
      &\qabs x x, \label{eq:ex:def:lambda_term/combinator/i}\tag{\logic{I}} \\
      &\qabs x \qabs y yx, \nonumber\label{eq:ex:def:lambda_term/combinator/k}\tag{\logic{K}} \\
      &\qabs x \qabs y \qabs z xzyz, \label{eq:ex:def:lambda_term/combinator/s}\tag{\logic{S}} \\
      &\qabs x (\qabs y xyy) (\qabs y xyy). \label{eq:ex:def:lambda_term/combinator/y}\tag{\logic{Y}}
    \end{align}
  \end{thmenum}
\end{example}

\paragraph{Variable substitution}

\begin{definition}\label{def:lambda_substitution}\mcite[def. 1A7]{Hindley1997}
  We define the \term{substitution} of the variable \( x \) in the term \( M \) with \( N \) as
  \begin{subequations}
    \begin{empheq}[left={M[x \mapsto L]} \coloneqq \empheqlbrace]{align}
      &N,                                        &&M = x, \label{eq:def:lambda_substitution/var/direct} \\
      &x,                                        &&M = y, \label{eq:def:lambda_substitution/var/noop} \\
      &N[x \mapsto L] \thinspace K[x \mapsto L], &&M = NK, \label{eq:def:lambda_substitution/applicatoin} \\
      &M,                                        &&M = \qabs x N, \label{eq:def:lambda_substitution/abstraction/self} \\
      &M,                                        &&M = \qabs y N \T{and} x \not\in \boldop{Free}(N), \label{eq:def:lambda_substitution/abstraction/noop} \\
      &\qabs y N[x \mapsto L],                   &&M = \qabs y N \T{and} x \in \boldop{Free}(N) \T{and} \nonumber \\
      &                                          &&\qquad y \not\in \boldop{Free}(L), \label{eq:def:lambda_substitution/abstraction/direct} \\
      &\qabs z N[y \mapsto z][x \mapsto L],      &&M = \qabs y N \T{and} x \in \boldop{Free}(N) \T{and} \nonumber \\
      &                                          &&\qquad y \in \boldop{Free}(L) \T{and} z \not\in \boldop{Free}(NP), \label{eq:def:lambda_substitution/abstraction/renaming}
    \end{empheq}
  \end{subequations}
  where \( z \) in \eqref{eq:def:lambda_substitution/abstraction/renaming} can be any variable not free in neither \( N \) nor \( P \).
\end{definition}
\begin{comments}
  \item For the sake of determinism, it makes sense for \( z \) in \eqref{eq:def:lambda_substitution/abstraction/renaming} to be the smallest suitable one given the identifier ordering discussed in \fullref{rem:grammar_rules_for_variables}.
\end{comments}

\begin{remark}\label{rem:lambda_abstraction_substitution}
  The substitution rules \eqref{eq:def:lambda_substitution/abstraction/self} through \eqref{eq:def:lambda_substitution/abstraction/renaming} require explanation.
\end{remark}

\paragraph{\( \beta \)-reduction}

\begin{definition}\label{def:beta_redex}\mcite[def. 1B1]{Hindley1997}
  A \( \beta \)-regex is a \( \synlambda \)-application whose first term is a \( \synlambda \)-abstraction, that is, a \( \synlambda \)-term of the form \( (\qabs x M) N \)
\end{definition}
