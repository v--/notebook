\section{\texorpdfstring{\( \muplambda \)}{λ}-term \texorpdfstring{\( \alpha \)}{α}-equivalence}\label{sec:lambda_term_alpha_equivalence}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:lambda_term_alpha_equivalence}\mimprovised
  Using \fullref{thm:recursively_defined_relations}, we will define \term{\( \alpha \)-equivalence} between \( \muplambda \)-terms:

  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Atom}_\alpha }]{inf:def:lambda_term_alpha_equivalence/atom}
        \begin{prooftree}
          \hypo{ M \in \op*{Atom} }
          \infer1[\ref{inf:def:lambda_term_alpha_equivalence/atom}]{ M \aequiv M }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{App}_\alpha }]{inf:def:lambda_term_alpha_equivalence/app}
        \begin{prooftree}
          \hypo{ A \aequiv C }
          \hypo{ B \aequiv D }
          \infer2[\ref{inf:def:lambda_term_alpha_equivalence/app}]{ AB \aequiv CD }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_\alpha }]{inf:def:lambda_term_alpha_equivalence/abs}
    \begin{prooftree}
      \hypo{ A[a \mapsto n] \aequiv B[b \mapsto n] \T{for every} n \not\in \op*{Free}(\qabs a A) }
      \infer1[\ref{inf:def:lambda_term_alpha_equivalence/abs}]{ (\qabs a A) \aequiv (\qabs b B) }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item The gist of \ref{inf:def:lambda_term_alpha_equivalence/abs} is that we want \( A[a \mapsto n] \aequiv B[a \mapsto n] \) to hold for every variable \( n \) that is not free in either \( A \) or \( B \), but we still want to allow \( n \) to be \( a \) or \( b \). This will simplify our inductive proofs, but it is impossible to mechanize. We will be able to split it into two simplified rules in \cref{thm:alpha_equivalence_simplified}.

  \item We do not need a separate condition for \( n \) not to be free in \( \qabs b B \) because, as we will show in \cref{thm:def:lambda_term_alpha_equivalence/free}, \( \qabs a A \) and \( \qabs b B \) have the same free variables if they are \( \alpha \)-equivalent.

  \item \hyperref[def:typed_lambda_term]{Typed \( \muplambda \)-terms} require modified rules for abstraction --- see \cref{def:typed_term_alpha_equivalence}.

  \item Our rules resemble those in \cite[5]{Pollack2005AlphaConversion}, with two notable differences, both of which allow us to simplify inductive proofs:
  \begin{itemize}
    \item We have restricted \ref{inf:def:lambda_term_alpha_equivalence/atom} to atomic terms only, while Pollack states the rule for general terms.
    \item We have allowed in \ref{inf:def:lambda_term_alpha_equivalence/abs} to be \( a \) or \( b \).
  \end{itemize}

  \item \incite[\S 2.1.11]{Barendregt1984LambdaCalculus} and \incite[def. 1A8]{Hindley1997BasicSTT} call the successive renaming of bound variables \enquote{\( \alpha \)-conversion} and consider \( \muplambda \)-terms \enquote{up to \( \alpha \)-conversion} (see \cref{rem:barendregt_convention}). Barendregt calls \enquote{\( \alpha \)-congruence} what we call \( \alpha \)-equivalence, while Hindley says that \enquote{\( M \) \( \alpha \)-converts to \( N \)}.

  \incite[5]{Pollack2005AlphaConversion} use \enquote{\( \alpha \)-conversion} and \enquote{\( \alpha \)-equivalence} interchangeably, while \incite[114]{Mimram2020ProgramEqualsProof} uses \enquote{\( \alpha \)-conversion} for what we call \( \alpha \)-equivalence.

  Due to this ambiguity, we will generally avoid the term \enquote{\( \alpha \)-conversion}.

  \item The rules themselves can be formalized using \( \muplambda \)-term schemas and instantiations akin to how we will formalize the typing rules in \fullref{sec:curry_howard_correspondence}. Such formalization will introduce some complications akin to those described in \cref{rem:dependent_type_rule_formalization}, so we will avoid it.
\end{comments}

\begin{remark}\label{rem:barendregt_convention}\mcite[\S 2.1.12]{Barendregt1984LambdaCalculus}
  \incite*[\S 2.1.12]{Barendregt1984LambdaCalculus} assumes the following convention:
  \begin{displayquote}
    Terms that are \( \alpha \)-congruent are identified.
  \end{displayquote}

  Thus, Barendregt suggests regarding \( \muplambda \)-terms as equivalence classes. Up until \fullref{sec:dependent_types}, we will be stubborn about not following this convention and treating each \( \muplambda \)-term as a separate entity. This will ensure correctness of our definitions and theorems.
\end{remark}
\begin{comments}
  \item This is not to be confused with Barendregt's variable convention described in \cref{rem:barendregt_variable_convention}.
\end{comments}

\begin{definition}\label{def:lambda_renaming_substitution}\mimprovised
  We say that an \hyperref[def:atomic_lambda_term_substitution]{atomic \( \muplambda \)-term substitution} is a \term{renaming} if it sends variables to variables.
\end{definition}
\begin{comments}
  \item This definition is an adaptation of the corresponding notion in first-order logic; see \cref{def:fol_renaming_substitution}.
\end{comments}

\begin{lemma}\label{thm:lambda_renaming_substitution_isomorphism}
  Via \fullref{alg:lambda_term_substitution}, \hyperref[def:lambda_renaming_substitution]{renaming substitutions} act as \hyperref[def:ordered_tree]{ordered tree isomorphisms} on the \hyperref[def:lambda_term_ast]{abstract syntax tree} of any \hyperref[def:lambda_term]{\( \muplambda \)-term}.

  Furthermore, this action preserves \hyperref[def:lambda_term_alphabet]{improper symbols} and constants (but not variables).
\end{lemma}
\begin{comments}
  \item If a \( \muplambda \)-term has no variables, this becomes a \hyperref[def:labeled_tree/homomorphism]{labeled tree isomorphism}.
\end{comments}
\begin{proof}
  We will use induction \fullref{thm:induction_on_rooted_trees} on the AST \( T(M) \) of \( M \) to show, simultaneously for any renaming substitution \( \Bbbs \), that \( M \) is isomorphic to \( T(M[\Bbbs]) \) as an ordered tree, and that it preserves improper symbols and constants.

  \begin{itemize}
    \item If \( M \) is a constant, it is invariant under substitution, so \( M = M[\Bbbs] \). The only possible map from \( T(M) \) to \( T(M[\Bbbs]) \) is then an isomorphism.

    \item If \( M \) is a variable, then \( M[\Bbbs] \) is also a variable. Again, the only possible map from \( T(M) \) to \( T(M[\Bbbs]) \) is an isomorphism.

    \item Suppose that \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \).

    We have \( M[\Bbbs] = N[\Bbbs] \thinspace K[\Bbbs] \). By the inductive hypothesis, there exist isomorphisms \( f: T(N) \to T(N[\Bbbs]) \) and \( g: T(K) \to T(K[\Bbbs]) \).

    Let \( r \) be the root of \( T(M) \) and \( r' \) --- of \( T(M[\Bbbs]) \). Since substitution sends applications to applications, both have the placeholder symbol \enquote{\( \anon \)} as their label.

    We can define the map
    \begin{equation*}
      \begin{aligned}
        &h: T(M) \to T(M[\Bbbs]), \\
        &h(n) \coloneqq \begin{cases}
          f(n), &n \T{is a node of} T(N), \\
          g(n), &n \T{is a node of} T(K), \\
          r',   &n = r.
        \end{cases}
      \end{aligned}
    \end{equation*}

    Since \( f \) and \( g \) are bijective, so is \( h \).

    The root \( r \) is incident to two edges --- \( e_N \) connects it to the root of \( T(N) \) and \( e_K \) --- to the root of \( T(K) \). Since \( f \) and \( g \) send roots to roots, \( h \) respects the endpoints of \( e_N \) and \( e_K \). Furthermore, \( f \) and \( g \) respect the edge endpoints and child order of \( T(N) \) and \( T(K) \); then so does \( h \).

    We have shown that \( h \) is a bijective homomorphism of ordered rooted trees. A similar argument works for \( h^{-1} \). Therefore, \( h \) is an isomorphism of ordered trees.

    Finally, \( h \) preserves improper symbols and constants; for \( T(N) \) and \( T(K) \) this follows from the inductive hypothesis, while for \( r \) this follows by construction.

    \item Suppose that \( M = \qabs x N \), where the inductive hypothesis holds for \( N \). \Cref{thm:lambda_substitution_single_rule} implies that, for some variable \( v \) not in \( \op*{Free}_\Bbbs(M) \), we have
    \begin{equation*}
      M[\Bbbs] = \qabs v N[\Bbbs_{x \mapsto v}].
    \end{equation*}

    Again, let \( r \) be the root of \( T(M) \) and \( r' \) --- of \( T(M[\Bbbs]) \). The label of \( r \) is \( \synlambda x \), while the label of \( r' \) is \( \synlambda v \).

    By the inductive hypothesis, there exists an isomorphism \( f: T(N) \to T(N[\Bbbs_{x \mapsto v}]) \). We can define
    \begin{equation*}
      \begin{aligned}
        &g: T(M) \to T(M[\Bbbs]), \\
        &g(n) \coloneqq \begin{cases}
          f(n), &n \T{is a node of} T(N), \\
          r',   &n = r.
        \end{cases}
      \end{aligned}
    \end{equation*}

    By the same reasoning as in the previous case, we conclude that \( g \) is an isomorphism of ordered trees that preserves improper symbols and constants.
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:def:lambda_term_alpha_equivalence}
  \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence} of \( \muplambda \)-terms has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:lambda_term_alpha_equivalence/ast} If two \( \muplambda \)-terms are \( \alpha \)-equivalent, their \hyperref[def:lambda_term_ast]{abstract syntax trees} are isomorphic as \hyperref[def:ordered_tree]{ordered trees} and have matching \hyperref[def:lambda_term_alphabet]{improper symbols} and constants, but may differ in their variables.

    In particular, they have the same kind, i.e. both are constants, variables, applications or abstractions.

    \thmitem{thm:def:lambda_term_alpha_equivalence/free} The free variables of \( \alpha \)-equivalent \( \muplambda \)-terms coincide.

    \thmitem{thm:def:lambda_term_alpha_equivalence/abstraction_body_free} If \( \qabs a A \aequiv \qabs b B \), then
    \begin{equation}\label{eq:thm:def:lambda_term_alpha_equivalence/abstraction_body_free}
      \op*{Free}(A) \setminus \set{ a } = \op*{Free}(B) \setminus \set{ b }.
    \end{equation}

    In particular, \( a \) is free in \( A \) if and only if \( b \) is free in \( B \). Unless \( a = b \), however, \( a \) is never free in \( B \), nor \( b \) --- in \( A \).

    \thmitem{thm:def:lambda_term_alpha_equivalence/equivalence} \( \alpha \)-equivalence is an \hyperref[def:equivalence_relation]{equivalence relation}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:lambda_term_alpha_equivalence/ast} We can prove this via \fullref{thm:induction_on_recursively_defined_relations} on \( M \aequiv N \), by constructing explicit isomorphisms as in \cref{thm:lambda_renaming_substitution_isomorphism}.

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/free} We proceed via induction on the \hyperref[def:graph_cardinality/order]{graph order} of the \hyperref[def:lambda_term_ast]{abstract syntax trees} of \( M \) to show that, if \( M \aequiv N \), then the free variables of \( M \) and \( N \) coincide.

  The smallest syntax trees have order \( 1 \). These are necessarily atoms, and the only rule that allow us to conclude that \( M \aequiv N \) is \ref{inf:def:lambda_term_alpha_equivalence/atom}. It is satisfied only if \( M = N \). Thus, \( \op*{Free}(M) = \op*{Free}(N) \).

  Suppose that the order of \( M \) is strictly greater than \( 1 \) and that the inductive hypothesis holds for terms of smaller order. We have the following possibilities:
  \begin{itemize}
    \item If \( M = AB \), the rule \ref{inf:def:lambda_term_alpha_equivalence/app} is applicable if \( N \) is also an application, say \( N = CD \), and if both \( A \aequiv C \) and \( B \aequiv D \). Then
    \begin{equation*}
      \op*{Free}(M)
      =
      \op*{Free}(A) \cup \op*{Free}(B)
      \reloset{\T{ind.}} =
      \op*{Free}(C) \cup \op*{Free}(D)
      =
      \op*{Free}(N).
    \end{equation*}

    \item Otherwise, we have \( M = \qabs a A \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( N = \qabs b B \), where, for every variable \( n \) not free in \( M = \qabs a A \), we have
    \begin{equation*}
      A[a \mapsto n] \aequiv B[b \mapsto n].
    \end{equation*}

    In particular, \( A[a \mapsto a] \aequiv B[b \mapsto a] \). \Cref{thm:lambda_substitution_noop} implies that \( A[a \mapsto a] = A \), thus \( A \aequiv B[b \mapsto a] \). The inductive hypothesis on \( A \) implies that
    \begin{equation}\label{eq:thm:def:lambda_term_alpha_equivalence/free/proof/abs/a_free}
      \op*{Free}(A) = \op*{Free}(B[b \mapsto a]).
    \end{equation}

    We also have \( A[a \mapsto b] \aequiv B[b \mapsto b] = B \). By \cref{thm:lambda_renaming_substitution_isomorphism}, \( A[a \mapsto b] \) has the same graph order as \( A \), so the inductive hypothesis holds for \( A[a \mapsto b] \) also. Hence,
    \begin{equation}\label{eq:thm:def:lambda_term_alpha_equivalence/free/proof/abs/b_free}
      \op*{Free}(A[a \mapsto b]) = \op*{Free}(B).
    \end{equation}

    \Cref{thm:lambda_substitution_free_variables_single} implies that
    \begin{equation*}
      \op*{Free}(A[a \mapsto b]) \subseteq (\op*{Free}(A) \setminus \set{ a }) \cup \set{ b }.
    \end{equation*}

    Thus,
    \begin{equation*}
      \op*{Free}(A[a \mapsto b]) \setminus \set{ b } \subseteq \op*{Free}(A) \setminus \set{ a }.
    \end{equation*}

    Combined with \eqref{eq:thm:def:lambda_term_alpha_equivalence/free/proof/abs/b_free}, this gives us
    \begin{equation*}
      \underbrace{\op*{Free}(B) \setminus \set{ b }}_{\op*{Free}(N)} \subseteq \underbrace{\op*{Free}(A) \setminus \set{ a }}_{\op*{Free}(M)}.
    \end{equation*}

    The converse inclusion can be proven similarly by using \eqref{eq:thm:def:lambda_term_alpha_equivalence/free/proof/abs/a_free}. It follows that \( \op*{Free}(M) = \op*{Free}(N) \).
  \end{itemize}

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/abstraction_body_free} Suppose that \( \qabs a A \aequiv \qabs b B \). Then
  \begin{equation*}
    \op*{Free}(A) \setminus \set{ a }
    =
    \op*{Free}(\qabs a A)
    \reloset {\ref{thm:def:lambda_term_alpha_equivalence/free}} =
    \op*{Free}(\qabs b B)
    =
    \op*{Free}(B) \setminus \set{ b }.
  \end{equation*}

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/equivalence}

  \SubProofOf*[def:binary_relation/reflexive]{reflexivity} We proceed on the graph order of \( M \) to show that \( M \aequiv M \).

  In the base case of order \( 1 \), \( M \) is necessarily an atomic term, and \ref{inf:def:lambda_term_alpha_equivalence/atom} directly implies that \( M \aequiv M \).

  For the inductive step, we consider two possibilities:
  \begin{itemize}
    \item If \( M = AB \), then \( A \aequiv A \) and \( B \aequiv B \), and the rule \ref{inf:def:lambda_term_alpha_equivalence/app} implies that \( M \aequiv M \).

    \item If \( M = \qabs x N \), \cref{thm:lambda_renaming_substitution_isomorphism} implies that \( N[x \mapsto n] \) has the same order as \( N \) for any variable \( n \), so the inductive hypothesis gives us \( N[x \mapsto n] \aequiv N[x \mapsto n] \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( M \aequiv M \).
  \end{itemize}

  \SubProofOf*[def:binary_relation/symmetric]{symmetry} We proceed on the graph order of \( M \) to show that \( M \aequiv N \) implies \( N \aequiv M \).

  In the base case of order \( 1 \), we consider atomic terms, and the rule \ref{inf:def:lambda_term_alpha_equivalence/atom} implies that \( \alpha \)-equivalent atomic terms are equal.

  For the inductive step, we consider two possibilities:
  \begin{itemize}
    \item Suppose first that \( M = AB \). Since \( M \aequiv N \), we have used \ref{inf:def:lambda_term_alpha_equivalence/app}, so \( N = CD \) for some \( \muplambda \)-terms such that \( A \aequiv C \) and \( B \aequiv D \).

    By the inductive hypothesis, \( C \aequiv A \) and \( D \aequiv B \). Applying \ref{inf:def:lambda_term_alpha_equivalence/app}, we conclude that \( N \aequiv M \).

    \item Otherwise, we have \( M = \qabs a A \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( N = \qabs b B \) and, for every variable \( n \) not free in \( M \), \( A[a \mapsto n] \aequiv B[b \mapsto n] \).

    Fix a variable \( n \) not free in \( N \). \Cref{thm:def:lambda_term_alpha_equivalence/free} implies that this is equivalent to \( n \) not being free in \( M \).

    By \cref{thm:lambda_renaming_substitution_isomorphism}, \( A[a \mapsto n] \) has the same graph order as \( A \), thus the inductive hypothesis holds for the former. Then \( B[b \mapsto n] \aequiv A[a \mapsto n] \).

    It remains to apply \ref{inf:def:lambda_term_alpha_equivalence/abs} to conclude that \( N \aequiv M \).
  \end{itemize}

  \SubProofOf*[def:binary_relation/transitive]{transitivity} We will again use induction on the graph order of \( M \) that \( M \aequiv N \) and \( N \aequiv K \) imply \( M \aequiv K \).

  The base case and the case where \( M \) is an application are straightforward. For the remaining case, suppose that \( M = \qabs a A \), so that \( N = \qabs b B \) and \( K = \qabs c C \).

  Fix a variable \( n \) not free in \( M \). Then \( A[a \mapsto n] \aequiv B[b \mapsto n] \) and, since by \cref{thm:def:lambda_term_alpha_equivalence/free} \( n \) is also not free in \( N \), we also have \( B[b \mapsto n] \aequiv C[c \mapsto n] \).

  \Cref{thm:lambda_renaming_substitution_isomorphism} implies that the term \( A[a \mapsto n] \) has the same order as \( A \), so we can apply the inductive hypothesis and conclude that
  \begin{equation*}
    A[a \mapsto n] \aequiv C[c \mapsto n].
  \end{equation*}

  It remains to apply \ref{inf:def:lambda_term_alpha_equivalence/abs} to conclude that \( M \aequiv K \).
\end{proof}

\begin{example}\label{ex:def:lambda_term_alpha_equivalence}
  We list examples of \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}:
  \begin{thmenum}
    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/combinator} The combinator \( \ref{eq:ex:def:lambda_term/combinator/i} \) has the same essential structure regardless of how we name its variables:
    \begin{equation*}
      I = \qabs \synx \synx \aequiv \qabs \syny \syny \aequiv \qabs \syna \syna \aequiv \cdots
    \end{equation*}

    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/nested} Consider a more complicated case:
    \begin{align*}
      \qabs \synx \qabs \syny \synx \syny
      &&
      \T{and}
      &&
      \qabs \syny \qabs \synx \syny \synx.
    \end{align*}

    In the notation of \ref{inf:def:lambda_term_alpha_equivalence/abs}, we have
    \begin{equation*}
      \qabs {\underbrace{\synx}_a} \underbrace{\qabs \syny \synx \syny}_A
      \T{and}
      \qabs {\underbrace{\syny}_b} \underbrace{\qabs \synx \syny \synx}_B.
    \end{equation*}

    We reduce our \( \alpha \)-equivalence check to \( A[a \mapsto n] \) and \( B[b \mapsto n] \) (note that the bound variables were possibly renamed):
    \begin{equation*}
      \qabs c \underbrace{n c}_C
      \T{and}
      \qabs d \underbrace{n d}_D.
    \end{equation*}

    We further reduce our check to \( C[c \mapsto m] = nm \) and \( D[d \mapsto m] = nm \). The rule \ref{inf:def:lambda_term_alpha_equivalence/app} allows us to reduce this problem to checking whether \( n \aequiv n \) and \( m \aequiv m \), while \ref{inf:def:lambda_term_alpha_equivalence/atom} confirms that the latter equivalences hold. Therefore, our entire verification is correct and
    \begin{equation*}
      \qabs \synx \qabs \syny \synx \syny \aequiv \qabs \syny \qabs \synx \syny \synx.
    \end{equation*}

    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/freeing} In \cref{ex:def:lambda_variable_freeness/both} we discussed how \( \synx \) is both bound and free in \( M = I \synx = (\qabs \synx \synx) \synx \).

    We can use the term \( M' = (\qabs \syny \syny) \synx \) instead, where all occurrences of \( \synx \) are free and all occurrences of \( \syny \) are bound.

    This is generalized by \fullref{alg:separation_of_free_and_bound_variables}.
  \end{thmenum}
\end{example}

\paragraph{Composite substitutions}

\begin{definition}\label{def:lambda_substitution_composition}\mimprovised
  We define the \term{composition} \( \Bbbt\Bbbs \) of the \hyperref[def:atomic_lambda_term_substitution]{atomic \( \muplambda \)-term substitutions} \( \Bbbs \) and \( \Bbbt \) as
  \begin{equation}\label{eq:def:lambda_substitution_composition}
    (\Bbbt\Bbbs)(x) \coloneqq x[\Bbbs][\Bbbt].
  \end{equation}

  This extends recursively to any number of substitutions, starting with the identity \( \id \) as a nullary composition.
\end{definition}
\begin{comments}
  \item This definition is an adaptation of the corresponding notion in first-order logic; see \cref{def:fol_substitution_composition}.
\end{comments}

\begin{lemma}\label{thm:substitution_composition_free_variables}
  For the \hyperref[def:atomic_lambda_term_substitution]{atomic substitution} \( \Bbbs \) and \( \Bbbt \), we have
  \begin{equation}\label{eq:thm:thm:substitution_composition_free_variables}
    \op*{Free}(M[\Bbbs][\Bbbt]) = \op*{Free}_{\Bbbt\Bbbs}(M),
  \end{equation}
  where \( \Bbbt\Bbbs \) is their composition in the sense of \cref{def:lambda_substitution_composition}.

  This straightforwardly extends to any number of substitutions.
\end{lemma}
\begin{proof}
  \begin{align*}
    \op*{Free}_{\Bbbt\Bbbs}(M)
    &=
    \bigcup_{a \in \op*{Free}(M)} \op*{Free}(a[\Bbbs][\Bbbt])
    \reloset {\ref{thm:lambda_substitution_free_variables}} = \\ &=
    \bigcup_{a \in \op*{Free}(M)} \op*{Free}_\Bbbt(\Bbbs(a))
    = \\ &=
    \bigcup_{a \in \op*{Free}(M)} \bigcup_{b \in \op*{Free}(\Bbbs(a))} \op*{Free}(\Bbbt(b))
    = \\ &=
    \bigcup_{b \in \op*{Free}_\Bbbs(M)} \op*{Free}(\Bbbt(b))
    \reloset {\ref{thm:lambda_substitution_free_variables}} = \\ &=
    \bigcup_{b \in \op*{Free}(M[\Bbbs])} \op*{Free}(\Bbbt(b))
    = \\ &=
    \op*{Free}_\Bbbt(M[\Bbbs])
    \reloset {\ref{thm:lambda_substitution_free_variables}} = \\ &=
    \op*{Free}(M[\Bbbs][\Bbbt]).
  \end{align*}
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_composition_term_equality}
  Fix a \( \muplambda \)-term \( M \) and two substitutions \( \Bbbs \) and \( \Bbbt \).

  Suppose that, for every variable \( x \) of \( M \), the variables of \( M \) and \( \Bbbs(x) \) are disjoint. Similarly, suppose that, for every variable \( y \) of \( M[\Bbbs] \), the variables of \( M[\Bbbs] \) and \( \Bbbt\Bbbs(y) \) are disjoint. Then
  \begin{equation}\label{eq:thm:lambda_substitution_composition_term_equality}
    M[\Bbbt\Bbbs] = M[\Bbbs][\Bbbt].
  \end{equation}
\end{proposition}
\begin{comments}
  \item Note that the restrictions hold for arbitrary variables, not necessarily free, because we want to use induction on subterms. These conditions are satisfied in many practical cases like
  \begin{equation*}
    M[x \mapsto c, y \mapsto d] = M[x \mapsto c][y \mapsto d],
  \end{equation*}
  where \( c \) and \( d \) are constants.

  Without the restrictions, \cref{thm:nary_lambda_substitution_composition_is_alpha_equivalent} gives us \( \muplambda \)-equivalence instead of equality.
\end{comments}
\begin{proof}
  We will use \fullref{thm:induction_on_abstract_syntax} on of \( M \), simultaneously on all suitable substitutions.

  \begin{itemize}
    \item If \( M \) is a constant, it is invariant under substitution, and thus
    \begin{equation*}
      M[\Bbbt\Bbbs] = M = M[\Bbbs][\Bbbt].
    \end{equation*}

    \item If \( M \) is a variable, then
    \begin{equation*}
      M[\Bbbt\Bbbs] = \Bbbt(\Bbbs(M)) = M[\Bbbs][\Bbbt].
    \end{equation*}

    \item Suppose that \( M = NK \) and that the inductive hypothesis holds for \( N \) and \( K \).

    We have
    \begin{equation*}
      M[\Bbbt\Bbbs]
      =
      N[\Bbbt\Bbbs] \thinspace K[\Bbbt\Bbbs]
      \reloset {\T{ind.}} =
      N[\Bbbt][\Bbbs] \thinspace K[\Bbbt][\Bbbs]
      =
      M[\Bbbt][\Bbbs].
    \end{equation*}

    \item Finally, suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \).

    By assumption, \( x \) does not belong to \( \op*{Free}_\Bbbs(M) = \op*{Free}(M[\Bbbs]) \), so
    \begin{equation*}
      M[\Bbbs] = \qabs x N[\Bbbs_{x \mapsto x}].
    \end{equation*}

    Similarly, since \( x \) is a variable of \( M[\Bbbs] \), it does not belong to \( \op*{Free}_\Bbbt(M[\Bbbs]) = \op*{Free}(M[\Bbbs][\Bbbt]) \), so
    \begin{equation*}
      M[\Bbbs][\Bbbt] = \qabs x N[\Bbbs_{x \mapsto x}][\Bbbt_{x \mapsto x}].
    \end{equation*}

    \Cref{thm:substitution_composition_free_variables} implies that \( \op*{Free}_{\Bbbt\Bbbs}(M) = \op*{Free}(M[\Bbbs][\Bbbt]) \), so \( x \) does not belong there also, and
    \begin{equation*}
      M[\Bbbt\Bbbs] = \qabs x N[(\Bbbt\Bbbs)_{x \mapsto x}].
    \end{equation*}

    Since \( x \) is a variable of \( M \), by assumption it is not in \( \Bbbs(y) \) for any \( y \) in \( N \), so the two substitutions \( \Bbbt_{x \mapsto x} \bincirc \Bbbs_{x \mapsto x} \) and \( (\Bbbt\Bbbs)_{x \mapsto x} \) agree on the free variables of \( N \). \Cref{thm:lambda_substitutions_agree} thus implies that
    \begin{equation*}
      M[\Bbbt\Bbbs] = \qabs x \underbrace{N[\Bbbt_{x \mapsto x} \bincirc \Bbbs_{x \mapsto x}]}_{N[\Bbbs_{x \mapsto x}][\Bbbt_{x \mapsto x}] \T{by ind.}}.
    \end{equation*}

    Therefore, \( M[\Bbbt\Bbbs] = M[\Bbbs][\Bbbt] \).
  \end{itemize}
\end{proof}

\paragraph{Invariance of \( \alpha \)-equivalence under substitution}

\begin{lemma}\label{thm:composition_of_lambda_substitutions_lemma}
  Fix a \( \muplambda \)-term \( M \) and a sequence of \hyperref[def:atomic_lambda_term_substitution]{substitutions} \( \Bbbs_1, \ldots, \Bbbs_n \).

  Fix also variables \( v_0, \ldots, v_n \) as follows:
  \begin{thmenum}
    \thmitem{thm:composition_of_lambda_substitutions_lemma/endpoints} We put no restrictions on \( v_0 \) and \( v_n \).
    \thmitem{thm:composition_of_lambda_substitutions_lemma/midpoints} For \( 1 \leq k \leq n - 1 \), we suppose that \( v_k \) is \hi{not} in \( \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M) \).
  \end{thmenum}

  We claim that the \hyperref[def:lambda_substitution_composition]{composite substitution} \( (\Bbbs_k)_{v_{n-1} \mapsto v_n} \cdots (\Bbbs_1)_{v_0 \mapsto v_1} \) agrees with \( (\Bbbs_n \cdots \Bbbs_1)_{v_0 \mapsto v_n} \) on the free variables of \( M \).
\end{lemma}
\begin{comments}
  \item This lemma is instrumental in our proof of \cref{thm:nary_lambda_substitution_composition_match_is_alpha_equivalent}.
\end{comments}
\begin{proof}
  We will use induction on \( n \).
  \begin{itemize}
    \item The case \( n = 0 \) is vacuous because there is no sequence of substitutions. In this case \( v_0 = v_n \), and we must simply note that the substitutions \( \id_{v_0 \mapsto v_0} \) and \( \id \) agree.

    \item We will also separately handle \( n = 1 \), which is again vacuous. In this case there is only one substitution, and we must conclude that \( (\Bbbs_1)_{v_0 \mapsto v_n} \) agrees with itself.

    \item For \( n > 1 \), we have
    \begin{equation*}
      \parens[\big]{ (\Bbbs_n)_{v_{n-1} \mapsto v_n} \cdots (\Bbbs_1)_{v_0 \mapsto v_1} }(a)
      =
      \begin{cases}
        v_n,                                        &a = v_0, \\
        v_n,                                        &v_1 \in \op*{Free}\parens[\big]{ \Bbbs_1(a) }, \\
                                                    &\vdots \\
        v_n,                                        &v_{n-1} \in \op*{Free}\parens[\big]{ \parens[\big]{ \Bbbs_{n-1} \cdots \Bbbs_1 }(a) }, \\
        \parens[\big]{ \Bbbs_n \cdots \Bbbs_1 }(a), &\T{otherwise.}
      \end{cases}
    \end{equation*}

    By assumption, for any index \( k = 1, \ldots, n \), the variable \( v_k \) is not in \( \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M) \). Thus, it is not free in \( \parens[\big]{ \Bbbs_k \cdots \Bbbs_1 }(a) \) whenever \( a \) is free in \( M \).

    Therefore, on the free variables of \( M \), we fall into neither case that distinguishes the composition \( (\Bbbs_n)_{v_{n-1} \mapsto v_n} \cdots (\Bbbs_1)_{v_0 \mapsto v_1} \) from \( (\Bbbs_n \cdots \Bbbs_1)_{v_0 \mapsto v_n} \).
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:nary_lambda_substitution_composition_match_is_alpha_equivalent}
  Fix a \( \muplambda \)-term \( M \) and fix \hyperref[def:atomic_lambda_term_substitution]{substitutions} --- \( \Bbbs_1, \ldots, \Bbbs_n \) and \( \Bbbt \) --- such that \( \Bbbt \) agrees with the \hyperref[def:lambda_substitution_composition]{composition} \( \Bbbs_n \cdots \Bbbs_1 \) on the free variables of \( M \).

  Explicitly, we require the following to hold for every free variable \( a \) of \( M \):
  \begin{equation*}
    a[\Bbbt] = a[\Bbbs_1] \cdots [\Bbbs_n].
  \end{equation*}

  Then
  \begin{equation}\label{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent}
    M[\Bbbt] \aequiv M[\Bbbs_1] \cdots [\Bbbs_n].
  \end{equation}
\end{proposition}
\begin{comments}
  \item We will need much weaker variants of this proposition. For example, \cref{thm:nary_lambda_substitution_composition_is_alpha_equivalent} only consider the case where \( \Bbbt = \Bbbs_n \cdots \Bbbs_1 \). A useful further special case is \cref{thm:lambda_substitution_chain_contraction}.

  The variant we state here is necessary for proving the inductive step.
\end{comments}
\begin{proof}
  We will use \fullref{thm:induction_on_abstract_syntax} on of \( M \), simultaneously for every \( n \) and all suitable substitutions.

  To avoid trivial considerations, we handle the case \( n = 0 \) separately. \Cref{thm:lambda_substitution_identity} implies \( M[\id] = M \), and, due to the reflexivity \( \alpha \)-equivalence, \( M[\id] \aequiv M \).

  Now, we can suppose that \( n > 0 \).

  \begin{itemize}
    \item If \( M \) is a constant, it is invariant under substitution, and thus
    \begin{equation*}
      M[\Bbbt] = M = M[\Bbbs_1] \cdots [\Bbbs_n].
    \end{equation*}

    Then \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent} again follows from the reflexivity of \( \alpha \)-equivalence.

    \item If \( M \) is a variable, then \( \op*{Free}(M) = \set{ M } \), and, by assumption,
    \begin{equation*}
      M[\Bbbt] = M[\Bbbs_1] \cdots [\Bbbs_n]
    \end{equation*}

    Then \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent} again follows from the reflexivity of \( \alpha \)-equivalence.

    \item Suppose that \( M = NK \) and that the inductive hypothesis holds for \( N \) and \( K \).

    We have
    \begin{equation*}
      M[\Bbbt] = N[\Bbbt] \thinspace K[\Bbbt].
    \end{equation*}

    The free variables of \( M \) are the union of those of \( N \) and \( K \), thus \( \Bbbt \) and \( \Bbbs_n \cdots \Bbbs_1 \) agree on them. Then, by the inductive hypothesis, \( N[\Bbbt] \aequiv N[\Bbbs_n] \cdots [\Bbbs_1] \) and similarly for \( K \), and we conclude that \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent} holds by applying \ref{inf:def:lambda_term_alpha_equivalence/app}.

    \item Finally, suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \).

    We will utilize \cref{thm:lambda_substitution_single_rule} several times. Let \( v_0 \coloneqq x \). Then
    \begin{align*}
      M[\Bbbt]                    &= \qabs u N\bracks[\big]{ \Bbbt_{x \mapsto u} },                                                                     &&u \not\in \op*{Free}_\Bbbt(M), \\
      M[\Bbbs_1] \cdots [\Bbbs_k] &= \qabs {v_k} N\bracks[\big]{ (\Bbbs_1)_{v_0 \mapsto v_1} } \cdots \bracks[\big]{ (\Bbbs_k)_{v_{k-1} \mapsto v_k} }, &&v_k \not\in \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M),
    \end{align*}
    where \( k \) ranges from \( 1 \) to \( n \).

    Note that, due to \cref{thm:substitution_composition_free_variables}, we have \( \op*{Free}_{\Bbbs_{k-1} \cdots \Bbbs_1}(M[\Bbbs_k]) = \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M) \).

    Fix a variable \( w \) not in \( \op*{Free}_\Bbbt(M) \)\fnote{We will not actually use this assumption. It is simply what \ref{inf:def:lambda_term_alpha_equivalence/abs} assumes.}. To use \ref{inf:def:lambda_term_alpha_equivalence/abs}, we must conclude that
    \begin{equation}\label{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent/proof/abstraction/goal}
      N\bracks[\big]{ \Bbbt_{x \mapsto u} }\bracks[\big]{ u \mapsto w } \aequiv N\bracks[\big]{ (\Bbbs_1)_{v_0 \mapsto v_1} } \cdots \bracks[\big]{ (\Bbbs_n)_{v_{n-1} \mapsto v_n} } \bracks[\big]{ v_n \mapsto w }.
    \end{equation}

    With the conditions on \( v_1, \ldots, v_n \), we can utilize \cref{thm:composition_of_lambda_substitutions_lemma} to conclude that the composed substitution
    \begin{equation}\label{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent/proof/abstraction/long_composed}
      \id_{v_n \mapsto w} \bincirc (\Bbbs_n)_{v_{n-1} \mapsto v_n} \bincirc \cdots \bincirc (\Bbbs_1)_{v_0 \mapsto v_1}
    \end{equation}
    agrees with \( (\Bbbs_n \cdots \Bbbs_1)_{x \mapsto w} \) on the free variables of \( M \). Furthermore, by assumption, on the free variables of \( M \), the composition \( \Bbbs_n \cdots \Bbbs_1 \) agrees with \( \Bbbt \); hence, \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent/proof/abstraction/long_composed} in turn also agrees with \( \Bbbt_{x \mapsto w} \).

    Note that \( x \) is not free in \( M \), but it is possibly free in \( N \)\fnote{This precise situation will be described in more detail in \cref{thm:lambda_substitution_chain_contraction/composition}.}. It is precisely the value which we modify the substitutions at, thus \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent/proof/abstraction/long_composed} also agrees with \( \Bbbt_{x \mapsto w} \) on the free variables of \( N \). Therefore, by the inductive hypothesis,
    \begin{equation*}
      N\bracks[\big]{ (\Bbbs_1)_{v_0 \mapsto v_1} } \cdots \bracks[\big]{ (\Bbbs_n)_{v_{n-1} \mapsto v_n} } \bracks[\big]{ v_n \mapsto w }
      \aequiv
      N\bracks[\big]{ \Bbbt_{x \mapsto w} }.
    \end{equation*}

    Similarly, since \( u \) is not in \( \op*{Free}_\Bbbt(M) \), \cref{thm:composition_of_lambda_substitutions_lemma} implies that the composition \( \id_{u \mapsto w} \bincirc \Bbbt_{x \mapsto u} \) agrees with \( \Bbbt_{x \mapsto w} \) on the free variables of \( N \). Thus, by the inductive hypothesis,
    \begin{equation*}
      N\bracks[\big]{ \Bbbt_{x \mapsto u} }\bracks[\big]{ u \mapsto w }
      \aequiv
      N\bracks[\big]{ \Bbbt_{x \mapsto w} }.
    \end{equation*}

    We have shown that both sides of \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent/proof/abstraction/goal} are \( \alpha \)-equivalent to \( N\bracks[\big]{ \Bbbt_{x \mapsto w} } \).

    It remains to apply \ref{inf:def:lambda_term_alpha_equivalence/abs} to generalize this from \( N \) to \( M \), i.e. to obtain \eqref{eq:thm:nary_lambda_substitution_composition_match_is_alpha_equivalent}.
  \end{itemize}
\end{proof}

\begin{corollary}\label{thm:nary_lambda_substitution_composition_is_alpha_equivalent}
  For the \hyperref[def:lambda_substitution_composition]{composition} \( \Bbbs_n \cdots \Bbbs_1 \) of the substitutions \( \Bbbs_1, \ldots, \Bbbs_n \), we have
  \begin{equation}\label{eq:thm:nary_lambda_substitution_composition_is_alpha_equivalent}
    M[\Bbbs_n \cdots \Bbbs_1] \aequiv M[\Bbbs_1] \cdots [\Bbbs_n]
  \end{equation}
  for any \( \muplambda \)-term \( M \).
\end{corollary}
\begin{proof}
  Special case of \cref{thm:nary_lambda_substitution_composition_match_is_alpha_equivalent} with \( \Bbbt = \Bbbs_n \cdots \Bbbs_1 \).
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_composition_associative}
  \hyperref[def:lambda_substitution_composition]{\( \muplambda \)-term substitution composition} is \hyperref[def:binary_operation/associative]{associative}.
\end{corollary}
\begin{proof}
  For substitutions \( \Bbbs \), \( \Bbbt \) and \( \Bbbr \), for every variable \( x \) we have
  \begin{equation*}
    \Bbbr(\Bbbt\Bbbs)(x)
    =
    x[\Bbbt\Bbbs][\Bbbr]
    \reloset {\eqref{eq:thm:nary_lambda_substitution_composition_is_alpha_equivalent}} =
    x[\Bbbs][\Bbbt\Bbbr]
    =
    \Bbbr(\Bbbt\Bbbs)(x)
  \end{equation*}
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_chain_contraction}
  Fix a \hyperref[def:atomic_lambda_term_substitution]{\( \muplambda \)-term substitution} \( \Bbbs \).

  \begin{thmenum}
    \thmitem{thm:lambda_substitution_chain_contraction/precomposition} For any variable \( y \) not in \( \op*{Free}(M) \), we have
    \begin{equation}\label{eq:thm:lambda_substitution_chain_contraction/precomposition}
      M[x \mapsto y][\Bbbs_{y \mapsto N}]
      \aequiv
      M[\Bbbs_{x \mapsto N}]
    \end{equation}

    This also holds more generally if \( x = y \).

    In this case, \( y \) depends only on \( M \).

    \thmitem{thm:lambda_substitution_chain_contraction/composition} For any variable \( y \) not in \( \op*{Free}_\Bbbs(M) \), we have
    \begin{equation}\label{eq:thm:lambda_substitution_chain_contraction/composition}
      M[\Bbbs_{x \mapsto y}][y \mapsto N]
      \aequiv
      M[\Bbbs_{x \mapsto N}].
    \end{equation}

    We will find useful the following generalization of the requirement \( y \not\in \op*{Free}_\Bbbs(M) \):
    \begin{displayquote}
      If \( y \in \op*{Free}(\Bbbs(p)) \) for some free variable \( p \) of \( M \), this variable is necessarily \( x \).
    \end{displayquote}

    In this case, \( y \) depends on the interaction of \( \Bbbs \) and \( M \).
  \end{thmenum}
\end{corollary}
\begin{proof}
  \SubProofOf{thm:lambda_substitution_chain_contraction/precomposition} Note that \( \op*{Free}(M) = \op*{Free}_{\id}(M) \), hence the assumption that \( y \) is not in \( \op*{Free}(M) \) allows us to use \cref{thm:nary_lambda_substitution_composition_is_alpha_equivalent} directly on the composition \( \Bbbs_{y \mapsto N} \bincirc \id_{x \mapsto y} \).

  If \( x = y \), \cref{thm:lambda_substitution_identity} implies that \( M[x \mapsto y] = M \), and \eqref{eq:thm:lambda_substitution_chain_contraction/precomposition} becomes trivial.

  \SubProofOf{thm:lambda_substitution_chain_contraction/composition} We use the generalized assumption on \( y \) --- that \( y \in \op*{Free}(\Bbbs(p)) \) implies \( p = x \) if \( p \) is a free variable of \( M \).

  Since we modify \( \Bbbs \) precisely at \( x \), the composition \( \id_{y \mapsto N} \bincirc \Bbbs_{x \mapsto y} \) agrees with \( \Bbbs_{x \mapsto N} \) on the free variables of \( M \).

  An application of \cref{thm:nary_lambda_substitution_composition_match_is_alpha_equivalent} yields \eqref{eq:thm:lambda_substitution_chain_contraction/composition}.
\end{proof}

\begin{proposition}\label{thm:substitution_on_alpha_equivalent_terms}
  If \( M \aequiv N \), for any \hyperref[def:atomic_lambda_term_substitution]{atomic substitution} \( \Bbbs \), we have \( M[\Bbbs] \aequiv N[\Bbbs] \).
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \aequiv N \).

  \begin{itemize}
    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/atom}, then \( M \) and \( N \) are the same atom.

    Either \( M \) and \( N \) are the same constants or the same variable. In both cases, we have \( M[\Bbbs] = N[\Bbbs] \).

    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/app}, then \( M = AB \) and \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \) and the inductive hypothesis holds for the latter two.

    By this inductive hypothesis, we have \( A[\Bbbs] \aequiv C[\Bbbs] \) and \( B[\Bbbs] \aequiv D[\Bbbs] \), and we can apply \ref{inf:def:lambda_term_alpha_equivalence/app} to obtain
    \begin{equation*}
      M[\Bbbs]
      =
      A[\Bbbs] \thinspace B[\Bbbs]
      \aequiv
      C[\Bbbs] \thinspace D[\Bbbs]
      =
      N[\Bbbs],
    \end{equation*}
    as desired.

    \item Finally, if \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/abs}, then \( M = \qabs a A \), \( N = \qabs b B \) and, for every variable \( n \) not free in \( M \), we have
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/assumption}
      A[a \mapsto n] \aequiv B[b \mapsto n].
    \end{equation}

    We suppose that the inductive hypothesis holds for \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/assumption} for any suitable \( n \).

    Before using it, we must first inspect \( M[\Bbbs] \) and \( N[\Bbbs] \). We use \cref{thm:lambda_substitution_single_rule} twice:
    \begin{align*}
      M[\Bbbs] &= \qabs u A[\Bbbs_{a \mapsto u}], &&u \not\in \op*{Free}_\Bbbs(M), \\
      N[\Bbbs] &= \qabs v B[\Bbbs_{b \mapsto v}], &&v \not\in \op*{Free}_\Bbbs(N).
    \end{align*}

    To conclude that \( M[\Bbbs] \aequiv N[\Bbbs] \), we will use the rule \ref{inf:def:lambda_term_alpha_equivalence/abs}. Fix a variable \( m \) not free in \( M[\Bbbs] \). We need to show that
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/pregoal}
      A[\Bbbs_{a \mapsto u}][u \mapsto m] \aequiv B[\Bbbs_{b \mapsto v}][v \mapsto m].
    \end{equation}

    We can use the inductive hypothesis on \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/assumption} with \( n = a \) as follows:
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp}
      A[a \mapsto a][\Bbbs_{a \mapsto m}] \aequiv B[b \mapsto a][\Bbbs_{a \mapsto m}].
    \end{equation}

    As we will show both \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/pregoal} and \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp} collapse to
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/goal}
      A[\Bbbs_{a \mapsto m}] \aequiv B[\Bbbs_{b \mapsto m}].
    \end{equation}

    To conclude that \( M[\Bbbs] \aequiv N[\Bbbs] \), it remains to apply \ref{inf:def:lambda_term_alpha_equivalence/abs}.

    \SubProof{Proof that \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/pregoal} collapses to \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/goal}} Since \( u \) is not in \( \op*{Free}_\Bbbs(M) \), \cref{thm:lambda_substitution_chain_contraction/composition} implies that
    \begin{equation*}
      A[\Bbbs_{a \mapsto u}][u \mapsto m] \aequiv A[\Bbbs_{a \mapsto m}],
    \end{equation*}
    and similarly
    \begin{equation*}
      A[\Bbbs_{b \mapsto v}][v \mapsto m] \aequiv B[\Bbbs_{b \mapsto m}].
    \end{equation*}

    \SubProof{Proof that \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp} collapses to \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/goal}} Here the left and right side require different reasoning.

    First, \cref{thm:lambda_substitution_identity} implies that \( A[a \mapsto a] = A \), so the left side of \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp} becomes \( A[\Bbbs_{a \mapsto m}] \).

    For the right side, we can use \cref{thm:def:lambda_term_alpha_equivalence/abstraction_body_free} to conclude that \( a \) is not free in \( B \), and \cref{thm:lambda_substitution_chain_contraction/precomposition} to conclude that
    \begin{equation*}
      B[b \mapsto a][\Bbbs_{a \mapsto m}] \aequiv B[\Bbbs_{b \mapsto m}].
    \end{equation*}
  \end{itemize}
\end{proof}

\paragraph{Mechanizing \( \alpha \)-equivalence}

\begin{proposition}\label{thm:alpha_equivalence_simplified}
  The rule \ref{inf:def:lambda_term_alpha_equivalence/abs}, specifying when two abstractions are \( \alpha \)-equivalent, is tantamount to the following pair of rules:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Lift}_\alpha }]{inf:thm:alpha_equivalence_simplified/lift}
        \begin{prooftree}
          \hypo{ A \aequiv B }
          \infer1[\ref{inf:thm:alpha_equivalence_simplified/lift}]{ (\qabs x A) \aequiv (\qabs x B) }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha }]{inf:thm:alpha_equivalence_simplified/ren}
        \begin{prooftree}
          \hypo{ a \neq b }
          \hypo{ a \not\in \op*{Free}(B) }
          \hypo{ A \aequiv B[b \mapsto a] }
          \infer3[\ref{inf:thm:alpha_equivalence_simplified/ren}]{ (\qabs a A) \aequiv (\qabs b B) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{proposition}
\begin{comments}
  \item This check can be found as \identifier{math.lambda_.untyped.alpha.are_terms_alpha_equivalent} in \cite{notebook:code}.
\end{comments}
\begin{proof}
  \SufficiencySubProof We will first show that \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren} are \hyperref[con:inference_rule_admissibility]{admissible} with respect to \ref{inf:def:lambda_term_alpha_equivalence/abs}.

  \SubProof*{Proof that \ref{inf:thm:alpha_equivalence_simplified/lift} is admissible} Fix a variable \( x \) and terms \( A \aequiv B \). Let \( n \) be any variable not free in \( \qabs x A \). \Cref{thm:substitution_on_alpha_equivalent_terms} then implies that \( A[x \mapsto n] \aequiv B[x \mapsto n] \).

  The general rule \ref{inf:def:lambda_term_alpha_equivalence/abs} then allows us to conclude that \( \qabs x A \aequiv \qabs x B \).

  Thus, \ref{inf:thm:alpha_equivalence_simplified/lift} is admissible.

  \SubProof*{Proof that \ref{inf:thm:alpha_equivalence_simplified/ren} is admissible} Fix variables \( a \neq b \) and terms \( A \) and \( B \) such that \( a \) is not free in \( B \) and \( A \aequiv B[b \mapsto a] \).

  Let \( n \) be any variable not free in \( \qabs a A \). \Cref{thm:substitution_on_alpha_equivalent_terms} implies that
  \begin{equation*}
    A[a \mapsto n] \aequiv B[b \mapsto a][a \mapsto n]
  \end{equation*}
  and \cref{thm:lambda_substitution_chain_contraction/precomposition} implies that
  \begin{equation*}
    A[a \mapsto n] \aequiv B[b \mapsto n].
  \end{equation*}

  The general rule \ref{inf:def:lambda_term_alpha_equivalence/abs} then allows us to conclude that \( \qabs a A \aequiv \qabs b B \).

  \NecessitySubProof We will show that \ref{inf:def:lambda_term_alpha_equivalence/abs} is admissible with respect to \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren}.

  Fix \( \muplambda \)-terms \( A \) and \( B \) and variables \( a \) and \( b \) and suppose that \( A[a \mapsto n] \aequiv B[b \mapsto n] \) for every variable \( n \) not free in \( \qabs a A \). In particular, we are interested in \( n = a \).

  \begin{itemize}
    \item If \( a = b \), then \cref{thm:lambda_substitution_noop} implies that \( A[a \mapsto a] = A \) and \( B[b \mapsto a] = B \), thus we can use \ref{inf:thm:alpha_equivalence_simplified/lift} to conclude that \( \qabs a A \aequiv \qabs b B \).

    \item Otherwise, \( A \aequiv B[b \mapsto a] \), and to use \ref{inf:thm:alpha_equivalence_simplified/ren} we must only verify that \( a \) is not free in \( B \).

    By \cref{thm:def:lambda_term_alpha_equivalence/abstraction_body_free}, \( b \) is not free in \( A \) (and hence in \( \qabs a A \)), thus we can use our assumption with \( n = b \) to conclude that \( A[a \mapsto b] \aequiv B \). By \cref{thm:def:lambda_term_alpha_equivalence/free}, \( A[a \mapsto b] \) and \( B \) have the same free variables. By \cref{thm:lambda_substitution_free_variables_single}, \( a \) is not free in \( A[a \mapsto b] \), hence also not in \( B \).

    Therefore, we can use \ref{inf:thm:alpha_equivalence_simplified/ren} to conclude that \( \qabs a A \aequiv \qabs b B \).
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:alpha_equivalence_simplified_right}
  In the simplified \( \alpha \)-equivalence rule \ref{inf:thm:alpha_equivalence_simplified/ren}, we may exchange the roles of the two sides and restate the rule as follows:
  \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha^{\logic{r}} }]{inf:thm:alpha_equivalence_simplified_right/ren}
    \begin{prooftree}
      \hypo{ a \neq b }
      \hypo{ b \not\in \op*{Free}(A) }
      \hypo{ A[a \mapsto b] \aequiv B }
      \infer3[\ref{inf:thm:alpha_equivalence_simplified_right/ren}]{ \qabs a A \aequiv \qabs b B }
    \end{prooftree}
  \end{equation*}
\end{proposition}
\begin{proof}
  Follows from symmetry of \( \alpha \)-equivalence.
\end{proof}

\begin{corollary}\label{thm:alpha_conversion_modified}
  If \( y \) and \( z \) are not free in \( M \), then
  \begin{equation}\label{eq:thm:alpha_conversion_modified}
    \qabs y M[x \mapsto y] \aequiv \qabs z M[x \mapsto z].
  \end{equation}
\end{corollary}
\begin{proof}
  \Cref{thm:lambda_substitution_chain_contraction/precomposition} implies that
  \begin{equation*}
    M[x \mapsto y] \aequiv M[x \mapsto z][z \mapsto y].
  \end{equation*}

  \Cref{thm:lambda_substitution_free_variables_single} implies that
  \begin{equation*}
    \op*{Free}(M[x \mapsto z]) \subseteq \parens[\Big]{ \op*{Free}(M) \setminus \set{ x } } \cup \set{ z }
  \end{equation*}

  Since \( y \) is not free in \( M \), it is thus not free in \( M[x \mapsto z] \).

  Thus, we can use the simplified rule \ref{inf:thm:alpha_equivalence_simplified/ren} with \( A = M[x \mapsto y] \) and \( B = M[x \mapsto z] \) to obtain \eqref{eq:thm:alpha_conversion_modified}.
\end{proof}

\begin{corollary}\label{thm:alpha_conversion}
  If \( y \) is not free in \( M \), then
  \begin{equation}\label{eq:thm:alpha_conversion}
    \qabs x M \aequiv \qabs y M[x \mapsto y]
  \end{equation}
\end{corollary}
\begin{comments}
  \item \incite[\S 2.1.11]{Barendregt1984LambdaCalculus} calls this property \enquote{\( \alpha \)-conversion} and uses it as a definition, while \incite[def. 1A8]{Hindley1997BasicSTT} calls it \enquote{change of bound variables} and calls \enquote{\( \alpha \)-conversion} the transitive closure of the relation obtained.
\end{comments}
\begin{proof}
  Special case of \cref{thm:alpha_conversion_modified} with \( z = x \).
\end{proof}

\begin{algorithm}[Separation of free and bound variables]\label{alg:separation_of_free_and_bound_variables}
  Fix a \( \muplambda \)-term \( M \). We will build an \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent} term \( M' \) where the \hyperref[def:lambda_variable_freeness]{free and bound variables} are distinct.

  Fix a map \( \sharp \) as in \cref{def:atomic_lambda_term_substitution} for generating fresh variable identifiers.

  We will use the following auxiliary operation, in which \( \Gamma \) is a set of variables that should be avoided:
  \begin{equation*}
    M'_\Gamma \coloneqq \begin{cases}
      M,                                 &M \in \op*{Atom}, \\
      N'_\Gamma \thinspace K'_\Gamma,    &M = NK, \\
      \qabs x N'_{\Gamma,x}              &M = \qabs x N \T{and} x \not\in \Gamma, \\
      \qabs n N'_{\Gamma,n}[x \mapsto n] &M = \qabs x N \T{and} x \in \Gamma,
    \end{cases}
  \end{equation*}
  where \( n \coloneqq \sharp(\op*{Free}(N) \cup \Gamma) \). We claim that \( M \aequiv M'_\Gamma \) and that the bound variables in \( M'_\Gamma \) are disjoint from \( \Gamma \).

  To obtain the desired \( \muplambda \)-term \( M' \), we simply take \( M'_\Gamma \) with \( \Gamma = \op*{Free}(M) \).
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.lambda_.untyped.alpha.separate_free_and_bound_variables} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  We proceed via \fullref{thm:induction_on_abstract_syntax} on of \( M \) to show that, for any finite set of variables \( \Gamma \), \( M \aequiv M'_\Gamma \) and the bound variables in \( M'_\Gamma \) are not in \( \Gamma \).

  \begin{itemize}
    \item If \( M \) is an atomic term, then \( M \) and \( M'_\Gamma \) are equal and hence also \( \alpha \)-equivalent. Furthermore, \( M \) has no bound variables.

    \item If \( M = NK \) and if the inductive hypothesis holds for both \( N \) and \( K \), then the rule \ref{inf:def:lambda_term_alpha_equivalence/app} allows us to conclude that \( M \aequiv M'_\Gamma \) and the inductive hypothesis allows us to conclude that the bound variables of \( M'_\Gamma \) are disjoint from \( \Gamma \).

    \item Finally, suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \). We have the following possibilities:
    \begin{itemize}
      \item If \( x \not\in \Gamma \), then \( M' = \qabs x N'_{\Gamma,x} \).

      By the inductive hypothesis, \( N \aequiv N'_{\Gamma,x} \) and the rule \ref{inf:thm:alpha_equivalence_simplified/lift} allows us to conclude that
      \begin{equation*}
        M = \qabs x N \aequiv \qabs x N'_{\Gamma,x} = M'_\Gamma.
      \end{equation*}

      Furthermore, by the inductive hypothesis,
      \begin{equation}\label{eq:alg:separation_of_free_and_bound_variables/proof/n_bound}
        \op*{Bound}(N'_{\Gamma,x}) \cap \parens[\Big]{ \Gamma \cup \set{ x } } = \varnothing,
      \end{equation}
      hence
      \begin{align*}
        \op*{Bound}(M'_\Gamma) \cap \Gamma
        &=
        \parens[\Big]{ \op*{Bound}(N'_{\Gamma,x}) \cup \set{ x } } \cap \Gamma
        \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} = \\ &=
        \parens[\Big]{ \underbrace{\op*{Bound}(N'_{\Gamma,x}) \cap \Gamma }_{\varnothing \T*{by} \eqref{eq:alg:separation_of_free_and_bound_variables/proof/n_bound}} } \cup \parens[\Big]{ \underbrace{\set{ x } \cap \Gamma}_{\mathclap{\varnothing \T*{by assumption}}} }
      \end{align*}

      \item If \( x \in \Gamma \), then \( M' = \qabs n N'_{\Gamma,n}[x \mapsto n] \), where \( n = \sharp(\op*{Free}(N) \cup \Gamma) \).

      By the inductive hypothesis, we have \( N \aequiv N'_{\Gamma,n} \). \Cref{thm:substitution_on_alpha_equivalent_terms} implies that
      \begin{equation}\label{eq:alg:separation_of_free_and_bound_variables/proof/final_ind}
        N[x \mapsto n] \aequiv N'_{\Gamma,n}[x \mapsto n].
      \end{equation}

      Let
      \begin{align*}
        a &\coloneqq n && A \coloneqq N[x \mapsto n], \\
        b &\coloneqq x && B \coloneqq N'_{\Gamma,n}.
      \end{align*}
      so that, in the notation of \ref{inf:thm:alpha_equivalence_simplified/ren}, \eqref{eq:alg:separation_of_free_and_bound_variables/proof/final_ind} becomes
      \begin{equation*}
        A \aequiv B[b \mapsto a].
      \end{equation*}

      By definition, \( a = n \) is not free in \( B = N \). Thus, we can apply \ref{inf:thm:alpha_equivalence_simplified/ren} and obtain \( M \aequiv M'_\Gamma \).

      Furthermore, by the inductive hypothesis,
      \begin{equation*}
        \op*{Bound}(N'_{\Gamma,n}) \cap \parens[\Big]{ \Gamma \cup \set{ n } } = \varnothing,
      \end{equation*}
      hence, again,
      \begin{align*}
        \op*{Bound}(M'_\Gamma) \cap \Gamma
        &=
        \parens[\Big]{ \op*{Bound}(N'_{\Gamma,n}) \cup \set{ n } } \cap \Gamma
        \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} = \\ &=
        \parens[\Big]{ \underbrace{\op*{Bound}(N'_{\Gamma,n}) \cap \Gamma }_\varnothing } \cup \parens[\Big]{ \underbrace{\set{ n } \cap \Gamma}_\varnothing }.
      \end{align*}
    \end{itemize}
  \end{itemize}
\end{defproof}
