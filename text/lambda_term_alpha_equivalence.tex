\section{\texorpdfstring{\( \muplambda \)}{λ}-term \texorpdfstring{\( \alpha \)}{α} equivalence}\label{sec:lambda_term_alpha_equivalence}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:lambda_term_alpha_equivalence}\mimprovised
  Using \fullref{thm:recursively_defined_relations}, we will define an equivalence relation between \( \muplambda \)-terms:

  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Atom}_\alpha }]{inf:def:lambda_term_alpha_equivalence/atom}
        \begin{prooftree}
          \hypo{ M \in \op*{Atom} }
          \infer1[\ref{inf:def:lambda_term_alpha_equivalence/atom}]{ M \aequiv M }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{App}_\alpha }]{inf:def:lambda_term_alpha_equivalence/app}
        \begin{prooftree}
          \hypo{ A \aequiv C }
          \hypo{ B \aequiv D }
          \infer2[\ref{inf:def:lambda_term_alpha_equivalence/app}]{ AB \aequiv CD }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_\alpha }]{inf:def:lambda_term_alpha_equivalence/abs}
    \begin{prooftree}
      \hypo{ A[a \mapsto n] \aequiv B[b \mapsto n] \T{for every} n \not\in \op*{Free}(\qabs a A) }
      \infer1[\ref{inf:def:lambda_term_alpha_equivalence/abs}]{ \qabs a A \aequiv \qabs b B }
    \end{prooftree}
  \end{equation*}

  The gist of \ref{inf:def:lambda_term_alpha_equivalence/abs} is that we want \( A[a \mapsto n] \aequiv B[a \mapsto n] \) to hold for every variable \( n \) that is not free in either \( A \) or \( B \), but we still want to allow \( n \) to be \( a \) or \( b \). This will simplify our inductive proofs, but it is impossible to mechanize. We will be able to split it into two simplified rules in \cref{thm:alpha_equivalence_simplified}.

  We do not need a separate condition for \( n \) not to be free in \( \qabs b B \) because, as we will show in \cref{thm:def:lambda_term_alpha_equivalence/free}, \( \qabs a A \) and \( \qabs b B \) have the same free variables if they are \( \alpha \)-equivalent.
\end{definition}
\begin{comments}
  \item \hyperref[def:typed_lambda_term]{Typed \( \muplambda \)-terms} require modified rules for abstraction --- see \cref{def:typed_term_alpha_equivalence}.

  \item Except for the explicit rule for constant terms, our rules resemble those in \cite[5]{Pollack2005AlphaConversion}, with two notable differences, both of which allow us to simplify inductive proofs:
  \begin{itemize}
    \item We have restricted \ref{inf:def:lambda_term_alpha_equivalence/atom} to atomic terms only, while Pollack states the rule for general terms.
    \item We have generalized the premise in \ref{inf:def:lambda_term_alpha_equivalence/abs} to hold for all suitable variables simultaneously, and have allowed this variable to be \( a \) or \( b \).
  \end{itemize}

  \item \incite[\S 2.1.11]{Barendregt1984LambdaCalculus} and \incite[def. 1A8]{Hindley1997BasicSTT} call the successive renaming of bound variables \enquote{\( \alpha \)-conversion} and consider \( \muplambda \)-terms \enquote{up to \( \alpha \)-conversion} (see \cref{rem:barendregt_convention}). Barendregt calls \enquote{\( \alpha \)-congruence} what we call \( \alpha \)-equivalence, while Hindley says that \enquote{\( M \) \( \alpha \)-converts to \( N \)}.

  \incite[5]{Pollack2005AlphaConversion} use \enquote{\( \alpha \)-conversion} and \enquote{\( \alpha \)-equivalence} interchangeably, while \incite[114]{Mimram2020ProgramEqualsProof} uses \enquote{\( \alpha \)-conversion} for what we call \( \alpha \)-equivalence.

  Due to this ambiguity, we will avoid using the term \enquote{\( \alpha \)-conversion}.

  \item The rules themselves can be formalized using \( \muplambda \)-term schemas and instantiations akin to how we will formalize the typing rules in \fullref{sec:curry_howard_correspondence}. Such formalization will introduce some complications akin to those described in \cref{rem:dependent_type_rule_formalization}, so we will avoid it.
\end{comments}

\begin{remark}\label{rem:barendregt_convention}\mcite[\S 2.1.12]{Barendregt1984LambdaCalculus}
  \incite*[\S 2.1.12]{Barendregt1984LambdaCalculus} assumes the following convention:
  \begin{displayquote}
    Terms that are \( \alpha \)-congruent are identified.
  \end{displayquote}

  Thus, Barendregt suggests regarding \( \muplambda \)-terms as equivalence classes. Up until \fullref{sec:dependent_types}, we will be stubborn about not following this convention and treating each \( \muplambda \)-term as a separate entity. This will ensure correctness of our definitions and theorems.
\end{remark}
\begin{comments}
  \item This is not to be confused with Barendregt's variable convention described in \cref{rem:barendregt_variable_convention}.
\end{comments}

\begin{definition}\label{def:lambda_renaming}
  We say that the \hyperref[def:lambda_term_substitution]{substitution} \( \Bbbs \) is a \term{renaming substitution} if \( \Bbbs(x) \) is a variable for every \( x \).
\end{definition}
\begin{comments}
  \item Renaming substitutions preserve the \hyperref[def:lambda_term_length]{length} of \( \muplambda \)-terms, which will aid us when proving \cref{thm:def:lambda_term_alpha_equivalence}.

  \item The definition is based on \cite[252]{Mimram2020ProgramEqualsProof}, but restated for \( \muplambda \)-terms.
\end{comments}

\begin{definition}\label{def:lambda_term_length}\mimprovised
  For inductive proofs, we will find useful to recursively define the \term{length} of a \( \muplambda \)-term as
  \begin{equation*}
    \len(M) \coloneqq \begin{cases}
      1,                     &M \in \op*{Atom}, \\
      2 + \len(N) + \len(K), &M = (NK), \\
      5 + \len(N),           &M = (\qabs x N). \\
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item If the variable names in \( M \) are single-symbol strings, then \( \len(M) \) is exactly the \hyperref[def:formal_language/string_length]{string length} of \( M \). The string length is the definition of term length given by \incite[\S 2.1.3]{Barendregt1984LambdaCalculus}.

  Our definition instead resembles that by \incite[def. 1A2]{Hindley1997BasicSTT}, but we also account for parentheses, dots and \( \muplambda \) itself.

  \item We have introduced this concept mostly for proofs like that of \cref{thm:def:lambda_term_alpha_equivalence/equivalence} so that the inductive hypothesis holds simultaneously for all terms of the same length.
\end{comments}

\begin{proposition}\label{thm:def:lambda_term_length}
  \( \muplambda \)-terms have the following basic properties regarding their \hyperref[def:lambda_term_length]{length}:
  \begin{thmenum}
    \thmitem{thm:def:lambda_term_length/subterm} Every strict subterm of a \( \muplambda \)-term is strictly shorter.

    \thmitem{thm:def:lambda_term_length/substitution} For any substitution \( \Bbbs \) and \( \muplambda \)-term \( M \), we have
    \begin{equation}\label{eq:thm:def:lambda_term_length/substitution}
      \len(M[\Bbbs]) = \len(M) + \sum_{\mathclap{u \in \op*{Free}(M)}} (\len(\Bbbs(u)) - 1).
    \end{equation}

    In particular, if \( \Bbbs \) is a \hyperref[def:lambda_renaming]{renaming substitution}, then \( \len(M[\Bbbs]) = \len(M) \).

    \thmitem{thm:def:lambda_term_length/equivalent} \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent}  \( \muplambda \)-terms have the same length.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:lambda_term_length/subterm} Trivial.

  \SubProofOf{thm:def:lambda_term_length/substitution} We proceed via \cref{thm:induction_on_rooted_trees} on the \hyperref[def:lambda_term_ast]{abstract syntax tree} of \( M \), simultaneously on all substitutions.
  \begin{itemize}
    \item If \( M \) is a constant, then \( M \) has no free variables, thus \eqref{eq:thm:def:lambda_term_length/substitution} holds vacuously.

    \item If \( M \) is a variable, then
    \begin{equation*}
      \len(M[\Bbbs]) = \len(\Bbbs(M)) = \len(M) + (\len(\Bbbs(M)) - \underbrace{\len(M)}_1).
    \end{equation*}

    \item If \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \), we have
    \begin{balign*}
      \len(M[\Bbbs])
      &=
      \len(N[\Bbbs] \thinspace K[\Bbbs])
      = \\ &=
      2 + \len(N[\Bbbs]) + \len(K[\Bbbs])
      \reloset {\T{ind.}} = \\ &=
      2 + \len(N) + \sum_{\mathclap{u \in \op*{Free}(N)}} \parens[\Big]{ \len(\Bbbs(u)) - 1 } + \len(K) + \sum_{\mathclap{u \in \op*{Free}(K)}} \parens[\Big]{ \len(\Bbbs(u)) - 1 }
      = \\ &=
      2 + \len(N) + \len(K) + \sum_{\mathclap{u \in \op*{Free}(NK)}} \parens[\Big]{ \len(\Bbbs(u)) - 1 }
      = \\ &=
      \len(NK) + \sum_{\mathclap{u \in \op*{Free}(NK)}} \parens[\Big]{ \len(\Bbbs(u)) - 1 }.
    \end{balign*}

    \item Finally, if \( M = \qabs x N \), where the inductive hypothesis holds for \( N \), \cref{thm:lambda_substitution_single_rule} implies that
    \begin{equation*}
      M[\Bbbs] = \qabs v N[\Bbbs_{x \mapsto v}],
    \end{equation*}
    where \( v \not\in \op*{Free}_\Bbbs(N) \).

    Then
    \begin{balign*}
      \len(M[\Bbbs])
      &=
      5 + \len(N[\Bbbs_{x \mapsto u}])
      \reloset {\T{ind.}} = \\ &=
      5 + \len(N) + \sum_{\mathclap{u \in \op*{Free}(N)}} (\len(\Bbbs_{x \mapsto v}(u)) - 1)
      = \\ &=
      5 + \len(N) + \sum_{\mathclap{u \in \op*{Free}(N) \setminus \set{ x }}} (\len(\Bbbs(u)) - 1) + (\underbrace{\len(v) - 1}_0)
      = \\ &=
      \len(M) + \sum_{\mathclap{u \in \op*{Free}(M)}} (\len(\Bbbs(u)) - 1).
    \end{balign*}
  \end{itemize}

  \SubProofOf{thm:def:lambda_term_length/equivalent} Straightforward considering \cref{thm:def:lambda_term_length/substitution}.
\end{proof}

\begin{proposition}\label{thm:def:lambda_term_alpha_equivalence}
  \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence} of \( \muplambda \)-terms has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:lambda_term_alpha_equivalence/same_kind} If two \( \muplambda \)-terms are \( \alpha \)-equivalent, they are both either variables, applications or abstractions.

    \thmitem{thm:def:lambda_term_alpha_equivalence/free} The free variables of \( \alpha \)-equivalent \( \muplambda \)-terms coincide.

    \thmitem{thm:def:lambda_term_alpha_equivalence/abstraction_condition} If \( \qabs a A \aequiv \qabs b B \), then \( a \) is free in \( A \) if and only if \( b \) is free in \( B \). Unless \( a = b \), however, \( a \) is never free in \( B \), nor \( b \) --- in \( A \).

    \thmitem{thm:def:lambda_term_alpha_equivalence/equivalence} \( \alpha \)-equivalence is an \hyperref[def:equivalence_relation]{equivalence relation}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:lambda_term_alpha_equivalence/same_kind} Follows by inspecting the conclusions of the rules in \cref{def:lambda_term_alpha_equivalence}.

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/free} We proceed via induction on the length of \( M \) to show that, if \( M \aequiv N \), then the free variables of \( M \) and \( N \) coincide.

  No term has length \( 0 \). As per \cref{rem:induction_base_case}, we will skip this case in the future, and consider the base case to be the terms of length \( 1 \).

  If \( M \) has length \( 1 \), it is necessarily an atom, and the only rule that allow us to conclude that \( M \aequiv N \) is \ref{inf:def:lambda_term_alpha_equivalence/atom}. It is satisfied only if \( M = N \). Thus, \( \op*{Free}(M) = \op*{Free}(N) \).

  If the length of \( M \) is strictly greater than \( 1 \), we have the following possibilities:
  \begin{itemize}
    \item If \( M = AB \), the rule \ref{inf:def:lambda_term_alpha_equivalence/app} is applicable if \( N \) is also an application, say \( N = CD \), and if both \( A \aequiv C \) and \( B \aequiv D \). Then
    \begin{equation*}
      \op*{Free}(M)
      =
      \op*{Free}(A) \cup \op*{Free}(B)
      \reloset{\T{ind.}} =
      \op*{Free}(C) \cup \op*{Free}(D)
      =
      \op*{Free}(N).
    \end{equation*}

    \item Otherwise, we have \( M = \qabs a A \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( N = \qabs b B \), where, for every variable \( n \) not free in \( \qabs a A \), we have
    \begin{equation*}
      A[a \mapsto n] \aequiv B[b \mapsto n].
    \end{equation*}

    We suppose that the inductive hypothesis holds for each term shorter than \( M \) and \( N \).

    In particular, \( A[a \mapsto a] \aequiv B[b \mapsto a] \). Furthermore, \cref{thm:lambda_substitution_noop} implies that \( A[a \mapsto a] = A \) and thus \( A \aequiv B[b \mapsto a] \).

    \begin{itemize}
      \item Suppose first that \( b \) is free in \( B \). Then
      \begin{equation*}
        \op*{Free}(A)
        \reloset{\T{ind.}} =
        \op*{Free}(B[b \mapsto a])
        \reloset {\eqref{eq:thm:lambda_substitution_free_variables_single}} =
        \parens[\Big]{ \op*{Free}(B) \setminus \set{ b } } \cup \set{ a },
      \end{equation*}
      hence
      \begin{equation*}
        \underbrace{\op*{Free}(\qabs a A)}_M
        =
        \op*{Free}(A) \setminus \set{ a }
        =
        \op*{Free}(B) \setminus \set{ b }
        =
        \underbrace{\op*{Free}(\qabs b B)}_N,
      \end{equation*}
      as desired.

      \item Otherwise, if \( b \) is not free in \( B \), then, by \cref{thm:lambda_substitution_noop}, \( B = B[b \mapsto a] \). Hence, \( A \aequiv B \).

      By the inductive hypothesis, \( \op*{Free}(A) = \op*{Free}(B) \).

      Since we have used \ref{inf:def:lambda_term_alpha_equivalence/abs}, we also have
      \begin{equation*}
        A[a \mapsto b] \aequiv \underbrace{B[b \mapsto b]}_B,
      \end{equation*}
      hence, by the inductive hypothesis,
      \begin{equation*}
        \op*{Free}(A[a \mapsto b]) = \op*{Free}(B).
      \end{equation*}

      Then the free variables of \( A \) and \( A[a \mapsto b] \) coincide. If \( a \) was free in \( A \), this would contradict \cref{thm:lambda_substitution_noop}. So \( a \) cannot be free in \( A \).

      Then
      \begin{multline*}
        \op*{Free}(\overbrace{\qabs a A}^M)
        =
        \op*{Free}(A) \setminus \set{ a }
        =
        \op*{Free}(A)
        = \\ =
        \op*{Free}(B)
        =
        \op*{Free}(B) \setminus \set{ b }
        =
        \op*{Free}(\underbrace{\qabs b B}_N),
      \end{multline*}
      as desired.
    \end{itemize}
  \end{itemize}

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/abstraction_condition}

  \SufficiencySubProof* Suppose that \( \qabs a A \aequiv \qabs b B \) and let \( a \) be free in \( A \).

  By \ref{inf:def:lambda_term_alpha_equivalence/abs}, we have \( B = B[b \mapsto b] \aequiv A[b \mapsto a] \). Then
  \begin{equation*}
    \op*{Free}(B)
    \reloset {\ref{thm:def:lambda_term_alpha_equivalence/free}} =
    \op*{Free}(A[a \mapsto b])
    \reloset {\eqref{eq:thm:lambda_substitution_free_variables_single}} =
    \parens[\Big]{ \op*{Free}(A) \setminus \set{ a } } \cup \set{ b }.
  \end{equation*}

  We have obtained that \( b \) is free in \( B \), while \( a \) is not (unless \( a = b \)).

  \NecessitySubProof* The converse is analogous.

  \Cref{thm:def:lambda_term_alpha_equivalence/free} implies that.

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/equivalence}

  \SubProofOf*[def:binary_relation/reflexive]{reflexivity} We proceed via \cref{thm:induction_on_rooted_trees} on the \( \muplambda \)-term \( M \) to show that \( M \aequiv N \) whenever \( M = N \).
  \begin{itemize}
    \item If \( M \) is an atomic term, the rule \ref{inf:def:lambda_term_alpha_equivalence/atom} directly implies that \( M \aequiv M \).
    \item If \( M = AB \) and the inductive hypothesis holds for \( A \) and \( B \), then \( A \aequiv A \) and \( B \aequiv B \), and the rule \ref{inf:def:lambda_term_alpha_equivalence/app} implies that \( M \aequiv M \).
    \item If \( M = \qabs x N \) and if the inductive hypothesis holds for \( N \), then \( N \aequiv N \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( M \aequiv M \).
  \end{itemize}

  \SubProofOf*[def:binary_relation/symmetric]{symmetry} We will use induction on the length of \( M \) to show that \( M \aequiv N \) implies \( N \aequiv M \).

  In the base case of length \( 1 \), we consider atomic terms, and the rule \ref{inf:def:lambda_term_alpha_equivalence/atom} implies that \( \alpha \)-equivalent atomic terms are equal.

  For longer terms, we have two possibilities:
  \begin{itemize}
    \item Suppose first that \( M = AB \). Then, if \( M \aequiv N \), \ref{inf:def:lambda_term_alpha_equivalence/app} implies that \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \).

    By the inductive hypothesis, \( C \aequiv A \) and \( D \aequiv B \). Applying \ref{inf:def:lambda_term_alpha_equivalence/app}, we conclude that \( N \aequiv M \).

    \item Otherwise, we have \( M = \qabs a A \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( N = \qabs b B \) and, for every variable \( n \) not free in \( M \), \( A[a \mapsto n] \aequiv B[b \mapsto n] \).

    By \cref{thm:def:lambda_term_length/substitution}, \( A[a \mapsto n] \) has the same length as \( A \), thus the inductive hypothesis holds for the former. Then \( B[b \mapsto n] \aequiv A[a \mapsto n] \).

    Furthermore, \cref{thm:def:lambda_term_alpha_equivalence/free} implies that \( n \) is not free in \( N \), so we can apply \ref{inf:def:lambda_term_alpha_equivalence/abs} to conclude that \( N \aequiv M \).
  \end{itemize}

  \SubProofOf*[def:binary_relation/transitive]{transitivity} We will again use induction on the length of \( M \) that \( M \aequiv N \) and \( N \aequiv K \) imply \( M \aequiv K \).

  The base case and the case where \( M \) is an application are straightforward. For the remaining case, suppose that \( M = \qabs a A \), so that \( N = \qabs b B \) and \( K = \qabs c C \).

  Fix a variable \( n \) not free in \( M \). \Cref{thm:def:lambda_term_alpha_equivalence/free} implies that \( n \) is also not free in \( N \). Then \( A[a \mapsto n] \aequiv B[b \mapsto n] \) and \( B[b \mapsto n] \aequiv C[c \mapsto n] \).

  The inductive hypothesis applies to terms shorter than \( M \), therefore
  \begin{equation*}
    A[a \mapsto n] \aequiv C[c \mapsto n].
  \end{equation*}

  We conclude via \ref{inf:def:lambda_term_alpha_equivalence/abs} that \( M \aequiv K \).
\end{proof}

\begin{example}\label{ex:def:lambda_term_alpha_equivalence}
  We list examples of \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}:
  \begin{thmenum}
    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/combinator} The combinator \( \ref{eq:ex:def:lambda_term/combinator/i} \) has the same essential structure regardless of how we name its variables:
    \begin{equation*}
      I = \qabs \synx \synx \aequiv \qabs \syny \syny \aequiv \qabs \syna \syna \aequiv \cdots
    \end{equation*}

    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/nested} Consider a more complicated case:
    \begin{align*}
      \qabs \synx \qabs \syny \synx \syny
      &&
      \T{and}
      &&
      \qabs \syny \qabs \synx \syny \synx.
    \end{align*}

    In the notation of \ref{inf:def:lambda_term_alpha_equivalence/abs}, we have
    \begin{equation*}
      \qabs {\underbrace{\synx}_a} \underbrace{\qabs \syny \synx \syny}_A
      \T{and}
      \qabs {\underbrace{\syny}_b} \underbrace{\qabs \synx \syny \synx}_B.
    \end{equation*}

    We reduce our \( \alpha \)-equivalence check to \( A[a \mapsto n] \) and \( B[b \mapsto n] \) (note that the bound variables were possibly renamed):
    \begin{equation*}
      \qabs c \underbrace{n c}_C
      \T{and}
      \qabs d \underbrace{n d}_D.
    \end{equation*}

    We further reduce our check to \( C[c \mapsto m] = nm \) and \( D[d \mapsto m] = nm \). The rule \ref{inf:def:lambda_term_alpha_equivalence/app} allows us to reduce this problem to checking whether \( n \aequiv n \) and \( m \aequiv m \), while \ref{inf:def:lambda_term_alpha_equivalence/atom} confirms that the latter equivalences hold. Therefore, our entire verification is correct and
    \begin{equation*}
      \qabs \synx \qabs \syny \synx \syny \aequiv \qabs \syny \qabs \synx \syny \synx.
    \end{equation*}

    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/freeing} In \cref{ex:def:lambda_variable_freeness/both} we discussed how \( \synx \) is both bound and free in \( M = I \synx = (\qabs \synx \synx) \synx \).

    We can use the term \( M' = (\qabs \syny \syny) \synx \) instead, where all occurrences of \( \synx \) are free and all occurrences of \( \syny \) are bound.

    This is generalized by \fullref{alg:separation_of_free_and_bound_variables}.
  \end{thmenum}
\end{example}

\paragraph{Invariance of \( \alpha \)-equivalence under substitution}

\begin{definition}\label{def:lambda_substitution_composition}\mimprovised
  We define the \term{composition} \( \Bbbt\Bbbs \) of the \hyperref[def:lambda_term]{\( \muplambda \)-term} \hyperref[def:lambda_term_substitution]{substitutions} \( \Bbbs \) and \( \Bbbt \) as
  \begin{equation}\label{eq:def:lambda_substitution_composition}
    \parens[\big]{ \Bbbt\Bbbs }(a) \coloneqq a[\Bbbs][\Bbbt].
  \end{equation}

  This extends recursively to any number of substitutions, starting with the identity \( \id \) as a nullary composition.
\end{definition}
\begin{comments}
  \item In more complicated cases we may also use the symbol \enquote{\( \circ \)} to denote composition, for example when handling \( \Bbbt_{v \mapsto w} \bincirc \Bbbs_{x \mapsto v} \) in the proof of \cref{thm:nary_substitution_composition_match_is_alpha_equivalent}.
\end{comments}

\begin{lemma}\label{thm:substitution_composition_free_variables}
  For the \hyperref[def:lambda_term_substitution]{substitution} \( \Bbbs \) and \( \Bbbt \), we have
  \begin{equation}\label{eq:thm:thm:substitution_composition_free_variables}
    \op*{Free}(M[\Bbbs][\Bbbt]) = \op*{Free}_{\Bbbt\Bbbs}(M),
  \end{equation}
  where \( \Bbbt\Bbbs \) is their composition in the sense of \cref{def:lambda_substitution_composition}.

  This straightforwardly extends to any number of substitutions.
\end{lemma}
\begin{proof}
  \begin{align*}
    \op*{Free}_{\Bbbt\Bbbs}(M)
    &=
    \bigcup_{a \in \op*{Free}(M)} \op*{Free}(a[\Bbbs][\Bbbt])
    \reloset {\ref{thm:lambda_substitution_free_variables}} = \\ &=
    \bigcup_{a \in \op*{Free}(M)} \op*{Free}_\Bbbt(\Bbbs(a))
    = \\ &=
    \bigcup_{a \in \op*{Free}(M)} \bigcup_{b \in \op*{Free}(\Bbbs(a))} \op*{Free}(\Bbbt(b))
    = \\ &=
    \bigcup_{b \in \op*{Free}_\Bbbs(M)} \op*{Free}(\Bbbt(b))
    \reloset {\ref{thm:lambda_substitution_free_variables}} = \\ &=
    \bigcup_{b \in \op*{Free}(M[\Bbbs])} \op*{Free}(\Bbbt(b))
    = \\ &=
    \op*{Free}_\Bbbt(M[\Bbbs])
    \reloset {\ref{thm:lambda_substitution_free_variables}} = \\ &=
    \op*{Free}(M[\Bbbs][\Bbbt]).
  \end{align*}
\end{proof}

\begin{lemma}\label{thm:composition_of_lambda_substitutions_lemma}
  Fix a \( \muplambda \)-term \( M \) and a sequence of \hyperref[def:lambda_term_substitution]{substitutions} \( \Bbbs_1, \ldots, \Bbbs_n \).

  Fix also variables \( v_0, \ldots, v_n \) as follows:
  \begin{thmenum}
    \thmitem{thm:composition_of_lambda_substitutions_lemma/endpoints} We put no restrictions on \( v_0 \) and \( v_n \).
    \thmitem{thm:composition_of_lambda_substitutions_lemma/midpoints} For \( 1 \leq k \leq n - 1 \), we suppose that \( v_k \) is \hi{not} in \( \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M) \).
  \end{thmenum}

  We claim that the \hyperref[def:lambda_substitution_composition]{composite substitution} \( (\Bbbs_k)_{v_{n-1} \mapsto v_n} \cdots (\Bbbs_1)_{v_0 \mapsto v_1} \) agrees with \( (\Bbbs_n \cdots \Bbbs_1)_{v_0 \mapsto v_n} \) on the free variables of \( M \).
\end{lemma}
\begin{comments}
  \item This lemma is instrumental in our proof of \cref{thm:nary_substitution_composition_match_is_alpha_equivalent}.
\end{comments}
\begin{proof}
  We will use induction on \( n \).
  \begin{itemize}
    \item The case \( n = 0 \) is vacuous because there is no sequence of substitutions. In this case \( v_0 = v_n \), and we must simply note that the substitutions \( \id_{v_0 \mapsto v_0} \) and \( \id \) agree.

    \item We will also separately handle \( n = 1 \), which is again vacuous. In this case there is only one substitution, and we must conclude that \( (\Bbbs_1)_{v_0 \mapsto v_n} \) agrees with itself.

    \item For \( n > 1 \), we have
    \begin{equation*}
      \parens[\big]{ (\Bbbs_n)_{v_{n-1} \mapsto v_n} \cdots (\Bbbs_1)_{v_0 \mapsto v_1} }(a)
      =
      \begin{cases}
        v_n,                                        &a = v_0, \\
        v_n,                                        &v_1 \in \op*{Free}\parens[\big]{ \Bbbs_1(a) }, \\
                                                    &\vdots \\
        v_n,                                        &v_{n-1} \in \op*{Free}\parens[\big]{ \parens[\big]{ \Bbbs_{n-1} \cdots \Bbbs_1 }(a) }, \\
        \parens[\big]{ \Bbbs_n \cdots \Bbbs_1 }(a), &\T{otherwise.}
      \end{cases}
    \end{equation*}

    By assumption, for any index \( k = 1, \ldots, n \), the variable \( v_k \) is not in \( \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M) \). Thus, it is not free in \( \parens[\big]{ \Bbbs_k \cdots \Bbbs_1 }(a) \) whenever \( a \) is free in \( M \).

    Therefore, on the free variables of \( M \), we fall into neither case that distinguishes the composition \( (\Bbbs_n)_{v_{n-1} \mapsto v_n} \cdots (\Bbbs_1)_{v_0 \mapsto v_1} \) from \( (\Bbbs_n \cdots \Bbbs_1)_{v_0 \mapsto v_n} \).
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:nary_substitution_composition_match_is_alpha_equivalent}
  Fix a \( \muplambda \)-term \( M \) and fix \hyperref[def:lambda_term_substitution]{substitutions} --- \( \Bbbs_1, \ldots, \Bbbs_n \) and \( \Bbbt \) --- such that \( \Bbbt \) agrees with the \hyperref[def:lambda_substitution_composition]{composition} \( \Bbbs_n \cdots \Bbbs_1 \) on the free variables of \( M \).

  Explicitly, we require the following to hold for every free variable \( a \) of \( M \):
  \begin{equation*}
    a[\Bbbt] = a[\Bbbs_1] \cdots [\Bbbs_n].
  \end{equation*}

  Then
  \begin{equation}\label{eq:thm:nary_substitution_composition_match_is_alpha_equivalent}
    M[\Bbbt] \aequiv M[\Bbbs_1] \cdots [\Bbbs_n].
  \end{equation}
\end{proposition}
\begin{comments}
  \item We will need much weaker variants of this proposition. For example, \cref{thm:nary_substitution_composition_is_alpha_equivalent} only consider the case where \( \Bbbt = \Bbbs_n \cdots \Bbbs_1 \). A useful further special case is \cref{thm:substitution_chain_contraction}.

  The variant we state here is necessary for proving the inductive step.
\end{comments}
\begin{proof}
  We will use \cref{thm:induction_on_rooted_trees} on the \hyperref[def:lambda_term_ast]{abstract syntax tree} of \( M \), simultaneously for every \( n \) and all suitable substitutions.

  To avoid trivial considerations, we handle the case \( n = 0 \) separately. \Cref{thm:lambda_substitution_identity} implies \( M[\id] = M \), and, due to the reflexivity \( \alpha \)-equivalence, \( M[\id] \aequiv M \).

  Now, we can suppose that \( n > 0 \).

  \begin{itemize}
    \item If \( M \) is a constant, it is invariant under substitution, and thus
    \begin{equation*}
      M[\Bbbt] = M = M[\Bbbs_1] \cdots [\Bbbs_n].
    \end{equation*}

    Then \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent} again follows from the reflexivity of \( \alpha \)-equivalence.

    \item If \( M \) is a variable, then \( \op*{Free}(M) = \set{ M } \), and, by assumption,
    \begin{equation*}
      M[\Bbbt] = M[\Bbbs_1] \cdots [\Bbbs_n]
    \end{equation*}

    Then \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent} again follows from the reflexivity of \( \alpha \)-equivalence.

    \item Suppose that \( M = NK \) and that the inductive hypothesis holds for \( N \) and \( K \).

    We have
    \begin{equation*}
      M[\Bbbt] = N[\Bbbt] \thinspace K[\Bbbt].
    \end{equation*}

    The free variables of \( M \) are the union of those of \( N \) and \( K \), thus \( \Bbbt \) and \( \Bbbs_n \cdots \Bbbs_1 \) agree on them. Then, by the inductive hypothesis, \( N[\Bbbt] \aequiv N[\Bbbs_n] \cdots [\Bbbs_1] \) and similarly for \( K \), and we conclude that \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent} holds by applying \ref{inf:def:lambda_term_alpha_equivalence/app}.

    \item Finally, suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \).

    We will utilize \cref{thm:lambda_substitution_single_rule} several times. Let \( v_0 \coloneqq x \). Then
    \begin{align*}
      M[\Bbbt]                    &= \qabs u N\bracks[\big]{ \Bbbt_{x \mapsto u} },                                                                     &&u \not\in \op*{Free}_\Bbbt(M), \\
      M[\Bbbs_1] \cdots [\Bbbs_k] &= \qabs {v_k} N\bracks[\big]{ (\Bbbs_1)_{v_0 \mapsto v_1} } \cdots \bracks[\big]{ (\Bbbs_k)_{v_{k-1} \mapsto v_k} }, &&v_k \not\in \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M),
    \end{align*}
    where \( k \) ranges from \( 1 \) to \( n \).

    Note that, due to \cref{thm:substitution_composition_free_variables}, we have \( \op*{Free}_{\Bbbs_{k-1} \cdots \Bbbs_1}(M[\Bbbs_k]) = \op*{Free}_{\Bbbs_k \cdots \Bbbs_1}(M) \).

    Fix a variable \( w \) not in \( \op*{Free}_\Bbbt(M) \)\fnote{We will not actually use this assumption. It is simply what \ref{inf:def:lambda_term_alpha_equivalence/abs} assumes.}. To use \ref{inf:def:lambda_term_alpha_equivalence/abs}, we must conclude that
    \begin{equation}\label{eq:thm:nary_substitution_composition_match_is_alpha_equivalent/proof/abstraction/goal}
      N\bracks[\big]{ \Bbbt_{x \mapsto u} }\bracks[\big]{ u \mapsto w } \aequiv N\bracks[\big]{ (\Bbbs_1)_{v_0 \mapsto v_1} } \cdots \bracks[\big]{ (\Bbbs_n)_{v_{n-1} \mapsto v_n} } \bracks[\big]{ v_n \mapsto w }.
    \end{equation}

    With the conditions on \( v_1, \ldots, v_n \), we can utilize \cref{thm:composition_of_lambda_substitutions_lemma} to conclude that the composed substitution
    \begin{equation}\label{eq:thm:nary_substitution_composition_match_is_alpha_equivalent/proof/abstraction/long_composed}
      \id_{v_n \mapsto w} \bincirc (\Bbbs_n)_{v_{n-1} \mapsto v_n} \bincirc \cdots \bincirc (\Bbbs_1)_{v_0 \mapsto v_1}
    \end{equation}
    agrees with \( (\Bbbs_n \cdots \Bbbs_1)_{x \mapsto w} \) on the free variables of \( M \). Furthermore, by assumption, on the free variables of \( M \), the composition \( \Bbbs_n \cdots \Bbbs_1 \) agrees with \( \Bbbt \); hence, \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent/proof/abstraction/long_composed} in turn also agrees with \( \Bbbt_{x \mapsto w} \).

    Note that \( x \) is not free in \( M \), but it is possibly free in \( N \)\fnote{This precise situation will be described in more detail in \cref{thm:substitution_chain_contraction/composition}.}. It is precisely the value which we modify the substitutions at, thus \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent/proof/abstraction/long_composed} also agrees with \( \Bbbt_{x \mapsto w} \) on the free variables of \( N \). Therefore, by the inductive hypothesis,
    \begin{equation*}
      N\bracks[\big]{ (\Bbbs_1)_{v_0 \mapsto v_1} } \cdots \bracks[\big]{ (\Bbbs_n)_{v_{n-1} \mapsto v_n} } \bracks[\big]{ v_n \mapsto w }
      \aequiv
      N\bracks[\big]{ \Bbbt_{x \mapsto w} }.
    \end{equation*}

    Similarly, since \( u \) is not in \( \op*{Free}_\Bbbt(M) \), \cref{thm:composition_of_lambda_substitutions_lemma} implies that the composition \( \id_{u \mapsto w} \bincirc \Bbbt_{x \mapsto u} \) agrees with \( \Bbbt_{x \mapsto w} \) on the free variables of \( N \). Thus, by the inductive hypothesis,
    \begin{equation*}
      N\bracks[\big]{ \Bbbt_{x \mapsto u} }\bracks[\big]{ u \mapsto w }
      \aequiv
      N\bracks[\big]{ \Bbbt_{x \mapsto w} }.
    \end{equation*}

    We have shown that both sides of \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent/proof/abstraction/goal} are \( \alpha \)-equivalent to \( N\bracks[\big]{ \Bbbt_{x \mapsto w} } \).

    It remains to apply \ref{inf:def:lambda_term_alpha_equivalence/abs} to generalize this from \( N \) to \( M \), i.e. to obtain \eqref{eq:thm:nary_substitution_composition_match_is_alpha_equivalent}.
  \end{itemize}
\end{proof}

\begin{corollary}\label{thm:nary_substitution_composition_is_alpha_equivalent}
  For the \hyperref[def:lambda_substitution_composition]{composition} \( \Bbbs_n \cdots \Bbbs_1 \) of the substitutions \( \Bbbs_1, \ldots, \Bbbs_n \), we have
  \begin{equation}\label{eq:thm:nary_substitution_composition_is_alpha_equivalent}
    M[\Bbbs_n \cdots \Bbbs_1] \aequiv M[\Bbbs_1] \cdots [\Bbbs_n]
  \end{equation}
  for any \( \muplambda \)-term \( M \).
\end{corollary}
\begin{proof}
  Special case of \cref{thm:nary_substitution_composition_match_is_alpha_equivalent} with \( \Bbbt = \Bbbs_n \cdots \Bbbs_1 \).
\end{proof}

\begin{corollary}\label{thm:substitution_chain_contraction}
  Fix a \hyperref[def:lambda_term_substitution]{\( \muplambda \)-term substitution} \( \Bbbs \).

  \begin{thmenum}
    \thmitem{thm:substitution_chain_contraction/precomposition} For any variable \( y \) not in \( \op*{Free}(M) \), we have
    \begin{equation}\label{eq:thm:substitution_chain_contraction/precomposition}
      M[x \mapsto y][\Bbbs_{y \mapsto N}]
      \aequiv
      M[\Bbbs_{x \mapsto N}]
    \end{equation}

    This also holds more generally if \( x = y \).

    In this case, \( y \) depends only on \( M \).

    \thmitem{thm:substitution_chain_contraction/composition} For any variable \( y \) not in \( \op*{Free}_\Bbbs(M) \), we have
    \begin{equation}\label{eq:thm:substitution_chain_contraction/composition}
      M[\Bbbs_{x \mapsto y}][y \mapsto N]
      \aequiv
      M[\Bbbs_{x \mapsto N}].
    \end{equation}

    We will find useful the following generalization of the requirement \( y \not\in \op*{Free}_\Bbbs(M) \):
    \begin{displayquote}
      If \( y \in \op*{Free}(\Bbbs(p)) \) for some free variable \( p \) of \( M \), this variable is necessarily \( x \).
    \end{displayquote}

    In this case, \( y \) depends on the interaction of \( \Bbbs \) and \( M \).
  \end{thmenum}
\end{corollary}
\begin{proof}
  \SubProofOf{thm:substitution_chain_contraction/precomposition} Note that \( \op*{Free}(M) = \op*{Free}_{\id}(M) \), hence the assumption that \( y \) is not in \( \op*{Free}(M) \) allows us to use \cref{thm:nary_substitution_composition_is_alpha_equivalent} directly on the composition \( \Bbbs_{y \mapsto N} \bincirc \id_{x \mapsto y} \).

  If \( x = y \), \cref{thm:lambda_substitution_identity} implies that \( M[x \mapsto y] = M \), and \eqref{eq:thm:substitution_chain_contraction/precomposition} becomes trivial.

  \SubProofOf{thm:substitution_chain_contraction/composition} We use the generalized assumption on \( y \) --- that \( y \in \op*{Free}(\Bbbs(p)) \) implies \( p = x \) if \( p \) is a free variable of \( M \).

  Since we modify \( \Bbbs \) precisely at \( x \), the composition \( \id_{y \mapsto N} \bincirc \Bbbs_{x \mapsto y} \) agrees with \( \Bbbs_{x \mapsto N} \) on the free variables of \( M \).

  An application of \cref{thm:nary_substitution_composition_match_is_alpha_equivalent} yields \eqref{eq:thm:substitution_chain_contraction/composition}.
\end{proof}

\begin{proposition}\label{thm:substitution_on_alpha_equivalent_terms}
  If \( M \aequiv N \), for any \hyperref[def:lambda_term_substitution]{substitution} \( \Bbbs \), we have \( M[\Bbbs] \aequiv N[\Bbbs] \).
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \aequiv N \).

  \begin{itemize}
    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/atom}, then \( M \) and \( N \) are the same atom.

    Either \( M \) and \( N \) are the same constants or the same variable. In both cases, \( M[\Bbbs] = N[\Bbbs] \).

    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/app}, then \( M = AB \) and \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \) and the inductive hypothesis holds for the latter two.

    By this inductive hypothesis, we have \( A[\Bbbs] \aequiv C[\Bbbs] \) and \( B[\Bbbs] \aequiv D[\Bbbs] \), and we can apply \ref{inf:def:lambda_term_alpha_equivalence/app} to obtain
    \begin{equation*}
      M[\Bbbs]
      =
      A[\Bbbs] \thinspace B[\Bbbs]
      \aequiv
      C[\Bbbs] \thinspace D[\Bbbs]
      =
      N[\Bbbs],
    \end{equation*}
    as desired.

    \item Finally, if \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/abs}, then \( M = \qabs a A \), \( N = \qabs b B \) and, for every variable \( n \) not free in \( M \), we have
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/assumption}
      A[a \mapsto n] \aequiv B[b \mapsto n].
    \end{equation}

    We suppose that the inductive hypothesis holds for \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/assumption} for any suitable \( n \).

    Before using it, we must first inspect \( M[\Bbbs] \) and \( N[\Bbbs] \). We use \cref{thm:lambda_substitution_single_rule} twice:
    \begin{align*}
      M[\Bbbs] &= \qabs u A[\Bbbs_{a \mapsto u}], &&u \not\in \op*{Free}_\Bbbs(M), \\
      N[\Bbbs] &= \qabs v B[\Bbbs_{b \mapsto v}], &&v \not\in \op*{Free}_\Bbbs(N).
    \end{align*}

    To conclude that \( M[\Bbbs] \aequiv N[\Bbbs] \), we will use the rule \ref{inf:def:lambda_term_alpha_equivalence/abs}. Fix a variable \( m \) not free in \( M[\Bbbs] \). We need to show that
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/pregoal}
      A[\Bbbs_{a \mapsto u}][u \mapsto m] \aequiv B[\Bbbs_{b \mapsto v}][v \mapsto m].
    \end{equation}

    We can use the inductive hypothesis on \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/assumption} with \( n = a \) as follows:
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp}
      A[a \mapsto a][\Bbbs_{a \mapsto m}] \aequiv B[b \mapsto a][\Bbbs_{a \mapsto m}].
    \end{equation}

    As we will show both \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/pregoal} and \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp} collapse to
    \begin{equation}\label{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/goal}
      A[\Bbbs_{a \mapsto m}] \aequiv B[\Bbbs_{b \mapsto m}].
    \end{equation}

    To conclude that \( M[\Bbbs] \aequiv N[\Bbbs] \), it remains to apply \ref{inf:def:lambda_term_alpha_equivalence/abs}.

    \SubProof{Proof that \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/pregoal} collapses to \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/goal}} Since \( u \) is not in \( \op*{Free}_\Bbbs(M) \), \cref{thm:substitution_chain_contraction/composition} implies that
    \begin{equation*}
      A[\Bbbs_{a \mapsto u}][u \mapsto m] \aequiv A[\Bbbs_{a \mapsto m}],
    \end{equation*}
    and similarly
    \begin{equation*}
      A[\Bbbs_{b \mapsto v}][v \mapsto m] \aequiv B[\Bbbs_{b \mapsto m}].
    \end{equation*}

    \SubProof{Proof that \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp} collapses to \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/goal}} Here the left and right side require different reasoning.

    First, \cref{thm:lambda_substitution_identity} implies that \( A[a \mapsto a] = A \), so the left side of \eqref{eq:thm:substitution_on_alpha_equivalent_terms_lemma/proof/hyp} becomes \( A[\Bbbs_{a \mapsto m}] \).

    For the right side, we can use \cref{thm:def:lambda_term_alpha_equivalence/abstraction_condition} to conclude that \( a \) is not free in \( B \), and \cref{thm:substitution_chain_contraction/precomposition} to conclude that
    \begin{equation*}
      B[b \mapsto a][\Bbbs_{a \mapsto m}] \aequiv B[\Bbbs_{b \mapsto m}].
    \end{equation*}
  \end{itemize}
\end{proof}

\paragraph{Mechanizing \( \alpha \)-equivalence}

\begin{proposition}\label{thm:alpha_equivalence_simplified}
  The rule \ref{inf:def:lambda_term_alpha_equivalence/abs}, specifying when two abstractions are \( \alpha \)-equivalent, is tantamount to the following pair of rules:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Lift}_\alpha }]{inf:thm:alpha_equivalence_simplified/lift}
        \begin{prooftree}
          \hypo{ A \aequiv B }
          \infer1[\ref{inf:thm:alpha_equivalence_simplified/lift}]{ \qabs x A \aequiv \qabs x B }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha }]{inf:thm:alpha_equivalence_simplified/ren}
        \begin{prooftree}
          \hypo{ a \neq b }
          \hypo{ a \not\in \op*{Free}(B) }
          \hypo{ A \aequiv B[b \mapsto a] }
          \infer3[\ref{inf:thm:alpha_equivalence_simplified/ren}]{ \qabs a A \aequiv \qabs b B }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{proposition}
\begin{comments}
  \item This check can be found as \identifier{lambda_.untyped.alpha.are_terms_alpha_equivalent} in \cite{notebook:code}.
\end{comments}
\begin{proof}
  \SufficiencySubProof We will first show that \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren} are \hyperref[con:inference_rule_admissibility]{admissible} with respect to \ref{inf:def:lambda_term_alpha_equivalence/abs}.

  \SubProof*{Proof that \ref{inf:thm:alpha_equivalence_simplified/lift} is admissible} Fix a variable \( x \) and terms \( A \aequiv B \). Let \( n \) be any variable not free in \( \qabs x A \). \Cref{thm:substitution_on_alpha_equivalent_terms} then implies that \( A[x \mapsto n] \aequiv B[x \mapsto n] \).

  The general rule \ref{inf:def:lambda_term_alpha_equivalence/abs} then allows us to conclude that \( \qabs x A \aequiv \qabs x B \).

  Thus, \ref{inf:thm:alpha_equivalence_simplified/lift} is admissible.

  \SubProof*{Proof that \ref{inf:thm:alpha_equivalence_simplified/ren} is admissible} Fix variables \( a \neq b \) and terms \( A \) and \( B \) such that \( a \) is not free in \( B \) and \( A \aequiv B[b \mapsto a] \).

  Let \( n \) be any variable not free in \( \qabs a A \). \Cref{thm:substitution_on_alpha_equivalent_terms} implies that
  \begin{equation*}
    A[a \mapsto n] \aequiv B[b \mapsto a][a \mapsto n]
  \end{equation*}
  and \cref{thm:substitution_chain_contraction/precomposition} implies that
  \begin{equation*}
    A[a \mapsto n] \aequiv B[b \mapsto n].
  \end{equation*}

  The general rule \ref{inf:def:lambda_term_alpha_equivalence/abs} then allows us to conclude that \( \qabs a A \aequiv \qabs b B \).

  \NecessitySubProof We will show that \ref{inf:def:lambda_term_alpha_equivalence/abs} is admissible with respect to \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren}.

  Fix \( \muplambda \)-terms \( A \) and \( B \) and variables \( a \) and \( b \) and suppose that \( A[a \mapsto n] \aequiv B[b \mapsto n] \) for every variable \( n \) not free in \( \qabs a A \). In particular, we are interested in \( n = a \).

  \begin{itemize}
    \item If \( a = b \), then \cref{thm:lambda_substitution_noop} implies that \( A[a \mapsto a] = A \) and \( B[b \mapsto a] = B \), thus we can use \ref{inf:thm:alpha_equivalence_simplified/lift} to conclude that \( \qabs a A \aequiv \qabs b B \).

    \item Otherwise, \( A \aequiv B[b \mapsto a] \), and to use \ref{inf:thm:alpha_equivalence_simplified/ren} we must only verify that \( a \) is not free in \( B \).

    By \cref{thm:def:lambda_term_alpha_equivalence/abstraction_condition}, \( b \) is not free in \( A \) (and hence in \( \qabs a A \)), thus we can use our assumption with \( n = b \) to conclude that \( A[a \mapsto b] \aequiv B \). By \cref{thm:def:lambda_term_alpha_equivalence/free}, \( A[a \mapsto b] \) and \( B \) have the same free variables. By \cref{thm:lambda_substitution_free_variables_single}, \( a \) is not free in \( A[a \mapsto b] \), hence also not in \( B \).

    Therefore, we can use \ref{inf:thm:alpha_equivalence_simplified/ren} to conclude that \( \qabs a A \aequiv \qabs b B \).
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:alpha_equivalence_simplified_right}
  In the simplified \( \alpha \)-equivalence rule \ref{inf:thm:alpha_equivalence_simplified/ren}, we may exchange the roles of the two sides and restate the rule as follows:
  \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha^{\logic{r}} }]{inf:thm:alpha_equivalence_simplified_right/ren}
    \begin{prooftree}
      \hypo{ a \neq b }
      \hypo{ b \not\in \op*{Free}(A) }
      \hypo{ A[a \mapsto b] \aequiv B }
      \infer3[\ref{inf:thm:alpha_equivalence_simplified_right/ren}]{ \qabs a A \aequiv \qabs b B }
    \end{prooftree}
  \end{equation*}
\end{proposition}
\begin{proof}
  Follows from symmetry of \( \alpha \)-equivalence.
\end{proof}

\begin{corollary}\label{thm:alpha_conversion_modified}
  If \( y \) and \( z \) are not free in \( M \), then
  \begin{equation}\label{eq:thm:alpha_conversion_modified}
    \qabs y M[x \mapsto y] \aequiv \qabs z M[x \mapsto z].
  \end{equation}
\end{corollary}
\begin{proof}
  \Cref{thm:substitution_chain_contraction/precomposition} implies that
  \begin{equation*}
    M[x \mapsto y] \aequiv M[x \mapsto z][z \mapsto y].
  \end{equation*}

  \Cref{thm:lambda_substitution_free_variables_single} implies that
  \begin{equation*}
    \op*{Free}(M[x \mapsto z]) \subseteq \parens[\Big]{ \op*{Free}(M) \setminus \set{ x } } \cup \set{ z }
  \end{equation*}

  Since \( y \) is not free in \( M \), it is thus not free in \( M[x \mapsto z] \).

  Thus, we can use the simplified rule \ref{inf:thm:alpha_equivalence_simplified/ren} with \( A = M[x \mapsto y] \) and \( B = M[x \mapsto z] \) to obtain \eqref{eq:thm:alpha_conversion_modified}.
\end{proof}

\begin{corollary}\label{thm:alpha_conversion}
  If \( y \) is not free in \( M \), then
  \begin{equation}\label{eq:thm:alpha_conversion}
    \qabs x M \aequiv \qabs y M[x \mapsto y]
  \end{equation}
\end{corollary}
\begin{comments}
  \item \incite[\S 2.1.11]{Barendregt1984LambdaCalculus} calls this property \enquote{\( \alpha \)-conversion} and uses it as a definition, while \incite[def. 1A8]{Hindley1997BasicSTT} calls it \enquote{change of bound variables} and calls \enquote{\( \alpha \)-conversion} the transitive closure of the relation obtained.
\end{comments}
\begin{proof}
  Special case of \cref{thm:alpha_conversion_modified} with \( z = x \).
\end{proof}

\begin{algorithm}[Separation of free and bound variables]\label{alg:separation_of_free_and_bound_variables}
  Fix a \( \muplambda \)-term \( M \). We will build an \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent} term \( M' \) where the \hyperref[def:lambda_variable_freeness]{free and bound variables} are distinct.

  Fix a map \( \sharp \) as in \cref{def:lambda_term_substitution} for generating fresh variable identifiers.

  We will use the following auxiliary operation, in which \( \Gamma \) is a set of variables that should be avoided:
  \begin{equation*}
    M'_\Gamma \coloneqq \begin{cases}
      M,                                 &M \in \op*{Atom}, \\
      N'_\Gamma \thinspace K'_\Gamma,    &M = NK, \\
      \qabs x N'_{\Gamma,x}              &M = \qabs x N \T{and} x \not\in \Gamma, \\
      \qabs n N'_{\Gamma,n}[x \mapsto n] &M = \qabs x N \T{and} x \in \Gamma,
    \end{cases}
  \end{equation*}
  where \( n \coloneqq \sharp(\op*{Free}(N) \cup \Gamma) \). We claim that \( M \aequiv M'_\Gamma \) and that the bound variables in \( M'_\Gamma \) are disjoint from \( \Gamma \).

  To obtain the desired \( \muplambda \)-term \( M' \), we simply take \( M'_\Gamma \) with \( \Gamma = \op*{Free}(M) \).
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.untyped.alpha.separate_free_and_bound_variables} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  We proceed via \cref{thm:induction_on_rooted_trees} on the \hyperref[def:lambda_term_ast]{abstract syntax tree} of \( M \) to show that, for any finite set of variables \( \Gamma \), \( M \aequiv M'_\Gamma \) and the bound variables in \( M'_\Gamma \) are not in \( \Gamma \).

  \begin{itemize}
    \item If \( M \) is an atomic term, then \( M \) and \( M'_\Gamma \) are equal and hence also \( \alpha \)-equivalent. Furthermore, \( M \) has no bound variables.

    \item If \( M = NK \) and if the inductive hypothesis holds for both \( N \) and \( K \), then the rule \ref{inf:def:lambda_term_alpha_equivalence/app} allows us to conclude that \( M \aequiv M'_\Gamma \) and the inductive hypothesis allows us to conclude that the bound variables of \( M'_\Gamma \) are disjoint from \( \Gamma \).

    \item Finally, suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \). We have the following possibilities:
    \begin{itemize}
      \item If \( x \not\in \Gamma \), then \( M' = \qabs x N'_{\Gamma,x} \).

      By the inductive hypothesis, \( N \aequiv N'_{\Gamma,x} \) and the rule \ref{inf:thm:alpha_equivalence_simplified/lift} allows us to conclude that
      \begin{equation*}
        M = \qabs x N \aequiv \qabs x N'_{\Gamma,x} = M'_\Gamma.
      \end{equation*}

      Furthermore, by the inductive hypothesis,
      \begin{equation}\label{eq:alg:separation_of_free_and_bound_variables/proof/n_bound}
        \op*{Bound}(N'_{\Gamma,x}) \cap \parens[\Big]{ \Gamma \cup \set{ x } } = \varnothing,
      \end{equation}
      hence
      \begin{align*}
        \op*{Bound}(M'_\Gamma) \cap \Gamma
        &=
        \parens[\Big]{ \op*{Bound}(N'_{\Gamma,x}) \cup \set{ x } } \cap \Gamma
        \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} = \\ &=
        \parens[\Big]{ \underbrace{\op*{Bound}(N'_{\Gamma,x}) \cap \Gamma }_{\varnothing \T*{by} \eqref{eq:alg:separation_of_free_and_bound_variables/proof/n_bound}} } \cup \parens[\Big]{ \underbrace{\set{ x } \cap \Gamma}_{\mathclap{\varnothing \T*{by assumption}}} }
      \end{align*}

      \item If \( x \in \Gamma \), then \( M' = \qabs n N'_{\Gamma,n}[x \mapsto n] \), where \( n = \sharp(\op*{Free}(N) \cup \Gamma) \).

      By the inductive hypothesis, we have \( N \aequiv N'_{\Gamma,n} \). \Cref{thm:substitution_on_alpha_equivalent_terms} implies that
      \begin{equation}\label{eq:alg:separation_of_free_and_bound_variables/proof/final_ind}
        N[x \mapsto n] \aequiv N'_{\Gamma,n}[x \mapsto n].
      \end{equation}

      Let
      \begin{align*}
        a &\coloneqq n && A \coloneqq N[x \mapsto n], \\
        b &\coloneqq x && B \coloneqq N'_{\Gamma,n}.
      \end{align*}
      so that, in the notation of \ref{inf:thm:alpha_equivalence_simplified/ren}, \eqref{eq:alg:separation_of_free_and_bound_variables/proof/final_ind} becomes
      \begin{equation*}
        A \aequiv B[b \mapsto a].
      \end{equation*}

      By definition, \( a = n \) is not free in \( B = N \). Thus, we can apply \ref{inf:thm:alpha_equivalence_simplified/ren} and obtain \( M \aequiv M'_\Gamma \).

      Furthermore, by the inductive hypothesis,
      \begin{equation*}
        \op*{Bound}(N'_{\Gamma,n}) \cap \parens[\Big]{ \Gamma \cup \set{ n } } = \varnothing,
      \end{equation*}
      hence, again,
      \begin{align*}
        \op*{Bound}(M'_\Gamma) \cap \Gamma
        &=
        \parens[\Big]{ \op*{Bound}(N'_{\Gamma,n}) \cup \set{ n } } \cap \Gamma
        \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} = \\ &=
        \parens[\Big]{ \underbrace{\op*{Bound}(N'_{\Gamma,n}) \cap \Gamma }_\varnothing } \cup \parens[\Big]{ \underbrace{\set{ n } \cap \Gamma}_\varnothing }.
      \end{align*}
    \end{itemize}
  \end{itemize}
\end{defproof}
