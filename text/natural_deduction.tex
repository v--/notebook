\section{Natural deduction}\label{sec:natural_deduction}

\paragraph{Inference rules}

\begin{definition}\label{def:inference_rule}\mimprovised
  An \term[ru=правило вывода (\cite[31]{Герасимов2011Вычислимость}), en=inference rule (\cite[2]{MartinLöf1996LogicalLaws})]{inference rule} is a string generated by the corresponding grammar rule from the \hyperref[def:formal_grammar/schema]{schema}
  \begin{bnf*}
    \bnfprod{entry list}     {\bnfpn{entry} \bnfor \bnfpn{entry} \bnfsp \bnftsq{,} \bnfsp \bnfpn{entry list}}, \\
    \bnfprod{premises}       {\bnfves \bnfor \bnfpn{entry list}}, \\
    \bnfprod{conclusion}     {\bnfpn{entry}}, \\
    \bnfprod{inference rule} {\bnftsq{(} \bnfsp \bnfpn{rule name} \bnfsp \bnftsq{)} \bnfsp \bnfpn{premises} \bnfsp \bnftsq{\( \vDdash \)} \bnfsp \bnfpn{conclusion}}
  \end{bnf*}
  where, similarly to \fullref{def:logical_context}, we have purposely not specified rules for the nonterminal \( \bnfpn{entry} \) in order to encompass entries with different syntax. We have also not specified a precise syntax for rule names because we use a variety of symbols and there is little benefit in listing them explicitly here.

  Following \incite[181]{Gentzen1935LogischeSchließen}, we will use the notation
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \Phi_1 }
      \hypo{ \cdots }
      \hypo{ \Phi_n }
      \infer3[\logic{R}]{ \Psi }
    \end{prooftree}
  \end{equation*}
  for the rule
  \begin{equation*}
    (\logic{R}) \enspace \Phi_1, \ldots, \Phi_n \vDdash \Psi.
  \end{equation*}

  We call \( n \) the \term{arity} of the rule \( \logic{R} \).
\end{definition}
\begin{comments}
  \item This definition is based on Gentzen's syntax for rules in \cite[181]{Gentzen1935LogischeSchließen}, but formalized via grammars and not tied to either formulas nor sequents.

  \item Somewhat similar syntax, albeit also informal, can be found in Barendregt's works \cite{Barendregt1984LambdaCalculus} and \cite{Barendregt1992LambdaCalculiWithTypes}, who expresses some of his rules linearly, with \enquote{\( {\implies} \)} rather than \enquote{\( \vDdash \)} as the connective --- for example, the typing rules in \cite[def. 3.1.3]{Barendregt1992LambdaCalculiWithTypes} are presented in both linear and tree-like style.

  \item Here \( \Phi_1, \ldots, \Phi_n \) and \( \Psi \) are metalogical variables representing placeholders for concrete entries.
\end{comments}

\begin{remark}\label{rem:inference_rules_semantics}
  We have introduced inference rules in \fullref{def:inference_rule} as strings with the intention to use them in vastly differing situations:
  \begin{itemize}
    \item We use inference rules for expressing the possibilities of constructing proof trees in natural deduction systems.

    We present such systems in \fullref{def:propositional_natural_deduction_systems} for propositional logic and in \fullref{def:first_order_natural_deduction_system} for first-order logic.

    We also use it when briefly discussing sequent calculus rules in \fullref{rem:sequent_calculus}.

    Using inference rules for logical rules is done in
    \cite{Gentzen1935LogischeSchließen},
    \cite{TroelstraSchwichtenberg2000BasicProofTheory},
    \cite{Mimram2020ProgramEqualsProof},
    \cite{КолмогоровДрагалин2006Логика} and
    \cite{Герасимов2011Вычислимость}.

    \item We use inference rules to succinctly define relations via \fullref{thm:recursively_defined_relations}, whose usage is demonstrated in \fullref{ex:recursively_defined_relation}. This will be very useful in \fullref{sec:lambda_term_alpha_equivalence} and \fullref{sec:lambda_term_reductions}.

    Among others, such usage can also be found in \cite{Mimram2020ProgramEqualsProof} for \( \beta \)- and \( \eta \)-reduction, as well as \cite{MartinLöf1984IntuitionisticTypeTheory} and \cite{UnivalentFoundationsProgram2024OctoberHoTT} for \hyperref[rem:type_theory_rule_classification/equality]{judgmental equality rules}.

    \item We use inference rules to express \hyperref[con:typing_rule]{typing rules} in \fullref{sec:simply_typed_lambda_terms}, \fullref{sec:curry_howard_correspondence} and \fullref{sec:dependent_types}. See \fullref{rem:dependent_type_rule_formalization} and \fullref{rem:dependent_type_rule_sequents} for some subtleties of typing rules.
  \end{itemize}

  Inference rules can easily be formalized as \hyperref[def:relation]{relations}, as is done by \incite[31]{Герасимов2011Вычислимость} and \incite[115]{CitkinMuravitsky2022ConsequenceRelations}, but this makes it difficult to reason about their semantics. Other authors only use the notion of inference rules informally.

  For describing his \enquote{natural deduction} systems, \incite[181]{Gentzen1935LogischeSchließen} introduces the notation
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \Phi_1 }
      \hypo{ \cdots }
      \hypo{ \Phi_n }
      \infer3[\logic{R}]{ \Psi }
    \end{prooftree},
  \end{equation*}
  where \( \Phi_1, \ldots, \Phi_n \) and \( \Psi \) are schemas for formulas. A problem with this approach is that the rules may depend on additional metalogical assumptions.

  Later in the same paper Gentzen also introduces \enquote{sequent calculus} based on \hyperref[def:sequent]{sequents}, where entries additionally have \hyperref[def:logical_context]{logical contexts}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \Gamma_1 \vdash \Phi_1 }
      \hypo{ \cdots }
      \hypo{ \Gamma_n \vdash \Phi_n }
      \infer3[\logic{R}]{ \Gamma \vdash \Psi }
    \end{prooftree},
  \end{equation*}

  \incite[2]{MartinLöf1996LogicalLaws} argues that we should always use metalogical sequents to affirm the corresponding formulas, thus natural deduction rules can instead use sequents with empty contexts:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \vdash \Phi_1 }
      \hypo{ \cdots }
      \hypo{ \vdash \Phi_n }
      \infer3[\logic{R}]{ \vdash \Psi }
    \end{prooftree}
  \end{equation*}

  Ironically, earlier work by Martin-L\"of like \cite{MartinLöf1984IntuitionisticTypeTheory} presents rules without sequents.

  Some authors like \incite[46]{Mimram2020ProgramEqualsProof} prefer to add the entire set of premises of a natural deduction proof tree as a context for each rule application. We call this \enquote{explicit sequent style} to contrast with the usual \enquote{implicit sequent style} --- see \fullref{rem:natural_deduction_explicit_sequents}. \incite[ch. 2]{TroelstraSchwichtenberg2000BasicProofTheory} present both of these styles of natural deduction.

  To clarify whether rules act inside the object theory or the metatheory, \incite[112]{CitkinMuravitsky2022ConsequenceRelations}, who define rules as relations, refer as \enquote{rule} to inference rules acting on sequents and as \enquote{hyperrules} to inference rules acting on judgments, and give distinct definitions for the two.
\end{remark}

\begin{remark}\label{rem:inference_rule_formalization}
  Using the fact that, in \fullref{def:inference_rule}, we have formalized inference rules as strings, we are able to encode some concrete rules. Our end goal is to completely formalize the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for \hyperref[def:propositional_syntax/formula]{propositional formulas} and \hyperref[def:simple_type]{simple types} in \fullref{alg:type_derivation_to_proof_tree} and \fullref{alg:proof_tree_to_type_derivation}.

  As we shall see in this remark, other cases often require more significant effort. We will still present many other rules, but only as part of the metatheory. Handling rules like those occurring in \fullref{sec:dependent_types} requires formalization efforts that resemble the creation of a programming language.

  \begin{itemize}
    \thmitem{rem:inference_rule_formalization/proofs} The propositional \hyperref[def:natural_deduction_rule]{natural deduction rules} stated in \fullref{def:propositional_natural_deduction_systems} are encoded in the module \identifier{logic.deduction.classical_logic}, based on the schemas defined in \fullref{def:propositional_formula_schema}.

    These rules can be applied to form proof trees as described in \fullref{def:natural_deduction_proof_tree}. Constructs for building such trees can be found in the module \identifier{logic.deduction.proof_tree}.

    We are not able to easily express substitution and eigenvariable conditions that are found in first-order logic rules. Hence, we will not completely formalize the first-order logic rules in \fullref{def:first_order_natural_deduction_system}.

    \thmitem{rem:inference_rule_formalization/types} The \hyperref[def:simple_typing_rule]{simple typing rules} stated in \fullref{sec:simply_typed_lambda_terms} and \fullref{sec:curry_howard_correspondence} are encoded in the module \identifier{lambda_.type_system}.

    Similarly to the above, the rules can be used to form derivation trees as described in \fullref{def:type_derivation_tree}, with an implementation in \identifier{lambda_.type_derivation.tree}.

    Formalizing well-formed contexts and types, judgmental equality and side conditions for the typing rules from \fullref{sec:dependent_types} however requires great effort, and we will not bother with those. Several impediments are highlighted in \fullref{rem:dependent_type_rule_formalization}.
  \end{itemize}
\end{remark}

\begin{concept}\label{con:inference_rule_admissibility}\mimprovised
  We say that the \hyperref[def:inference_rule]{inference rule} \( R \) is \term[ru=допустимое (правило) (\cite[252]{Герасимов2011Вычислимость}), en=admissible (rule) (\cite[76]{TroelstraSchwichtenberg2000BasicProofTheory})]{admissible} with respect to a family \( \mscrR \) of rules if the conclusion of \( R \) can be obtained from its premises by using the rules from \( \mscrR \).
\end{concept}
\begin{comments}
  \item The precise meaning of \enquote{obtaining} a conclusion via a rule depends on the precise semantics. Particular examples of admissibility in different contexts are given in \fullref{thm:minimal_implicational_logic_axioms_nd_proof}, \fullref{thm:alpha_equivalence_simplified}, \fullref{thm:typed_substitution_assertions} and \fullref{thm:reduction_typing_rules}.
\end{comments}

\paragraph{Natural deduction systems}

\begin{definition}\label{def:natural_deduction_rule}\mimprovised
  A \term{natural deduction rule} is an \hyperref[def:inference_rule]{inference rule} whose entries can be \hyperref[con:schemas_and_instances]{formula schemas} or pairs of schemas:
  \begin{bnf*}
    \bnfprod{entry} {\bnfpn{formula schema} \bnfor} \\
    \bnfmore        {\bnftsq{[} \bnfsp \bnfpn{formula schema} \bnfsp \bnftsq{]} \bnfsp \bnfpn{formula schema}}.
  \end{bnf*}

  These bracketed schemas allow \enquote{discharging} certain assumptions --- see \fullref{def:natural_deduction_proof_tree/application}. Some rules require more than one dischargeable assumption; see \fullref{inf:def:identity_type/j/elim}. We do not bother with formalizing these cases since they affect the programmatic implementation as well, but it is clear how to handle them.

  We forbid the conclusion to have such a bracketed schema by replacing the existing rules from \fullref{def:inference_rule} with
  \begin{bnf*}
    \bnfprod{conclusion} {\bnfpn{formula schema}}
  \end{bnf*}

  For the rule
  \begin{equation*}
    (\logic{R}) \enspace \Phi_1, \ldots, [\Theta_k] \thickspace \Phi_k, \ldots, \Phi_n \vDdash \Psi
  \end{equation*}
  we use the more convenient notation
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \Phi_1 }
      \hypo{ \cdots }

      \hypo{ [\Theta_k] }
      \infer[dashed]1{ \Phi_k }

      \hypo{ \cdots }
      \hypo{ \Phi_n }
      \infer5[\logic{R}]{ \Psi }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item Our purpose with this definition is to mechanize arbitrary natural deduction rules for propositional logic, breaking the tradition described in \cite[13]{MartinLöf1984IntuitionisticTypeTheory}:
  \begin{displayquote}
    In the usual natural deduction style, the rules given are not quite formal.
  \end{displayquote}

  The rules are formalized as strings so that they can be treated rigorously, and then they are specifically adjusted for natural deduction. The adjustments are based on \cite[\S 2.1]{TroelstraSchwichtenberg2000BasicProofTheory}. Furthermore, we assume no axioms here.

  The notation is based on Gentzen's original \cite[186]{Gentzen1935LogischeSchließen}, with a dashed line added for clarity.

  \item The placeholder variables like \( \Psi \) represent schemas. For example, \( \Psi \) can be the propositional formula schema \( \syn\varphi \synimplies \syn\psi \), which are purely syntactic objects, and to reason about formulas instead we must use the schema instantiations as defined in \fullref{def:propositional_schema_instantiation}.

  \item The only schemas we have completely formalized are propositional formula schemas in \fullref{def:propositional_formula_schema} and typed \( \muplambda \)-term schemas in \fullref{def:simple_type_schema} and \fullref{def:lambda_term_schema}.
\end{comments}

\begin{definition}\label{def:abstract_natural_deduction_system}\mimprovised
  An \term{abstract natural deduction system} consists of a nonempty collection of \hyperref[def:natural_deduction_rule]{natural deduction rules} for either propositional or signatureless first-order formula schemas.
\end{definition}
\begin{comments}
  \item This definition resembles \enquote{deductive systems} defined by \incite[31]{Герасимов2011Вычислимость} and \enquote{axiom systems} defined by \incite[80]{Smullyan1995FOL}. We have restricted ourselves to propositional and first-order logic and to natural deduction because we want our definition to be as precise as possible.
  \item We implicitly assume that the rules have different names.
\end{comments}

\begin{definition}\label{def:natural_deduction_proof_tree}\mimprovised
  Fix a \hyperref[def:abstract_natural_deduction_system]{natural deduction system}. We will define a family of \hyperref[def:labeled_tree]{labeled trees}, which we will call \term{proof trees}.

  The labels of proof trees are triples consisting of the following objects:
  \begin{thmenum}[series=def:natural_deduction_proof_tree]
    \thmitem{def:natural_deduction_proof_tree/conclusion} A formula, called the \term[ru=conclusion (\cite[35]{TroelstraSchwichtenberg2000BasicProofTheory}), en=conclusion (\cite[36]{TroelstraSchwichtenberg2000BasicProofTheory})]{conclusion} of the proof.

    \thmitem{def:natural_deduction_proof_tree/rule_name} An empty string or the name of a rule from the deduction system.

    \thmitem{def:natural_deduction_proof_tree/open} A set of marked formulas generated by the following grammar:
    \begin{bnf*}
      \bnfprod{marker}          {\bnfpn{Small Latin identifier}}, \\
      \bnfprod{marked formula}  {\bnfpn{marker} \bnfsp \bnftsq{:} \bnfsp \bnfpn{formula}}.
    \end{bnf*}

    We will call these formulas \term{open assumptions}.
  \end{thmenum}

  We define two kinds of proof trees:
  \begin{thmenum}[resume=def:natural_deduction_proof_tree]
    \thmitem{def:natural_deduction_proof_tree/assumption} An \term{assumption} tree for a propositional formula \( \varphi \) and marker \( u \) is the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with the following label:
    \begin{itemize}
      \item The conclusion is, unsurprisingly, \( \varphi \).
      \item The rule name is the empty string (because the conclusion has not been obtained by an application of a rule).
      \item There is only one assumption --- \( \varphi \) marked with \( u \).
    \end{itemize}

    We will denote such a tree as follows:
    \begin{equation*}
      [\varphi]^u.
    \end{equation*}

    \thmitem{def:natural_deduction_proof_tree/application} We now define \term{rule application} trees.

    Consider the schema instantiation \( \BbbI \) and the rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Phi_1 }
        \hypo{ \cdots }

        \hypo{ [\Theta_i] }
        \infer[dashed]1{ \Phi_i }

        \hypo{ \cdots }
        \hypo{ \Phi_n }
        \infer5[\logic{R}]{ \Psi }
      \end{prooftree}
    \end{equation*}

    Fix a list \( (P_1, \ldots, P_n) \) of proof trees such that, for \( i = 1, \ldots, n \), the conclusion of \( P_i \) is \( \Phi_i[\BbbI] \).

    The delicate part of defining rule application trees is to build a set of open assumption. We define it as the union of the assumptions for \( P_1, \ldots, P_n \), with some of the assumptions possibly removed.

    We say that these removed assumptions have been \term{discharged} or \term{closed}. The formula \( \varphi \) is a discharge candidate if there exists an index \( i = 1, \ldots, n \) such that \( \varphi \) is open in \( P_i \) and the rule premise \( \Phi_i \) has a bracketed formula \( [\Theta_i] \) attached such that \( \varphi = \Theta_i[\BbbI] \).

    Discharging requires some additional elucidation that can also be seen implemented programmatically as \identifier{logic.deduction.proof_tree.apply} in \cite{notebook:code}:
    \begin{itemize}
      \item Since open assumptions have markers attached, there generally is nondeterminism involved in the choice of marker, and different choices lead to different rule application trees.

      \item If the rule allows discharging an assumption but no such assumption can be discharged, we apply the rule without discharging anything. We call the corresponding assumption \term{implicit}. For \hyperref[con:typing_rule]{typing rules}, \incite[note 2A8.1]{Hindley1997BasicSTT} calls this \enquote{discharging vacuously}. \Fullref{ex:natural_deduction_efq_vs_dne} demonstrates this, and a more practical example can be found in the proof of \fullref{thm:simple_algebraic_type_arithmetic/equivalence}.

      \item We disallow the case where the same marked formula is open in multiple premise subtrees, but dischargeable in only some of them. This is done to prevent name collisions in complicated rules like \ref{inf:def:identity_type/j/elim}.

      \item We also disallow multiple formulas with the same marker because that would break \fullref{alg:proof_tree_to_type_derivation}. If two assumptions have the same marker, we require the corresponding formulas to coincide. This requirement is also explicit in \cite[\S 2.1.8]{TroelstraSchwichtenberg2000BasicProofTheory}, and allows smoothly transforming marked formulas to variable \hyperref[def:type_assertion]{type assertions} in \fullref{alg:proof_tree_to_type_derivation}.

      \item On the other hand, we allow the same formula with multiple markers. Or rather, we do not disallow them. But we will not make use of them.

      \item It is possible to avoid markers entirely and discharge assumptions independently of their label. \incite[\S 2.1.9]{TroelstraSchwichtenberg2000BasicProofTheory} call this the \enquote{complete discharge convention}. We prefer to use markers because it simplifies \fullref{alg:proof_tree_to_type_derivation}.
    \end{itemize}

    Finally, we can define the rule application tree by \hyperref[def:ordered_tree_grafting_product]{grafting} \( P_1, \ldots, P_n \) to a new root with the following label:
    \begin{itemize}
      \item The conclusion is \( \Psi[\BbbI] \).
      \item The rule name is \( \logic{R} \).
      \item The set of open assumptions was defined above.
    \end{itemize}

    Let \( c_1, \ldots, c_m \) be the list of markers of assumptions discharged by this rule application. We draw this tree as follows (resembling stacked inference rules):
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis { \( P_1 \) } { \Phi_1[\BbbI] }

        \hypo{ \cdots }

        \hypo{}
        \ellipsis { \( P_n \) } { \Phi_n[\BbbI] }
        \infer[left label={\( c_1, \ldots, c_m \)}]3[\logic{R}]{ \Psi[\BbbI] }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition somewhat resembles \enquote{prooftrees} from \incite{TroelstraSchwichtenberg2000BasicProofTheory}, but is completely rigorous and explicitly encodes which inference rules have been used. The treatment of the rules is based on \cite[\S 2.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

  \item Even though we have defined what a natural deduction proof tree is, it is not always immediate what it means to \enquote{apply a rule}. There may be multiple possible ways to do so, in which cases specifying an \hyperref[def:propositional_schema_instantiation]{instantiation} is necessary. See \fullref{rem:natural_deduction_rule_application} for a broader discussion.

  \item Our formalization allows us to avoid some issues present in other systems; for example \fullref{ex:proof_tree_non_uniqueness}.
\end{comments}

\begin{definition}\label{def:natural_deduction_entailment}\mcite[205]{Hinman2005Logic}
  For a \hyperref[def:abstract_natural_deduction_system]{natural deduction system}, we define a \hyperref[def:consequence_relation]{consequence relation} as follows: we let \( \Gamma \vdash \varphi \) if there is a \hyperref[def:natural_deduction_proof_tree]{proof tree} with conclusion \( \varphi \) whose \hyperref[def:natural_deduction_proof_tree/open]{open assumptions} are all in \( \Gamma \).

  As per \fullref{def:abstract_logic}, we say that \( \varphi \) is \term{derivable} from \( \Gamma \) if this relation holds.
\end{definition}
\begin{comments}
  \item We lose almost all information about the concrete proof by using such an entailment relation. Here \( \Gamma \) is a set of formulas somehow deriving \( \varphi \), and we only know that there exists a proof tree whose open assumptions include those from \( \Gamma \) with some label.
\end{comments}
\begin{defproof}
  We must show that \( {\vdash} \) satisfies the conditions for being a consequence relation.

  \SubProofOf[def:consequence_relation/reflexivity]{reflexivity} If \( \varphi \in \Gamma \), then, for any marker \( u \), the tree \( [\varphi]^u \) proves \( \varphi \) from \( \Gamma \).

  \SubProofOf[def:consequence_relation/monotonicity]{monotonicity} If \( \Gamma \vdash \varphi \), then there exists a proof tree deriving \( \varphi \) from \( \Gamma \). Such a tree also proves \( \varphi \) from any superset of \( \Gamma \).

  \SubProofOf[def:consequence_relation/transitivity]{transitivity} Suppose that \( \Delta, \Epsilon \vdash \varphi \) and that, for every \( \psi \in \Delta \), we have \( \Gamma, \Epsilon \vdash \psi \).

  Let \( P_\varphi \) be a proof tree deriving \( \varphi \) from \( \Delta \cup \Epsilon \) and let \( P_\psi \) be a proof tree deriving \( \psi \) from \( \Gamma \cup \Epsilon \).

  Then, for any formula \( \psi \in \Delta \) and any marker \( u \), we can replace the assumption \( [\psi]^u \) in \( P_\varphi \) with \( P_\psi \) and close \( [\psi]^u \).

  The resulting tree will have the same conclusion as \( P_\varphi \) --- namely, \( \varphi \) --- but different open assumptions --- namely, members of \( \Gamma \cup \Epsilon \).
\end{defproof}

\begin{definition}\label{def:interderivability}\mimprovised
  In a \hyperref[def:abstract_natural_deduction_system]{natural deduction system} or, more generally, some \hyperref[def:abstract_logic]{abstract logic}, we say that two sentences are \term{interderivable} if each can be derived from the other.
\end{definition}

\begin{proposition}\label{thm:propositional_natural_deduction_entailment_compact}
  Every \hyperref[def:natural_deduction_entailment]{natural deduction entailment relation} is \hyperref[def:consequence_relation/compactness]{compact}.
\end{proposition}
\begin{comments}
  \item See \fullref{rem:logical_compactness_theorems} for a list of similar results.
\end{comments}
\begin{proof}
  A proof tree is, by definition, finite, and only some of the leaves are open assumptions.
\end{proof}

\paragraph{Axiomatic derivations via natural deduction}

\begin{remark}\label{rem:axiomatic_derivation_system_as_natural_deduction_system}
  We can regard any (propositional) \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} as a \hyperref[def:abstract_natural_deduction_system]{natural deduction system}. For this, suppose that each axiom schema \( \Phi \) has a name \( \logic{R}_\Phi \). If we are willing to break our convention of rules having unique names, we may use a generic name such as \( \logic{Ax} \) for each schema.

  \begin{thmenum}
    \thmitem{thm:axiomatic_derivation_as_natural_deduction/axiom} For the axiom schema \( \Phi \), we introduce the rule
    \begin{equation*}
      \begin{prooftree}
        \infer0[\ensuremath{ \logic{R}_\Phi }]{ \Phi }
      \end{prooftree}
    \end{equation*}

    Note that \( \Phi \) here is a metalogical variable that refers to a \hyperref[def:propositional_formula_schema]{formula schema}.

    \thmitem{thm:axiomatic_derivation_as_natural_deduction/mp} For deducing proofs, we introduce the following rule, called \term{modus ponens}:
    \begin{equation*}\taglabel[\ensuremath{ \logic{MP} }]{inf:thm:axiomatic_derivation_as_natural_deduction/mp}
      \begin{prooftree}
        \hypo{ \syn\varphi \synimplies \syn\psi }
        \hypo{ \syn\varphi }
        \infer2[\ref{inf:thm:axiomatic_derivation_as_natural_deduction/mp}]{ \syn\psi }
      \end{prooftree}
    \end{equation*}

    Note that \( \syn\varphi \synimplies \syn\psi \) here refers to a concrete formula schema.
  \end{thmenum}
\end{remark}

\begin{example}\label{ex:minimal_implication_logic_identity/trees}
  Regard \hyperref[def:minimal_implication_logic]{minimal implicational logic} as a \hyperref[def:abstract_natural_deduction_system]{natural deduction system} as explained in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  The two axiom schemas --- \eqref{eq:def:minimal_implication_logic/intro} and \eqref{eq:def:minimal_implication_logic/dist} --- become inference rules.

  Then the final derivation in \fullref{ex:minimal_implication_logic_identity/derivations} can be presented as follows:
  \begin{equation*}
    \begin{prooftree}[separation=3em]
      \hypo
        {
          \eqref{eq:def:minimal_implication_logic/intro}
        }

      \ellipsis
        {
          \(
            \substack
              {
                \psi \mapsto (\varphi \synimplies \varphi)
                \\
                \mbox{}
              }
          \)
        }
        {
          \ref{ex:minimal_implication_logic_identity/trees/dagger}
        }

      \hypo
        {
          \eqref{eq:def:minimal_implication_logic/dist}
        }

      \ellipsis
        {
          \(
            \substack
              {
                \psi \mapsto (\varphi \synimplies \varphi)
                \\
                \theta \mapsto \varphi
              }
          \)
        }
        {
          \ref{ex:minimal_implication_logic_identity/trees/dagger}
          \synimplies ((\varphi \synimplies (\varphi \synimplies \varphi)) \synimplies (\varphi \synimplies \varphi))
        }

      \infer2[\ref{inf:thm:axiomatic_derivation_as_natural_deduction/mp}]{(\varphi \synimplies (\varphi \synimplies \varphi)) \synimplies (\varphi \synimplies \varphi)}

      \hypo
        {
          \eqref{eq:def:minimal_implication_logic/intro}
        }

      \ellipsis
        {
          \( \psi \mapsto \varphi \)
        }
        {
          \varphi \synimplies (\varphi \synimplies \varphi)
        }

      \infer2[\ref{inf:thm:axiomatic_derivation_as_natural_deduction/mp}]{\varphi \synimplies \varphi}
    \end{prooftree}
  \end{equation*}
  where
  \begin{equation}\label{ex:minimal_implication_logic_identity/trees/dagger}
    \varphi \synimplies ((\varphi \synimplies \varphi) \synimplies \varphi). \tag{\ensuremath{ \dagger }}
  \end{equation}
\end{example}

\begin{algorithm}[Axiomatic derivation to proof tree]\label{alg:axiomatic_derivation_to_proof_tree}
  Fix an \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} and consider the corresponding \hyperref[def:abstract_natural_deduction_system]{natural deduction system} as described in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  Fix a derivation \( \psi_1, \ldots, \psi_n \) of \( \varphi \). We will build a proof tree whose conclusion is \( \varphi \) and whose \hyperref[def:natural_deduction_proof_tree/open]{open assumptions} are the premises of the derivation. We recurse on the length \( n \) of the derivation.

  \begin{thmenum}
    \thmitem{alg:axiomatic_derivation_to_proof_tree/premise} If \( \varphi \) itself is a premise, then, for a fixed marker \( u \), we declare the result of the algorithm to be the assumption tree \( [\varphi]^u \).

    \thmitem{alg:axiomatic_derivation_to_proof_tree/axiom} If \( \varphi \) is an instance of the schema \( \Phi \), we declare the result of the algorithm to be
    \begin{equation*}
      \begin{prooftree}
        \infer0[\ensuremath{ \logic{R}_\Phi }]{ \varphi }
      \end{prooftree}
    \end{equation*}

    \thmitem{alg:axiomatic_derivation_to_proof_tree/recursive} Otherwise, there must exist indices \( i \) and \( j \) such that
    \begin{equation*}
      \varphi_i = \varphi_j \synimplies \varphi_n.
    \end{equation*}

    We assume that the algorithm already correctly produces results for derivations shorter than \( n \). Denote by \( P_i \) and \( P_j \) the proof trees corresponding to \( \varphi_i \) and \( \varphi_j \).

    We declare our result of the algorithm to be the tree
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis { \( P_i \) } { \varphi_j \synimplies \varphi }

        \hypo{}
        \ellipsis { \( P_j \) } { \varphi_j }

        \infer2[\logic{MP}]{ \varphi }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{natural_deduction.axiomatic_derivation.derivation_to_proof_tree} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[Proof tree to axiomatic derivation]\label{alg:proof_tree_to_axiomatic_derivation}
  Again, fix an \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} and consider the corresponding \hyperref[def:abstract_natural_deduction_system]{natural deduction system} as described in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  Then, given a \hyperref[def:natural_deduction_proof_tree]{proof tree}, enumerating its nodes' conclusions via \hyperref[def:ordered_tree_enumeration]{pre-order traversal}, we obtain an axiomatic derivation whose premises are the open assumptions of the tree, and whose conclusion coincides with that of the tree.
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{natural_deduction.axiomatic_derivation.proof_tree_to_derivation} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:axiomatic_derivation_as_natural_deduction}
  Fix an \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} and consider the corresponding \hyperref[def:abstract_natural_deduction_system]{natural deduction system} as described in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  Then there exists an \hyperref[def:axiomatic_derivation]{axiomatic derivation} of \( \varphi \) from \( \Gamma \) if and only if there exists a \hyperref[def:natural_deduction_proof_tree]{proof tree} concluding \( \varphi \) from \( \Gamma \).
\end{proposition}
\begin{proof}
  We can use \fullref{alg:axiomatic_derivation_to_proof_tree} in one direction and \fullref{alg:proof_tree_to_axiomatic_derivation} in the other one.
\end{proof}

\paragraph{Minimal, intuitionistic and classical logic}

\begin{definition}\label{def:propositional_natural_deduction_systems}\mcite[def. 2.1.1]{TroelstraSchwichtenberg2000BasicProofTheory}
  We will now describe several \hyperref[def:abstract_natural_deduction_system]{propositional natural deduction systems}. The base set of rules describes \hyperref[con:minimal_logic]{minimal logic}, while \hyperref[con:intuitionistic_logic]{intuitionistic} and \hyperref[con:classical_logic]{classical logic} additionally require \ref{inf:def:propositional_natural_deduction_systems/bot/efq} and \ref{inf:def:propositional_natural_deduction_systems/bot/dne}, respectively.

  \begin{thmenum}
    \thmitem{def:propositional_natural_deduction_systems/top}\mimprovised A single rules for introducing \hyperref[def:propositional_alphabet/constants/verum]{verum}:
    \begin{equation*}\taglabel[\ensuremath{ \top_+ }]{inf:def:propositional_natural_deduction_systems/top/intro}
      \begin{prooftree}
        \infer0[\ref{inf:def:propositional_natural_deduction_systems/top/intro}]{ \syntop }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:propositional_natural_deduction_systems/bot} Rules corresponding to \eqref{eq:thm:intuitionistic_tautologies/efq} and \eqref{eq:thm:classical_tautologies/dne}:
    \begin{paracol}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\logic{EFQ}]{inf:def:propositional_natural_deduction_systems/bot/efq}
        \begin{prooftree}
          \hypo{ \synbot }
          \infer1[\ref{inf:def:propositional_natural_deduction_systems/bot/efq}]{ \syn\varphi }
        \end{prooftree}
      \end{equation*}

      \switchcolumn

      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\logic{DNE}]{inf:def:propositional_natural_deduction_systems/bot/dne}
        \begin{prooftree}
          \hypo{ [\synneg \syn\varphi] }
          \infer[dashed]1{ \synbot }
          \infer1[\ref{inf:def:propositional_natural_deduction_systems/bot/dne}]{ \syn\varphi }
        \end{prooftree}
      \end{equation*}

      \switchcolumn*

      We add this rule to the system only when working with \hyperref[con:intuitionistic_logic]{intuitionistic object logic}.

      \switchcolumn

      We add this rule to the system only when working with \hyperref[con:classical_logic]{classical object logic}.
    \end{paracol}

    \thmitem{def:propositional_natural_deduction_systems/negation}\mcite[46]{Mimram2020ProgramEqualsProof} Rules for expressing \hyperref[def:propositional_alphabet/negation]{negation} via the \hyperref[def:propositional_alphabet/constants/falsum]{falsum}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \neg_+ }]{inf:def:propositional_natural_deduction_systems/neg/intro}
          \begin{prooftree}
            \hypo{ [\syn\varphi] }
            \ellipsis {} { \synbot }
            \infer1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \synneg \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \neg_- }]{inf:def:propositional_natural_deduction_systems/neg/elim}
          \begin{prooftree}
            \hypo{ \synneg \syn\varphi }
            \hypo{ \syn\varphi }
            \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:propositional_natural_deduction_systems/or} Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/disjunction]{disjunctions}:
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_{+L} }]{inf:def:propositional_natural_deduction_systems/or/intro_left}
          \begin{prooftree}
            \hypo{ \syn\varphi }
            \infer1[\ref{inf:def:propositional_natural_deduction_systems/or/intro_left}]{ \syn\varphi \synvee \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_{+R} }]{inf:def:propositional_natural_deduction_systems/or/intro_right}
          \begin{prooftree}
            \hypo{ \syn\psi }
            \infer1[\ref{inf:def:propositional_natural_deduction_systems/or/intro_right}]{ \syn\varphi \synvee \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_- }]{inf:def:propositional_natural_deduction_systems/or/elim}
          \begin{prooftree}
            \hypo{ \syn\varphi \synvee \syn\psi }

            \hypo{ [\syn\varphi] }
            \infer[dashed]1{ \syn\theta }

            \hypo{ [\syn\psi] }
            \infer[dashed]1{ \syn\theta }

            \infer3[\ref{inf:def:propositional_natural_deduction_systems/or/elim}]{ \syn\theta }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}

    \thmitem{def:propositional_natural_deduction_systems/and} Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/conjunction]{conjunctions}:
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_+ }]{inf:def:propositional_natural_deduction_systems/and/intro}
          \begin{prooftree}
            \hypo{ \syn\varphi }
            \hypo{ \syn\psi }
            \infer2[\ref{inf:def:propositional_natural_deduction_systems/and/intro}]{ \syn\varphi \synwedge \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_{-L} }]{inf:def:propositional_natural_deduction_systems/and/elim_left}
          \begin{prooftree}
            \hypo{ \syn\varphi \synwedge \syn\psi }
            \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_left}]{ \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_{-R} }]{inf:def:propositional_natural_deduction_systems/and/elim_right}
          \begin{prooftree}
            \hypo{ \syn\varphi \synwedge \syn\psi }
            \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_right}]{ \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}

    \thmitem{def:propositional_natural_deduction_systems/imp} Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/conditional]{conditionals}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \rightarrow_+ }]{inf:def:propositional_natural_deduction_systems/imp/intro}
          \begin{prooftree}[center=false]
            \hypo{ [\syn\varphi] }
            \infer[dashed]1{ \syn\psi }
            \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \syn\varphi \synimplies \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \rightarrow_- }]{inf:def:propositional_natural_deduction_systems/imp/elim}
          \begin{prooftree}[center=false]
            \hypo{ \syn\varphi \synimplies \syn\psi }
            \hypo{ \syn\varphi }
            \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:propositional_natural_deduction_systems/iff}\mimprovised Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/biconditional]{biconditionals}:
    \begin{paracol}{3}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \leftrightarrow_+ }]{inf:def:propositional_natural_deduction_systems/iff/intro}
          \begin{prooftree}
            \hypo{ [\syn\varphi] }
            \infer[dashed]1{ \syn\psi }
            \hypo{ [\syn\psi] }
            \infer[dashed]1{ \syn\varphi }
            \infer2[\ref{inf:def:propositional_natural_deduction_systems/iff/intro}]{ \syn\varphi \syniff \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{nthcolumn}{1}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \leftrightarrow_{-L} }]{inf:def:propositional_natural_deduction_systems/iff/elim_left}
          \begin{prooftree}
            \hypo{ \syn\varphi \syniff \syn\psi }
            \hypo{ \syn\varphi }
            \infer2[\ref{inf:def:propositional_natural_deduction_systems/iff/elim_left}]{ \syn\psi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \leftrightarrow_{-R} }]{inf:def:propositional_natural_deduction_systems/iff/elim_right}
          \begin{prooftree}
            \hypo{ \syn\varphi \syniff \syn\psi }
            \hypo{ \syn\psi }
            \infer2[\ref{inf:def:propositional_natural_deduction_systems/iff/elim_right}]{ \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The systems are mostly based on \cite[def. 2.1.1]{TroelstraSchwichtenberg2000BasicProofTheory}, with additional rules for \( \syntop \), \( \synneg \) and \( \syniff \).

  The rules for \( \syntop \) and \( \synneg \) can be found in \cite[fig. 2.5]{Mimram2020ProgramEqualsProof}. Mimram uses \hyperref[def:abstract_propositional_sequent_calculus_system]{sequent calculus rule} for his natural deduction rules.

  \item Although we have defined abstract natural deduction systems in great generality, we will refer to the above as \enquote{the} natural deduction systems.
\end{comments}

\begin{remark}\label{rem:natural_deduction_rule_application}
  Most rules of natural deduction listed in \fullref{def:propositional_natural_deduction_systems} are straightforward to apply. For example, given assumption trees \( [\varphi]^u \) and \( [\psi]^v \), in that order, the rule \ref{inf:def:propositional_natural_deduction_systems/and/intro} can only possibly produce the rule application tree
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi]^u }
      \hypo{ [\psi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/and/intro}]{ \varphi \synwedge \psi }
    \end{prooftree}
  \end{equation*}

  Some cases are more complicated, however. Consider the rule \ref{inf:def:propositional_natural_deduction_systems/bot/efq}, which we defined as
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synbot }
      \infer1{ \syn\varphi }
    \end{prooftree}
  \end{equation*}

  It has two schemas --- \( \synbot \), which corresponds to only one formula, and \( \syn\varphi \), whose desired instance is impossible to determine based on the premises alone.

  Applying \ref{inf:def:propositional_natural_deduction_systems/bot/efq} thus requires specifying an instance for \( \syn\varphi \). In informal usage this is resolved easily, but in a formal setting, this requires specifying a \hyperref[def:propositional_schema_instantiation]{schema instantiation}. This is crucial in some cases like \fullref{alg:type_derivation_to_proof_tree/instantiation}.
\end{remark}

\begin{example}\label{ex:natural_deduction_efq_vs_dne}
  The only difference between \ref{inf:def:propositional_natural_deduction_systems/bot/efq} and \ref{inf:def:propositional_natural_deduction_systems/bot/dne} is the dischargeable negation in the latter.

  For example, by using the rule \ref{inf:def:propositional_natural_deduction_systems/bot/dne}, we can derive the formula \( \eqref{eq:thm:classical_tautologies/dne} = \neg \neg \varphi \synimplies \varphi \):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\neg\neg\varphi]^u }
      \hypo{ [\neg\varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }
      \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction_systems/bot/dne}]{ \neg\varphi }

      \hypo{ [\varphi]^w }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }
      \infer[left label=\( w \)]1[\ref{inf:def:propositional_natural_deduction_systems/bot/dne}]{ \varphi }
      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \neg\neg\varphi \synimplies \varphi }
    \end{prooftree}
  \end{equation*}

  If we instead use the weaker \ref{inf:def:propositional_natural_deduction_systems/bot/efq}, we cannot discharge \( [\neg\varphi]^v \) nor \( [\varphi]^w \), and we are left with
  \begin{equation*}
    \neg\varphi, \varphi \vdash \neg\neg\varphi \synimplies \varphi.
  \end{equation*}

  We will show in \fullref{thm:syntactic_propositional_conjunction_of_premises} that this implies
  \begin{equation*}
    (\neg\varphi \synwedge \varphi) \vdash \neg\neg\varphi \synimplies \varphi
  \end{equation*}

  We will show in \fullref{thm:syntactic_minimal_tautologies} that the law of non-contradiction \eqref{eq:thm:intuitionistic_tautologies/lnc} can also be derived, which combined with \( \neg\varphi \synwedge \varphi \) gives us \( \synbot \).

  Thus, the assumptions are interderivable with \( \synbot \), and might have just as well used the rule \ref{inf:def:propositional_natural_deduction_systems/bot/efq} directly.
\end{example}

\begin{proposition}\label{thm:minimal_implicational_logic_axioms_nd_proof}
  Every instance of the two axiom schemas --- \eqref{eq:def:minimal_implication_logic/intro} and \eqref{eq:def:minimal_implication_logic/dist} --- of \hyperref[def:minimal_implication_logic]{minimal implicational logic} is derivable in the \hyperref[def:propositional_natural_deduction_systems]{minimal natural deduction system}.
\end{proposition}
\begin{comments}
  \item When regarding \hyperref[def:minimal_implication_logic]{minimal implicational logic} as a \hyperref[def:abstract_natural_deduction_system]{natural deduction system} (as explained in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}), the rules of the resulting system are \hyperref[con:inference_rule_admissibility]{admissible} with respect to the minimal natural deduction system. Thus, we do not need to introduce additional rules in order for implicational proofs to hold in the natural deduction systems we will consider.
\end{comments}
\begin{proof}
  \SubProofOf{eq:def:minimal_implication_logic/intro}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \psi \synimplies \varphi }
      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies (\psi \synimplies \varphi) }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{eq:def:minimal_implication_logic/dist}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi \synimplies (\psi \synimplies \theta)]^u }
      \hypo{ [\varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi \synimplies \theta }

      \hypo{ [\varphi \synimplies \psi]^w }
      \hypo{ [\varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }

      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \theta }

      \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \theta }
      \infer[left label=\( w \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ (\varphi \synimplies \psi) \synimplies (\varphi \synimplies \theta) }
      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ (\varphi \synimplies (\psi \synimplies \theta)) \synimplies ((\varphi \synimplies \psi) \synimplies (\varphi \synimplies \theta)) }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:syntactic_minimal_tautologies}
  The intuitionistic tautologies \eqref{eq:thm:intuitionistic_tautologies/dni} and \eqref{eq:thm:intuitionistic_tautologies/lnc} are derivable in the \hyperref[def:propositional_natural_deduction_systems]{minimal natural deduction system}.
\end{proposition}
\begin{proof}
  \SubProofOf{eq:thm:intuitionistic_tautologies/dni}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi]^u }
      \hypo{ [\synneg \varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }
      \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \synneg \synneg \varphi }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{eq:thm:intuitionistic_tautologies/lnc}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi \synwedge \synneg \varphi]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_right}]{ \varphi }

      \hypo{ [\varphi \synwedge \synneg \varphi]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_left}]{ \synneg \varphi }

      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }

      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \synneg (\varphi \synwedge \synneg \varphi) }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{theorem}[Propositional syntactic deduction theorem]\label{thm:propositional_syntactic_deduction_theorem}
  With respect to the \hyperref[def:abstract_natural_deduction_system]{propositional natural deduction system}, for arbitrary propositional formulas, we have
  \begin{equation*}
    \Gamma, \varphi \vdash \psi \T{if and only if} \Gamma \vdash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item See \fullref{rem:deduction_theorem_list} for a list of similar theorems.
\end{comments}
\begin{proof}
  \SufficiencySubProof Let \( P \) be a \hyperref[def:natural_deduction_proof_tree]{proof tree} of \( \psi \) from \( \Gamma \cup \set{ \varphi } \). If \( \varphi \) is marked with \( u \) in an open assumption in \( P \), the following tree derives \( \varphi \synimplies \psi \) from \( \Gamma \):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi]^u }
      \ellipsis { \( P \) } { \psi }
      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \psi }
    \end{prooftree}
  \end{equation*}

  Otherwise, we use the same rule but without discharging any assumptions:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis { \( P \) } { \psi }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \psi }
    \end{prooftree}
  \end{equation*}

  \NecessitySubProof Let \( P \) be a proof tree deriving \( \varphi \synimplies \psi \) from \( \Gamma \). Then the following proves \( \psi \) from \( \Gamma \cup \set{ \varphi } \):
  \begin{equation*}
    \begin{prooftree}
      \hypo {\Gamma}
      \ellipsis { \( P \) } { \varphi \synimplies \psi }

      \hypo { [\varphi]^u }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:minimal_propositional_negation_laws}
  With respect to the \hyperref[def:propositional_natural_deduction_systems]{minimal natural deduction system}, we have the following strict derivability graph (\eqref{eq:thm:classical_tautologies/dne} being the most powerful):
  \begin{center}
    \begin{forest}
      [
        {\eqref{eq:thm:classical_tautologies/dne}}
          [
            {\eqref{eq:thm:classical_tautologies/pierce}}
              [{\eqref{eq:thm:classical_tautologies/lem}}]
          ]
          [
            {\eqref{eq:thm:intuitionistic_tautologies/efq}}
              [{\eqref{eq:thm:intuitionistic_tautologies/lnc}}]
          ]
      ]
    \end{forest}
  \end{center}
\end{proposition}
\begin{proof}
  Most proofs are given in \cite[prop. 3]{DienerMcKubreJordens2020MaterialImplication} and \cite[prop. 13]{DienerMcKubreJordens2020MaterialImplication}. We will only show that \eqref{eq:thm:intuitionistic_tautologies/lnc} is strictly weaker than \eqref{eq:thm:intuitionistic_tautologies/efq}.

  For any formula \( \varphi \), we have the \hyperref[def:propositional_natural_deduction_systems]{natural deduction} proof that \( \eqref{eq:thm:intuitionistic_tautologies/lnc} \) is a tautology:
  \begin{equation*}
    \begin{prooftree}[separation=3em]
      \hypo{ [\varphi \synwedge \synneg \varphi]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_left}]{ \varphi }

      \hypo{ [\varphi \synwedge \synneg \varphi]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_right}]{ \synneg \varphi }

      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }

      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \synneg (\varphi \synwedge \synneg \varphi) }
    \end{prooftree}
  \end{equation*}

  Hence, \eqref{eq:thm:intuitionistic_tautologies/lnc} is a theorem of \hyperref[con:minimal_logic]{minimal logic}. If it were to imply \eqref{eq:thm:intuitionistic_tautologies/efq}, then minimal and intuitionistic logic would be equivalent, which would contradict \cite[prop. 3]{DienerMcKubreJordens2020MaterialImplication}. Therefore, \eqref{eq:thm:intuitionistic_tautologies/lnc} is indeed strictly weaker than \eqref{eq:thm:intuitionistic_tautologies/efq}.
\end{proof}

\begin{proposition}\label{thm:syntactic_propositional_conjunction_of_premises}
  With respect to the \hyperref[def:propositional_natural_deduction_systems]{minimal natural deduction system}, we have \( \varphi, \psi \vdash \theta \) if and only if \( (\varphi \synwedge \psi) \vdash \theta \).
\end{proposition}
\begin{proof}
  \SufficiencySubProof If \( \varphi, \psi \vdash \theta \), the following is a proof tree deriving \( \theta \) from \( \varphi \synwedge \psi \):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \varphi \synwedge \psi }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_left}]{ \varphi }

      \hypo{ \varphi \synwedge \psi }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_right}]{ \psi }

      \infer2{}

      \ellipsis {} { \theta }
    \end{prooftree}
  \end{equation*}

  \NecessitySubProof If \( (\varphi \synwedge \psi) \vdash \theta \), the following is a proof tree deriving \( \theta \) from \( \set{ \varphi, \psi } \):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \varphi }
      \hypo{ \psi }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/and/intro}]{ \varphi \synwedge \psi }
      \ellipsis{}{ \theta }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:propositional_derivations}
  We can construct the following proofs in the \hyperref[def:propositional_natural_deduction_systems]{minimal natural deduction system}:
  \begin{thmenum}
    \thmitem{thm:propositional_derivations/biconditional_as_conjunction} The biconditional is a conjunction of conditionals:
    \begin{equation}\label{eq:thm:propositional_derivations/biconditional_as_conjunction}
      \varphi \syniff \psi \vdash (\varphi \synimplies \psi) \synwedge  (\psi \synimplies \varphi)
    \end{equation}

    \thmitem{thm:propositional_derivations/conjunction_of_conditionals} Conversely, a conjunction of compatible conditionals is a biconditional:
    \begin{equation}\label{eq:thm:propositional_derivations/conjunction_of_conditionals}
      (\varphi \synimplies \psi) \synwedge (\psi \synimplies \varphi) \vdash \varphi \syniff \psi
    \end{equation}

    \thmitem{thm:propositional_derivations/conditional_as_conjunction} A conditional formula is the negation of a conjunction:
    \begin{equation}\label{eq:thm:propositional_derivations/conditional_as_conjunction}
      \varphi \synimplies \psi \vdash \neg(\varphi \synwedge \synneg \psi)
    \end{equation}

    \thmitem{thm:propositional_derivations/disjunction_as_conditional} When additionally assuming \eqref{eq:thm:intuitionistic_tautologies/efq}, a disjunction with the first subformula negated is a conditional:
    \begin{equation}\label{eq:thm:propositional_derivations/disjunction_as_conditional}
      \synneg \varphi \synvee \psi \vdash \varphi \synimplies \psi
    \end{equation}

    \thmitem{thm:propositional_derivations/contraposition} From a conditional we can derive its contraposition:
    \begin{equation}\label{eq:thm:propositional_derivations/contraposition}
      \varphi \synimplies \psi \vdash \synneg \psi \synimplies \synneg \varphi
    \end{equation}

    \thmitem{thm:propositional_derivations/contraposition_elim} From a contraposition we can derive a variation of the original:
    \begin{equation}\label{eq:thm:propositional_derivations/contraposition_elim}
      \synneg \psi \synimplies \synneg \varphi \vdash \varphi \synimplies \synneg \synneg \psi
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:propositional_derivations/biconditional_as_conjunction}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi \syniff \psi]^u }
      \hypo{ [\varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/iff/elim_left}]{ \psi }
      \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \psi }

      \hypo{ [\varphi \syniff \psi]^u }
      \hypo{ [\psi]^w }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/iff/elim_right}]{ \varphi }
      \infer[left label=\( w \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \psi \synimplies \varphi }

      \infer2[\ref{inf:def:propositional_natural_deduction_systems/and/intro}]{ (\varphi \synimplies \psi) \synwedge (\psi \synimplies \varphi) }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:propositional_derivations/conjunction_of_conditionals}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [(\varphi \synimplies \psi) \synwedge (\psi \synimplies \varphi)]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_right}]{ \varphi \synimplies \psi }
      \hypo{ [\varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }

      \hypo{ [(\varphi \synimplies \psi) \synwedge (\psi \synimplies \varphi)]^u }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_left}]{ \psi \synimplies \varphi }
      \hypo{ [\psi]^w }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \varphi }

      \infer[left label={\( v, w \)}]2[\ref{inf:def:propositional_natural_deduction_systems/iff/intro}]{ \varphi \syniff \psi }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:propositional_derivations/disjunction_as_conditional}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\synneg \varphi \synvee \psi]^w }

      \hypo{ \eqref{eq:thm:intuitionistic_tautologies/efq} }
      \ellipsis {} {\bot \synimplies \psi}

      \hypo{ [\synneg \varphi]^x }
      \hypo{ [\varphi]^u }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \bot }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }

      \hypo{ [\psi]^v }
      \infer[left label={\( x, v \)}]3[\ref{inf:def:propositional_natural_deduction_systems/or/elim}]{ \psi }

      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \psi }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:propositional_derivations/conditional_as_conjunction}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi \synwedge \synneg \psi]^u}
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_left}]{ \synneg \psi }

      \hypo { [\varphi \rightarrow \psi]^v }

      \hypo{ [\varphi \synwedge \synneg \psi]^u}
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/and/elim_right}]{ \varphi }

      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \synbot }

      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \neg(\varphi \synwedge \synneg \psi) }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:propositional_derivations/contraposition}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \varphi \synimplies \psi }
      \hypo{ [\varphi]^u }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }

      \hypo{ [\synneg \psi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }

      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \synneg \varphi }
      \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \synneg \psi \synimplies \synneg \varphi }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:propositional_derivations/contraposition_elim}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synneg \psi \synimplies \synneg \varphi }
      \hypo{ [\synneg \psi]^u }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/imp/elim}]{ \synneg \varphi }

      \hypo{ [\varphi]^v }
      \infer2[\ref{inf:def:propositional_natural_deduction_systems/neg/elim}]{ \synbot }

      \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/neg/intro}]{ \synneg \synneg \psi }
      \infer[left label=\( v \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \synneg \synneg \psi }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{theorem}[Propositional natural deduction soundness]\label{thm:propositional_natural_deduction_soundness}
  The minimal, intuitionistic and classical \hyperref[def:propositional_natural_deduction_systems]{propositional natural deduction systems} are \hyperref[def:abstract_logic/soundness]{sound} with respect to \hyperref[def:minimal_propositional_semantics]{minimal}, \hyperref[def:propositional_semantics/intuitionistic]{intuitionistic} and \hyperref[def:propositional_semantics/classical]{classical} semantics.
\end{theorem}
\begin{comments}
  \item See \fullref{rem:soundness_and_completeness_theorem_list} for a list of soundness and completeness theorems.
\end{comments}
\begin{proof}
  We justify the rules of \fullref{def:propositional_natural_deduction_systems} individually, utilizing \fullref{thm:propositional_syntactic_deduction_theorem} when necessary.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/top/intro} We define valuations of \( \syntop \) to be \( T \).

  \SubProofOf{inf:def:propositional_natural_deduction_systems/bot/efq} Justified by \eqref{eq:thm:intuitionistic_tautologies/efq}.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/bot/dne} Justified by \eqref{eq:thm:classical_tautologies/dne} and \eqref{eq:thm:intuitionistic_equivalences/negation_bottom}.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/neg/intro} Justified by \eqref{eq:thm:intuitionistic_equivalences/negation_bottom}, which, as explained in \fullref{thm:intuitionistic_equivalences}, holds under minimal semantics.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/neg/elim} Also justified by \eqref{eq:thm:intuitionistic_equivalences/negation_bottom}.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/or/intro_left} If \( \Bracks{\varphi}_I = T \), then
  \begin{equation*}
    \Bracks{\varphi \synvee \psi}_I = T \vee \Bracks{\psi}_I = T.
  \end{equation*}

  \SubProofOf{inf:def:propositional_natural_deduction_systems/or/intro_right} Analogous.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/or/elim} If \( \varphi \vDash \theta \) and \( \psi \vDash \theta \), then
  \begin{equation*}
    \Bracks{(\varphi \synvee \psi) \synimplies \theta}_I
    =
    (\Bracks{\varphi}_I \vee \Bracks{\psi}_I) \rightarrow \Bracks{\theta}_I
  \end{equation*}

  \SubProofOf{inf:def:propositional_natural_deduction_systems/and/intro} If \( \Bracks{\varphi}_I = \Bracks{\psi}_I = T \), then
  \begin{equation*}
    \Bracks{\varphi \synwedge \psi}_I = T \wedge T = T.
  \end{equation*}

  \SubProofOf{inf:def:propositional_natural_deduction_systems/and/elim_left} If \( \Bracks{\varphi \synwedge \psi}_I = T \), then \( \Bracks{\varphi}_I = \Bracks{\psi}_I = T \).

  \SubProofOf{inf:def:propositional_natural_deduction_systems/and/elim_right} Analogous.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/imp/intro} Justified by \fullref{thm:propositional_syntactic_deduction_theorem}.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/imp/elim} If \( \Bracks{\varphi \synimplies \psi}_I = T \) and \( \Bracks{\varphi}_I = T \), then
  \begin{equation*}
    \underbrace{\Bracks{\varphi \synimplies \psi}_I}_T
    =
    \underbrace{\Bracks{\varphi}_I}_T \rightarrow \Bracks{\psi}_I
    \reloset {\ref{thm:def:heyting_algebra/top_left}} =
    \Bracks{\psi}_I.
  \end{equation*}

  \SubProofOf{inf:def:propositional_natural_deduction_systems/iff/intro} Justified by \fullref{thm:propositional_syntactic_deduction_theorem}.

  \SubProofOf{inf:def:propositional_natural_deduction_systems/iff/elim_left} If \( \Bracks{\varphi \syniff \psi}_I = T \) and \( \Bracks{\varphi}_I = T \), then
  \begin{multline*}
    \underbrace{\Bracks{\varphi \syniff \psi}_I}_T
    =
    \Bracks{\varphi}_I \leftrightarrow \Bracks{\psi}_I
    =
    (\underbrace{\Bracks{\varphi}_I}_T \rightarrow \Bracks{\psi}_I) \wedge (\Bracks{\psi}_I \rightarrow \underbrace{\Bracks{\varphi}_I}_T)
    \reloset {\ref{thm:def:heyting_algebra/top_left}} = \\ =
    \Bracks{\psi}_I \wedge (\Bracks{\psi}_I \rightarrow \underbrace{\Bracks{\varphi}_I}_T)
    \reloset {\eqref{eq:def:heyting_algebra/axioms/modus_ponens}} =
    \Bracks{\psi}_I \wedge \underbrace{\Bracks{\varphi}_I}_T
    =
    \Bracks{\psi}_I.
  \end{multline*}

  \SubProofOf{inf:def:propositional_natural_deduction_systems/iff/elim_right} Analogous.
\end{proof}

\begin{theorem}[Glivenko's double negation theorem]\label{thm:glivenkos_double_negation_theorem}\mcite[202]{CitkinMuravitsky2022ConsequenceRelations}
  A formula \( \varphi \) is derivable from \( \Gamma \) in the \hyperref[def:propositional_natural_deduction_systems]{classical propositional natural deduction system} if and only if it's double negation \( \synneg \synneg \varphi \) is derivable from \( \Gamma \) in the minimal natural deduction system.
\end{theorem}
\begin{proof}
  \item We will not prove this theorem.
\end{proof}

\paragraph{Sequent calculus}

We will only briefly sketch some ideas of sequent calculus because of their importance.

\begin{definition}\label{def:sequent_calculus_rule}
  A \term{sequent calculus rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[def:sequent]{sequents} of \hyperref[con:schemas_and_instances]{formula schemas}.
\end{definition}
\begin{comments}
  \item These rules are motivated in \fullref{rem:sequent_calculus}.
  \item The only formula schemas we have completely formalized are \hyperref[def:propositional_formula_schema]{propositional formula schemas}, but we also consider first-order and higher-order schemas.
\end{comments}

\begin{remark}\label{rem:sequent_calculus}
  As discussed in \fullref{rem:inference_rules_semantics}, \incite*{Gentzen1935LogischeSchließen} introduced both natural deduction rules and sequent calculus rules.

  We saw in \fullref{def:abstract_natural_deduction_system} and \fullref{def:natural_deduction_proof_tree} how natural deduction can be completely formalized, and we will extend those rules (although less formally) to first-order logic in \fullref{def:abstract_first_order_natural_deduction_system}.

  Sequent calculus is instead based on \hyperref[def:inference_rule]{inference rules} whose entries are all \hyperref[def:sequent]{sequents}. The intended instantiation of the sequent  \( \syn\Gamma \synvdash \syn\Delta \)\fnote{We regard inference rules are purely syntactic objects. In order to explicitly distinguish sequents in a rule from \hyperref[con:judgment]{judgments} in the metalanguage a-la those discussed by Martin-L\"of in \cite[2]{MartinLöf1996LogicalLaws}, in accordance with \fullref{rem:object_language_dots}, we put dots over the \hyperref[def:variable_identifier]{capital Greek identifiers} denoting \hyperref[def:logical_context]{logical context placeholders}, as well as over the sequent symbol \( {\vdash} \). Thus, we denote by \( \syn\Gamma \synvdash \syn\Delta \) what Gentzen denotes by \( \Gamma \vdash \Delta \).} is that at least one formula in \( \syn\Delta \) is a consequence of the entire set \( \syn\Gamma \). Thus, \( \syn\varphi, \syn\psi \vdash \syn\theta, \syn\chi \) corresponds to \( \syn\varphi \synwedge \syn\psi \vdash \syn\theta \synvee \syn\chi \).

  Consider Gentzen's natural deduction rule \ref{inf:def:propositional_natural_deduction_systems/imp/intro}, which we will restate here for clarity:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\syn\varphi] }
      \ellipsis {} { \syn\psi }
      \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \syn\varphi \synimplies \syn\psi }
    \end{prooftree}
  \end{equation*}

  It corresponds to two \hyperref[def:abstract_propositional_sequent_calculus_system]{sequent calculus rules}:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \rightarrow_L }]{inf:rem:sequent_calculus/imp/left}
        \begin{prooftree}
          \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
          \hypo{ \syn\psi, \syn\Gamma' \synvdash \syn\Delta' }
          \infer2[\ref{inf:rem:sequent_calculus/imp/left}]{ (\syn\varphi \synimplies \syn\psi), \syn\Gamma, \syn\Gamma' \synvdash \syn\Delta, \syn\Delta' }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation}\taglabel[\ensuremath{ \rightarrow_R }]{inf:rem:sequent_calculus/imp/right}
        \begin{prooftree}
          \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta, \syn\psi }
          \infer1[\ref{inf:rem:sequent_calculus/imp/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synimplies \syn\psi) }
        \end{prooftree}
      \end{equation}
    \end{rightcolumn}
  \end{paracol}

  One fundamental difference is that the subtleties of defining natural deduction proof trees that we saw in \fullref{def:natural_deduction_proof_tree} are now made explicit --- they are simply a part of the rule itself.

  Furthermore, the conclusion of a proof tree is now a sequent, and, rather than encoding a single \hyperref[con:proposition]{proposition}, it encodes an entailment of finitely many propositions from finitely many propositions. The assumptions of a proof tree are contained entirely in its conclusion. To make sure that the tree's premises are valid, we introduce the following rule, made implicit by Gentzen:
  \begin{equation*}\taglabel[\ensuremath{ \logic{Init} }]{inf:rem:sequent_calculus/init}
    \begin{prooftree}
      \infer0[\ref{inf:rem:sequent_calculus/init}]{ \syn\varphi \synvdash \syn\varphi }.
    \end{prooftree}
  \end{equation*}

  Unfortunately, this makes the proofs more cumbersome since we need to list all premises at every node of the proof tree.

  Furthermore, since the complexity is now in the rules themselves, sequent calculus requires additional rules for properly handling sequents --- what Gentzen himself calls \enquote{Struktur-Schlu\ss{}figuren} (\enquote{structural rules}). In particular, the rules rely on the order of items in a context, so we need to work with \hyperref[def:logical_context_semantics]{list-based context semantics}. We present Gentzen's structural rules in \fullref{def:abstract_propositional_sequent_calculus_system/rules}.

  Gentzen's primary motivation for sequent calculus is the ability to prove that the structural rule \ref{inf:def:abstract_propositional_sequent_calculus_system/rules/cut} is redundant given sequent calculus rules for first-order logic. He called this result the \enquote{Hauptsatz}, and \incite[92]{TroelstraSchwichtenberg2000BasicProofTheory} and \incite[\S 2.6.4]{Mimram2020ProgramEqualsProof} call it \enquote{cut elimination}.

  Since we aren't interested in proof theory and thus in cut elimination, we will not further pursue sequent calculus but only state the original structural rules.
\end{remark}

\begin{definition}\label{def:abstract_propositional_sequent_calculus_system}\mimprovised
  We define an \term{abstract propositional sequent calculus system} as a collection of \hyperref[def:sequent_calculus_rule]{sequent calculus rules}.

  As discussed in \fullref{rem:sequent_calculus}, auxiliary rules are needed to ensure that contexts can be manipulated in accordance with the set-based or list-based semantics presented in \fullref{def:logical_context_semantics}. We list here Gentzen's original structural rules from \cite[192]{Gentzen1935LogischeSchließen} with the English translation of his terminology from \cite[296]{Gentzen1964LogicalDeduction}\fnote{These rules are also discussed in \cite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory}, \cite[\S 2.6.2]{Mimram2020ProgramEqualsProof} and \cite[\S III*.3]{КолмогоровДрагалин2006Логика}, with slight variations made immaterial by the interplay of the structural rules themselves (e.g. whether we use \enquote{\( \syn\Gamma, \syn\varphi \)} or \enquote{\( \syn\varphi, \syn\Gamma \)} is immaterial due to \ref{inf:def:abstract_propositional_sequent_calculus_system/rules/inter/left}).}. As per Gentzen's presentation, we will refer to these as \term[ru=структурные правила (\cite[97]{КолмогоровДрагалин2006Логика}), de=Struktur-Schlu\ss{}figuren (\cite[191]{Gentzen1935LogischeSchließen})]{structural rules}, and to other rules as \term[ru=логические правила (\cite[97]{КолмогоровДрагалин2006Логика}), de=Logische-Zeichen-Schlu\ss{}figuren (\cite[191]{Gentzen1935LogischeSchließen})]{logical rules}. If a system includes only a part of Gentzen's structural rules, we will call it \term[en=substructural (\cite[91]{TroelstraSchwichtenberg2000BasicProofTheory})]{substructural}.

  \begin{thmenum}
    \thmitem{def:abstract_propositional_sequent_calculus_system/rules/weak} \term[ru=правила добавления (\cite[217]{КолмогоровДрагалин2006Логика})]{Weakening rules} (originally called \enquote{thinning rules} in \cite[296]{Gentzen1964LogicalDeduction}):
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Weak}_L }]{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/left}]{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Weak}_R }]{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/right}]{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    When the other structural rules are chosen carefully, weakening rules can be avoided to simplify inductive proofs; see \cite{CST:weakening_rule_for_lambda_cube}.

    \thmitem{def:abstract_propositional_sequent_calculus_system/rules/contract} \term[ru=правила сокращения (\cite[218]{КолмогоровДрагалин2006Логика})]{Contraction rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Contr}_L }]{inf:def:abstract_propositional_sequent_calculus_system/rules/contract/left}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/contract/left}]{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Contr}_R }]{inf:def:abstract_propositional_sequent_calculus_system/rules/contract/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi, \syn\varphi }
            \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/contract/right}]{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:abstract_propositional_sequent_calculus_system/rules/inter} \term{Interchange rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Inter}_L }]{inf:def:abstract_propositional_sequent_calculus_system/rules/inter/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma, \syn\varphi, \syn\psi, \syn\Gamma' \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/inter/left}]{ \syn\Gamma, \syn\psi, \syn\varphi, \syn\Gamma' \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Inter}_R }]{inf:def:abstract_propositional_sequent_calculus_system/rules/inter/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi, \syn\psi, \syn\Delta' }
            \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/inter/right}]{ \syn\Gamma \synvdash \syn\Delta, \syn\psi, \syn\varphi, \syn\Delta' }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    These rules are only needed if imitating set-based context semantics is desired.

    \thmitem{def:abstract_propositional_sequent_calculus_system/rules/cut} The \term[ru=правило сечения (\cite[219]{КолмогоровДрагалин2006Логика})]{cut rule}:
    \begin{equation*}\taglabel[\logic{Cut}]{inf:def:abstract_propositional_sequent_calculus_system/rules/cut}
      \begin{prooftree}
        \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
        \hypo{ \syn\varphi, \syn\Gamma' \synvdash \syn\Delta' }
        \infer2[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/cut}]{ \Gamma, \Gamma' \synvdash \syn\Delta, \syn\Delta' }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{example}\label{ex:proof_tree_non_uniqueness}
  \incite[\S 4.1.7.2]{Mimram2020ProgramEqualsProof} highlights some inherent subtleties of applying rules when working with \hyperref[def:logical_context_semantics]{set-based context semantics}. We have designed our proof trees so that they mitigate these issues, but they are easily reproducible in a more informal treatment.

  Consider the natural deduction proof trees
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}
        \begin{prooftree}
          \hypo{ [\varphi]^u }
          \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \varphi }

          \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \psi \synimplies (\varphi \synimplies \varphi) }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}
        \begin{prooftree}
          \hypo{ [\varphi]^u }
          \infer1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \psi \synimplies \varphi }

          \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies (\psi \synimplies \varphi) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  If \( \varphi = \psi \), we obtain two distinct proofs of
  \begin{equation*}
    \varphi \synimplies (\varphi \synimplies \varphi).
  \end{equation*}

  We are able to distinguish them because we mark the discharged assumptions during each rule application. Otherwise, the two proof trees would be identical, but obtained by applying \ref{inf:def:propositional_natural_deduction_systems/imp/intro} to distinct premises.

  The corresponding sequent calculus proofs are
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}
        \begin{prooftree}
          \infer0[\ref{inf:rem:sequent_calculus/init}]{ \varphi \synvdash \varphi }
          \infer1[\ref{inf:rem:sequent_calculus/imp/right}]{ \synvdash \varphi \synimplies \varphi }
          \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/left}]{ \psi \synvdash \varphi \synimplies \varphi }
          \infer1[\ref{inf:rem:sequent_calculus/imp/right}]{ \synvdash \psi \synimplies (\varphi \synimplies \varphi) }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}
        \begin{prooftree}
          \infer0[\ref{inf:rem:sequent_calculus/init}]{ \varphi \synvdash \varphi }
          \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/left}]{ \psi, \varphi \synvdash \varphi }
          \infer1[\ref{inf:rem:sequent_calculus/imp/right}]{ \varphi \synvdash \psi \synimplies \varphi }
          \infer1[\ref{inf:rem:sequent_calculus/imp/right}]{ \synvdash \varphi \synimplies (\psi \synimplies \varphi) }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  Again, if \( \varphi = \psi \), we obtain two distinct proofs of the same formula.

  It is essential here that we use list-based context semantics governed by structural rules. If we were to treat contexts as unordered collections, we would have two distinct cases:
  \begin{itemize}
    \item If \( \varphi = \psi \), the left proof would still be valid, but using the weakening rule in the second proof would be ineffective, and we would only be able to derive
    \begin{equation*}
      \begin{prooftree}
        \infer0[\ref{inf:rem:sequent_calculus/init}]{ \varphi \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_propositional_sequent_calculus_system/rules/weak/left}]{ \varphi \synvdash \varphi }
        \infer1[\ref{inf:rem:sequent_calculus/imp/right}]{ \synvdash \varphi \synimplies \varphi }
      \end{prooftree}
    \end{equation*}

    As an alternative to treating contexts as lists, Mimram suggests treating them as \hyperref[def:multiset]{multisets}, which would mitigate this concrete issue and derive
    \begin{equation*}
      \synvdash \varphi \synimplies (\varphi \synimplies \varphi).
    \end{equation*}

    \item If either \( \varphi \neq \psi \) or if we were using multisets, applying \ref{inf:rem:sequent_calculus/imp/right} to the sequent
    \begin{equation*}
      \psi, \varphi \synvdash \varphi
    \end{equation*}
    could lead to either
    \begin{equation*}
      \varphi \synvdash \psi \synimplies \varphi
    \end{equation*}
    or
    \begin{equation*}
      \psi \synvdash \varphi \synimplies \varphi.
    \end{equation*}

    Thus, treating contexts as multisets leads to a multiset of proof trees.
  \end{itemize}
\end{example}

\begin{remark}\label{rem:natural_deduction_explicit_sequents}
  The familiar \hyperref[def:natural_deduction_rule]{natural deduction rules} from \fullref{def:propositional_natural_deduction_systems} and \fullref{def:first_order_natural_deduction_system} are sometimes stated with explicit \hyperref[def:sequent]{sequents}, in a way similar to \hyperref[def:sequent_calculus_rule]{sequent calculus rules}. \incite[\S 2.1.8]{TroelstraSchwichtenberg2000BasicProofTheory} call this \enquote{natural deduction in sequent style}.

  For example, the \hyperref[thm:axiomatic_derivation_as_def:type_of_booleanstion/mp]{modus ponens} (arrow type elimination) rule
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\varphi \synimplies \syn\psi }
      \hypo{ \syn\varphi }
      \infer2[\ensuremath{ \logic{MP} }]{ \syn\psi }
    \end{prooftree}
  \end{equation*}
  becomes
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma \synvdash \syn\varphi \synimplies \syn\psi }
      \hypo{ \syn\Delta \synvdash \syn\varphi }
      \infer2[\ensuremath{ \logic{MP} }]{ \syn\Gamma, \syn\Delta \synvdash \syn\psi }
    \end{prooftree}
  \end{equation*}

  One benefit of this presentation is that discharging assumptions no longer requires special syntax:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\syn\varphi] }
      \infer[dashed]1{ \syn\psi }
      \infer1[\ensuremath{ \rightarrow_+ }]{ \syn\varphi \synimplies \syn\psi }
    \end{prooftree}
  \end{equation*}
  becomes
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma, \syn\varphi \synvdash \syn\psi }
      \infer1[\ensuremath{ \rightarrow_+ }]{ \syn\Gamma \synvdash \syn\varphi \synimplies \syn\psi }
    \end{prooftree}
  \end{equation*}

  The latter resembles the sequent calculus rule \ref{inf:rem:sequent_calculus/imp/right}, but with no context on the right.

  Other than that, there will be no benefit for us from using explicit sequents in our natural deduction rules. Furthermore, as discussed in \fullref{rem:typing_rule_eigenvariables}, they still require stating eigenvariable conditions as side conditions, so they share the same limitations.
\end{remark}
