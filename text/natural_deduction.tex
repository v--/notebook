\subsection{Natural deduction}\label{subsec:natural_deduction}

\paragraph{Inference rules}

\begin{definition}\label{def:inference_rule}\mimprovised
  An \term[ru=правило вывода (\cite[31]{Герасимов2011}), en=inference rule (\cite[2]{MartinLof1996Meanings})]{inference rule} is a string generated by the corresponding grammar rule from the \hyperref[def:formal_grammar/schema]{schema}
  \begin{bnf*}
    \bnfprod{entry list}     {\bnfpn{entry} \bnfor \bnfpn{entry list} \bnfsp \bnftsq{,} \bnfsp \bnfpn{entry list}}, \\
    \bnfprod{premises}       {\bnfes \bnfor \bnfpn{entry} \bnfor \bnfpn{entry list}}, \\
    \bnfprod{conclusion}     {\bnfpn{entry}}, \\
    \bnfprod{inference rule} {\bnftsq{(} \bnfsp \bnfpn{rule name} \bnfsp \bnftsq{)} \bnfsp \bnfpn{premises} \bnfsp \bnftsq{\( \vDdash \)} \bnfsp \bnfpn{conclusion}}
  \end{bnf*}
  where, similarly to \fullref{def:logical_context}, we have purposely not specified rules for the nonterminal \( \bnfpn{entry} \) in order to encompass entries with different syntax. We have also not specified a precise syntax for rule names because we use a variety of symbols as there is little benefit in listing them explicitly here.

  \incite[291]{Szabo1964Gentzen} introduces the notation
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \varphi_1 }
      \hypo{ \cdots }
      \hypo{ \varphi_n }
      \infer3[\logic{R}]{ \psi }
    \end{prooftree}
  \end{equation*}
  for the rule
  \begin{equation*}
    (\logic{R}) \enspace \varphi_1, \ldots, \varphi_n \vDdash \psi.
  \end{equation*}

  We call \( n \) the \term{arity} of the rule \( \logic{R} \).
\end{definition}
\begin{comments}
  \item Identifier grammar rules are motivated and discussed in \fullref{rem:grammar_rules_for_variables}.
  \item This definition is based on the one by \incite[291]{Szabo1964Gentzen}, but formalized via grammars and not tied to either formulas nor sequents.
\end{comments}

\begin{example}\label{ex:fixed_point_recursion_for_relations}
  Among their other uses, \hyperref[def:inference_rule]{inference rules} are a convenient mechanism for defining relations. We will illustrate this with an example.

  The following rules express how to construct the \hyperref[thm:equivalence_closure]{equivalence closure} \( {\congdot} \) of a binary relation \( {\dotsim} \). In the following, \( \alpha \), \( \beta \) and \( \gamma \) are variables whose purpose is act as schemas for concrete values:
  \begin{align*}
    \begin{prooftree}
      \hypo{ \alpha \dotsim \beta }
      \infer1[\logic{I}]{ \alpha \congdot \beta }
    \end{prooftree}
    &&
    \begin{prooftree}
      \infer0[\logic{R}]{ \alpha \congdot \alpha }
    \end{prooftree}
    \\\\
    \begin{prooftree}
      \hypo{ \alpha \congdot \beta }
      \infer1[\logic{S}]{ \beta \congdot \alpha }
    \end{prooftree}
    &&
    \begin{prooftree}
      \hypo{ \alpha \congdot \beta }
      \hypo{ \beta \congdot \gamma }
      \infer2[\logic{T}]{ \alpha \congdot \gamma }
    \end{prooftree}
  \end{align*}

  Note that we have used \( {\congdot} \) and \( {\dotsim} \) as our relation symbols to highlight that inference rules are syntactic constructions, and the relation symbols are merely schemas for actual relations.

  Rather than giving an all-encompassing formal definition for how such inference rules are interpreted, we will translate the aforementioned rules into an endofunction on \( M \to M \) suitable for \fullref{thm:knaster_tarski_theorem}:
  \begin{equation*}
    \begin{aligned}
      T(r) \coloneqq \thickspace & r \thickspace {\cup} \\
                                 & \set{ (x, y) \given x \sim y } \thickspace {\cup} \\
                                 & \set{ (x, x) \given x \in M } \thickspace {\cup} \\
                                 & \set{ (y, x) \given (x, y) \in r } \thickspace {\cup} \\
                                 & \set{ (x, z) \given (x, y) \in r \T{and} (y, z) \in r }.
    \end{aligned}
  \end{equation*}

  The equivalence closure is simply the least fixed point of \( T \).

  A downside of this approach is that it may be difficult to determine whether \( T \) is \hyperref[def:scott_continuity]{Scott-continuous}, and thus whether the least fixed point can be reached by taking the union
  \begin{equation*}
    \bigcup_{k=0}^\infty T^k(\varnothing).
  \end{equation*}

  An alternative is to use \fullref{thm:least_fixed_point_recursion}, which guarantees that the underlying operator is Scott-continuous, but has the downside of being more verbose in this particular case. Suppose that our domain of discourse is \( D \coloneqq M \times M \) and consider the following constructors:
  \begin{itemize}
    \item Corresponding to rule \( \logic{I} \), for each pair \( (x, y) \) in \( {\sim} \), the nullary constructor\fnote{This family of constructors could of course be replaced by choosing the set of base elements to be the underlying set of the relation \( {\sim} \), but our purpose is to illustrate how the particular inference rules can be translated into constructors.}
    \begin{equation*}
      i_{x,y} \coloneqq (x, y).
    \end{equation*}

    \item Corresponding to rule \( \logic{R} \), for each element \( x \) of \( M \), the nullary constructor
    \begin{equation*}
      r_x \coloneqq (x, x).
    \end{equation*}

    \item Corresponding to rule \( \logic{S} \), the unary constructor
    \begin{equation*}
      s((x, y)) \coloneqq (y, x).
    \end{equation*}

    \item Corresponding to rule \( \logic{T} \), the partial binary constructor
    \begin{equation*}
      t((x, y), (y', z)) \coloneqq \begin{cases}
        (x, z),        &y = y', \\
        \T{undefined}, &\T{otherwise.} \\
      \end{cases}
    \end{equation*}
  \end{itemize}
\end{example}

\begin{remark}\label{rem:inference_rules_semantics}
  We have introduced inference rules in \fullref{def:inference_rule} as strings with the intention to use them in vastly differing situations:
  \begin{itemize}
    \item Expressing typing rules in \fullref{subsec:simple_type_theory}. This is done, among others, by \incite{Hindley1997} and \incite{Mimram2020}.
    \item Succinctly defining relations as shown in \fullref{ex:fixed_point_recursion_for_relations}. This is done by \incite{Mimram2020}.
    \item Expressing the possibilities of constructing proof trees in natural deduction systems. This is done by \incite{TroelstraSchwichtenberg2000}, \incite{КолмогоровДрагалин2006}, \incite{Герасимов2011} and \incite{Hindley1997}.
  \end{itemize}

  Inference rules can easily be formalized as \hyperref[def:relation]{relations}, as is done by \incite[31]{Герасимов2011}, \incite[115]{CitkinMuravitsky2021} and \incite[63]{Galatos2007}, but this makes it difficult to change the underlying semantics. Other authors only use the notion of inference rules informally.

  For describing his \enquote{natural deduction} systems, \incite{Szabo1964Gentzen} uses the notation
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \varphi_1 }
      \hypo{ \cdots }
      \hypo{ \varphi_n }
      \infer3[\logic{R}]{ \psi }
    \end{prooftree},
  \end{equation*}
  where \( \varphi_1, \ldots, \varphi_n \) and \( \psi \) are schemas for formulas. A problem with this approach is that the rules may depend on additional metalogical context.

  \incite[2]{MartinLof1996Meanings} argues that, in situations like the one above, we should instead use metalogical rules to affirm the corresponding formulas:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \vdash \varphi_1 }
      \hypo{ \cdots }
      \hypo{ \vdash \varphi_n }
      \infer3[\logic{R}]{ \vdash \psi }
    \end{prooftree}
  \end{equation*}

  Later in \cite{Szabo1964Gentzen}, the original of which was written prior to Martin-L\"of's birth, Gentzen introduces \enquote{sequent calculus} that uses \hyperref[def:sequent]{sequents} instead of formulas, which results in an extension of the latter notation that also allows formulas on the left. Some authors, like \incite[46]{Mimram2020}, prefer to add the necessary context for natural deduction on the left side of sequents, which would otherwise be empty. \incite[ch. 2]{TroelstraSchwichtenberg2000} present both of these variants of natural deduction.

  To clarify whether rules act inside the object theory or the metatheory, \incite[117]{CitkinMuravitsky2021}, who define rules as relations, refer as \enquote{rule} to inference rules acting on sequents and as \enquote{hyperrules} to inference rules acting on judgments, and give distinct definitions for the two.
\end{remark}

\paragraph{Natural deduction systems}

\begin{definition}\label{def:propositional_natural_deduction_systems}\mimprovised
  Consider the grammar schema of propositional logic from \fullref{def:propositional_syntax} extended with \hyperref[def:propositional_formula_schema]{formula schemas}.

  A \term{propositional natural deduction system} consists of a nonempty collection of \hyperref[def:inference_rule]{inference rules}, implicitly assumed to have different names, whose entries can be either formula schemas or pairs of schemas:
  \begin{bnf*}
    \bnfprod{entry} {\bnfpn{formula schema} \bnfor} \\
    \bnfmore        {\bnftsq{[} \bnfsp \bnfpn{formula schema} \bnfsp \bnftsq{]} \bnfsp \bnfpn{formula schema}}.
  \end{bnf*}

  These bracketed schemas allow \enquote{closing} certain assumptions --- see \fullref{def:natural_deduction_proof_tree}.

  We forbid the conclusion to have such a bracketed schema by replacing the existing rules from \fullref{def:inference_rule} with
  \begin{bnf*}
    \bnfprod{conclusion} {\bnfpn{formula schema}}
  \end{bnf*}

  We prefer to denote the rule
  \begin{equation*}
    (\logic{R}) \enspace \Phi_1, \ldots, [\Phi_k] \thickspace \Theta_k, \ldots, \Theta_n \vDdash \Psi
  \end{equation*}
  as
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \Phi_1 }
      \hypo{ \cdots }
      \hypo{ [\Theta_k] }
      \ellipsis {} { \Phi_k }
      \hypo{ \cdots }
      \hypo{ \Phi_n }
      \infer5[\logic{R}]{ \Psi }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item This definition resembles \enquote{deductive systems} defined by \incite[31]{Герасимов2011} and \enquote{axiom systems} defined by \incite[80]{Smullyan1995}. We have restricted ourselves to propositional logic and to natural deduction because we want our definition to be as precise as possible. The rules are formalized as strings so that they can be treated rigorously, and then they are specifically adjusted for natural deduction. The adjustments are based on \cite[sec. 2.1]{TroelstraSchwichtenberg2000}. Furthermore, we assume no axioms here.
\end{comments}

\begin{definition}\label{def:natural_deduction_proof_tree}\mimprovised
  Fix a \hyperref[def:propositional_natural_deduction_systems]{propositional natural deduction system}. We will define a family of \hyperref[def:multiway_tree]{multiway trees}, which we will call \term{proof trees}.

  We will use \fullref{thm:least_fixed_point_recursion} on multiway trees whose values are triples consisting of the following objects:
  \begin{thmenum}[series=def:natural_deduction_proof_tree]
    \thmitem{def:natural_deduction_proof_tree/conclusion} A formula, called the \term[ru=conclusion (\cite[35]{TroelstraSchwichtenberg2000}), en=conclusion (\cite[36]{TroelstraSchwichtenberg2000})]{conclusion} of the proof.

    \thmitem{def:natural_deduction_proof_tree/rule_name} An empty string or the name of a rule from the natural deduction system.

    \thmitem{def:natural_deduction_proof_tree/context} A \hyperref[def:logical_context]{context} whose entries are marked formulas generated by the following grammar:
    \begin{bnf*}
      \bnfprod{marker}          {\bnfpn{Latin identifier}}, \\
      \bnfprod{marked formula}  {\bnfpn{marker} \bnfsp \bnftsq{:} \bnfsp \bnfpn{formula}}.
    \end{bnf*}
  \end{thmenum}

  We will define constructors on general multiway trees of this form, however by \enquote{proof tree} we will only mean those recursively obtained via \fullref{thm:least_fixed_point_recursion}.

  We will define two kinds of trees:
  \begin{thmenum}[resume=def:natural_deduction_proof_tree]
    \thmitem{def:natural_deduction_proof_tree/assumption} We will first define trees corresponding to assumptions, which will be the \hyperref[thm:least_fixed_point_recursion/base]{base elements} of the recursion.

    An \term{assumption} for a propositional formula \( \varphi \) and marker \( u \) is the singleton tree with the following value:
    \begin{itemize}
      \item The conclusion is, unsurprisingly, \( \varphi \).
      \item The rule name is empty (because the conclusion has not been obtained by an application of a rule).
      \item The context is the singleton list with entry \( u: \varphi \).
    \end{itemize}

    We will denote such a tree as follows:
    \begin{equation*}
      [\varphi]^u.
    \end{equation*}

    \thmitem{def:natural_deduction_proof_tree/application} We will now define trees called \term{rule applications}. In terms of \fullref{thm:least_fixed_point_recursion}, we define an \( n \)-ary \hyperref[thm:least_fixed_point_recursion/base]{partial constructor} for every \( n \)-ary rule and every (uniform) \hyperref[def:uniform_schema_substitution]{schema substitution}.

    Consider the substitution \( \sigma \) and the rule
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Phi_1 }
        \hypo{ \cdots }
        \hypo{ [\Theta_i] }
        \ellipsis {} { \Phi_i }
        \hypo{ \cdots }
        \hypo{ \Phi_n }
        \infer5[\logic{R}]{ \Psi }
      \end{prooftree}
    \end{equation*}

    Fix a tuple \( (T_1, \ldots, T_n) \) of trees such that, for \( i = 1, \ldots, n \), the conclusion of \( T_i \) is \( \Phi_i[\sigma] \). We leave the constructor undefined for tuples that do not satisfy this condition.

    The delicate part of defining rule application trees is to choose a context \( \Gamma \) of assumptions \enquote{closed} at this step. We start with an empty context and use recursion on \( i = 1, \ldots, n \) to define \( \Gamma \). At step \( i \), if \( \Phi_i \) has a bracketed formula \( [\Theta_i] \) attached, if \( T_i \) contains an assumption node labeled by the formula \( \Theta_i[\sigma] \) and if the marker \( u \) of the assumption is not in the context of any rule application subtree of \( T_i \), we will close this assumption now by adding \( u: \Theta_i[\sigma] \) to \( \Gamma \).

    We can now define a node value that will serve as the root of an application tree:
    \begin{itemize}
      \item The conclusion is \( \Psi[\sigma] \).
      \item The rule name is \( \logic{R} \).
      \item The context is \( \Gamma \).
    \end{itemize}

    Finally, we define a rule application tree, the value of our constructor, as the tree whose root has the aforementioned value and whose immediate subtrees are \( T_1, \ldots, T_n \). We draw this tree as follows (resembling stacked inference rules):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ T_1 }
        \hypo{ \cdots }
        \hypo{ T_n }
        \infer[left label=\( \Gamma \)]3[\logic{R}]{ \Psi[\sigma] }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition somewhat resembles \enquote{prooftrees} from \incite{TroelstraSchwichtenberg2000}, but is completely rigorous and explicitly encodes which inference rules have been used. The treatment of the rules is based on \incite[sec. 2.1]{TroelstraSchwichtenberg2000}.
  \item It is possible to avoid markers entirely and close assumptions independent of their label. \incite[subsec. 2.1.9]{TroelstraSchwichtenberg2000} call this the \enquote{complete discharge convention}. We prefer not to use this convention for two reasons:
  \begin{itemize}
    \item It is easier to track assumptions in proofs.
    \item The relationship to \( \synlambda \)-terms becomes apparent.
  \end{itemize}
\end{comments}

\begin{definition}\label{def:natural_deduction_open_assumptions}\mimprovised
  We say that the formula \( \varphi \) is an \term{open assumption} of a \hyperref[def:natural_deduction_proof_tree]{natural deduction proof tree} \( T \) if there exists an assumption subtree \( [\varphi]^u \) in \( T \) and if \( u: \varphi \) is not closed by any rule application in \( T \).
\end{definition}
\begin{comments}
  \item By this definition, \( \varphi \) is an open assumption if, for distinct labels, \( [\varphi]^v \) is closed and \( [\varphi]^u \) is not. To avoid such situations, it is best to only have one marker per formula.
  \item Another curious situation is if \( [\varphi]^u \) is closed in one subtree but not in another. We do not consider it an open assumption in this case.
\end{comments}

\begin{definition}\label{def:natural_deduction_entailment}\mcite[205]{Hinman2005}
  For a \hyperref[def:natural_deduction_system]{natural deduction system}, we define a \hyperref[def:consequence_relation]{consequence relation} \( \Gamma \vdash \varphi \) that holds when there is a \hyperref[def:natural_deduction_proof_tree]{proof tree} with conclusion \( \varphi \) whose \hyperref[def:natural_deduction_open_assumptions]{open assumptions} are all in \( \Gamma \).
\end{definition}
\begin{defproof}
  We must show that \( {\vdash} \) satisfies the conditions for being a consequence relation.

  \SubProofOf[def:consequence_relation/reflexivity]{reflexivity} If \( \varphi \in \Gamma \), then, for any marker \( u \), the tree \( [\varphi]^u \) proves \( \varphi \) from \( \Gamma \).

  \SubProofOf[def:consequence_relation/monotonicity]{monotonicity} If \( \Gamma \vdash \varphi \), then there exists a proof tree of \( \varphi \) from \( \Gamma \). Such a tree also proves \( \varphi \) from any superset of \( \Gamma \).

  \SubProofOf[def:consequence_relation/transitivity]{transitivity} Suppose that \( \Delta, \Epsilon \vdash \varphi \) and that, for every \( \psi \in \Delta \), we have \( \Gamma, \Epsilon \vdash \psi \).

  Let \( T_\varphi \) be a proof tree of \( \varphi \) from \( \Delta \cup \Epsilon \) and let \( T_\psi \) be a proof tree of \( \psi \) from \( \Gamma \cup \Epsilon \).

  Then, for any formula \( \psi \in \Delta \) and any marker \( u \), we can replace the assumption \( [\psi]^u \) in \( T_\varphi \) with \( T_\psi \) and remove \( u: \psi \) from the contexts of the rule applications in \( T_\varphi \).

  The resulting tree will have the same conclusion as \( T_\varphi \) --- namely, \( \varphi \) --- but different open assumptions --- namely, members of \( \Gamma \cup \Epsilon \).
\end{defproof}

\paragraph{Axiomatic derivations via natural deduction}

\begin{remark}\label{rem:axiomatic_derivation_system_as_natural_deduction_system}
  We can regard any (propositional) \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} as a \hyperref[def:natural_deduction_system]{natural deduction system} as follows:
  \begin{thmenum}
    \thmitem{thm:axiomatic_derivation_as_natural_deduction/axiom} For every axiom schema \( \Phi \), we introduce the rule
    \begin{equation*}
      \begin{prooftree}
        \infer0[\logic{Ax}]{ \Phi }
      \end{prooftree}
    \end{equation*}

    Note that \( \Phi \) here is a metalogical variable that refers to a \hyperref[def:propositional_formula_schema]{formula schema}.

    For convenience, here we must break our convention of rules having unique names.

    \thmitem{thm:axiomatic_derivation_as_natural_deduction/mp} For deducing proofs, we introduce the following rule, called \term{modus ponens}:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \varphi \rightarrow \psi }
        \hypo{ \varphi }
        \infer2[\logic{MP}]{ \psi }
      \end{prooftree}
    \end{equation*}

    Note that \( \varphi \rightarrow \psi \) here refers to a concrete formula schema.
  \end{thmenum}
\end{remark}

\begin{example}\label{ex:minimal_implication_logic_identity/trees}
  Regard \hyperref[def:minimal_implication_logic]{minimal implicational logic} as a \hyperref[def:natural_deduction_system]{natural deduction system} as explained in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  The two axiom schemas --- \eqref{eq:def:minimal_implication_logic/intro} and \eqref{eq:def:minimal_implication_logic/dist} --- become inference rules.

  Then the final derivation in \fullref{ex:minimal_implication_logic_identity/derivations} can be presented as follows:
  \begin{equation}\label{eq:ex:minimal_implication_logic_identity/trees/derivation/proof}
    \begin{prooftree}[separation=3em]
      \hypo
        {
          \eqref{eq:def:minimal_implication_logic/intro}
        }

      \ellipsis
        {
          \( \begin{array}{l}
            \psi \mapsto (\varphi \synimplies \varphi)
            \\
            \mbox{}
          \end{array} \)
        }
        {
          \eqref{ex:minimal_implication_logic_identity/trees/dagger}
        }

      \hypo
        {
          \eqref{eq:def:minimal_implication_logic/trans}
        }

      \ellipsis
        {
          \( \begin{array}{l}
            \psi \mapsto (\varphi \synimplies \varphi)
            \\
            \theta \mapsto \varphi
          \end{array} \)
        }
        {
          \eqref{ex:minimal_implication_logic_identity/trees/dagger}
          \synimplies ((\varphi \synimplies (\varphi \synimplies \varphi)) \synimplies (\varphi \synimplies \varphi))
        }

      \infer2[\ref{eq:def:def:axiomatic_derivation_system/mp}]{(\varphi \synimplies (\varphi \synimplies \varphi)) \synimplies (\varphi \synimplies \varphi)}

      \hypo
        {
          \eqref{eq:def:minimal_implication_logic/intro}
        }

      \ellipsis
        {
          \( \psi \mapsto \varphi \)
        }
        {
          \varphi \synimplies (\varphi \synimplies \varphi)
        }

      \infer2[\ref{eq:def:def:axiomatic_derivation_system/mp}]{\varphi \synimplies \varphi}
    \end{prooftree}
  \end{equation}
  where
  \begin{equation}\label{ex:minimal_implication_logic_identity/trees/dagger}
    \varphi \synimplies ((\varphi \synimplies \varphi) \synimplies \varphi).
  \end{equation}
\end{example}

\begin{algorithm}[Axiomatic derivation to proof tree]\label{alg:axiomatic_derivation_to_proof_tree}
  Fix an \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} and consider the corresponding \hyperref[def:natural_deduction_system]{natural deduction system} as described in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  Fix a derivation \( \psi_1, \ldots, \psi_n \) of \( \varphi \). We will build a proof tree whose conclusion is \( \varphi \) and whose \hyperref[def:natural_deduction_open_assumptions]{open assumptions} are the premises of the derivation. We recurse on the length \( n \) of the derivation.

  \begin{thmenum}
    \thmitem{alg:axiomatic_derivation_to_proof_tree/premise} If \( \varphi \) itself is a premise, then, for a fixed marker \( u \), we declare the result of the algorithm to be the assumption tree \( [\varphi]^u \).

    \thmitem{alg:axiomatic_derivation_to_proof_tree/axiom} If \( \varphi \) is an instance of the schema \( \Phi \), we declare the result of the algorithm to be
    \begin{equation*}
      \begin{prooftree}
        \infer0[\logic{Ax}]{ \varphi }
      \end{prooftree}
    \end{equation*}

    \thmitem{alg:axiomatic_derivation_to_proof_tree/recursive} Otherwise, there must exist indices \( i \) and \( j \) such that
    \begin{equation*}
      \varphi_i = \varphi_j \synimplies \varphi_n.
    \end{equation*}

    We assume that the algorithm already correctly produces results for derivations shorter than \( n \). Denote by \( T_i \) and \( T_j \) the proof trees corresponding to \( \varphi_i \) and \( \varphi_j \).

    We declare our result of the algorithm to be the tree
    \begin{equation*}
      \begin{prooftree}
        \hypo{ T_i }
        \ellipsis {} { \varphi_j \synimplies \varphi }
        \hypo{ T_j }
        \ellipsis {} { \varphi_j }
        \infer2[\logic{MP}]{ \varphi }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{natural_deduction.axiomatic_derivation.derivation_to_proof_tree} in \cite{code}.
\end{comments}

\begin{algorithm}[Proof tree to axiomatic derivation]\label{alg:proof_tree_to_axiomatic_derivation}
  Again, fix an \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} and consider the corresponding \hyperref[def:natural_deduction_system]{natural deduction system} as described in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  Then, given a \hyperref[def:natural_deduction_proof_tree]{proof tree}, enumerating its nodes' conclusions via \hyperref[def:traversal_ordering]{pre-order traversal}, we obtain an axiomatic derivation whose premises are the open assumptions of the tree, and whose conclusion coincides with that of the tree.
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{natural_deduction.axiomatic_derivation.proof_tree_to_derivation} in \cite{code}.
\end{comments}

\begin{proposition}\label{thm:axiomatic_derivation_as_natural_deduction}
  Fix an \hyperref[def:axiomatic_derivation_system]{axiomatic derivation system} and consider the corresponding \hyperref[def:natural_deduction_system]{natural deduction system} as described in \fullref{rem:axiomatic_derivation_system_as_natural_deduction_system}.

  Then there exists an \hyperref[def:axiomatic_derivation]{axiomatic derivation} of \( \varphi \) from \( \Gamma \) if and only if there exists a \hyperref[def:natural_deduction_proof_tree]{proof tree} concluding \( \varphi \) from \( \Gamma \).
\end{proposition}
\begin{proof}
  We can use \fullref{alg:axiomatic_derivation_to_proof_tree} in one direction and \fullref{alg:proof_tree_to_axiomatic_derivation} in the other one.
\end{proof}

\paragraph{Minimal, intuitionistic and classical logic}

\begin{definition}\label{def:propositional_natural_deduction_systems}\mcite[def. 2.1.1]{TroelstraSchwichtenberg2000}
  We will now describe several \hyperref[def:propositional_natural_deduction_systems]{propositional natural deduction systems}. The base set of rules describes \hyperref[def:minimal_logic]{minimal logic}, while \hyperref[def:intuitionistic_logic]{intuitionistic} and \hyperref[def:classical_logic]{classical logic} additionally require \eqref{eq:def:propositional_natural_deduction_systems/bot/efq} and \eqref{eq:def:propositional_natural_deduction_systems/bot/dne}, respectively.

  \begin{thmenum}
    \thmitem{def:propositional_natural_deduction_systems/top}\mimprovised Rules for introducing and eliminating \hyperref[def:propositional_alphabet/constants/verum]{verum}:
    \begin{TwoColumns}
      \begin{equation*}\taglabel[\( \top^+ \)]{eq:def:propositional_natural_deduction_systems/top/intro}
        \begin{prooftree}
          \infer0[\ref{eq:def:propositional_natural_deduction_systems/top/intro}]{ \syntop }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\( \top^- \)]{eq:def:propositional_natural_deduction_systems/top/elim}
        \begin{prooftree}
          \hypo{ [\syntop] }
          \ellipsis {} { \varphi }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/top/elim}]{ \varphi }
        \end{prooftree}
      \end{equation*}
    \end{TwoColumns}

    \thmitem{def:propositional_natural_deduction_systems/bot} Rules corresponding to \eqref{eq:thm:intuitionistic_tautologies/efq} and \eqref{eq:thm:classical_tautologies/dne}:
    \begin{TwoColumns}
      \begin{equation*}\taglabel[\logic{EFQ}]{eq:def:propositional_natural_deduction_systems/bot/efq}
        \begin{prooftree}
          \hypo{ \synbot }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/bot/efq}]{ \varphi }
        \end{prooftree}
      \end{equation*}

      We add this rule to the system only when working with \hyperref[def:intuitionistic_logic]{intuitionistic object logic}.
    \BeginSecondColumn
      \begin{equation*}\taglabel[\logic{DNE}]{eq:def:propositional_natural_deduction_systems/bot/dne}
        \begin{prooftree}
          \hypo{ [\neg \varphi] }
          \ellipsis {} { \synbot }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/bot/dne}]{ \varphi }
        \end{prooftree}
      \end{equation*}

      We add this rule to the system only when working with \hyperref[def:classical_logic]{classical object logic}.
    \end{TwoColumns}

    \thmitem{def:propositional_natural_deduction_systems/negation}\mcite[46]{Mimram2020} Rules for expressing \hyperref[def:propositional_alphabet/negation]{negation} via the \hyperref[def:propositional_alphabet/constants/falsum]{falsum}:
    \begin{TwoColumns}
      \begin{equation*}\taglabel[\( \neg^+ \)]{eq:def:propositional_natural_deduction_systems/neg/intro}
        \begin{prooftree}
          \hypo{ [\varphi] }
          \ellipsis {} { \synbot }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/neg/intro}]{ \neg \varphi }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\( \neg^+ \)]{eq:def:propositional_natural_deduction_systems/neg/elim}
        \begin{prooftree}
          \hypo{ \neg \varphi }
          \hypo{ \varphi }
          \infer2[\ref{eq:def:propositional_natural_deduction_systems/neg/intro}]{ \synbot }
        \end{prooftree}
      \end{equation*}
    \end{TwoColumns}

    \thmitem{def:propositional_natural_deduction_systems/or} Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/disjunction]{disjunctions}:
    \begin{ThreeColumns}
      \begin{equation*}\taglabel[\( \vee^{+_L} \)]{eq:def:propositional_natural_deduction_systems/or/intro_left}
        \begin{prooftree}
          \hypo{ \varphi }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/or/intro_left}]{ \varphi \synvee \psi }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\( \vee^{+_R} \)]{eq:def:propositional_natural_deduction_systems/or/intro_right}
        \begin{prooftree}
          \hypo{ \psi }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/or/intro_right}]{ \varphi \synvee \psi }
        \end{prooftree}
      \end{equation*}
    \BeginThirdColumn
      \begin{equation*}\taglabel[\( \vee^- \)]{eq:def:propositional_natural_deduction_systems/or/elim}
        \begin{prooftree}
          \hypo{ \varphi \synvee \psi }
          \hypo{ [\varphi] }
          \ellipsis {} { \theta }
          \hypo{ [\psi] }
          \ellipsis {} { \theta }
          \infer3[\ref{eq:def:propositional_natural_deduction_systems/or/elim}]{ \theta }
        \end{prooftree}
      \end{equation*}
    \end{ThreeColumns}

    \thmitem{def:propositional_natural_deduction_systems/and} Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/conjunction]{conjunctions}:
    \begin{ThreeColumns}
      \begin{equation*}\taglabel[\( \wedge^+ \)]{eq:def:propositional_natural_deduction_systems/and/intro}
        \begin{prooftree}
          \hypo{ \varphi }
          \hypo{ \psi }
          \infer2[\ref{eq:def:propositional_natural_deduction_systems/and/intro}]{ \varphi \synwedge \psi }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\( \wedge^{-_L} \)]{eq:def:propositional_natural_deduction_systems/and/elim_left}
        \begin{prooftree}
          \hypo{ \varphi \synwedge \psi }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/and/elim_left}]{ \psi }
        \end{prooftree}
      \end{equation*}
    \BeginThirdColumn
      \begin{equation*}\taglabel[\( \wedge^{-_R} \)]{eq:def:propositional_natural_deduction_systems/and/elim_right}
        \begin{prooftree}
          \hypo{ \varphi \synwedge \psi }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/and/elim_right}]{ \varphi }
        \end{prooftree}
      \end{equation*}
    \end{ThreeColumns}

    \thmitem{def:propositional_natural_deduction_systems/imp} Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/conditional]{conditionals}:
    \begin{TwoColumns}
      \begin{equation*}\taglabel[\( \rightarrow^+ \)]{eq:def:propositional_natural_deduction_systems/imp/intro}
        \begin{prooftree}
          \hypo{ [\psi] }
          \ellipsis {} { \varphi }
          \infer1[\ref{eq:def:propositional_natural_deduction_systems/imp/intro}]{ \psi \synimplies \varphi }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\( \rightarrow^- \)]{eq:def:propositional_natural_deduction_systems/imp/elim}
        \begin{prooftree}
          \hypo{ \varphi \synimplies \psi }
          \hypo{ \varphi }
          \infer2[\ref{eq:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }
        \end{prooftree}
      \end{equation*}
    \end{TwoColumns}

    \thmitem{def:propositional_natural_deduction_systems/iff}\mimprovised Rules for introducing and eliminating \hyperref[def:propositional_alphabet/connectives/biconditional]{biconditionals}:
    \begin{ThreeColumns}
      \begin{equation*}\taglabel[\( \leftrightarrow^+ \)]{eq:def:propositional_natural_deduction_systems/iff/intro}
        \begin{prooftree}
          \hypo{ [\varphi] }
          \ellipsis {} { \psi }
          \hypo{ [\psi] }
          \ellipsis {} { \varphi }
          \infer2[\ref{eq:def:propositional_natural_deduction_systems/iff/intro}]{ \varphi \syniff \psi }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\( \leftrightarrow^{-_L} \)]{eq:def:propositional_natural_deduction_systems/iff/elim_left}
        \begin{prooftree}
          \hypo{ \varphi \syniff \psi }
          \hypo{ \varphi }
          \infer2[\ref{eq:def:propositional_natural_deduction_systems/iff/elim_left}]{ \psi }
        \end{prooftree}
      \end{equation*}
    \BeginThirdColumn
      \begin{equation*}\taglabel[\( \leftrightarrow^{-_R} \)]{eq:def:propositional_natural_deduction_systems/iff/elim_right}
        \begin{prooftree}
          \hypo{ \varphi \syniff \psi }
          \hypo{ \psi }
          \infer2[\ref{eq:def:propositional_natural_deduction_systems/iff/elim_right}]{ \varphi }
        \end{prooftree}
      \end{equation*}
    \end{ThreeColumns}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The system is mostly based on \cite[def. 2.1.1]{TroelstraSchwichtenberg2000}, but with additional rules for \( \syntop \), \( \synneg \) and \( \syniff \).
\end{comments}

\begin{proposition}\label{thm:minimal_implicational_logic_axioms_nd_proof}
  Every instance of the two axiom schemas --- \eqref{eq:def:minimal_implication_logic/intro} and \eqref{eq:def:minimal_implication_logic/dist} --- of \hyperref[def:minimal_implication_logic]{minimal implicational logic} is derivable in the \hyperref[def:propositional_natural_deduction_systems]{minimal natural deduction system}.
\end{proposition}
\begin{comments}
  \item Thus, we do not need to introduce additional rules in order for implicational proofs to hold in the natural deduction systems we will consider.
\end{comments}
\begin{proof}
  \SubProofOf{eq:def:minimal_implication_logic/intro}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi]^u }
      \infer1[\ref{eq:def:propositional_natural_deduction_systems/imp/intro}]{ \psi \synimplies \varphi }
      \infer[left label=\( u \)]1[\ref{eq:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies (\psi \synimplies \varphi) }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{eq:def:minimal_implication_logic/dist}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\varphi \synimplies (\psi \synimplies \theta)]^u }
      \hypo{ [\varphi]^v }
      \infer2[\ref{eq:def:propositional_natural_deduction_systems/imp/elim}]{ \psi \synimplies \theta }

      \hypo{ [\varphi \synimplies \psi]^w }
      \hypo{ [\varphi]^v }
      \infer2[\ref{eq:def:propositional_natural_deduction_systems/imp/elim}]{ \psi }

      \infer2[\ref{eq:def:propositional_natural_deduction_systems/imp/elim}]{ \theta }

      \infer[left label=\( v \)]1[\ref{eq:def:propositional_natural_deduction_systems/imp/intro}]{ \varphi \synimplies \theta }
      \infer[left label=\( w \)]1[\ref{eq:def:propositional_natural_deduction_systems/imp/intro}]{ (\varphi \synimplies \psi) \synimplies (\varphi \synimplies \theta) }
      \infer[left label=\( u \)]1[\ref{eq:def:propositional_natural_deduction_systems/imp/intro}]{ (\varphi \synimplies (\psi \synimplies \theta)) \synimplies ((\varphi \synimplies \psi) \synimplies (\varphi \synimplies \theta)) }
    \end{prooftree}
  \end{equation*}
\end{proof}
