\section{Propositional formula transformation}\label{sec:propositional_formula_transformation}

We sometimes want to substitute a propositional variable with another variable or even with a formula. This is akin to applying a \hyperref[def:boolean_function]{Boolean function} like \( x \vee y \) to different variables (e.g. \( a \vee b \)) or even concrete values (e.g. \( \sembot \vee \semtop \)), except that it is done on a purely syntactic level.

\paragraph{Simultaneous substitution}

\begin{concept}\label{con:syntactic_substitution}
  A basic operation on \hyperref[con:expression]{syntactic expressions} is the ability to replace all occurrences of a \hyperref[con:variable]{variable} with another expression so that the result is well-formed.

  Such an operation is called \term[en=substitution (\cite[78]{Kleene1971Metamathematics})]{substitution} or, if we replace multiple variables at once, \term[en=simultaneous substitution (\cite[def. 3.1.3]{CitkinMuravitsky2022ConsequenceRelations})]{simultaneous substitution}.

  We usually define an \term{atomic substitution} \( \Bbbs \) for variables and then algorithmically extend it to more complicated expressions. Based on the notation for substitutions, which we will discuss in \cref{rem:substitution_notation}, we denote this extension to \( \varphi \) by \( \varphi[\Bbbs] \).
\end{concept}
\begin{comments}
  \item Substitution is a syntactic counterpart of \hyperref[con:evaluation]{evaluation}.
\end{comments}

\begin{definition}\label{def:atomic_propositional_substitution}\mimprovised
  An \hyperref[con:syntactic_substitution]{atomic instantiation} for \hyperref[def:propositional_formula]{propositional formulas} is a map \( \Bbbs: \op*{Prop} \to \op*{Form} \), for which only finitely many variables are not \hyperref[def:function_fixed_point]{fixed points}.
\end{definition}

\begin{algorithm}[Propositional substitution]\label{alg:propositional_substitution}\mimprovised
  Given an \hyperref[def:atomic_propositional_substitution]{atomic substitution map} \( \Bbbs \), we define via \hyperref[rem:straightforward_traversal]{straightforward traversal} the following operation on arbitrary formulas:
  \begin{equation*}
    \varphi[\Bbbs] \coloneqq \begin{cases}
      \varphi,                            &\varphi \in \op*{PConst}, \\
      \Bbbs(P),                           &\varphi = p \in \op*{Prop}, \\
      \synneg \psi[\Bbbs],                &\varphi = \neg \psi, \\
      \psi[\Bbbs] \syncirc \theta[\Bbbs], &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}. \\
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item Our definition is loosely based on that in \cite[def. 3.1.3]{CitkinMuravitsky2022ConsequenceRelations}, but with a fixed set of logical operations. Furthermore, we require only finitely many variables to not be fixed; this requirement is inspired by \cite[222]{Mimram2020ProgramEqualsProof}.

  \item This substitution has the properties listed in \cref{rem:variable_binding_properties}, but since we perform no renaming, these properties are trivial.

  \item We focus on simultaneous substitutions directly instead of defining substituting a single variable. The latter is often done similarly to \cref{alg:propositional_subformula_substitution}. See \cref{rem:simulating_simultaneous_substitution} for an alternative approach.

  \item This algorithm is a special case of the analogous first-order logic algorithm \fullref{alg:fol_substitution}, implemented as \identifier{math.logic.substitution.apply_substitution_to_formula} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:substitution_symbol}
  Using \( \Bbbs \) and adjacent letters to denote an instantiation function is inspired by Hindley's \enquote{type-substitutions} defined in \cite[def. 3A1]{Hindley1997BasicSTT}. An alternative used by \incite[\S 5.4]{Mimram2020ProgramEqualsProof} and \incite[def. 3.1.3]{CitkinMuravitsky2022ConsequenceRelations} is \( \sigma \).

  We find Hindley's notation useful because:
  \begin{itemize}
    \item Plain Latin letters adjacent to \( p \), like \( s \), are used for both propositional variables and \hyperref[def:fol_signature/predicates]{first-order predicates}.
    \item Greek letters adjacent to \( \tau \), like \( \sigma \), are used for both \hyperref[def:fol_schema]{first-order terms} and for \hyperref[rem:type_theory]{types}.
  \end{itemize}
\end{remark}

\begin{remark}\label{rem:substitution_notation}
  Suppose that the substitution \( \Bbbs \) replaces the variables \( p_1, \cdots, p_n \) with the formulas \( \omega_1, \ldots, \omega_n \), and fixes all other variables. This allows us to use the notation
  \begin{equation*}
    \varphi[p_1 \mapsto \omega_1, \ldots, p_n \mapsto \omega_n]
  \end{equation*}
  without referring to \( \Bbbs \) itself.

  This syntax is formalized in \cref{def:substitution_schema}.

  A similar variation, used by \incite[def. 2.1.15]{Barendregt1984LambdaCalculus} in the context of \hyperref[def:atomic_lambda_term_substitution]{\( \muplambda \)-term substitution}, is
  \begin{equation*}
    \varphi[p_1 \coloneqq \omega_1, \ldots, p_n \coloneqq \omega_n].
  \end{equation*}

  Another popular alternative that we find less straightforward is
  \begin{equation*}
    \varphi[\omega_1 / p_1, \cdots, \omega_n / p_n].
  \end{equation*}

  It is used for logical formulas by \incite[19]{VanDalen2004LogicAndStructure} and \incite[\S 3.1.4]{Mimram2020ProgramEqualsProof} and for \( \muplambda \)-terms by \incite[def. 1A7]{Hindley1997BasicSTT}.

  Moreover, some authors like \incite[4]{TroelstraSchwichtenberg2000BasicProofTheory} exchange the variables and formulas in this notation.

  Other authors use more esoteric notations --- \incite[47]{КолмогоровДрагалин2006Логика} use
  \begin{equation*}
    \varphi(p_1, \ldots, p_n \mathrel{\Vert} \omega_1, \cdots, \omega_n),
  \end{equation*}
  while \incite[131]{Эдельман1975Логика} uses
  \begin{equation*}
    S_{b_{p_1, \ldots, p_n}}(\varphi; \omega_1, \ldots, \omega_n).
  \end{equation*}

  \incite[16]{Andrews2002Logic} instead uses the very concise notation
  \begin{equation*}
    \varphi^{p_1, \ldots, p_n}_{\omega_1, \ldots, \omega_n},
  \end{equation*}
  which \incite[def. 2.2.19]{Hinman2005Logic} writes only for a single variable as
  \begin{equation*}
    \varphi_p(\omega).
  \end{equation*}
\end{remark}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  For a \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \) and \hyperref[def:atomic_propositional_substitution]{simultaneous substitution} \( \Bbbs \), we have \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \) if and only if \( \Bracks{\Bbbs(p)}_I = I(p) \) for every variable \( p \) in \( \op*{Var}(\varphi) \).
\end{proposition}
\begin{proof}
  \SufficiencySubProof Suppose that \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I\). We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \Bracks{\Bbbs(p)}_I = I(p) \) for every variable \( p \) in \( \op*{Var}(\varphi) \).

  \begin{itemize}
    \item If \( \varphi \) is a proposition constant, it has no variables, so the statement is vacuous.
    \item If \( \varphi \) is a variable and \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \), then the statement holds since \( \varphi \) is the only variable of \( \varphi \).
    \item If \( \varphi = \synneg \psi \), where the inductive hypothesis holds for \( \psi \), then the statement automatically holds for \( \varphi \) because \( \varphi \) and \( \psi \) have the same free variables.
    \item Finally, if \( \varphi = \psi \syncirc \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), then again the statement holds for \( \varphi \) because its variables are the union of those \( \psi \) and \( \theta \).
  \end{itemize}

  \NecessitySubProof Suppose that \( \Bracks{\Bbbs(p)}_I = I(p) \) for every variable \( p \) in \( \op*{Var}(\varphi) \). We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \).

  \begin{itemize}
    \item If \( \varphi \) is a propositional constant, then \( \varphi[\Bbbs] = \varphi \), so naturally \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \).
    \item If \( \varphi \) is a variable, then \( \Bracks[\big]{\varphi[\Bbbs]}_I = I(\Bbbs(\varphi)) \), which we have assumed equals \( I(\varphi) \).
    \item If \( \varphi = \synneg \psi \), where the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Bracks[\big]{\varphi[\Bbbs]}_I
      =
      \Bracks{\synneg \psi[\Bbbs]}_I
      =
      \oline{\Bracks[\big]{\psi[\Bbbs]}_I}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi}_I}
      =
      \Bracks{\synneg \psi}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    \item Similarly, if \( \varphi = \psi \syncirc \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), then
    \begin{equation*}
      \Bracks[\big]{\varphi[\Bbbs]}_I
      =
      \Bracks[\big]{\psi[\Bbbs] \syncirc \theta[\Bbbs]}_I
      =
      \Bracks[\big]{\psi[\Bbbs]}_I \bincirc \Bracks[\big]{\theta[\Bbbs]}_I
      \reloset {\T{ind.}} =
      \Bracks{\psi}_I \bincirc \Bracks{\psi}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{definition}\label{def:substitution_schema_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} for substitution schemas consists of the following:
  \begin{thmenum}
    \thmitem{def:substitution_schema_alphabet/brackets} The brackets \enquote{\( [ \)} and \enquote{\( ] \)}.

    \thmitem{def:substitution_schema_alphabet/connective} The connective \enquote{\( \synsubst \)}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:substitution_schema}\mimprovised
  The metalinguistic syntax from \cref{rem:substitution_notation} for describing \hyperref[con:syntactic_substitution]{substitution} of finitely many variables can be formalized via the \hyperref[def:formal_grammar/schema]{grammar schema}
  \begin{bnf*}
    \bnfprod{replacement}      {\bnfpn{variable} \bnfsp \bnftsq{\( \synsubst \)} \bnfsp \bnfpn{subject}}, \\
    \bnfprod{replacement list} {\bnfpn{replacement} \bnfor \bnfpn{replacement} \bnfsp \bnftsq{,} \bnfsp \bnfpn{replacement list}}, \\
    \bnfprod{substitution}     {\bnfpn{subject} \bnfsp \bnftsq{\( [ \)} \bnfsp \bnfpn{replacement list} \bnfsp \bnftsq{\( ] \)}}.
  \end{bnf*}

  Here the rules \( \bnfpn{variable} \) and \( \bnfpn{subject} \) must be provided externally. The subjects can be \hyperref[def:propositional_formula]{propositional formulas}, \hyperref[def:lambda_term]{\( \muplambda \)-terms}, or any other syntactic construct where substitution makes sense.
\end{definition}
\begin{comments}
  \item These grammar rules give us the ability to formalize the syntax used for the \hyperref[def:inference_rule]{inference rules} in \fullref{sec:first_order_natural_deduction}.
\end{comments}

\begin{remark}\label{rem:simulating_simultaneous_substitution}
  Substitution as defined in \fullref{alg:propositional_substitution} allows us to replace more than one variable at a time:
  \begin{equation*}
    (pqr)[p \mapsto r, r \mapsto p]
    =
    rqp.
  \end{equation*}

  We can also simulate this via single-variable substitution with the aid of temporary variables:
  \begin{equation*}
    (pqr)[p \mapsto t][r \mapsto p][t \mapsto r]
    =
    (tqr)[r \mapsto p][t \mapsto r]
    =
    (tqp)[t \mapsto r]
    =
    (rqp).
  \end{equation*}
\end{remark}

\paragraph{Subformula substitution}

For propositional logic, We will also find useful the ability to replace an entire subformula with another formula. We will use this, for example, to justify the substitutions in \fullref{alg:formula_to_cnf_and_dnf}.

\begin{algorithm}[Propositional subformula substitution]\label{alg:propositional_subformula_substitution}\mcite[def. 1.3.13]{Hinman2005Logic}
  We define the \term[en=substitution]{subformula substitution} of the propositional formula \( \chi \) with \( \omega \) in \( \varphi \) as follows:
  \begin{equation}\label{eq:alg:propositional_subformula_substitution}
    \varphi[\chi \mapsto \omega] \coloneqq \begin{cases}
      \omega,                                                         &\varphi = \chi \\
      \varphi,                                                        &\varphi \neq \chi \T{and} \varphi \in \op*{Atom} \\
      \synneg \psi[\chi \mapsto \omega],                              &\varphi \neq \chi \T{and} \varphi = \synneg \psi \\
      \psi[\chi \mapsto \omega] \syncirc \theta[\chi \mapsto \omega], &\varphi \neq \chi \T{and} \varphi = \psi \syncirc \theta, \circ \in \op*{Conn}.
    \end{cases}
  \end{equation}
\end{algorithm}
\begin{comments}
  \item Note that it is not necessary for \( \chi \) to be a subformula of \( \varphi \) --- the substitution simply does nothing otherwise.
  \item It is safe to reuse the notation for simultaneous substitutions because in the case where \( \chi \) is a variable, the two notions coincide.
  \item This algorithm can be found as \identifier{math.logic.propositional.substitute_subformula} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:propositional_subformula_substitution_equivalence}
  For a \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \) and formulas \( \chi \) and \( \omega \) such that \( \Bracks{\chi}_I = \Bracks{\omega}_I \), we have \( \Bracks[\big]{\varphi[\chi \mapsto \omega]}_I = \Bracks{\varphi}_I \) for every \( \varphi \).

  In particular, if \( \chi \gleichstark \omega \), then \( \varphi[\chi \mapsto \omega] \gleichstark \varphi \).
\end{proposition}
\begin{proof}
  Suppose that \( \Bracks{\chi}_I = \Bracks{\omega}_I \). We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that
  \begin{equation}\label{eq:thm:propositional_subformula_substitution_equivalence/proof}
    \Bracks[\big]{\varphi[\chi \mapsto \omega]}_I = \Bracks{\varphi}_I.
  \end{equation}

  \begin{itemize}
    \item If \( \varphi = \chi \), then \( \varphi[\chi \mapsto \omega] = \omega \) and \eqref{eq:thm:propositional_subformula_substitution_equivalence/proof} is immediate.

    \item If \( \varphi \neq \chi \) and \( \varphi \in \op*{PConst} \cup \op*{Prop} \), then \( \varphi[\chi \mapsto \omega] = \varphi \) and \eqref{eq:thm:propositional_subformula_substitution_equivalence/proof} again holds trivially.

    \item If \( \varphi \neq \chi \) and \( \varphi = \synneg \omega \) and if the inductive hypothesis holds for \( \omega \), then
    \begin{equation*}
      \varphi[\chi \mapsto \omega] = \synneg \psi[\chi \mapsto \omega].
    \end{equation*}

    Thus,
    \begin{equation*}
      \Bracks[\big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \oline{\Bracks[\big]{\psi[\chi \mapsto \omega] }_I}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi}_I}
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    \item If \( \varphi \neq \chi \) and \( \varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn} \) and if the inductive hypothesis holds for both \( \psi \) and \( \theta \), then
    \begin{equation*}
      \Bracks[\big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \Bracks[\big]{ \psi[\chi \mapsto \omega] }_I \bincirc \Bracks[\big]{ \theta[\chi \mapsto \omega] }_I
      \reloset {\T{ind.}} =
      \Bracks[\big]{\psi}_I \bincirc \Bracks[\big]{\theta}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_subformula_substitution_equivalence/proof} holds in all cases.
\end{proof}

\paragraph{Elimination of propositional constants}

\begin{algorithm}[Propositional constant collapse]\label{alg:propositional_constant_collapse}
  We introduce an operator \( T_{\logic{cc}} \) on \hyperref[def:propositional_formula]{propositional formulas} that attempts to simplify subformulas involving logical constants. The result \( T_{\logic{cc}}(\varphi) \) will be \hyperref[def:first_order_semantics/equivalence]{semantically equivalent} with \( \varphi \).

  \begin{thmenum}
    \thmitem{alg:propositional_constant_collapse/atomic} If \( \varphi \) is atomic, i.e. a constant or variable, there is nothing we can do, so let \( T_{\logic{cc}} \coloneqq \varphi \).

    \thmitem{alg:propositional_constant_collapse/negation} If \( \varphi = \synneg \psi \), let \( \psi' \coloneqq T_{\logic{cc}}(\psi) \) and proceed as follows:
    \begin{equation*}
      T_{\logic{cc}}(\synneg \psi) \coloneqq \begin{cases}
        \synbot,       &\psi' = \syntop \\
        \syntop,       &\psi' = \synbot \\
        \synneg \psi', &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \thmitem{alg:propositional_constant_collapse/conjunction} If \( \varphi = \psi \synwedge \theta \), let \( \psi' \coloneqq T_{\logic{cc}}(\psi) \) and \( \theta' \coloneqq T_{\logic{cc}}(\theta) \) and proceed as follows:
    \begin{equation*}
      T_{\logic{cc}}(\psi \synwedge \theta) \coloneqq \begin{cases}
        \synbot,                   &\psi' = \synbot \T{or} \theta' = \synbot \\
        \theta',                   &\T{otherwise if} \psi' = \syntop \\
        \psi',                     &\T{otherwise if} \theta' = \syntop \\
        \psi' \synwedge \theta',   &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The replacement here is justified semantically since \( \semtop \) and \( \sembot \) are absorbing.

    \thmitem{alg:propositional_constant_collapse/disjunction} Dually, if \( \varphi = \psi \synvee \theta \), we proceed as follows:
    \begin{equation*}
      T_{\logic{cc}}(\psi \synvee \theta) \coloneqq \begin{cases}
        \syntop,                   &\psi' = \syntop \T{or} \theta' = \syntop \\
        \theta',                   &\T{otherwise if} \psi' = \synbot \\
        \psi',                     &\T{otherwise if} \theta' = \synbot \\
        \psi' \synvee \theta',     &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \thmitem{alg:propositional_constant_collapse/conditional} If \( \varphi = \psi \synimplies \theta \), we proceed as we would for \( \synneg \psi \synvee \theta \):
    \begin{equation*}
      T_{\logic{cc}}(\psi \synimplies \theta) \coloneqq \begin{cases}
        \syntop,                   &\psi' = \synbot \T{or} \theta' = \syntop \\
        \theta',                   &\T{otherwise if} \psi' = \syntop \\
        \synneg \psi',             &\T{otherwise if} \theta' = \synbot \\
        \psi' \synimplies \theta', &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The replacements here are justified by \cref{thm:def:heyting_algebra/leq}, \cref{thm:def:heyting_algebra/top_left} and the definition \eqref{eq:def:heyting_algebra/pseudocomplement} of pseudocomplement, respectively.

    \thmitem{alg:propositional_constant_collapse/biconditional} Finally, the case \( \varphi = \psi \syniff \theta \) is a bit different:
    \begin{equation*}
      T_{\logic{cc}}(\psi \syniff \theta) \coloneqq \begin{cases}
        \syntop,                   &\psi' = \theta' = \syntop \T{or} \psi' = \theta' = \synbot \\
        \synbot,                   &(\psi' = \syntop \T{and} \theta' = \synbot) \T{or} (\psi' = \synbot \T{and} \theta' = \syntop) \\
        \psi' \syniff \theta',     &\T{otherwise.}
      \end{cases}
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.collapse_constants_propositional} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  For a fixed interpretation, \cref{thm:propositional_subformula_substitution_equivalence} justifies replacing the subformulas of \( \varphi \) with their substitute.
\end{defproof}

\begin{remark}\label{rem:straightforward_traversal}
  When defining an operator acting on formulas, we usually handle only a few cases, and the others become straightforward. For example, replacing \( \synneg \varphi \) with \( \varphi \synimplies \synbot \), as justified by \cref{thm:intuitionistic_equivalences/negation_bottom}, can be achieved via
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        \varphi,                     &\varphi \in \op*{PConst}, \\
        \varphi,                     &\varphi \in \op*{Prop}, \\
        R(\psi) \synimplies \synbot, &\varphi = \synneg \psi, \\
        R(\psi) \syncirc R(\theta),  &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \end{cases}
    \end{aligned}
  \end{equation*}

  We can instead use the notational shorthand
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        R(\psi) \synimplies \synbot,                                             &\varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{aligned}
  \end{equation*}
\end{remark}
\begin{comments}
  \item In computer programming, this exact problem is solved via the visitor design pattern --- generic visitors for formulas of first-order logic can be found in the module \identifier{math.logic.formulas.formula_visitor} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[Propositional constant expansion]\label{alg:propositional_constant_expansion}
  While \fullref{alg:propositional_constant_collapse} aims to remove unnecessary occurrences of the propositional constants, we may want to dispose of them altogether. For this, we introduce an operator \( T_{\logic{ce}} \) on \hyperref[def:propositional_formula]{propositional formulas} that replaces propositional constants with equivalent constructs expressed via other connective.

  Denote by \( p_\varphi \) the lexicographically smallest variable in \( \varphi \), if such exists, and let \( p_\varphi \) be the default variable \( \synp \) otherwise. Define
  \begin{equation*}
    T_{\logic{ce}}(\varphi) \coloneqq \begin{cases}
      p_\varphi \synimplies p_\varphi,       &\varphi = \syntop \\
      p_\varphi \synwedge \synneg p_\varphi, &\varphi = \synbot \\
      \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item A variation suitable for \fullref{alg:formula_to_cnf_and_dnf} is to replace \( \syntop \) with \( p_\varphi \synvee \synneg p_\varphi \). This has the downside of only being sound with respect to classical semantics.

  \item This algorithm can be found as \identifier{math.logic.transformation.expand_constants_propositional} in \cite{notebook:code}.
\end{comments}
\begin{proof}
  The replacement is justified by \eqref{eq:thm:intuitionistic_tautologies/self} and \cref{thm:intuitionistic_equivalences/contradiction}.
\end{proof}

\paragraph{Propositional formula dualization}

\begin{algorithm}[Propositional repeated negation collapse]\label{alg:propositional_repeated_negation_collapse}
  We can collapse repeated negations in any \hyperref[def:propositional_formula]{propositional formula} \( \varphi \) via the operator
  \begin{equation*}
    T_{\logic{DNE}}(\varphi) = \begin{cases}
      T_{\logic{DNE}}(\psi), &\varphi = \synneg \synneg \psi, \\
      \varphi,               &\T{otherwise.}
    \end{cases}
  \end{equation*}

  For any \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \), due to \cref{thm:def:heyting_algebra/dni} we have \( \Bracks{\varphi}_I \leq \Bracks{T_{\logic{DNE}}(\varphi)}_I \). Equality holds under \hyperref[def:truth_value_algebra/classical]{classical semantics}.
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.collapse_repeated_negation} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[Propositional formula dualization]\label{alg:propositional_formula_dualization}
  Suppose we are working with \hyperref[def:truth_value_algebra/classical]{classical semantics}.

  We will introduce an operator on \hyperref[def:propositional_formula]{propositional formulas} loosely based on the recursive expression of \hyperref[def:free_boolean_algebra/polynomial]{Boolean polynomial} \hyperref[def:bounded_lattice_complement]{complements} from \cref{thm:boolean_polynomial_complement}.

  Our goal is to build a formula \( \oline{T}(\varphi) \) such that \( \Bracks{\oline{T}(\varphi)}_I = \oline{\Bracks{\varphi}_I} \) for every \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \).

  \begin{thmenum}
    \thmitem{alg:propositional_formula_dualization/const} If \( \varphi \) is a constant formula, let \( \oline{T}(\varphi) \) be the \hyperref[def:bounded_lattice/opposite]{dual constant} of \( \varphi \).

    \thmitem{alg:propositional_formula_dualization/prop} For every variable \( p \), let \( \oline{T}(p) \coloneqq \synneg p \).

    \thmitem{alg:propositional_formula_dualization/neg} If \( \varphi = \synneg \psi \), let
    \begin{equation*}
      \oline{T}(\varphi) \coloneqq T_{\logic{DNE}}(\synneg \oline{T}(\psi)),
    \end{equation*}
    where \( T_{\logic{DNE}} \) is the operator from \fullref{alg:propositional_repeated_negation_collapse}.

    \thmitem{alg:propositional_formula_dualization/conn} Finally, if \( \varphi = \psi \syncirc \theta \), let
    \begin{equation*}
      \oline{T}(\varphi) \coloneqq \begin{cases}
        \oline{T}(\psi) \synvee \oline{T}(\theta),                                          &{\syncirc} = {\synwedge}, \\
        \oline{T}(\psi) \synwedge \oline{T}(\theta),                                        &{\syncirc} = {\synvee}, \\
        \synneg \parens[\big]{ T_{\logic{DNE}}(\psi) \synimplies T_{\logic{DNE}}(\theta) }, &{\syncirc} = {\synimplies}, \\
        \synneg \parens[\big]{ T_{\logic{DNE}}(\psi) \syniff T_{\logic{DNE}}(\theta) },     &{\syncirc} = {\syniff}. \\
      \end{cases}
    \end{equation*}

    The first two cases are justified by De Morgan's laws from \cref{thm:classical_equivalences/de_morgan}, while the other cases simply negate \( \varphi \) because we lack the necessary dual connectives.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.dualize_formula_propositional} in \cite{notebook:code}.

  \item The other Boolean polynomial operations from \cref{def:opposite_boolean_polynomial} also give rise to transformations of propositional formulas. For example, \incite{Gottschalk1953Quaternality} discusses contradual and dual formulas. \incite[114]{Church1956LogicVol1} and \incite[192]{Andrews2002Logic} call the latter formulas \enquote{principal dual}.

  The aforementioned authors add additional dual connectives --- \( \nleftarrow \) for \( \rightarrow \) (which also requires adding \( \leftarrow \) and \( \nrightarrow \)), and also \( \nleftrightarrow \) for \( \leftrightarrow \). In our algorithm we emulate these connectives.

  \item It seems simpler to define \( \oline{T}(\synneg \psi) \) as \( \psi \) rather than \( \synneg \oline{T}(\psi) \) (module double negation elimination). Unfortunately, this would require handling recursive cases separately.

  \item As stated, the algorithm satisfies some useful properties like \cref{thm:alg:propositional_formula_dualization} and \cref{thm:full_cnf_and_dnf_uniqueness}.
\end{comments}

\begin{proposition}\label{thm:alg:propositional_formula_dualization}
  \Fullref{alg:propositional_formula_dualization} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:alg:propositional_formula_dualization/no_double_negation} The result of the algorithm contains no double negations.

    \thmitem{thm:alg:propositional_formula_dualization/double_dual} If \( \varphi \) does not contain double negations, then \( \varphi \) coincides with its double opposite \( \oline{T}(\oline{T}(\varphi)) \).
   \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:alg:propositional_formula_dualization/no_double_negation} We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( T(\varphi) \) contains no double negations.

  \begin{itemize}
    \item If \( \varphi \) is atomic, there is nothing to prove.
    \item If \( \varphi = \synneg \psi \), then \( \oline{T}(\varphi) \coloneqq T_{\logic{DNE}}(\synneg \oline{T}(\psi)) \). We explicitly remove double negations here.

    \item If \( \varphi = \psi \synwedge \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), we have
    \begin{equation*}
      \oline{T}(\varphi) = \oline{T}(\psi) \synvee \oline{T}(\theta).
    \end{equation*}

    No additional negations are introduced in \( \oline{T}(\varphi) \) compared to \( \oline{T}(\psi) \) or \( \oline{T}(\theta) \), so the inductive hypothesis implies that \( \oline{T}(\varphi) \) does not contain double negation.

    \item If \( \varphi = \psi \synvee \theta \), the result follows by duality.
    \item If \( \varphi = \psi \synimplies \theta \), then
    \begin{equation*}
      \oline{T}(\varphi) = \synneg \parens[\big]{ T_{\logic{DNE}}(\psi) \synimplies T_{\logic{DNE}}(\theta) }.
    \end{equation*}

    We explicitly remove double negations from \( \psi \) and \( \theta \), so \( \oline{T}(\varphi) \) also contains none.

    \item If \( \varphi = \psi \syniff \theta \), we proceed analogously.
  \end{itemize}

  \SubProofOf{thm:alg:propositional_formula_dualization/double_dual} Suppose that \( \varphi \) contains no double negations. We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \oline{T}(\oline{T}(\varphi)) \).

  \begin{itemize}
    \item If \( \varphi \) is a constant, then \( \oline{T}(\varphi) \) is by definition the dual constant, and \( \oline{T}(\oline{T}(\varphi)) \) thus coincides with \( \varphi \).

    \item If \( \varphi \) is a propositional variable, say \( p \), then \( \oline{T}(p) = \synneg p \)
    \begin{equation*}
      \oline{T}(\oline{T}(p)) = \oline{T}(\synneg p) = p.
    \end{equation*}

    \item If \( \varphi = \synneg \psi \), where the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \oline{T}(\varphi)
      =
      \oline{T}(\synneg \psi)
      =
      T_{\logic{DNE}}(\synneg \oline{T}(\psi)).
    \end{equation*}

    We have two possibilities:
    \begin{itemize}
      \item If \( \oline{T}(\psi) \) is a negation, then \( \oline{T}(\psi) = \synneg \psi = \varphi \).

      Indeed, we have the following possibilities:
      \begin{itemize}
        \item If \( \psi \) is a variable, say \( p \), then \( \oline{T}(p) = \synneg p \).

        \item If \( \psi = \theta \synimplies \chi \), then
        \begin{equation*}
          \oline{T}(\psi)
          =
          \oline{T}(\theta \synimplies \chi)
          =
          \synneg (T_{\logic{DNE}}(\theta) \synimplies T_{\logic{DNE}}(\chi))
          =
          \synneg (\theta \synimplies \chi)
          =
          \synneg \psi
        \end{equation*}
        because we have assumed that \( \varphi \), and hence all its subformulas, have no double negations.

        \item If \( \psi = \theta \syniff \chi \), we proceed similarly.
      \end{itemize}

      In all three cases,
      \begin{equation*}
        \oline{T}(\varphi)
        =
        \oline{T}(\synneg \psi)
        =
        T_{\logic{DNE}}(\synneg \oline{T}(\psi))
        =
        T_{\logic{DNE}}(\synneg \synneg \psi)
        =
        \psi,
      \end{equation*}
      thus
      \begin{equation*}
        \oline{T}(\oline{T}(\varphi)) = \oline{T}(\psi) = \synneg \psi = \varphi.
      \end{equation*}

      \item Otherwise, \( \oline{T}(\psi) \) is not a negation, thus
      \begin{equation*}
        \oline{T}(\varphi) = T_{\logic{DNE}}(\synneg \oline{T}(\psi) = \synneg \oline{T}(\psi)
      \end{equation*}
      and
      \begin{equation*}
        \oline{T}(\oline{T}(\varphi))
        =
        T_{\logic{DNE}}(\synneg \oline{T}(\oline{T}(\psi)))
        \reloset {\T{ind.}} =
        T_{\logic{DNE}}(\synneg \psi)
        =
        T_{\logic{DNE}}(\varphi)
        =
        \varphi.
      \end{equation*}
    \end{itemize}

    \item If \( \varphi = \psi \synwedge \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), then
    \begin{equation*}
      \oline{T}(\oline{T}(\varphi))
      =
      \oline{T}(\oline{T}(\psi) \synvee \oline{T}(\theta))
      =
      \oline{T}(\oline{T}(\psi)) \synwedge \oline{T}(\oline{T}(\theta))
      \reloset {\T{ind.}} =
      \psi \synwedge \theta
      =
      \varphi,
    \end{equation*}
    as desired.

    \item If \( \varphi = \psi \synvee \theta \), the result follows by duality.

    \item If \( \varphi = \psi \synimplies \theta \), then
    \begin{equation*}
      \oline{T}(\oline{T}(\varphi))
      =
      \oline{T}(T_{\logic{DNE}}(\psi) \synimplies T_{\logic{DNE}}(\theta))
      =
      \oline{T}(\psi \synimplies \theta)
      =
      \varphi,
    \end{equation*}
    where we have used that \( \varphi \), and hence all its subformulas, contain no double negations.

    \item Finally, if \( \varphi = \psi \syniff \theta \), we proceed similarly.
  \end{itemize}
\end{proof}

\paragraph{Conjunctive and disjunctive normal forms}

\begin{definition}\label{def:propositional_cnf_and_dnf}\mimprovised
  We will now introduce \term[ru=конъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975Логика}), en=conjunctive normal form (\cite[def. 1.3.10]{Hinman2005Logic})]{conjunctive normal forms} (CNF) and \term[ru=дизъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975Логика}), en=disjunctive normal form (\cite[def. 1.3.10]{Hinman2005Logic})]{disjunctive normal forms} (DNF) for propositional formulas.

  The structure of these formulas is best described by the following extension of the \hyperref[def:propositional_formula]{propositional formula grammar schema}:
  \begin{longbnf*}
    \bnfprod{positive literal}       {\bnfpn{propositional variable}} \\
    \bnfprod{negative literal}       {\bnftsq{\( \synneg \)} \bnfsp \bnfpn{propositional variable}} \\
    \bnfprod{literal}                {\bnfpn{positive literal} \bnfor \bnfpn{negative literal}} \\
    \bnfprod{elementary disjunction} {\bnfpn{constant formula} \bnfor \bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{CNF}                    {\bnfpn{elem. disjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{CNF}              \bnfsp \bnftsq{\( \synwedge \)} \bnfsp \bnfpn{CNF}             \bnfsp \bnftsq{)}} \\
    \bnfprod{elementary disjunction} {\bnfpn{constant formula} \bnfor \bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{DNF}                    {\bnfpn{elem. conjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{DNF}              \bnfsp \bnftsq{\( \synvee \)}   \bnfsp \bnfpn{DNF}             \bnfsp \bnftsq{)}}
  \end{longbnf*}
\end{definition}
\begin{comments}
  \item We can use \cref{alg:propositional_constant_collapse} to remove unnecessary propositional constants in formulas like \( \synp \wedge \syntop \).

  We can expand \( \synbot \) to \( \synp \wedge \synneg \synp \) (in accordance with \fullref{alg:propositional_constant_expansion}) and, dually, we can expand \( \syntop \) to \( \synp \vee \synneg \synp \).

  \item The terms \enquote{literal}, \enquote{positive literal} and \enquote{negative literal} are used in \cite[def. 12.2.1]{Rosen2019DiscreteMathematics}, \cite[103]{DaveyPriestley2002LatticeTheory}, \cite[77]{Mimram2020ProgramEqualsProof} and \cite[132]{Savage2008ModelsOfComputation}. The adjective \enquote{elementary} for conjunctions and disjunctions is based on \cite[36]{Эдельман1975Логика}.

  \item Via \fullref{alg:propositional_formula_to_boolean_term}, this becomes a particular syntax for \hyperref[def:free_boolean_algebra/polynomial]{Boolean polynomials}.

  \item As usual, we utilize the convention in \cref{rem:propositional_formula_notation_conventions} and avoid excessive parentheses.
\end{comments}

\begin{proposition}\label{thm:propositional_cnf_and_dnf_dualization}
  Suppose that the \hyperref[def:propositional_formula]{propositional formula} \( \varphi \) has no double negations. Consider its opposite \( \oline{T}(\varphi) \) obtained via \fullref{alg:propositional_formula_dualization}.

  \begin{thmenum}
    \thmitem{thm:propositional_cnf_and_dnf_dualization/cnf} The formula \( \varphi \) is in \hyperref[def:propositional_cnf_and_dnf]{conjunctive normal form} if and only if \( \oline{T}(\varphi) \) is in disjunctive normal form.

    \thmitem{thm:propositional_cnf_and_dnf_dualization/dnf} Conversely, \( \varphi \) is in disjunctive normal form if and only if \( \oline{T}(\varphi) \) is in conjunctive normal form.
  \end{thmenum}
\end{proposition}
\begin{proof}
  We will only show \cref{thm:propositional_cnf_and_dnf_dualization/cnf} because \cref{thm:propositional_cnf_and_dnf_dualization/dnf} follows by \fullref{thm:lattice_duality} (via \fullref{alg:propositional_formula_to_boolean_term}).

  \SufficiencySubProof Suppose that \( \varphi \) is in CNF.

  We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \oline{T}(\varphi) \) is in DNF:
  \begin{itemize}
    \item If \( \varphi \) is atomic, it is either a variable (i.e. a positive literal) or a constant, so it is in both CNF and DNF.

    Then \( \oline{T}(\varphi) \) is either a negative literal or a constant; hence it is also both in CNF and DNF.

    \item If \( \varphi = \synneg \psi \), then \( \psi \) must be a propositional variable. In this case \( \oline{T}(\varphi) = \psi \), which is again both in CNF and DNF.

    \item If \( \varphi = \psi \synvee \theta \), then \( \psi \) and \( \theta \) are elementary disjuncts.

    Then \( \oline{T}(\psi) \) and \( \oline{T}(\theta) \) are elementary conjuncts, and thus so is their conjunction.

    \item If \( \varphi = \psi \synwedge \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), we have
    \begin{equation*}
      \oline{T}(\varphi) = \oline{T}(\psi) \synvee \oline{T}(\theta).
    \end{equation*}

    Since \( \varphi \) is in CNF, so are \( \psi \) and \( \theta \). By the inductive hypothesis, \( \oline{T}(\psi) \) and \( \oline{T}(\theta) \) are in DNF; then so is their disjunction \( \oline{T}(\varphi) \).
  \end{itemize}

  \NecessitySubProof Let \( \varphi \) be a formula without double negation and suppose that \( \oline{T}(\varphi) \) is in DNF.

  Sufficiency in \cref{thm:propositional_cnf_and_dnf_dualization/dnf} implies that \( \oline{T}(\oline{T}(\varphi)) \) is in CNF. Moreover, since we have assumed that \( \varphi \) contains no double negations, \cref{thm:alg:propositional_formula_dualization/double_dual} implies that \( \oline{T}(\oline{T}(\varphi)) = \varphi \).

  Therefore, \( \varphi \) is in CNF.
\end{proof}

\begin{algorithm}[Propositional formula to CNF or DNF]\label{alg:propositional_formula_to_cnf_or_dnf}
  Again, suppose we are working with \hyperref[def:truth_value_algebra/classical]{classical semantics}.

  We will define two complementary operators on \hyperref[def:propositional_formula]{propositional formulas}, \( T_{\wedge}(\varphi) \) and \( T_{\vee}(\varphi) \), that convert \( \varphi \) to \hyperref[def:propositional_cnf_and_dnf]{conjunctive and disjunctive normal form}, respectively.

  Denote by \( \syncirc \) the outer connective (\( \synwedge \) for CNF and \( \synvee \) for DNF) and by \( \syncirc^{\oppos} \) its dual, the inner connective.

  \begin{thmenum}
    \thmitem{alg:formula_to_cnf_and_dnf/atomic} If \( \varphi \) is atomic, it is either a constant or a positive literal, and thus it is already in both conjunctive and disjunctive normal form.

    In this case, let \( T_{\anon}(\varphi) \coloneqq \varphi \) for both \( {\anon} = \wedge \) and \( {\anon} = \vee \).

    \thmitem{alg:formula_to_cnf_and_dnf/negation} If \( \varphi = \synneg \psi \), let
    \begin{align*}
      T_\wedge(\varphi) \coloneqq \oline{T}(T_\vee(\psi))
      &&
      \T{and}
      &&
      T_\vee(\varphi) \coloneqq \oline{T}(T_\wedge(\psi)),
    \end{align*}
    where \( \oline{T} \) is the dualization operator from \fullref{thm:alg:propositional_formula_dualization}.

    These cases are justified by \cref{thm:propositional_cnf_and_dnf_dualization}.

    \thmitem{alg:formula_to_cnf_and_dnf/conditional} If \( \varphi = \psi \synimplies \theta \), let
    \begin{equation*}
      T_{\anon}(\varphi) \coloneqq T_{\anon}(\synneg \psi \synvee \theta).
    \end{equation*}

    \thmitem{alg:formula_to_cnf_and_dnf/biconditional} If \( \varphi = \psi \syniff \theta \), let
    \begin{align*}
      T_\wedge(\varphi) &\coloneqq T_\wedge\parens[\big]{ (\synneg \psi \synvee \theta) \synwedge (\psi \synvee \synneg \theta) }, \\
      T_\vee(\varphi)   &\coloneqq T_\vee\parens[\big]{ (\psi \synvee \theta) \synwedge (\synneg \psi \synvee \synneg \theta) }.
    \end{align*}

    \thmitem{alg:formula_to_cnf_and_dnf/outer} If \( \varphi = \psi \syncirc \theta \), let
    \begin{equation*}
      T_{\syncirc}(\varphi) \coloneqq T_{\syncirc}(\psi) \syncirc T_{\syncirc}(\theta).
    \end{equation*}

    \thmitem{alg:formula_to_cnf_and_dnf/inner} If \( \varphi = \psi \syncirc^{\oppos} \theta \), define \( \psi' \coloneqq T_{\syncirc}(\psi) \) and \( \theta' \coloneqq T_{\syncirc}(\theta) \) and let
    \begin{equation*}
      T_{\syncirc}(\varphi) \coloneqq \begin{cases}
        T_{\syncirc}(\chi \syncirc^{\oppos} \psi) \syncirc T_{\syncirc}(\omega \syncirc^{\oppos} \psi),   &\psi' = \chi \syncirc \omega, \\
        T_{\syncirc}(\psi' \syncirc^{\oppos} \chi) \syncirc T_{\syncirc}(\psi' \syncirc^{\oppos} \omega), &\T{otherwise if} \theta' = \chi \syncirc \omega, \\
        \psi' \syncirc \theta',                                                                           &\T{otherwise.}
      \end{cases}
    \end{equation*}

    These cases are justified by \cref{thm:classical_equivalences/distributivity}.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.formula_to_cnf_or_dnf} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:full_propositional_cnf_and_dnf}\mimprovised
  Fix a \hyperref[def:propositional_formula]{propositional formula} \( \varphi \) and let \( p_1, \ldots, p_n \) be the lexicographic enumeration of its variables as per \cref{def:variable_identifier}.

  We say that \( \varphi \) is in \term[ru=совершенная дизъюнктная нормальная форма (\cite[def. 6.3; def. 6.4]{Эдельман1975Логика}), en=full disjunctive normal form (\cite[103]{DaveyPriestley2002LatticeTheory}); strict disjunctive normal form (\cite[def. 1.3.10]{Hinman2005Logic})]{full disjunctive normal form} (resp. \term{full conjunctive normal form}) if it is in \hyperref[def:propositional_cnf_and_dnf]{DNF} (resp. \hyperref[def:propositional_cnf_and_dnf]{CNF}) and the following additional conditions hold:
  \begin{thmenum}
    \thmitem{def:full_propositional_cnf_and_dnf/constants} If \( n = 0 \), then \( \varphi \) is a propositional constant.

    Otherwise, either \( \varphi = \sembot \) (resp. \( \varphi = \semtop \)) or otherwise \( \varphi \) contains no constants.

    \thmitem{def:full_propositional_cnf_and_dnf/literals} Every elementary disjunction (resp. conjunction) has the form
    \begin{equation*}
      L_1 \synvee L_2 \synvee \cdots \synvee L_n,
    \end{equation*}
    where \( L_k \) is either \( p_k \) or \( \synneg p_k \) for \( k = 1, \ldots, n \).

    \thmitem{def:full_propositional_cnf_and_dnf/ordering} The elementary disjunctions (resp. conjunctions) are ordered \hyperref[def:lexicographic_order]{lexicographically} so that \( p_k < \neg p_k \) for every variable \( p_k \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is based on \cite[def. 6.3; def. 6.4]{Эдельман1975Логика}, but with adjustments made in order to improve rigor.
\end{comments}

\begin{example}\label{ex:def:propositional_cnf_and_dnf}
  We list examples of formulas in \hyperref[def:propositional_cnf_and_dnf]{conjunctive and disjunctive normal forms}:
  \begin{thmenum}
    \thmitem{def:propositional_cnf_and_dnf/perfect_cnf} The Boolean equivalence \eqref{eq:thm:classical_equivalences/conditional_as_disjunction} allows us to represent convert the \hyperref[def:propositional_alphabet/connectives/conditional]{conditional} \( \varphi \synimplies \psi \) to \( \synneg \varphi \synvee \psi \), which is both in CNF and in DNF.

    It is an elementary disjunction, hence it is vacuously in perfect CNF.

    The DNF is not perfect, however, because the condition \cref{def:full_propositional_cnf_and_dnf/literals} is not satisfied.

    \thmitem{def:propositional_cnf_and_dnf/perfect_dnf} Consider instead the formula
    \begin{equation*}
      (\varphi \synwedge \psi) \synvee (\synneg \varphi \synwedge \psi) \synvee (\synneg \varphi \synwedge \synneg \psi)
    \end{equation*}

    It is in perfect DNF, and it is equivalent to \( \varphi \synimplies \psi \).
  \end{thmenum}
\end{example}

\begin{algorithm}[Boolean function to perfect DNF]\label{alg:function_to_dnf}\mcite[thm. I.1.3]{Яблонский2003ДискретнаяМатематика}
  Fix a \hyperref[def:boolean_function]{Boolean function} \( f(x_1, \ldots, x_n) \).

  We will build a formula \( \varphi_f \) in \hyperref[def:full_propositional_cnf_and_dnf]{perfect} \hyperref[def:propositional_cnf_and_dnf]{disjunctive normal form} whose \hyperref[def:parametrized_propositional_denotation]{parametrized denotation} under \hyperref[def:truth_value_algebra/classical]{classical semantics} coincides with \( f \).

  If we wish to obtain a perfect conjunctive normal form instead, we can take the opposite \( \oline{T}(\varphi_f) \) obtained via \fullref{alg:propositional_formula_dualization}.

  Fix some propositional variables \( p_1, \ldots, p_n \). It will follow from the proof of correctness that, for fixed variables, \( \varphi_f \) is unique.

  \begin{thmenum}
    \thmitem{alg:function_to_dnf/false} If \( f \) is canonically false, let \( \varphi_f \coloneqq \synbot \).

    \thmitem{alg:function_to_dnf/true} If \( n = 0 \) and \( f = \semtop \), let \( \varphi_f \coloneqq \syntop \).

    \thmitem{alg:function_to_dnf/elementary} Given a tuple \( x_1, \ldots, x_n \) of Boolean values, we can construct the elementary conjunction
    \begin{equation}\label{alg:function_to_dnf/cnf}
      p_1^{x_1} \synwedge \cdots \synwedge p_n^{x_n},
    \end{equation}
    where
    \begin{equation*}
      p_k^{x_k} \coloneqq \begin{cases}
        p_k,      &x_k = \semtop, \\
        \neg p_k, &x_k = \sembot.
      \end{cases}
    \end{equation*}

    \thmitem{alg:function_to_dnf/total} Finally, let \( \varphi_f \) be the disjunction of those elementary conjunctions for which
    \begin{equation*}
      f(x_1, \ldots, x_n) = \semtop,
    \end{equation*}
    ordered as per \cref{def:full_propositional_cnf_and_dnf/ordering}.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.conjunctive.function_to_cnf} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  We will use induction on \( n \) to show that
  \begin{equation*}
    \Bracks{\varphi_f}(x_1, \ldots, x_n) = f(x_1, \ldots, x_n)
  \end{equation*}
  and that \( \varphi_f \) is unique with this property.

  \begin{itemize}
    \item The case \( n = 0 \) must be handled separately.
    \begin{itemize}
      \item If \( f = \semtop \), then \( \varphi_f = \syntop \) by \cref{alg:function_to_dnf/true}.
      \item If \( f = \sembot \), then \( \varphi_f = \synbot \) by \cref{alg:function_to_dnf/false}.
    \end{itemize}

    Uniqueness is obvious.

    \item Let \( n = 1 \).
    \begin{itemize}
      \item If \( f(x) = \sembot \), then \( \varphi_f = \synbot \), again by \cref{alg:function_to_dnf/false}.

      \item If \( f(x) = \semtop \), then \cref{alg:function_to_dnf/elementary} provides us with the elementary disjunctions \( p_1^\semtop = p_1 \) and \( p_1^\sembot = \synneg p_1 \) and \cref{alg:function_to_dnf/total} gives us \( \varphi_f = p_1 \synwedge \synneg p_1 \).

      \item If \( f(x) = x \), then we only consider the elementary conjunction \( p_1^\semtop = p_1 \), which leads us to \( \varphi_f = p_1 \).

      \item If \( f(x) = \oline{x} \), then \( \varphi_f = \synneg p_1 \).
    \end{itemize}

    Therefore, if \( f \) is a unary function, the formula \( \varphi_f \) constructed via this algorithm satisfies \( \Bracks{\varphi_f}(x) = f(x) \).

    Again, uniqueness is obvious.

    \item Let \( n > 0 \), suppose that the inductive hypothesis holds for \( n - 1 \) and consider some function \( f(x_1, \ldots, x_n) \).

    Let \( \varphi_{\sembot} \) be the formula obtained for \( f(x_1, \ldots, x_{n-1}, \sembot) \) and let \( \varphi_{\sembot'} \) be the formula obtained from \( \varphi_{\sembot} \) by appending the negative literal \( \synneg p_n \) to each elementary conjunction.

    Let \( \varphi_{\semtop} \) be the formula for \( f(x_1, \ldots, x_{n-1}, \semtop) \) and let \( \varphi_{\semtop'} \) be the formula obtained by appending the literal \( p_n \) to each elementary conjunction. Then
    \begin{align*}
      \Bracks{\varphi_{\semtop'}}(x_1, \ldots, x_{n-1}, \semtop) &= \Bracks{\varphi_{\semtop}}(x_1, \ldots, x_{n-1}) \wedge \semtop = \Bracks{\varphi_{\semtop}}(x_1, \ldots, x_{n-1}), \\
      \Bracks{\varphi_{\semtop'}}(x_1, \ldots, x_{n-1}, \sembot) &= \Bracks{\varphi_{\semtop}}(x_1, \ldots, x_{n-1}) \wedge \sembot = \sembot.
    \end{align*}

    Dually, let \( \varphi_{\sembot} \) be the formula obtained for \( f(x_1, \ldots, x_{n-1}, \sembot) \) and let \( \varphi_{\sembot'} \) be the formula obtained from \( \varphi_{\sembot} \) by appending the negative literal \( \synneg p_n \) to each elementary conjunction. Similarly,
    \begin{align*}
      \Bracks{\varphi_{\sembot'}}(x_1, \ldots, x_{n-1}, \semtop) &= \Bracks{\varphi_{\sembot}}(x_1, \ldots, x_{n-1}) \wedge \sembot = \sembot, \\
      \Bracks{\varphi_{\sembot'}}(x_1, \ldots, x_{n-1}, \sembot) &= \Bracks{\varphi_{\sembot}}(x_1, \ldots, x_{n-1}) \wedge \semtop = \Bracks{\varphi_{\sembot}}(x_1, \ldots, x_{n-1}).
    \end{align*}

    Let \( \varphi_f \coloneqq \varphi_{\semtop'} \synvee \varphi_{\sembot'} \). Then
    \begin{equation*}
      \Bracks{\varphi}(x_1, \ldots, x_{n-1}, x_n)
      =
      \begin{cases}
        \overbrace{\Bracks{\varphi_{\semtop'}}(x_1, \ldots, x_{n-1}, \semtop)}^{\Bracks{\varphi_{\semtop}}(x_1, \ldots, x_{n-1})} \vee \overbrace{\Bracks{\varphi_{\sembot'}}(x_1, \ldots, x_{n-1}, \sembot)}^{\semtop},   &x_n = \semtop \\
        \underbrace{\Bracks{\varphi_{\semtop'}}(x_1, \ldots, x_{n-1}, \sembot)}_{\sembot} \vee \underbrace{\Bracks{\varphi_{\sembot'}}(x_1, \ldots, x_{n-1}, \semtop)}_{\Bracks{\varphi_{\sembot}}(x_1, \ldots, x_{n-1})}, &x_n = \sembot,
      \end{cases}
    \end{equation*}
    as desired.

    Uniqueness follows readily from the inductive hypothesis.
  \end{itemize}
\end{defproof}

\begin{proposition}\label{thm:full_cnf_and_dnf_uniqueness}
  Every \hyperref[def:propositional_formula]{propositional formula} is \hyperref[def:semantic_equivalence]{semantically equivalent} to a unique formula in \hyperref[def:full_propositional_cnf_and_dnf]{perfect disjunctive normal form} (resp. perfect conjunctive normal form).
\end{proposition}
\begin{proof}
  Follows from the uniqueness of \fullref{alg:function_to_dnf} applied to the \hyperref[def:parametrized_propositional_denotation]{parametrized denotation} of the formula.
\end{proof}
