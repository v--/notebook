\section{Propositional formula transformation}\label{sec:propositional_formula_transformation}

We sometimes want to substitute a propositional variable with another variable or even with a formula. This is akin to applying a \hyperref[def:boolean_function]{Boolean function} like \( x \vee y \) to different variables (e.g. to obtain \( x \vee x \)) or even concrete values (e.g. \( \sembot \vee \semtop \)), except that it is done on a purely syntactic level without involving any semantics involved.

\paragraph{Simultaneous substitution}

\begin{concept}\label{con:syntactic_substitution}
  A basic operation on \hyperref[con:expression]{syntactic expressions} is the ability to replace all occurrences of a \hyperref[con:variable]{variable} with another expression so that the result is well-formed.

  Such an operation is called \term[en=substitution (\cite[78]{Kleene1971Metamathematics})]{substitution} or, if we replace multiple variables at once, \term[en=simultaneous substitution (\cite[def. 3.1.3]{CitkinMuravitsky2022ConsequenceRelations})]{simultaneous substitution}.

  Substitution is a syntactic counterpart of \hyperref[con:evaluation]{evaluation}.
\end{concept}

\begin{definition}\label{def:atomic_propositional_substitution}\mimprovised
  For \hyperref[con:syntactic_substitution]{simultaneous substitution} of \hyperref[def:propositional_formula]{propositional formulas}, we will need a map \( \Bbbs: \op*{Prop} \to \op*{Form} \), called an \term{atomic substitution}, for which only finitely many variables are not \hyperref[def:function_fixed_point]{fixed points}.
\end{definition}

\begin{algorithm}[Propositional substitution]\label{alg:propositional_substitution}\mimprovised
  Given an \hyperref[def:atomic_propositional_substitution]{atomic substitution map} \( \Bbbs \), we define via \hyperref[rem:straightforward_traversal]{straightforward traversal} the following operation on arbitrary formulas:
  \begin{equation*}
    \varphi[\Bbbs] \coloneqq \begin{cases}
      \varphi,                            &\varphi \in \op*{PConst}, \\
      \Bbbs(\varphi),                     &\varphi \in \op*{Prop}, \\
      \synneg \psi[\Bbbs],                &\varphi = \neg \psi, \\
      \psi[\Bbbs] \syncirc \theta[\Bbbs], &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}. \\
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item Our definition is loosely based on that in \cite[def. 3.1.3]{CitkinMuravitsky2022ConsequenceRelations}, but with a fixed set of logical operations. Furthermore, we require only finitely many variables to not be fixed; this requirement is inspired by \cite[222]{Mimram2020ProgramEqualsProof}.

  \item We focus on simultaneous substitutions directly instead of defining substituting a single variable. The latter is often done similarly to \cref{alg:propositional_subformula_substitution}. See \cref{rem:simulating_simultaneous_substitution} for an alternative approach.

  \item This algorithm is a special case of the analogous first-order logic algorithm \fullref{alg:fol_substitution}, implemented as \identifier{math.logic.substitution.apply_substitution_to_formula} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:substitution_symbol}
  Using \( \Bbbs \) and adjacent letters to denote an instantiation function is inspired by Hindley's \enquote{type-substitutions} defined in \cite[def. 3A1]{Hindley1997BasicSTT}. An alternative used by \incite[\S 5.4]{Mimram2020ProgramEqualsProof} and \incite[def. 3.1.3]{CitkinMuravitsky2022ConsequenceRelations} is \( \sigma \).

  We find Hindley's notation useful because:
  \begin{itemize}
    \item Plain Latin letters adjacent to \( p \), like \( s \), are used for both propositional variables and \hyperref[def:fol_signature/predicates]{first-order predicates}.
    \item Greek letters adjacent to \( \tau \), like \( \sigma \), are used for both \hyperref[def:fol_schema]{first-order terms} and for \hyperref[rem:type_theory]{types}.
  \end{itemize}
\end{remark}

\begin{remark}\label{rem:substitution_notation}
  Suppose that the substitution \( \Bbbs \) replaces the variables \( p_1, \cdots, p_n \) with the formulas \( \omega_1, \ldots, \omega_n \), and fixes all other variables. This allows us to use the notation
  \begin{equation*}
    \varphi[p_1 \mapsto \omega_1, \ldots, p_n \mapsto \omega_n]
  \end{equation*}
  without referring to \( \Bbbs \) itself.

  This syntax is formalized in \cref{def:substitution_schema}.

  A similar variation, used by \incite[def. 2.1.15]{Barendregt1984LambdaCalculus} in the context of \hyperref[def:atomic_lambda_term_substitution]{\( \muplambda \)-term substitution}, is
  \begin{equation*}
    \varphi[p_1 \coloneqq \omega_1, \ldots, p_n \coloneqq \omega_n].
  \end{equation*}

  Another popular alternative that we find less straightforward is
  \begin{equation*}
    \varphi[\omega_1 / p_1, \cdots, \omega_n / p_n].
  \end{equation*}

  It is used for logical formulas by \incite[19]{VanDalen2004LogicAndStructure} and \incite[\S 3.1.4]{Mimram2020ProgramEqualsProof} and for \( \muplambda \)-terms by \incite[def. 1A7]{Hindley1997BasicSTT}.

  Moreover, some authors like \incite[4]{TroelstraSchwichtenberg2000BasicProofTheory} exchange the variables and formulas in this notation.

  Other authors use more esoteric notations --- \incite[47]{КолмогоровДрагалин2006Логика} use
  \begin{equation*}
    \varphi(p_1, \ldots, p_n \mathrel{\Vert} \omega_1, \cdots, \omega_n),
  \end{equation*}
  while \incite[131]{Эдельман1975Логика} uses
  \begin{equation*}
    S_{b_{p_1, \ldots, p_n}}(\varphi; \omega_1, \ldots, \omega_n).
  \end{equation*}

  \incite[16]{Andrews2002Logic} instead uses the very concise notation
  \begin{equation*}
    \varphi^{p_1, \ldots, p_n}_{\omega_1, \ldots, \omega_n},
  \end{equation*}
  which \incite[def. 2.2.19]{Hinman2005Logic} writes only for a single variable as
  \begin{equation*}
    \varphi_p(\omega).
  \end{equation*}
\end{remark}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  For a \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \) and \hyperref[def:atomic_propositional_substitution]{simultaneous substitution} \( \Bbbs \), we have \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \) if and only if \( \Bracks{\Bbbs(p)}_I = I(p) \) for every variable \( p \) in \( \op*{Var}(\varphi) \).
\end{proposition}
\begin{proof}
  \SufficiencySubProof Suppose that \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I\). We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \Bracks{\Bbbs(p)}_I = I(p) \) for every variable \( p \) in \( \op*{Var}(\varphi) \).

  \begin{itemize}
    \item If \( \varphi \) is a proposition constant, it has no variables, so the statement is vacuous.
    \item If \( \varphi \) is a variable and \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \), then the statement holds since \( \varphi \) is the only variable of \( \varphi \).
    \item If \( \varphi = \synneg \psi \), where the inductive hypothesis holds for \( \psi \), then the statement automatically holds for \( \varphi \) because \( \varphi \) and \( \psi \) have the same free variables.
    \item Finally, if \( \varphi = \psi \syncirc \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), then again the statement holds for \( \varphi \) because its variables are the union of those \( \psi \) and \( \theta \).
  \end{itemize}

  \NecessitySubProof Suppose that \( \Bracks{\Bbbs(p)}_I = I(p) \) for every variable \( p \) in \( \op*{Var}(\varphi) \). We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \).

  \begin{itemize}
    \item If \( \varphi \) is a propositional constant, then \( \varphi[\Bbbs] = \varphi \), so naturally \( \Bracks[\big]{\varphi[\Bbbs]}_I = \Bracks{\varphi}_I \).
    \item If \( \varphi \) is a variable, then \( \Bracks[\big]{\varphi[\Bbbs]}_I = I(\Bbbs(\varphi)) \), which we have assumed equals \( I(\varphi) \).
    \item If \( \varphi = \synneg \psi \), where the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Bracks[\big]{\varphi[\Bbbs]}_I
      =
      \Bracks{\synneg \psi[\Bbbs]}_I
      =
      \oline{\Bracks[\big]{\psi[\Bbbs]}_I}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi}_I}
      =
      \Bracks{\synneg \psi}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    \item Similarly, if \( \varphi = \psi \syncirc \theta \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), then
    \begin{equation*}
      \Bracks[\big]{\varphi[\Bbbs]}_I
      =
      \Bracks[\big]{\psi[\Bbbs] \syncirc \theta[\Bbbs]}_I
      =
      \Bracks[\big]{\psi[\Bbbs]}_I \bincirc \Bracks[\big]{\theta[\Bbbs]}_I
      \reloset {\T{ind.}} =
      \Bracks{\psi}_I \bincirc \Bracks{\psi}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{definition}\label{def:substitution_schema_alphabet}
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} for substitution schemas consists of the following:
  \begin{thmenum}
    \thmitem{def:substitution_schema_alphabet/brackets} The brackets \enquote{\( [ \)} and \enquote{\( ] \)}.

    \thmitem{def:substitution_schema_alphabet/connective} The connective \enquote{\( \synsubst \)}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:substitution_schema}
  The metalinguistic syntax from \cref{rem:substitution_notation} for describing \hyperref[con:syntactic_substitution]{substitution} of finitely many variables can be formalized via the \hyperref[def:formal_grammar/schema]{grammar schema}
  \begin{bnf*}
    \bnfprod{replacement}      {\bnfpn{variable} \bnfsp \bnftsq{\( \synsubst \)} \bnfsp \bnfpn{subject}}, \\
    \bnfprod{replacement list} {\bnfpn{replacement} \bnfor \bnfpn{replacement} \bnfsp \bnftsq{,} \bnfsp \bnfpn{replacement list}}, \\
    \bnfprod{substitution}     {\bnfpn{subject} \bnfsp \bnftsq{\( [ \)} \bnfsp \bnfpn{replacement list} \bnfsp \bnftsq{\( ] \)}}.
  \end{bnf*}

  Here the rules \( \bnfpn{variable} \) and \( \bnfpn{subject} \) must be provided externally. The subjects can be \hyperref[def:propositional_formula]{propositional formulas}, \hyperref[def:lambda_term]{\( \muplambda \)-terms}, or any other syntactic construct where substitution makes sense.
\end{definition}
\begin{comments}
  \item These grammar rules give us the ability to formalize the syntax used for the \hyperref[def:inference_rule]{inference rules} in \fullref{sec:first_order_natural_deduction}.
\end{comments}

\begin{remark}\label{rem:simulating_simultaneous_substitution}
  Substitution as defined in \fullref{alg:propositional_substitution} allows us to replace more than one variable at a time:
  \begin{equation*}
    (pqr)[p \mapsto r, r \mapsto p]
    =
    rqp.
  \end{equation*}

  We can also simulate this via single-variable substitution with the aid of temporary variables:
  \begin{equation*}
    (pqr)[p \mapsto t][r \mapsto p][t \mapsto r]
    =
    (tqr)[r \mapsto p][t \mapsto r]
    =
    (tqp)[t \mapsto r]
    =
    (rqp).
  \end{equation*}
\end{remark}

\paragraph{Subformula substitution}

For propositional logic, We will also find useful the ability to replace an entire subformula with another formula. We will use this, for example, to justify the substitutions in \fullref{alg:formula_to_cnf}.

\begin{algorithm}[Propositional subformula substitution]\label{alg:propositional_subformula_substitution}\mcite[def. 1.3.13]{Hinman2005Logic}
  We define the \term[en=substitution]{subformula substitution} of the propositional formula \( \chi \) with \( \omega \) in \( \varphi \) as follows:
  \begin{equation}\label{eq:alg:propositional_subformula_substitution}
    \varphi[\chi \mapsto \omega] \coloneqq \begin{cases}
      \omega,                                                         &\varphi = \chi \\
      \varphi,                                                        &\varphi \neq \chi \T{and} \varphi \in \op*{Atom} \\
      \synneg \psi[\chi \mapsto \omega],                              &\varphi \neq \chi \T{and} \varphi = \synneg \psi \\
      \psi[\chi \mapsto \omega] \syncirc \theta[\chi \mapsto \omega], &\varphi \neq \chi \T{and} \varphi = \psi \syncirc \theta, \circ \in \op*{Conn}.
    \end{cases}
  \end{equation}
\end{algorithm}
\begin{comments}
  \item Note that it is not necessary for \( \chi \) to be a subformula of \( \varphi \) --- the substitution simply does nothing otherwise.
  \item It is safe to reuse the notation for simultaneous substitutions because in the case where \( \chi \) is a variable, the two notions coincide.
  \item This algorithm can be found as \identifier{math.logic.propositional.substitute_subformula} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:propositional_subformula_substitution_equivalence}
  For a \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \) and formulas \( \chi \) and \( \omega \) such that \( \Bracks{\chi}_I = \Bracks{\omega}_I \), we have \( \Bracks[\big]{\varphi[\chi \mapsto \omega]}_I = \Bracks{\varphi}_I \) for every \( \varphi \).

  In particular, if \( \chi \gleichstark \omega \), then \( \varphi[\chi \mapsto \omega] \gleichstark \varphi \).
\end{proposition}
\begin{proof}
  Suppose that \( \Bracks{\chi}_I = \Bracks{\omega}_I \). We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that
  \begin{equation}\label{eq:thm:propositional_subformula_substitution_equivalence/proof}
    \Bracks[\big]{\varphi[\chi \mapsto \omega]}_I = \Bracks{\varphi}_I.
  \end{equation}

  \begin{itemize}
    \item If \( \varphi = \chi \), then \( \varphi[\chi \mapsto \omega] = \omega \) and \eqref{eq:thm:propositional_subformula_substitution_equivalence/proof} is immediate.

    \item If \( \varphi \neq \chi \) and \( \varphi \in \op*{PConst} \cup \op*{Prop} \), then \( \varphi[\chi \mapsto \omega] = \varphi \) and \eqref{eq:thm:propositional_subformula_substitution_equivalence/proof} again holds trivially.

    \item If \( \varphi \neq \chi \) and \( \varphi = \synneg \omega \) and if the inductive hypothesis holds for \( \omega \), then
    \begin{equation*}
      \varphi[\chi \mapsto \omega] = \synneg \psi[\chi \mapsto \omega].
    \end{equation*}

    Thus,
    \begin{equation*}
      \Bracks[\big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \oline{\Bracks[\big]{\psi[\chi \mapsto \omega] }_I}
      \reloset {\T{ind.}} =
      \oline{\Bracks{\psi}_I}
      =
      \Bracks{\varphi}_I.
    \end{equation*}

    \item If \( \varphi \neq \chi \) and \( \varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn} \) and if the inductive hypothesis holds for both \( \psi \) and \( \theta \), then
    \begin{equation*}
      \Bracks[\big]{ \varphi[\chi \mapsto \omega] }_I
      =
      \Bracks[\big]{ \psi[\chi \mapsto \omega] }_I \bincirc \Bracks[\big]{ \theta[\chi \mapsto \omega] }_I
      \reloset {\T{ind.}} =
      \Bracks[\big]{\psi}_I \bincirc \Bracks[\big]{\theta}_I
      =
      \Bracks{\varphi}_I.
    \end{equation*}
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_subformula_substitution_equivalence/proof} holds in all cases.
\end{proof}

\paragraph{Elimination of propositional constants}

\begin{algorithm}[Propositional constant collapse]\label{alg:propositional_constant_collapse}
  We introduce an operator \( T_{\logic{cc}} \) on \hyperref[def:propositional_formula]{propositional formulas} that attempts to simplify subformulas involving logical constants. The result \( T_{\logic{cc}}(\varphi) \) will be \hyperref[def:first_order_semantics/equivalence]{semantically equivalent} with \( \varphi \).

  \begin{thmenum}
    \thmitem{alg:propositional_constant_collapse/atomic} If \( \varphi \) is atomic, i.e. a constant or variable, there is nothing we can do, so we let \( T_{\logic{cc}} \coloneqq \varphi \).

    \thmitem{alg:propositional_constant_collapse/negation} If \( \varphi = \synneg \psi \), let \( \psi' \coloneqq T_{\logic{cc}}(\psi) \) and proceed as follows:
    \begin{equation*}
      T_{\logic{cc}}(\synneg \psi) \coloneqq \begin{cases}
        \synbot,       &\psi' = \syntop \\
        \syntop,       &\psi' = \synbot \\
        \synneg \psi', &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \thmitem{alg:propositional_constant_collapse/conjunction} If \( \varphi = \psi \synwedge \theta \), let \( \psi' \coloneqq T_{\logic{cc}}(\psi) \) and \( \theta' \coloneqq T_{\logic{cc}}(\theta) \) and proceed as follows:
    \begin{equation*}
      T_{\logic{cc}}(\psi \synwedge \theta) \coloneqq \begin{cases}
        \synbot,                   &\psi' = \synbot \T{or} \theta' = \synbot \\
        \theta',                   &\T{otherwise if} \psi' = \syntop \\
        \psi',                     &\T{otherwise if} \theta' = \syntop \\
        \psi' \synwedge \theta',   &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The replacement here is justified semantically since \( \semtop \) and \( \sembot \) are absorbing.

    \thmitem{alg:propositional_constant_collapse/disjunction} Dually, if \( \varphi = \psi \synvee \theta \), we proceed as follows:
    \begin{equation*}
      T_{\logic{cc}}(\psi \synvee \theta) \coloneqq \begin{cases}
        \syntop,                   &\psi' = \syntop \T{or} \theta' = \syntop \\
        \theta',                   &\T{otherwise if} \psi' = \synbot \\
        \psi',                     &\T{otherwise if} \theta' = \synbot \\
        \psi' \synvee \theta',     &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \thmitem{alg:propositional_constant_collapse/conditional} If \( \varphi = \psi \synimplies \theta \), we proceed as we would for \( \synneg \psi \synvee \theta \):
    \begin{equation*}
      T_{\logic{cc}}(\psi \synimplies \theta) \coloneqq \begin{cases}
        \syntop,                   &\psi' = \synbot \T{or} \theta' = \syntop \\
        \theta',                   &\T{otherwise if} \psi' = \syntop \\
        \synneg \psi',             &\T{otherwise if} \theta' = \synbot \\
        \psi' \synimplies \theta', &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The replacements here are justified by \cref{thm:def:heyting_algebra/leq}, \cref{thm:def:heyting_algebra/top_left} and the definition \eqref{eq:def:heyting_algebra/pseudocomplement} of pseudocomplement, respectively.

    \thmitem{alg:propositional_constant_collapse/biconditional} Finally, the case \( \varphi = \psi \syniff \theta \) is a bit different:
    \begin{equation*}
      T_{\logic{cc}}(\psi \syniff \theta) \coloneqq \begin{cases}
        \syntop,                   &\psi' = \theta' = \syntop \T{or} \psi' = \theta' = \synbot \\
        \synbot,                   &(\psi' = \syntop \T{and} \theta' = \synbot) \T{or} (\psi' = \synbot \T{and} \theta' = \syntop) \\
        \psi' \syniff \theta',     &\T{otherwise.}
      \end{cases}
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.collapse_constants_propositional} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  For a fixed interpretation, \cref{thm:propositional_subformula_substitution_equivalence} justifies replacing the subformulas of \( \varphi \) with their substitute.
\end{defproof}

\begin{remark}\label{rem:straightforward_traversal}
  When defining an operator acting on formulas, we usually handle only a few cases, and the others become straightforward. For example, replacing \( \synneg \varphi \) with \( \varphi \synimplies \synbot \), as justified by \cref{thm:intuitionistic_equivalences/negation_bottom}, can be achieved via
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        \varphi,                     &\varphi \in \op*{PConst}, \\
        \varphi,                     &\varphi \in \op*{Prop}, \\
        R(\psi) \synimplies \synbot, &\varphi = \synneg \psi, \\
        R(\psi) \syncirc R(\theta),  &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \end{cases}
    \end{aligned}
  \end{equation*}

  We can instead use the notational shorthand
  \begin{equation*}
    \begin{aligned}
      R(\varphi) \coloneqq \begin{cases}
        R(\psi) \synimplies \synbot,                                             &\varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{aligned}
  \end{equation*}
\end{remark}
\begin{comments}
  \item In computer programming, this exact problem is solved via the visitor design pattern --- generic visitors for formulas of first-order logic can be found in the module \identifier{math.logic.formulas.formula_visitor} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[Propositional constant expansion]\label{alg:propositional_constant_expansion}
  While \fullref{alg:propositional_constant_collapse} aims to remove unnecessary occurrences of the propositional constants, we may want to dispose of them altogether. For this, we introduce an operator \( T_{\logic{ce}} \) on \hyperref[def:propositional_formula]{propositional formulas} that replaces propositional constants with equivalent constructs expressed via other connective.

  Denote by \( p_\varphi \) the lexicographically smallest variable in \( \varphi \), if such exists, and let \( p_\varphi \) be the default variable \( \synp \) otherwise. Define
  \begin{equation*}
    T_{\logic{ce}}(\varphi) \coloneqq \begin{cases}
      p_\varphi \synimplies p_\varphi,       &\varphi = \syntop \\
      p_\varphi \synwedge \synneg p_\varphi, &\varphi = \synbot \\
      \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item A variation suitable for \fullref{alg:formula_to_cnf} is to replace \( \syntop \) with \( p_\varphi \synvee \synneg p_\varphi \). This has the downside of only being sound with respect to classical semantics.

  \item This algorithm can be found as \identifier{math.logic.transformation.expand_constants_propositional} in \cite{notebook:code}.
\end{comments}
\begin{proof}
  The replacement is justified by \eqref{eq:thm:intuitionistic_tautologies/self} and \cref{thm:intuitionistic_equivalences/contradiction}.
\end{proof}

\paragraph{Propositional formula dualization}

\begin{algorithm}[Propositional formula dualization]\label{alg:propositional_formula_dualization}
  Suppose we are working with \hyperref[def:truth_value_algebra/classical]{classical semantics}.

  We will introduce an operator on \hyperref[def:propositional_formula]{propositional formulas} based on the recursive expression of \hyperref[def:free_boolean_algebra/polynomial]{Boolean polynomial} \hyperref[def:bounded_lattice_complement]{complements} from \cref{thm:boolean_polynomial_complement}.

  Our goal is to build a formula \( \oline{T}(\varphi) \) such that \( \Bracks{\oline{T}(\varphi)}_I = \oline{\Bracks{\varphi}_I} \) for every \hyperref[def:propositional_interpretation]{propositional interpretation} \( I \).

  \begin{thmenum}
    \thmitem{alg:propositional_formula_dualization/const} If \( \varphi \) is a constant formula, let
    \begin{equation*}
      \oline{T}(\varphi) \coloneqq \begin{cases}
        \synbot, &\varphi = \syntop, \\
        \syntop, &\varphi = \synbot.
      \end{cases}
    \end{equation*}

    \thmitem{alg:propositional_formula_dualization/prop} For every variable \( P \), let
    \begin{equation*}
      P^\oppos \coloneqq \synneg P.
    \end{equation*}

    \thmitem{alg:propositional_formula_dualization/neg} Suppose that \( \varphi = \synneg \psi \) and let \( \psi' = \oline{T}(\psi) \) and
    \begin{equation*}
      \oline{T}(\varphi) \coloneqq \begin{cases}
        (\psi')^{\oppos}, &\psi' \in \op*{PConst}, \\
        \psi',            &\psi' = \synneg \theta, \\
        \synneg \psi',    &\T{otherwise.} \\
      \end{cases}
    \end{equation*}

    \thmitem{alg:propositional_formula_dualization/conn} Finally, suppose that \( \varphi = \psi \syncirc \theta \) and let \( \psi' = \oline{T}(\psi) \), \( \theta' = \oline{T}(\theta) \) and
    \begin{equation*}
      \oline{T}(\varphi) \coloneqq \begin{cases}
        \psi' \synvee \theta',               &{\syncirc} = {\synwedge}, \\
        \psi' \synwedge \theta',             &{\syncirc} = {\synvee}, \\
        \synneg (\theta' \synimplies \psi'), &{\syncirc} = {\synimplies}, \\
        \synneg (\psi' \syniff \theta'),     &{\syncirc} = {\syniff}. \\
      \end{cases}
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.dualize_formula_propositional} in \cite{notebook:code}.

  \item The other Boolean polynomial operations from \cref{def:opposite_boolean_polynomial} also give rise to transformations of propositional formulas. For example, \incite{Gottschalk1953Quaternality} discusses contradual and dual formulas. \incite[114]{Church1956LogicVol1} and \incite[192]{Andrews2002Logic} call the latter formulas \enquote{principal dual}.

  The aforementioned authors add additional dual connectives --- \( \nleftarrow \) for \( \rightarrow \) (which also requires adding \( \leftarrow \) and \( \nrightarrow \)), and also \( \nleftrightarrow \) for \( \leftrightarrow \). In our algorithm we emulate these connectives.
\end{comments}

\paragraph{Conjunctive and disjunctive normal forms}

\begin{definition}\label{def:cnf_and_dnf}\mimprovised
  We will now introduce \term[ru=конъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975Логика}), en=conjunctive normal form (\cite[def. 1.3.10]{Hinman2005Logic})]{conjunctive normal forms} (CNF) and \term[ru=дизъюнктивная нормальная форма (\cite[def. 6.2]{Эдельман1975Логика}), en=disjunctive normal form (\cite[def. 1.3.10]{Hinman2005Logic})]{disjunctive normal forms} (DNF) for propositional formulas.

  The structure of these formulas is best described by the following extension of the \hyperref[def:propositional_formula]{propositional formula grammar schema}:
  \begin{longbnf*}
    \bnfprod{positive literal}       {\bnfpn{propositional variable}} \\
    \bnfprod{negative literal}       {\bnftsq{\( \synneg \)} \bnfsp \bnfpn{propositional variable}} \\
    \bnfprod{literal}                {\bnfpn{positive literal} \bnfor \bnfpn{negative literal}} \\
    \bnfprod{elementary disjunction} {\bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. disjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{CNF}                    {\bnfpn{elem. disjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{CNF}              \bnfsp \bnftsq{\( \synwedge \)} \bnfsp \bnfpn{CNF}             \bnfsp \bnftsq{)}} \\
    \bnfprod{elementary conjunction} {\bnfpn{literal} \bnfor} \\
    \bnfmore                         {\bnftsq{(} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{\( \synvee \)} \bnfsp \bnfpn{elem. conjunction} \bnfsp \bnftsq{)}} \\
    \bnfprod{DNF}                    {\bnfpn{elem. conjunction} \bnfor \bnftsq{(} \bnfsp \bnfpn{DNF}              \bnfsp \bnftsq{\( \synvee \)}   \bnfsp \bnfpn{DNF}             \bnfsp \bnftsq{)}}
  \end{longbnf*}
\end{definition}
\begin{comments}
  \item The terms \enquote{literal}, \enquote{positive literal} and \enquote{negative literal} are used by \incite[def. 12.2.1]{Rosen2019DiscreteMathematics}, \incite[103]{DaveyPriestley2002LatticeTheory}, \incite[77]{Mimram2020ProgramEqualsProof} and \incite[132]{Savage2008ModelsOfComputation}. The adjective \enquote{elementary} for conjunctions and disjunctions is based on \cite[36]{Эдельман1975Логика}.
  \item With only positive literals, this becomes a particular syntax for \hyperref[rem:algebraic_and_lattice_polynomials]{lattice polynomials}.
  \item As usual, we utilize the convention in \cref{rem:propositional_formula_notation_conventions} and avoid excessive parentheses.
\end{comments}

\begin{algorithm}[Formula to CNF or DNF]\label{alg:formula_to_cnf}
  Again, suppose we are working with \hyperref[def:truth_value_algebra/classical]{classical semantics}.

  We will define four operators, \( C_1 \) through \( C_4 \), such that, for a \hyperref[def:propositional_formula]{propositional formula} \( \varphi \)
  \begin{equation*}
    [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\varphi)
  \end{equation*}
  is a formula in \hyperref[def:cnf_and_dnf]{conjunctive normal form} that is \hyperref[def:semantic_equivalence]{semantically equivalent} to \( \varphi \).

  In order to obtain a \hyperref[def:cnf_and_dnf]{disjunctive normal form} instead, we will need to use \( C_4^\oppos \) rather than \( C_4 \).

  \begin{thmenum}
    \thmitem{alg:formula_to_cnf/constants} First, we remove the propositional constants. Choose any propositional variable, say \( \synp \), and let
    \begin{equation*}
      C_1(\varphi) \coloneqq \begin{cases}
        \synp \synvee \synneg \synp,                                             &\varphi = \syntop, \\
        \synp \synwedge \synneg \synp,                                           &\varphi = \synbot, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Cref{thm:propositional_subformula_substitution_equivalence} implies that, since \( \synp \synvee \synneg \synp \gleichstark \syntop \) and \( \synp \synwedge \synneg \synp \gleichstark \synbot \), then \( C_1(\varphi) \gleichstark \varphi \).

    \thmitem{alg:formula_to_cnf/conditional} Next, we remove the conditional \( \synimplies \) and biconditional \( \syniff \). Let
    \begin{equation*}
      C_2(\varphi) \coloneqq \begin{cases}
        \synneg C_2(\psi) \synvee C_2(\theta),                                   &\varphi = \psi \synimplies \theta, \\
        C_2(\psi \synimplies \theta) \synwedge C_2(\theta \synimplies \psi),     &\varphi = \psi \syniff \theta, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Cref{thm:classical_equivalences/conditional_as_disjunction} and \cref{def:heyting_algebra/biconditional} justify the substitutions and ensure that \( C_2(\varphi) \gleichstark \varphi \).

    \thmitem{alg:formula_to_cnf/negation} We \enquote{push} negations inwards. Let
    \begin{equation*}
      C_3(\varphi) \coloneqq \begin{cases}
        C_3(\synneg \psi) \synwedge C_3(\synneg \theta),                         &\varphi = \synneg (\psi \synvee \theta), \\
        C_3(\synneg \psi) \synvee C_3(\synneg \theta),                           &\varphi = \synneg (\psi \synwedge \theta), \\
        C_3(\psi),                                                               &\varphi = \synneg \synneg \psi, \\
        \synneg C_3(\psi),                                                       &\T{otherwise if} \varphi = \synneg \psi, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \Cref{thm:classical_equivalences/de_morgan} and \cref{thm:classical_equivalences/double_negation} ensure that \( C_3(\varphi) \gleichstark \varphi \) for any formula \( \varphi \).

    If case \( \varphi \) has no (bi)conditionals (e.g. due to \( C_2 \)), the result \( C_3(\varphi) \) has negations only before propositional variables.

    \thmitem{alg:formula_to_cnf/distributive} Finally, we \enquote{pull} conjunctions outwards. Let
    \begin{equation*}
      C_4(\varphi) \coloneqq \begin{cases}
        C_4(\psi_1 \synvee \theta) \synwedge C_4(\psi_1 \synvee \theta),         &\varphi = \psi \synvee \theta \T{and} C_4(\psi) = \psi_1 \synwedge \psi_2, \\
        C_4(\psi \synvee \theta_1) \synwedge C_4(\psi \synvee \theta_2),         &\T{otherwise if} \varphi = \psi \synvee \theta \T{and} C_4(\theta) = \theta_1 \synwedge \theta_2, \\
        C_4(\psi) \synvee C_4(\theta),                                           &\T{otherwise if} \varphi = \psi \synvee \theta, \\
        C_4(\psi) \synwedge C_4(\theta),                                         &\varphi = \psi \synwedge \theta, \\
        \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
      \end{cases}
    \end{equation*}

    The last case is due to the usual traversal rules, and we could avoid writing it, but we wanted to be explicit about how conjunction behaves with \( C_4 \).

    \Cref{thm:classical_equivalences/distributivity} ensures that \( C_4(\varphi) \gleichstark \varphi \) for any formula \( \varphi \).

    To \enquote{pull} out disjunctions instead, we will need the operator \( C_4^\oppos \), which is defined like \( C_4 \) but with \( \synvee \) and \( \synwedge \) swapped.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformations.conjunctive.formula_to_cnf} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  It is obvious from our comments that \( \varphi \) is equivalent to
  \begin{equation*}
    \varphi' \coloneqq [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\varphi).
  \end{equation*}

  We will use \hyperref[con:induction/peano_arithmetic]{natural number induction} on the length of \( \varphi \) to show that it is in conjunctive normal form.

  \begin{itemize}
    \item If \( \varphi = \syntop \), then \( \varphi' = C_1(\varphi) = \synp \synvee \synneg \synp \), which is a disjunction of literals.
    \item If \( \varphi = \synbot \), then \( \varphi' = C_1(\varphi) = \synp \synwedge \synneg \synp \), which is a conjunction of \enquote{unary} disjuncts of literals.
    \item If \( \varphi \) is a propositional variable, then \( \varphi' = \varphi \) is a literal.

    \item If \( \varphi = \psi_1 \synvee \psi_2 \), then
    \begin{equation*}
      \varphi'
      =
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \synvee \psi_2)
      =
      C_4\parens[\big]{ [C_3 \bincirc C_2 \bincirc C_1](\psi_1) \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) }
    \end{equation*}

    The result of applying \( C_4 \) depends on \( \psi_1' \) and \( \psi_2' \). Note that both are shorter than \( \varphi \), so both must be in CNF.
    \begin{itemize}
      \item If \( (\synneg \theta_1)' = \chi_1 \synwedge \chi_2 \), then
      \begin{balign*}
        \varphi'
        &=
        C_4\parens[\bigg]{ \parens[\big]{ \chi_1 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } \synwedge \parens[\big]{ \chi_2 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } }
        = \\ &=
        C_4\parens[\big]{ \chi_1 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) } \synwedge C_4\parens[\big]{ \chi_2 \synvee [C_3 \bincirc C_2 \bincirc C_1](\psi_2) }
        = \\ &=
        (\chi_1 \synvee \psi_2)' \synwedge (\chi_2 \synvee \psi_2)'.
      \end{balign*}

      Since both \( (\chi_1 \synvee \psi_2)' \) and \( (\chi_2 \synvee \psi_2)' \) are shorter than \( \varphi \), the inductive hypothesis implies that they are in CNF. Then \( \varphi' \) itself is also in CNF.

      \item If \( \psi_1' \) is not a conjunction and if \( \psi_2' = \chi_1 \synwedge \chi_2 \), then, by analogy with the case above, we conclude that \( \varphi' \) is in CNF.

      \item If neither \( \psi_1' \) nor \( \psi_2' \) are conjunctions, then they must be disjunctions of literals, and hence \( \varphi' \) is also a disjunction of literals.
    \end{itemize}

    \item If \( \varphi = \psi_1 \synwedge \psi_2 \), the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), hence \( \varphi' = \psi_1' \synwedge \psi_2' \) is in CNF.

    \item If \( \varphi = \psi_1 \synimplies \psi_2 \), then
    \begin{balign*}
      \varphi'
      &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \synimplies \psi_2)
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2]\parens[\big]{ C_1(\psi_1) \synimplies C_1(\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3]\parens[\big]{ [C_2 \bincirc C_1](\synneg \psi_1) \synvee [C_2 \bincirc C_1](\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\synneg \psi_1 \synvee \psi_2).
    \end{balign*}

    This reduces to the case where \( \varphi \) is a disjunction, hence we can conclude that \( \varphi' \) is in CNF.

    \item If \( \varphi = \psi_1 \syniff \psi_1 \), then
    \small
    \begin{balign*}
      \varphi'
      &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1](\psi_1 \syniff \psi_2)
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2]\parens[\big]{ C_1(\psi_1) \syniff C_1(\psi_2) }
      = \\ &=
      [C_4 \bincirc C_3]\parens[\bigg]{ \parens[\big]{\synneg [C_2 \bincirc C_1](\psi_1) \synvee [C_2 \bincirc C_1](\psi_2)} \synwedge \parens[\big]{ [C_2 \bincirc C_1](\psi_1) \synvee \synneg [C_2 \bincirc C_1](\psi_2) } }
      = \\ &=
      [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1]\parens[\big]{ (\synneg \psi_1 \synvee \psi_2) \synwedge (\psi_1 \synvee \synneg \psi_2) },
    \end{balign*}
    \normalsize
    which reduces to the case where \( \varphi \) is a conjunction.

    \item If \( \varphi = \synneg \psi \), where \( \psi' \) is in CNF, then we must use nested induction on \( \psi' \):
    \begin{itemize}
      \item If \( \psi = \syntop \), then
      \begin{multline*}
        \varphi'
        =
        C_3(C_1(\synneg \syntop))
        =
        C_3(\synneg C_1(\syntop))
        =
        C_3(\synneg (\synp \synvee \synneg \synp))
        = \\ =
        C_3(\synneg \synp) \synvee C_3(\synneg \synneg \synp)
        =
        \synneg C_3(\synp) \synwedge C_3(\synp)
        =
        \synneg \synp \synwedge \synp,
      \end{multline*}
      which is again a conjunction of unary disjuncts of literals.

      \item Dually, if \( \psi = \synbot \), then
      \begin{equation*}
        \varphi'
        =
        C_3(C_1(\synneg \synbot))
        =
        C_3(\synneg (\synp \synwedge \synneg \synp))
        =
        \synneg \synp \synvee \synp,
      \end{equation*}
      which is a disjunction of literals.

      \item If \( \psi = \synneg \theta \), we have \( \varphi' = \theta' \). Furthermore, since \( \theta \) is shorter than \( \varphi \), \( \theta' \) is in CNF, and hence so is.

      \item If \( \psi = \theta_1 \synvee \theta_2 \), then
      \begin{balign*}
        \varphi'
        &=
        [C_4 \bincirc C_3 \bincirc C_2 \bincirc C_1]\parens[\big]{\synneg (\theta_1 \synvee \theta_2) }
        = \\ &=
        [C_4 \bincirc C_3]\parens[\big]{ \synneg \parens[\big]{ [C_2 \bincirc C_1](\theta_1) \synvee [C_2 \bincirc C_1](\theta_2) } }
        = \\ &=
        C_4\parens[\big]{ C_3\parens[\big]{ \synneg [C_2 \bincirc C_1](\theta_1) } \synwedge C_3\parens[\big]{ \synneg [C_2 \bincirc C_1](\theta_2) } }
        = \\ &=
        C_4\parens[\big]{ [C_3 \bincirc C_2 \bincirc C_1](\synneg \theta_1) \synwedge [C_3 \bincirc C_2 \bincirc C_1](\synneg \theta_2) }
        = \\ &=
        (\synneg \theta_1 \synwedge \synneg \theta_2)'
      \end{balign*}

      This reduces to the case where \( \varphi' \) is a conjunction.

      \item If \( \psi = \theta_1 \synwedge \theta_2 \), then
      \begin{align*}
        \varphi'
        =
        (\synneg \theta_1 \synvee \synneg \theta_2)',
      \end{align*}
      which reduces to the case where \( \varphi \) is a disjunction.

      \item If \( \psi = \theta_1 \synimplies \theta_2 \), this reduces to the case where \( \psi \) is a disjunction and \( \varphi \) is a conjunction.
      \item If \( \psi = \theta_1 \syniff \theta_2 \), this reduces to the case where \( \psi \) is a conjunction and \( \varphi \) is a disjunction.
    \end{itemize}

    In all cases for \( \psi \) in \( \varphi = \synneg \psi \), we have shown that \( \varphi' \) is in CNF.
  \end{itemize}

  We have finished the inductive proof that, for any formula \( \varphi \), the result \( \varphi' \) of applying the transformations \( C_1 \) through \( C_4 \) is a formula in CNF.
\end{defproof}

\begin{definition}\label{def:full_cnf_and_dnf}\mimprovised
  We say that the \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}) is \term[ru=совершенная (\cite[def. 6.3; def. 6.4]{Эдельман1975Логика}), en=full (\incite[103]{DaveyPriestley2002LatticeTheory}); strict (\cite[def. 1.3.10]{Hinman2005Logic})]{full} if the following hold:
  \begin{thmenum}
    \thmitem{def:full_cnf_and_dnf/literals} Every elementary disjunction (resp. conjunction) contains exactly one literal for each variable encountered in the formula, and these variables are ordered as per \cref{def:variable_identifier}.

    More explicitly, if the variables are \( p_1, \ldots, p_n \), every elementary disjunction has the form
    \begin{equation*}
      L_1 \synvee L_2 \synvee \cdots \synvee L_n,
    \end{equation*}
    where, for every \( k = 1, \ldots, n \), \( L_k \) is either \( p_k \) or \( \neg p_k \).

    \thmitem{def:full_cnf_and_dnf/elementary} The elementary disjunctions (resp. conjunctions) are ordered \hyperref[def:lexicographic_order]{lexicographically} so that \( p_k < \neg p_k \) for every variable \( p_k \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is based on \cite[def. 6.3; def. 6.4]{Эдельман1975Логика}, but with adjustments made in order to improve rigor.
\end{comments}

\begin{proposition}\label{thm:full_cnf_and_dnf_uniqueness}
  A \hyperref[def:full_cnf_and_dnf]{perfect} \hyperref[def:cnf_and_dnf]{CNF} (resp. \hyperref[def:cnf_and_dnf]{DNF}) is unique.
\end{proposition}
\begin{proof}
  Trivial.
\end{proof}

\begin{example}\label{ex:def:cnf_and_dnf}
  We list examples of formulas in \hyperref[def:cnf_and_dnf]{conjunctive and disjunctive normal forms}:
  \begin{thmenum}
    \thmitem{def:cnf_and_dnf/perfect_cnf} The \hyperref[thm:classical_equivalences]{Boolean equivalence} \eqref{eq:thm:classical_equivalences/conditional_as_disjunction} allows us to represent convert the \hyperref[def:propositional_alphabet/connectives/conditional]{conditional} \( \varphi \synimplies \psi \) to \( \synneg \varphi \synvee \psi \), which is both in CNF and in DNF.

    It is an elementary disjunction, hence it is vacuously in perfect CNF.

    The DNF is not perfect, however, because the condition \cref{def:full_cnf_and_dnf/literals} is not satisfied.

    \thmitem{def:cnf_and_dnf/perfect_dnf} Consider instead the formula
    \begin{equation*}
      (\varphi \synwedge \psi) \synvee (\synneg \varphi \synwedge \psi) \synvee (\synneg \varphi \synwedge \synneg \psi)
    \end{equation*}

    It is in perfect DNF, and it is equivalent to \( \varphi \synimplies \psi \).
  \end{thmenum}
\end{example}

\begin{algorithm}[Boolean function to perfect CNF or DNF]\label{alg:function_to_cnf}\mcite[thm. I.1.3]{Яблонский2003ДискретнаяМатематика}
  Let \( f(x_1, \ldots, x_n) \) be an arbitrary \hyperref[def:boolean_function]{Boolean function}.

  We will build a formula \( \varphi \) in \hyperref[def:full_cnf_and_dnf]{perfect} \hyperref[def:cnf_and_dnf]{conjunctive normal form} whose \hyperref[def:parametrized_propositional_denotation]{induced function} under \hyperref[def:truth_value_algebra/classical]{classical semantics} will be \( f \).

  \begin{thmenum}
    \thmitem{alg:function_to_cnf/true} If \( f \) is canonically true, let \( \varphi \coloneqq \synp \synvee \neg \synp \).

    \thmitem{alg:function_to_cnf/false} If \( n = 0 \) and \( f = \sembot \), let \( \varphi \coloneqq \synp \synwedge \neg \synp \).

    \thmitem{alg:function_to_cnf/elementary} Otherwise, fix some propositional variables \( p_1, \ldots, p_n \). Given a tuple \( x_1, \ldots, x_n \) of Boolean values, we can construct the following elementary disjunction:
    \begin{equation}\label{alg:function_to_cnf/cnf}
      p_1^{x_1} \synvee \cdots \synvee p_n^{x_n},
    \end{equation}
    where
    \begin{equation*}
      p_k^{x_k} \coloneqq \begin{cases}
        p_k,      &x_k = \sembot, \\
        \neg p_k, &x_k = \semtop.
      \end{cases}
    \end{equation*}

    \thmitem{alg:function_to_cnf/total} Finally, order the disjunctions with respect to the \hyperref[def:lexicographic_order]{lexicographic order} on the set \( \set{ \semtop, \sembot }^n \) (\( \sembot < \semtop \)) to which the tuples of Boolean values \( (x_1, \ldots, x_n) \) belong. Then let \( \varphi \) be the conjunction of the corresponding elementary disjunctions for which
    \begin{equation*}
      f(x_1, \ldots, x_n) = \sembot.
    \end{equation*}

    \thmitem{alg:function_to_cnf/dual} In order to obtain a perfect DNF instead, we can utilize \fullref{thm:cnf_and_dnf_duality} by instead considering the function
    \begin{equation*}
      \oline{f(x_1, \ldots, x_n)},
    \end{equation*}
    obtaining a formula \( \varphi \) in CNF and then using the dual formula \( \oline{T}(\varphi) \).
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.transformation.conjunctive.function_to_cnf} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  We will use induction on \( n \) to show that
  \begin{equation*}
    \Bracks{\varphi}(x_1, \ldots, x_n) = f(x_1, \ldots, x_n).
  \end{equation*}

  \begin{itemize}
    \item The case \( n = 0 \) is special.
    \begin{itemize}
      \item If \( f = \semtop \), then, by \fullref{alg:function_to_cnf/true}, \( \varphi = p \synvee \neg p \), which is a tautology.
      \item If \( f = \sembot \), then, by \fullref{alg:function_to_cnf/false}, \( \varphi = p \synwedge \neg p \), which is a contradictory formula.
    \end{itemize}

    \item Let \( n = 1 \).
    \begin{itemize}
      \item If \( f(x) = \semtop \), then again by \fullref{alg:function_to_cnf/true}, \( \varphi = p \synvee \neg p \) is a tautology.
      \item If \( f(x) = \sembot \), then \fullref{alg:function_to_cnf/elementary} provides us with the elementary disjunctions \( p^\sembot = p \) and \( p^\semtop = \neg p \) and \fullref{alg:function_to_cnf/total} gives us \( \varphi = p \synwedge \neg p \).
      \item If \( f(x) = x \), then we only consider the elementary disjunction \( p^\sembot = p \), which leads us to \( \varphi = p \).
      \item If \( f(x) = \oline{x} \), then \( \varphi = \neg p \).
    \end{itemize}

    Therefore, if \( f \) is unary, the formula \( \varphi \) constructed via this algorithm satisfies \( \Bracks{\varphi}(x) = f(x) \).

    \item Consider the function \( f(x_1, \ldots, x_n, x_{n+1}) \) and suppose that, for any \( n \)-ary Boolean function \( g \), the interpretation of its corresponding formula coincides with \( g \).

    Let \( \varphi_F \) be the formula obtained for \( f(x_1, \ldots, x_n, \sembot) \) and let \( \varphi_F' \) be the formula obtained from \( \varphi_F \) by adding the literal \( p_{n+1} \) to each elementary disjunction.

    Dually, let \( \varphi_T \) be the formula for \( f(x_1, \ldots, x_n, \semtop) \) and let \( \varphi_T' \) be the formula obtained by adding the literal \( \neg p_{n+1} \) to each elementary disjunction.

    Then
    \begin{equation*}
      \Bracks{\varphi_F' \synwedge \varphi_T'}(x_1, \ldots, x_n, \sembot)
      =
      \underbrace{\Bracks{\varphi_F'}(x_1, \ldots, x_n, \sembot)}_{\mathclap{\Bracks{\varphi_F}(x_1, \ldots, x_n) \T*{because} \Bracks{p_{n+1}}(\sembot) = \sembot}} \wedge \overbrace{\Bracks{\varphi_T'}(x_1, \ldots, x_n, \sembot)}^{\semtop \T*{because} \Bracks{\neg p_{n+1}}(\sembot) = \semtop}
      =
      \underbrace{\Bracks{\varphi_F}(x_1, \ldots, x_n)}_{f(x_1, \ldots, x_n, \sembot)}
    \end{equation*}
    and similarly
    \begin{equation*}
      \Bracks{\varphi_F' \synwedge \varphi_T'}(x_1, \ldots, x_n, \semtop)
      =
      \Bracks{\varphi_T}(x_1, \ldots, x_n)
      =
      f(x_1, \ldots, x_n, \semtop).
    \end{equation*}
  \end{itemize}

  We conclude that the interpretation of a formula obtained through this algorithm is the initial function.
\end{defproof}

\paragraph{Equivalence of propositional formulas and Boolean functions}

\begin{proposition}\label{thm:propositional_formulas_and_boolean_functions}
  \hyperref[def:propositional_formula]{Propositional formulas} under \hyperref[def:truth_value_algebra/classical]{classical semantics} have the following structural properties when treated as \hyperref[def:boolean_function]{Boolean functions}:

  \begin{thmenum}
    \thmitem{thm:propositional_formulas_and_boolean_functions/equivalence_classes} \hyperref[def:semantic_equivalence]{Semantic equivalence} \( \gleichstark \) is an \hyperref[def:equivalence_relation]{equivalence relation} on the set \( \op*{Form} \) of all propositional formulas.

    \thmitem{thm:propositional_formulas_and_boolean_functions/bijection} Given the set \( \mscrB \) of all \hyperref[def:boolean_function]{Boolean functions} of arbitrary arity, the following map is bijective:
    \begin{equation*}
      \begin{aligned}
        &\Phi: \op*{Form} / {\gleichstark} \to \mscrB \\
        &\Phi([\varphi]) \coloneqq \Bracks{\varphi}.
      \end{aligned}
    \end{equation*}
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item This is one of the motivations for studying \hyperref[def:lindenbaum_tarski_algebra]{Lindenbaum-Tarski algebras}.
  \item Both \( \op*{Form} / {\gleichstark} \) and \( \mscrB \) are provably Boolean algebras, but we give very different proofs --- the former is a Boolean algebra due to the syntactic \cref{thm:lindenbaum_tarski_algebras}, and the latter is a Boolean algebra due to the semantic \cref{thm:functions_over_model_form_model}. This is another demonstration of the soundness and completeness stated in \fullref{thm:classical_first_order_logic_soundness_and_complete}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:propositional_formulas_and_boolean_functions/equivalence_classes} Straightforward.

  \SubProofOf{thm:propositional_formulas_and_boolean_functions/bijection} The map \( \Phi \) is well-defined since, by definition of semantic equivalence, \( \varphi \gleichstark \psi \) whenever \( \Bracks{\varphi}_I = \Bracks{\psi}_I \) for every interpretation \( I \).

  Injectivity of \( \Phi \) is also obvious from the definition of semantic equivalence, while surjectivity is given by \fullref{alg:function_to_cnf}.
\end{proof}
