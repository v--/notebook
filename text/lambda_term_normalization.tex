\section{Lambda term normalization}\label{sec:lambda_term_normalization}

Unless explicitly noted otherwise, we will follow \fullref{rem:base_typing_rules}, that is, we will restrict ourselves to explicitly typed terms and to derivation trees constructed using the two base rules from \fullref{def:base_typing_rules}. In particular, we will not consider constant terms.

\paragraph{Typed substitution}

\begin{algorithm}[Typed substitution]\label{alg:typed_substitution}
  Fix a \hyperref[def:lambda_substitution]{substitution} \( \Bbbs \) and a \hyperref[def:type_derivation_tree]{type derivation tree} \( T \) for \( M: \tau \). For every assumption \( v: \sigma \) of \( T \), suppose we are given a derivation tree \( T_v \) for \( \Bbbs(v): \sigma \).

  We will build a derivation tree \( T' \) for \( M[\Bbbs]: \tau \).

  \begin{thmenum}
    \thmitem{alg:typed_substitution/var} If \( T \) is an assumption tree, then \( M \) is a variable. The assertion \( M: \tau \) is then an assumption of \( T \), and we have supposed that there exists a corresponding tree \( T_M \) deriving \( M[\Bbbs]: \tau \).

    \thmitem{alg:typed_substitution/app} If \( M = NK \), then \( T \) is an application tree for the rule \ref{inf:def:base_typing_rules/arrow/elim}; thus, \( T \) has subtrees \( T_N \) and \( T_K \) deriving \( N: \sigma \synimplies \tau \) and \( K: \sigma \) for some type \( \sigma \).

    We apply the algorithm to these subtrees to obtain \( T_N' \) and \( T_K' \) deriving \( N[\Bbbs]: \sigma \synimplies \tau \) and \( K[\Bbbs]: \sigma \).

    Then we use \ref{inf:def:base_typing_rules/arrow/elim} to combine \( T_N' \) and \( T_K' \), obtaining a derivation of \( M[\Bbbs]: \sigma \).

    \thmitem{alg:typed_substitution/abs} If \( M = \qabs {x^\sigma} N \), then \( \tau = \sigma \synimplies \rho \) for some type \( \rho \), and \( T \) is an application tree for \ref{inf:def:base_typing_rules/arrow/intro/exp} with discharge assertion \( x: \sigma \) and subtree \( T_N \) deriving \( N: \rho \).

    We must consider two possibilities:
    \begin{thmenum}
      \thmitem{alg:typed_substitution/abs/renaming} If \( x \) is in \( \op*{Free}_\Bbbs(M) \), then substitution uses the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming}:
      \begin{equation*}
        M[\Bbbs] = \qabs {n^\sigma} N[\Bbbs_{x \mapsto n}],
      \end{equation*}
      where \( n = \sharp(\op*{Free}(N) \cup \op*{Free}_\Bbbs(N)) \).

      We can use the algorithm on the modified substitution \( \Bbbs_{x \mapsto n} \) to obtain a tree \( S \) deriving \( N[\Bbbs_{x \mapsto n}]: \rho \). Applying \ref{inf:def:base_typing_rules/arrow/intro/exp} to \( S \) with discharge assertion \( n: \sigma \), we obtain a derivation tree for \( M[\Bbbs]: \tau \).

      \thmitem{alg:typed_substitution/abs/direct} If \( x \) is instead not in \( \op*{Free}_\Bbbs(M) \), then substitution uses the non-renaming rule renaming rule \eqref{eq:def:lambda_substitution/abstraction/direct}:
      \begin{equation*}
        M[\Bbbs] = \qabs {x^\sigma} N[\Bbbs_{x \mapsto x}].
      \end{equation*}

      We proceed analogously to the previous case to construct a derivation of \( M[\Bbbs]: \tau \).
    \end{thmenum}
  \end{thmenum}
\end{algorithm}
\begin{defproof}
  The algorithm halts as can be easily proven using induction on the length of terms.
\end{defproof}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.type_derivation.substitution.apply_tree_substitution} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:typed_substitution_assertions}
  The following \hyperref[def:simple_typing_rule]{simple typing rule} is \hyperref[con:inference_rule_admissibility]{admissible} with respect to \ref{inf:def:base_typing_rules/arrow/elim} and \ref{inf:def:base_typing_rules/arrow/intro/exp}:
  \begin{equation*}\taglabel[\ensuremath{ Subst }]{inf:thm:typed_substitution_assertions}
    \begin{prooftree}
      \hypo{ [\synx: \syn\sigma] }
      \ellipsis {} { \synM: \syn\tau }

      \hypo{ \synN: \syn\sigma }
      \infer2[\ref{inf:thm:typed_substitution_assertions}]{ \synM[\synx \synsubst \synN]: \syn\tau }.
    \end{prooftree}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item When defining term schemas in \fullref{def:lambda_term_schema}, we have not defined schemas for substitution. This will be done for first-order formulas in \fullref{def:first_order_formula_schema}, but here the complexity of such a definition will not pay off --- our goal is merely to illustrate a possible typing rule.

  \item We can also express this via the following \hyperref[rem:sequent_calculus]{sequent calculus} style rule:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma, \synx: \syn\sigma \synvdash \synM: \syn\tau }
      \hypo{ \syn\Delta \synvdash \synN: \syn\sigma }
      \infer2{ \syn\Gamma, \syn\Delta \synvdash \synM[\synx \synsubst \synN]: \syn\tau }.
    \end{prooftree}
  \end{equation*}
\end{comments}
\begin{proof}
  Let \( T_M \) and \( T_N \) be derivation trees for \( M: \tau \) and \( N: \sigma \), respectively. \Fullref{alg:typed_substitution} allows us to build a derivation tree \( T'_M \) for \( M[x \mapsto N]: \tau \).

  Suppose that the open assumptions of \( T_M \) are among \( \Gamma, x: \sigma \), and those of \( T_N \) --- among \( \Delta \).

  \Fullref{thm:lambda_substitution_free_variables_single} implies that
  \begin{equation*}
    \op*{Free}(M[x \mapsto N]) \subseteq \parens[\Big]{ \op*{Free}(M) \setminus \set{ x } } \cup \op*{Free}(N).
  \end{equation*}

  \Fullref{thm:assumptions_and_free_variables} implies that the open assumptions of \( T'_M \) are a subset of those of \( T_M \) with \( x: \sigma \) removed and with the open assumptions of \( T_N \) added.

  Therefore, the open assumptions of \( T'_M \) are among \( \Gamma, \Delta \).
\end{proof}

\paragraph{Typed \( \alpha \)-equivalence}

\begin{definition}\label{def:typed_term_alpha_equivalence}
  \hyperref[def:typed_lambda_term]{Typed \( \synlambda \)-terms} require adapting \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence} by replacing the rules \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren} with the following:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Lift}_\alpha^{\T{tt}} }]{inf:def:typed_term_alpha_equivalence/lift}
        \begin{prooftree}
          \hypo{ A \aequiv B }
          \infer1[\ref{inf:def:typed_term_alpha_equivalence/lift}]{ \qabs {x^\tau} A \aequiv \qabs {x^\tau} B }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Ren}_\alpha^{\T{tt}} }]{inf:def:typed_term_alpha_equivalence/ren}
        \begin{prooftree}
          \hypo{ a \neq b }
          \hypo{ a \not\in \op*{Free}(B) }
          \hypo{ A \aequiv B[b \mapsto a] }
          \infer3[\ref{inf:def:typed_term_alpha_equivalence/ren}]{ \qabs {a^\tau} A \aequiv \qabs {b^\tau} B }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item Here \( \tau \) is an arbitrary type, just like \( A \) and \( B \) are arbitrary terms.

  \item Note that these are not typing rules and are thus not stated in terms of schemas. Introducing schemas for capturing the complexity of these rules would require much additional work.

  \item This limits the scope of \( \alpha \)-equivalence considerably compared to relying on \( \alpha \)-equivalence on untyped terms via \hyperref[alg:type_erasure]{type erasure} --- see \fullref{ex:def:typed_term_alpha_equivalence}.
\end{comments}

\begin{example}\label{ex:def:typed_term_alpha_equivalence}
  The rule \ref{inf:thm:alpha_equivalence_simplified/ren} for untyped terms ensures that \( \qabs x x \) and \( \qabs y y \) are \( \tau \)-equivalent irrespective of the choice of \( x \) and \( y \).

  The corresponding rule \ref{inf:def:typed_term_alpha_equivalence/ren} for typed terms however ensures that \( \qabs {x^\tau} x \) and \( \qabs {y^\sigma} y \) are \( \tau \)-equivalent only if \( \tau = \sigma \).

  If we were instead to rely on \hyperref[alg:type_erasure]{type erasure}, we would conclude that \( \qabs {x^\tau} x \) and \( \qabs {y^\sigma} y \) are \( \tau \)-equivalent even when their type annotations are distinct.
\end{example}

\begin{algorithm}[Typed alpha-conversion]\label{alg:typed_alpha_conversion}
  Fix a \hyperref[def:type_derivation_tree]{type derivation tree} \( T \) for \( M: \tau \) and a term \( N \) \hyperref[def:typed_term_alpha_equivalence]{\( \alpha \)-equivalent} to \( M \).

  We will build a derivation tree \( T_N \) for \( N: \tau \).

  \begin{thmenum}
    \thmitem{alg:typed_alpha_conversion/var} If \( T \) is an assumption tree, then \( M \) is a variable, and hence \( M = N \). Then \( T \) itself is a derivation tree for \( N: \tau \).

    \thmitem{alg:typed_alpha_conversion/app} If \( M = AB \), then \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \), and \( T \) is an application tree for the rule \ref{inf:def:base_typing_rules/arrow/elim}; thus, \( T \) has subtrees \( T_A \) and \( T_B \) deriving \( A: \sigma \synimplies \tau \) and \( B: \sigma \) for some type \( \sigma \).

    We apply the algorithm to these subtrees to obtain \( T_C \) and \( T_D \) deriving \( C: \sigma \synimplies \tau \) and \( D: \sigma \).

    Then we use \ref{inf:def:base_typing_rules/arrow/elim} to combine \( T_C \) and \( T_D \), obtaining a derivation of \( N: \sigma \).

    \thmitem{alg:typed_alpha_conversion/abs} If \( M = \qabs {a^\sigma} A \) then \( N = \qabs {b^\sigma} B \) and \( \tau = \sigma \synimplies \rho \) for some type \( \rho \), and \( T \) is an application tree for \ref{inf:def:base_typing_rules/arrow/intro/exp} with discharge assertion \( x: \sigma \) and subtree \( T_A \) deriving \( A: \rho \).

    \begin{thmenum}
      \thmitem{alg:typed_alpha_conversion/lift} If \( a = b \), then \( M \aequiv N \) due to \ref{inf:def:typed_term_alpha_equivalence/lift}, hence \( A \aequiv B \).

      We apply the algorithm to \( T_A \) to obtain a tree \( T_A' \) deriving \( B: \rho \), and then use \ref{inf:def:base_typing_rules/arrow/intro/exp} with discharge assertion \( x: \sigma \) to construct a tree deriving \( N: \tau \).

      \thmitem{alg:typed_alpha_conversion/ren} Otherwise, if \( a \neq b \), then \( M \aequiv N \) due to \ref{inf:def:typed_term_alpha_equivalence/ren}, hence \( a \) is not free in \( B \) and we have \( A \aequiv B[b \mapsto a] \).

      \Fullref{thm:substitution_composition_is_alpha_equivalent} implies that \( A[a \mapsto b] \aequiv B[b \mapsto a][a \mapsto b] \), and \fullref{thm:substitution_composition_is_alpha_equivalent} implies that \( B[b \mapsto a][a \mapsto b] \aequiv B \).

      We apply \fullref{alg:typed_substitution} to obtain a tree \( S \) deriving, with the additional assumption \( b: \rho \), the assertion \( A[a \mapsto b]: \rho \), and then we apply the current algorithm to \( S \) to obtain a tree \( T_B \) deriving \( B: \rho \).

      We then discharge this additional assumption when applying the rule \ref{inf:def:base_typing_rules/arrow/intro/exp} to \( T_B \), obtaining a tree \( T_N \) deriving \( N: \rho \) from the assumptions of \( T \).
    \end{thmenum}
  \end{thmenum}
\end{algorithm}
\begin{defproof}
  The algorithm halts as can be easily proven using induction on the length of terms.
\end{defproof}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.type_derivation.alpha.alpha_convert_derivation} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:alpha_equivalent_term_typing}
  If \( \Gamma \vdash M: \tau \) and if \( M \aequiv N \), then \( \Gamma \vdash N: \tau \).
\end{proposition}
\begin{proof}
  \Fullref{alg:typed_alpha_conversion} allows us to construct a derivation tree for \( N: \tau \) from any tree for \( M: \tau \).

  \Fullref{thm:assumptions_and_free_variables} implies that the assumptions in both trees coincide since, by \fullref{thm:def:lambda_term_alpha_equivalence/free}, the free variables of \( M \) and \( N \) coincide.
\end{proof}

\paragraph{Reduction}

\begin{definition}\label{def:typed_reduction_rules}
  Analogously to \fullref{def:typed_term_alpha_equivalence}, some rules for reductions from \fullref{def:lambda_reduction} and \fullref{def:beta_eta_reduction} require adaptations for \hyperref[def:typed_lambda_term]{typed \( \synlambda \)-terms}. We will see a better justified adaptation in \fullref{thm:reduction_typing_rules}; reduction rules in type theory are discussed in \fullref{rem:type_theory_rule_classification}.

  Of these, adapting \ref{inf:def:lambda_reduction/abs} puts restrictions on the abstractor variables:
  \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_{\Anon}^{\T{tt}} }]{inf:def:typed_reduction_rules/abs}
    \begin{prooftree}
      \hypo{ M \pred N }
      \infer1[\ref{inf:def:typed_reduction_rules/abs}]{ \qabs {x^\tau} M \pred \qabs {x^\tau} N }.
    \end{prooftree}
  \end{equation*}

  The adaptations of \ref{inf:def:beta_eta_reduction/beta} and \ref{inf:def:beta_eta_reduction/eta} instead do not make use of this annotation without type assertions on other terms:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\beta^{\T{tt}} }]{inf:def:typed_reduction_rules/beta}
        \begin{prooftree}
          \infer0[\ref{inf:def:typed_reduction_rules/beta}]{ (\qabs {x^\tau} M) N \bred M[x \mapsto N] }.
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Par}_\eta^{\T{tt}} }]{inf:def:typed_reduction_rules/eta}
        \begin{prooftree}
          \infer0[\ref{inf:def:typed_reduction_rules/eta}]{ \qabs {x^\tau} M x \ered M }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{definition}

\begin{algorithm}[Typed reduction]\label{alg:typed_reduction}
  As in \fullref{sec:lambda_term_reductions}, let \enquote{\( {\Anon} \)} be a combination of \enquote{\( \beta \)} and \enquote{\( \eta \)}.

  Fix a \hyperref[def:type_derivation_tree]{type derivation tree} \( T \) for \( M: \tau \) and a term \( N \) such that \( M \pred N \). We will build a tree deriving \( N: \tau \).

  We proceed recursively on \( M \pred N \):
  \begin{thmenum}
    \thmitem{alg:typed_reduction/app_left} If \( M \pred N \) due to \ref{inf:def:lambda_reduction/app_left}, then \( M = AB \) and \( N = CB \), where \( A \pred C \).

    In this case \( T \) is an application tree for \ref{inf:def:base_typing_rules/arrow/elim}, and its subtrees \( T_A \) and \( T_B \) derive \( A: \sigma \synimplies \tau \) and \( B: \sigma \), correspondingly.

    We apply the algorithm to \( T_A \) to obtain a tree \( T_C \) deriving \( C: \sigma \synimplies \tau \), and then construct a tree for \( N: \tau \) using \ref{inf:def:base_typing_rules/arrow/elim}.

    \thmitem{alg:typed_reduction/app_right} If \( M \pred N \) due to \ref{inf:def:lambda_reduction/app_right}, we proceed analogously.

    \thmitem{alg:typed_reduction/abs} If \( M \pred N \) due to \ref{inf:def:typed_reduction_rules/abs}, then \( M = \qabs {x^\sigma} A \) and \( N = \qabs {x^\sigma} B \), where \( A \pred B \). In this case \( \tau = \sigma \synimplies \rho \) for some type \( \rho \).

    Then \( T \) is an application tree for \ref{inf:def:base_typing_rules/arrow/intro/imp} with a subtree \( T_A \) for \( A: \rho \) and discharged assumption \( x: \sigma \).

    We apply the algorithm to \( T_A \) to obtain a tree \( T_B \) deriving \( B: \rho \), and then construct a tree for \( N: \tau \) using \ref{inf:def:base_typing_rules/arrow/intro/imp}.

    \thmitem{alg:typed_reduction/alpha} If \( M \pred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( M \aequiv A \) and \( N \aequiv B \), where \( A \pred B \).

    We use \fullref{alg:typed_alpha_conversion} to construct a tree \( T_A \) deriving \( A: \tau \), and then apply the current algorithm to obtain a tree \( T_B \) deriving \( B: \tau \). Finally, we use \fullref{alg:typed_alpha_conversion} again to construct a tree \( T_N \) for \( N: \tau \).

    \thmitem{alg:typed_reduction/beta} If \( M \pred N \) due to \ref{inf:def:typed_reduction_rules/beta}, then \( M = (\qabs x A)B \) and \( N = A[x \mapsto B] \).

    In this case \( T \) is an application tree for \ref{inf:def:base_typing_rules/arrow/elim}, and its subtrees \( T_X \) and \( T_B \) derive \( \qabs x A: \sigma \synimplies \tau \) and \( B: \sigma \), correspondingly. Furthermore, \( T_X \) is an application tree for \ref{inf:def:base_typing_rules/arrow/intro/imp} with a subtree \( T_A \) for \( A: \tau \) and discharged assumption \( x: \sigma \).

    We have a derivation tree \( T_B \) for \( B: \sigma \) corresponding to the assumption \( x: \sigma \) for \( T_A \). We can thus apply \fullref{alg:typed_substitution} to obtain from \( T_A \) a derivation tree for \( A[x \mapsto B]: \tau \).

    \thmitem{alg:typed_reduction/eta} Finally, if \( M \pred N \) due to \ref{inf:def:typed_reduction_rules/eta}, then \( M = \qabs x N x \), where \( x \) is a variable not free in \( N \).

    In this case \( T \) is an application tree for \ref{inf:def:base_typing_rules/arrow/intro/imp} with a subtree \( T_N \) for \( N: \tau \) and discharged assumption \( x: \sigma \).

    This subtree \( T_N \) is the desired derivation tree for \( N: \tau \).
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.type_derivation.reduction.reduce_derivation} in \cite{notebook:code}.
\end{comments}
\begin{defproof}
  It follows via \fullref{thm:induction_on_recursively_defined_relations} on \( M \pred N \) that the algorithm halts --- we only use it on relation instances for which we assume the inductive hypothesis.
\end{defproof}

\begin{proposition}\label{thm:reduction_typing_rules}
  The following \hyperref[def:simple_typing_rule]{simple typing rules} are \hyperref[con:inference_rule_admissibility]{admissible} with respect to \ref{inf:def:base_typing_rules/arrow/elim} and \ref{inf:def:base_typing_rules/arrow/intro/exp}:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \rightarrow_\beta }]{inf:thm:typed_beta_reduction/beta}
        \begin{prooftree}
          \hypo{ (\qabs {\synx^{\syn\sigma}} \synM) \synN: \syn\tau }
          \hypo{ \synN: \syn\sigma }
          \infer2[\ref{inf:thm:typed_beta_reduction/beta}]{ \synM[\synx \synsubst \synN]: \syn\tau }.
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \leftarrow_\eta }]{inf:thm:typed_eta_reduction/eta}
        \begin{prooftree}
          \hypo{ \synM: \syn\tau \synimplies \syn\sigma }
          \infer1[\ref{inf:thm:typed_eta_reduction/eta}]{ \qabs {\synx^{\syn\tau}} \synM \synx: \syn\tau \synimplies \syn\sigma }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{proposition}
\begin{comments}
  \item Even though \ref{inf:thm:typed_beta_reduction/beta} effectively replaces \ref{inf:def:typed_reduction_rules/beta}, \ref{inf:def:typed_reduction_rules/eta} corresponds to \( \eta \)-expansion rather than \( \eta \)-reduction and is thus inverse to \ref{inf:def:typed_reduction_rules/eta}.

  \item Per the classification of type theory rules described in \fullref{rem:type_theory_rule_classification/computation}, these are computation and uniqueness rules, respectively.

  \item As in \fullref{thm:typed_substitution_assertions}, we note that we have avoided defining schemas for substitutions. We simply state the rules without the ability to completely formalize them since that would complicate us unnecessarily.
\end{comments}
\begin{proof}
  Given a type derivation tree for \( (\qabs {x^\sigma} M) N: \tau \), we can apply \fullref{alg:typed_reduction/beta} to obtain a tree for \( M[x \mapsto N]: \tau \). The assertion \( N: \sigma \) is not necessary; it simply makes explicit that the types of \( x \) and \( N \) coincide.

  The rule \ref{inf:thm:typed_eta_reduction} is more subtle since it corresponds to \( \eta \)-expansion rather than \( \eta \)-reduction. Thus, we cannot use \fullref{alg:typed_reduction}. Fortunately, admissibility can easily be proven directly:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {} { M: \tau \synimplies \sigma }
      \hypo{ x: \sigma }

      \infer2[\ref{inf:def:base_typing_rules/arrow/elim}]{ Mx: \tau }

      \infer[left label=\( x \)]1[\ref{inf:def:base_typing_rules/arrow/intro/exp}]{ \qabs {x^\sigma} Mx: \tau \synimplies \sigma }
    \end{prooftree}
  \end{equation*}
\end{proof}

\paragraph{Normalization}

\begin{definition}\label{def:lambda_term_strong_normalization}
\end{definition}
