\section{Propositional sequent calculus}\label{sec:propositional_sequent_calculus}

\begin{remark}\label{rem:natural_deduction_in_sequent_style}
  We have formalized propositional natural deduction proof trees, with all their intricacies, in \cref{def:propositional_natural_deduction_proof_tree}.

  Then in \cref{def:propositional_natural_deduction_consequence} we have defined a \hyperref[def:consequence_relation]{consequence relation} by letting \( \Gamma \vdash \varphi \) whenever there is a proof tree whose conclusion is \( \varphi \) and whose open assumptions belong to \( \Gamma \).

  \Fullref{thm:recursively_defined_relations} suggests an alternative --- we can use \hyperref[def:inference_rule]{inference rules} whose entries are \hyperref[def:sequent]{sequents} in order to define the relation \( {\vdash} \) directly.

  For example, consider the \hyperref[def:natural_deduction_rule]{natural deduction rule}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\varphi \synvee \syn\psi }

      \hypo{ [\syn\varphi] }
      \infer[dashed]1{ \syn\theta }

      \hypo{ [\syn\psi] }
      \infer[dashed]1{ \syn\theta }

      \infer3[\ensuremath{ \vee_- }]{ \syn\theta }
    \end{prooftree}
  \end{equation*}

  \incite[fig. 2.1]{Mimram2020ProgramEqualsProof} restates the above rule as follows\fnote{In order to explicitly distinguish sequents in a rule from \hyperref[con:judgment]{judgments} in the metalanguage a-la those discussed by Martin-L\"of in \cite[2]{MartinLöf1996LogicalLaws}, in accordance with \cref{rem:mathematical_logic_conventions/terminal_dots}, we put dots over the \hyperref[def:variable_identifier]{capital Greek identifiers} denoting \hyperref[def:logical_context]{logical context placeholders}, as well as over the sequent symbol \( {\synvdash} \). The rule presented can be written linearly (with parenthesized sequents) in accordance with \cref{def:inference_rule} as
  \begin{equation*}
    (\vee_-) (\syn\Gamma \synvdash \syn\varphi \synvee \syn\psi), (\syn\Gamma, \syn\varphi \synvdash \syn\theta), (\syn\Gamma, \syn\psi \synvdash \syn\theta) \synVdash (\syn\Gamma \synvdash \syn\theta)
  \end{equation*}}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma \synvdash \syn\varphi \synvee \syn\psi }
      \hypo{ \syn\Gamma, \syn\varphi \synvdash \syn\theta }
      \hypo{ \syn\Gamma, \syn\psi \synvdash \syn\theta }
      \infer3[\ensuremath{ \vee_- }]{ \syn\Gamma \synvdash \syn\theta }
    \end{prooftree}
  \end{equation*}

  This rule removes the need to handle dischargeable assumptions, with a certain hidden cost. Namely, ensuring that the logical contexts are well-behaved requires some care. This can be achieved by introducing additional rules that allow contexts can be treated like we expect them to --- the so-called \enquote{structural rules} presented \cref{def:abstract_sequent_calculus_system}.

  \incite[\S 2.1.8]{TroelstraSchwichtenberg2000BasicProofTheory} call this \enquote{natural deduction in sequent style}.
\end{remark}

\paragraph{Sequent schemas}

\begin{definition}\label{def:logical_context_schema}\mimprovised
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:logical_context]{logical contexts}:
  \begin{bnf*}
    \bnfprod{context placeholder} {\bnfpn{Capital Greek identifier}} \\
    \bnfprod{nonempty context}    {\bnfpn{context entry schema} \bnfor \bnfpn{context placeholder} \bnfor} \\
    \bnfmore                      {\bnfpn{nonempty context} \bnfsp \bnftsq{,} \bnfsp \bnfpn{nonempty context}} \\
    \bnfprod{empty context}       {\bnfves} \\
    \bnfprod{context}             {\bnfpn{empty context} \bnfor \bnfpn{nonempty context}}
  \end{bnf*}

  We have used the variable identifier rules from \cref{def:variable_identifier}.
\end{definition}

\begin{definition}\label{def:sequent_schema}\mimprovised
  A \term{sequent schema} is simply a \hyperref[def:sequent]{sequent} with \hyperref[def:logical_context_schema]{context schemas}.
\end{definition}

\begin{definition}\label{def:atomic_context_instantiation}
  Consider \hyperref[def:logical_context_schema]{logical context schemas} with a fixed syntax for entities, e.g. \hyperref[def:propositional_formula_schema]{propositional formula schemas} or \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \muplambda \)-term schemas}. We suppose that the entities are schemas and that \hyperref[con:schemas_and_instances]{instantiation} has been defined for them.

  An atomic instantiation for context schemas is then a pair \( \BbbI = (\BbbE, \BbbP) \), where \( \BbbE \) is an instantiation on entries and \( \BbbP \) is another \hyperref[def:set_valued_map/partial]{partial map} that sends context placeholders to \hyperref[def:ordered_tuple]{lists} of entities.
\end{definition}

\begin{algorithm}[Logical context schema instantiation]\label{alg:logical_context_instantiation}
  We can extend an \hyperref[def:atomic_context_instantiation]{atomic logical context instantiation} \( \BbbI = (\BbbE, \BbbP) \) to a compound \hyperref[def:logical_context_schema]{context schema} \( C \) as follows:
  \begin{empheq}[left={C[\BbbI]} \coloneqq \empheqlbrace]{align}
    &\bnfves,                      &&C \T{is empty}                  \label{eq:alg:logical_context_instantiation/empty} \\
    &C[\BbbE],                     &&C \T{is an entry}               \label{eq:alg:logical_context_instantiation/entry} \\
    &C[\BbbP],                     &&C \T{is a context placeholder}, \label{eq:alg:logical_context_instantiation/placeholder} \\
    &D_1[\BbbI] \ldots D_n[\BbbI], &&C = D_1 \ldots D_n.             \label{eq:alg:logical_context_instantiation/list}
  \end{empheq}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_context_schema} in \cite{notebook:code}.
\end{comments}

\paragraph{Abstract sequent calculus}

\begin{definition}\label{def:sequent_calculus_rule}\mimprovised
  A \term{sequent calculus rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[def:sequent_schema]{sequent schemas}.
\end{definition}
\begin{comments}
  \item We do not specify the base entries of the sequents. They may be, for example, \hyperref[def:propositional_formula_schema]{propositional formulas schema} or \hyperref[def:type_assertion]{type assertion schemas}.
\end{comments}

\begin{definition}\label{def:abstract_sequent_calculus_system}
  We define an \term{abstract sequent calculus system} as a collection of \hyperref[def:sequent_calculus_rule]{sequent calculus rules}.

  As discussed in \cref{rem:natural_deduction_in_sequent_style}, auxiliary rules are needed to ensure that contexts can be treated like we expect them to. In his original publication in \cite[192]{Gentzen1935LogischeSchließen}, Gentzen refers to these as \term[ru=структурные правила (\cite[97]{КолмогоровДрагалин2006Логика}), de=Struktur-Schlu\ss{}figuren (\cite[191]{Gentzen1935LogischeSchließen})]{structural rules}, and to other rules as \term[ru=логические правила (\cite[97]{КолмогоровДрагалин2006Логика}), de=Logische-Zeichen-Schlu\ss{}figuren (\cite[191]{Gentzen1935LogischeSchließen})]{logical rules}\fnote{If we are dealing with \hyperref[def:abstract_type_system]{abstract type systems}, it will be more appropriate to call non-structural rules \term{typing rules} instead.}. Additional structural rules may be considered; for example, \ref{inf:def:classical_propositional_sequent_calculus/top/left} and \ref{inf:def:classical_propositional_sequent_calculus/bot/right} for propositional logic.

  The formulations of the structural rules differ from author to authors, but the interaction between them makes the differences irrelevant. Different variations of structural and logical rules are discussed in detail in \cite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

  \begin{thmenum}
    \thmitem{def:abstract_sequent_calculus_system/ax}\mcite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory} The simplest structural rule, assumed implicit by Gentzen, is the \term{axiom rule}
    \begin{equation*}\taglabel[\ensuremath{ \logic{Ax} }]{inf:def:abstract_sequent_calculus_system/ax}
      \begin{prooftree}
        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \syn\varphi \synvdash \syn\varphi }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:abstract_sequent_calculus_system/weak}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} The following are called \term[ru=правила добавления (\cite[217]{КолмогоровДрагалин2006Логика})]{weakening rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Weak}_L }]{inf:def:abstract_sequent_calculus_system/weak/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \syn\Gamma_1, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Weak}_R }]{inf:def:abstract_sequent_calculus_system/weak/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \syn\Delta_2 }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    These can technically be avoided if the other rules are chosen properly.

    \thmitem{def:abstract_sequent_calculus_system/contr}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} The following are called \term[ru=правила сокращения (\cite[218]{КолмогоровДрагалин2006Логика})]{contraction rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Contr}_L }]{inf:def:abstract_sequent_calculus_system/contr/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syn\varphi, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/contr/left}]{ \syn\Gamma_1, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Contr}_R }]{inf:def:abstract_sequent_calculus_system/contr/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\varphi, \syn\Delta_2 }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/contr/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:abstract_sequent_calculus_system/inter}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} The following are called \term[en=interchange rules (\cite[296]{Gentzen1964LogicalDeduction})]{interchange rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Inter}_L }]{inf:def:abstract_sequent_calculus_system/inter/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syn\varphi, \syn\psi, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}]{ \syn\Gamma_1, \syn\psi, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Inter}_R }]{inf:def:abstract_sequent_calculus_system/inter/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\psi, \syn\Delta_2 }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\psi, \syn\varphi, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    These rules must be avoided if the order of entries is significant, like in \hyperref[def:type_context]{type contexts}.

    \thmitem{def:abstract_sequent_calculus_system/cut}\mcite[192]{Gentzen1935LogischeSchließen} Finally, we have the \term[ru=правило сечения (\cite[219]{КолмогоровДрагалин2006Логика})]{cut rule}:
    \begin{equation*}\taglabel[\logic{Cut}]{inf:def:abstract_sequent_calculus_system/cut}
      \begin{prooftree}
        \hypo{ \syn\Gamma_1 \synvdash \syn\Delta_1, \syn\varphi }
        \hypo{ \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta_2 }
        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \syn\Gamma_1, \syn\Gamma_2 \synvdash \syn\Delta_1, \syn\Delta_2 }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}

  If the weakening or contraction rules are not present and not \hyperref[con:inference_rule_admissibility]{admissible}, we refer to the resulting system as \term[en=substructural (\cite[91]{TroelstraSchwichtenberg2000BasicProofTheory})]{substructural}.
\end{definition}

\begin{definition}\label{def:sequent_calculus_proof_tree}\mimprovised
  For a \hyperref[def:abstract_sequent_calculus_system]{sequent calculus system}, proof trees are particularly simple to define, based entirely on \cref{def:proof_tree}.

  We do not need assumption trees. Every tree is thus a rule application tree, whose conclusion is a \hyperref[def:sequent]{sequent} \( \Gamma \synvdash \Delta \).

  Consider the following sequent calculus rule, where all metalingual variables are \hyperref[def:logical_context_schema]{logical context schemas}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ A_1 \synvdash B_1 }
      \hypo{ \cdots }
      \hypo{ A_n \synvdash B_n }
      \infer3[\logic{ R }]{ C \synvdash D }
    \end{prooftree}
  \end{equation*}

  Fix an \hyperref[def:atomic_context_instantiation]{atomic context instantiation} \( \BbbI \). Suppose we already have proof trees \( P_1, \ldots, P_n \) such that, for \( i = 1, \ldots, n \), the conclusion of \( P_i \) is \( A_i[\BbbI] \synvdash B_i[\BbbI] \). Then, as long as our instantiation is defined for \( C \) and \( D \), we can \hyperref[def:ordered_tree_grafting_product]{graft} these premises to a new root whose rule name is \( \logic{R} \) and whose conclusion is \( C[\BbbI] \synvdash D[\BbbI] \).

  As a shorthand, when applying a structural rule multiple times, we will denote it by \( \logic{R}^* \) rather than \( \logic{R} \).
\end{definition}
\begin{comments}
  \item We have distinct formalisms for \hyperref[def:propositional_natural_deduction_proof_tree]{propositional natural deduction proof trees} and \hyperref[def:fol_natural_deduction_proof_tree]{their first-order counterparts}, as well as for \hyperref[def:type_derivation_tree]{type derivation trees}. These intricacies are needed because a rule application relies in nontrivial ways on the premise subtrees.

  Sequent calculus instead does not require such adaptations because the contexts contain all information we may need, and we can simply forbid invalid rule application by making our instantiation algorithm to fail. See \cref{rem:sequent_calculus_eigenvariables} for an example of how we can handle \hyperref[def:fol_natural_deduction_proof_tree/eigenvariables]{eigenvariables}.
\end{comments}

\begin{definition}\label{def:sequent_calculus_consequence}\mimprovised
  For a \hyperref[def:abstract_sequent_calculus_system]{sequent calculus system}, we define a \hyperref[def:consequence_relation]{consequence relation} as follows: we let \( H \vdash \varphi \) if there exists a \hyperref[def:sequent_calculus_proof_tree]{proof tree} whose conclusion is \( \Gamma \synvdash \varphi \), where the entries of the \hi{context} \( \Gamma \) are contained in the \hi{set} \( H \).

  In accordance with \cref{def:general_logic}, we say that \( \varphi \) is \term{derivable} from \( H \) if this relation holds.
\end{definition}
\begin{comments}
  \item With this definition, we try to fit sequent calculus into the wider framework of consequence relations. In particular, through this chapter, we use a distinct notation for the set \( H \) of hypotheses, which is unordered and possibly infinite, and the context \( \Gamma \), which is by definition a list.
\end{comments}
\begin{defproof}
  We must show that \( {\vdash} \) is indeed a consequence relation. We noted that these conditions are modeled on structural rules.

  \SubProofOf[def:consequence_relation/reflexivity]{reflexivity} Follows by applying \ref{inf:def:abstract_sequent_calculus_system/ax}.

  \SubProofOf[def:consequence_relation/monotonicity]{monotonicity} This is trivial considering our definition.

  If \( H \) is finite, we could have required the entries of \( H \) and of \( \Gamma \) to match, and repeatedly apply \ref{inf:def:abstract_sequent_calculus_system/weak/left} if necessary. But if \( H \) is infinite, then a finite list cannot have the same entries.

  \SubProofOf[def:consequence_relation/transitivity]{transitivity} Suppose that \( B, C \vdash \varphi \) and that, for every \( \psi \in B \), we have \( A, C \vdash \psi \).

  Let \( P \) be a tree deriving \( \theta_1, \ldots, \theta_n \synvdash \varphi \), where each \( \theta_k \) is in \( B \cup C \).

  Recursively on \( k = 1, \ldots, n \), we will build a context \( \Gamma_k \) of entries of \( A \cup C \) and a tree \( P_k \) deriving \( \theta_{k+1}, \ldots, \theta_n, \Gamma_k \synvdash \varphi \). Let \( \Gamma_0 \coloneqq \bnfves \) and \( P_0 \coloneqq P \).
  \begin{itemize}
    \item If \( \theta_k \) is in \( C \), simply let \( \Gamma_k \coloneqq \theta_k, \Gamma_{k-1} \) and \( P_k \coloneqq P_{k-1} \).

    \item Otherwise, \( \theta_k \) belongs to \( B \). Let \( R \) be a tree deriving \( \Delta \synvdash \theta_k \), where the entries of \( \Delta \) are in \( A \cup C \).

    Let \( P_k \) be the tree
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis{ \( R \) } { \Delta \synvdash \theta_k }

        \hypo{}
        \ellipsis{ \( P_{k-1} \) } { \theta_k, \theta_{k+1}, \ldots, \theta_n, \Gamma_{k-1} \synvdash \varphi }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Delta, \theta_{k+1}, \ldots, \theta_n, \Gamma_{k-1} \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \theta_{k+1}, \ldots, \theta_n, \Delta, \Gamma_{k-1} \synvdash \varphi }
      \end{prooftree}
    \end{equation*}

    Finally, let \( \Gamma_k \coloneqq \Delta, \Gamma_{k-1} \).
  \end{itemize}
\end{defproof}

\begin{proposition}\label{thm:sequent_calculus_consequence_compact}
  Every \hyperref[def:sequent_calculus_consequence]{sequent calculus consequence relation} is \hyperref[def:consequence_relation/compactness]{compact}.
\end{proposition}
\begin{comments}
  \item This is one of several compactness theorems presented here --- see \cref{rem:logical_compactness_theorems}.
\end{comments}
\begin{proof}
  A context is by definition a finite list.
\end{proof}

\paragraph{Propositional sequent calculus}

\begin{definition}\label{def:classical_propositional_sequent_calculus}\mimprovised
  We present a \hyperref[def:abstract_sequent_calculus_system]{sequent calculus system} for \hyperref[def:propositional_logic]{propositional logic} based on the system \logic{G3c} from \cite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} and on \cite[\S 2.6.2]{Mimram2020ProgramEqualsProof}, extended with rules for biconditional formulas from \cite[289]{Kleene2002Logic}.

  We restrict ourselves to \hyperref[con:classical_logic]{classical logic} here. Unlike for natural deduction, \hyperref[con:intuitionistic_logic]{intuitionistic} and \hyperref[con:minimal_logic]{minimal logic} require nontrivial adaptations.

  \begin{thmenum}
    \thmitem{def:classical_propositional_sequent_calculus/top}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} Rules for the \hyperref[def:propositional_alphabet/constants/verum]{verum}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \top_L }]{inf:def:classical_propositional_sequent_calculus/top/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syntop, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/top/left}]{ \syn\Gamma_1, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \top_R }]{inf:def:classical_propositional_sequent_calculus/top/right}
          \begin{prooftree}
            \infer0[\ref{inf:def:classical_propositional_sequent_calculus/top/right}]{ \Gamma \synvdash \syntop, \Delta }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Since \ref{inf:def:classical_propositional_sequent_calculus/top/left} removes assumptions, we regard it as a structural (and not a logical) rule.

    \thmitem{def:classical_propositional_sequent_calculus/bot}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} Rules for the \hyperref[def:propositional_alphabet/constants/verum]{falsum}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \bot_L }]{inf:def:classical_propositional_sequent_calculus/bot/left}
          \begin{prooftree}
            \infer0[\ref{inf:def:classical_propositional_sequent_calculus/bot/left}]{ \synbot, \Gamma \synvdash \Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \bot_R }]{inf:def:classical_propositional_sequent_calculus/bot/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \synbot, \syn\Delta_2 }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/bot/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    We regard \ref{inf:def:classical_propositional_sequent_calculus/bot/right} as a structural (and not a logical) rule.

    \thmitem{def:classical_propositional_sequent_calculus/negation}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} Rules for \hyperref[def:propositional_alphabet/negation]{negation}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \neg_L }]{inf:def:classical_propositional_sequent_calculus/neg/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/left}]{ \synneg \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \neg_R }]{inf:def:classical_propositional_sequent_calculus/neg/right}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \syn\Gamma \synvdash \syn\Delta, \synneg \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/and}\mcite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for \hyperref[def:propositional_alphabet/connectives/conjunction]{conjunctions}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_L }]{inf:def:classical_propositional_sequent_calculus/and/left}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\psi, \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ (\syn\varphi \synwedge \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_R }]{inf:def:classical_propositional_sequent_calculus/and/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\psi }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/and/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synwedge \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/or}\mcite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for \hyperref[def:propositional_alphabet/connectives/disjunction]{disjunction}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_L }]{inf:def:classical_propositional_sequent_calculus/or/left}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
            \hypo{ \syn\psi, \syn\Gamma \synvdash \syn\Delta }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/or/left}]{ (\syn\varphi \synvee \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_R }]{inf:def:classical_propositional_sequent_calculus/or/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi, \syn\psi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synvee \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/imp}\mcite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for the \hyperref[def:propositional_alphabet/connectives/conditional]{conditional}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \rightarrow_L }]{inf:def:classical_propositional_sequent_calculus/imp/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
            \hypo{ \syn\psi, \syn\Gamma \synvdash \syn\Delta }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/imp/left}]{ (\syn\varphi \synimplies \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \rightarrow_R }]{inf:def:classical_propositional_sequent_calculus/imp/right}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta, \syn\psi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synimplies \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/iff}\mcite[289]{Kleene2002Logic} Rules for the \hyperref[def:propositional_alphabet/connectives/biconditional]{biconditional}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \leftrightarrow_L }]{inf:def:classical_propositional_sequent_calculus/iff/left}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\psi, \syn\Gamma \synimplies \syn\Delta }
            \hypo{ \syn\Gamma \synimplies \syn\Delta, \syn\varphi, \syn\psi }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/iff/left}]{ (\syn\varphi \syniff \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \leftrightarrow_R }]{inf:def:classical_propositional_sequent_calculus/iff/right}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synimplies \syn\Delta, \syn\psi }
            \hypo{ \syn\psi, \syn\Gamma \synimplies \syn\Delta, \syn\varphi }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/iff/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \syniff \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}
  \end{thmenum}
\end{definition}

\begin{example}\label{ex:def:classical_propositional_sequent_calculus}
  We list some examples of using \hyperref[def:classical_propositional_sequent_calculus]{classical propositional sequent calculus}:
  \begin{thmenum}
    \thmitem{ex:def:classical_propositional_sequent_calculus/lem} A simple proof of \fullref{thm:propositional_semantic_lem} in its tautological form \eqref{eq:thm:classical_tautologies/lem} can be given:
    \begin{equation*}
      \begin{prooftree}
        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \synvdash \varphi, \synneg \varphi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \synvdash \varphi \synvee \synneg \varphi }
      \end{prooftree}
    \end{equation*}

    \thmitem{ex:def:classical_propositional_sequent_calculus/proof_tree_non_uniqueness} \incite[\S 4.1.7.2]{Mimram2020ProgramEqualsProof} highlights some inherent subtleties of applying rules when working with \hyperref[def:logical_context]{unordered contexts}. We have designed our proof trees so that they mitigate these issues, but they are easily reproducible in a more informal treatment.

    Consider the natural deduction proof trees
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [\varphi]^u }
            \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \varphi \synimplies \varphi }

            \infer1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \psi \synimplies (\varphi \synimplies \varphi) }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \hypo{ [\varphi]^u }
            \infer1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \psi \synimplies \varphi }

            \infer[left label=\( u \)]1[\ref{inf:def:propositional_natural_deduction/imp/intro}]{ \varphi \synimplies (\psi \synimplies \varphi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    If \( \varphi = \psi \), we obtain two distinct proofs of
    \begin{equation*}
      \varphi \synimplies (\varphi \synimplies \varphi).
    \end{equation*}

    We are able to distinguish them because we mark the discharged assumptions during each rule application. Otherwise, the two proof trees would be identical, but obtained by applying \ref{inf:def:propositional_natural_deduction/imp/intro} to distinct premises.

    The corresponding sequent calculus proofs are
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \synvdash (\varphi \synimplies \varphi) }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \psi \synvdash (\varphi \synimplies \varphi) }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \synvdash \psi \synimplies (\varphi \synimplies \varphi) }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}
          \begin{prooftree}
            \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \psi, \varphi \synvdash \varphi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \varphi \synvdash (\psi \synimplies \varphi) }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \synvdash \varphi \synimplies (\psi \synimplies \varphi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Again, if \( \varphi = \psi \), we obtain two distinct proofs of the same formula.

    It is essential here that we use ordered contexts governed by structural rules. If we were to treat contexts as unordered collections, we would have two distinct cases:
    \begin{itemize}
      \item If \( \varphi = \psi \), the left proof would still be valid, but using the weakening rule in the second proof would be ineffective, and we would only be able to derive
      \begin{equation*}
        \begin{prooftree}
          \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
          \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi \synvdash \varphi }
          \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \synvdash \varphi \synimplies \varphi }
        \end{prooftree}
      \end{equation*}

      As an alternative to treating contexts as lists, Mimram suggests treating them as \hyperref[def:multiset]{multisets}, which would mitigate this concrete issue and derive
      \begin{equation*}
        \synvdash \varphi \synimplies (\varphi \synimplies \varphi).
      \end{equation*}

      \item If either \( \varphi \neq \psi \) or if we were using multisets, applying \ref{inf:def:classical_propositional_sequent_calculus/imp/right} to the sequent
      \begin{equation*}
        \psi, \varphi \synvdash \varphi
      \end{equation*}
      could lead to either
      \begin{equation*}
        \varphi \synvdash \psi \synimplies \varphi
      \end{equation*}
      or
      \begin{equation*}
        \psi \synvdash \varphi \synimplies \varphi.
      \end{equation*}

      Thus, treating contexts as multisets leads to a multiset of proof trees for each application.
    \end{itemize}
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:propositional_sequent_calculus_characterization}
  In \hyperref[def:classical_propositional_sequent_calculus]{classical propositional sequent calculus}, we can derive the sequent
  \begin{equation}\label{eq:thm:propositional_sequent_calculus_characterization/multiple}
    \varphi_1, \ldots, \varphi_n \synvdash \psi_1, \ldots, \psi_n
  \end{equation}
  if and only if we can derive
  \begin{equation}\label{eq:thm:propositional_sequent_calculus_characterization/single}
    \varphi_1 \synwedge \cdots \synwedge \varphi_n \synvdash \psi_1 \synvee \cdots \synvee \psi_n.
  \end{equation}

  We extend this the case \( n = 0 \) by
  \begin{equation}\label{eq:thm:propositional_sequent_calculus_characterization/zero}
    \syntop \synvdash \synbot.
  \end{equation}
\end{proposition}
\begin{proof}
  \SufficiencySubProof Let \( P \) be a tree deriving \eqref{eq:thm:propositional_sequent_calculus_characterization/multiple}. We can transform it into the following:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {\( P \)} { \varphi_1, \ldots, \varphi_n \synvdash \psi_1, \ldots, \psi_n }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/and/left}*]{ \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1, \ldots, \psi_n }
      \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}*]{ \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n }
    \end{prooftree}
  \end{equation*}

  \NecessitySubProof Let \( P \) be a tree deriving \eqref{eq:thm:propositional_sequent_calculus_characterization/single}. We can deconstruct \( P \) to show that it contains a subtree whose conclusion differs from \eqref{eq:thm:propositional_sequent_calculus_characterization/multiple} by applications of structural rules.

  We will instead extend \( P \) to a tree deriving \eqref{eq:thm:propositional_sequent_calculus_characterization/multiple} explicitly. This can serve as a demonstration of \fullref{thm:cut_elimination}.

  The construction we need grows quickly in complexity, so we will only demonstrate it for \( n = 3 \). Let \( R \) be the following tree:
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi_1 \synvdash \varphi_1 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2 \synvdash \varphi_1 }

      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi_2 \synvdash \varphi_2 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2 \synvdash \varphi_2 }

      \infer2[\ref{inf:def:classical_propositional_sequent_calculus/and/right}]{ \varphi_1, \varphi_2 \synvdash \varphi_1 \synwedge \varphi_2 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2, \varphi_3 \synvdash \varphi_1 \synwedge \varphi_2 }

      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi_3 \synvdash \varphi_3 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_2, \varphi_3 \synvdash \varphi_3 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2, \varphi_3 \synvdash \varphi_3 }

      \infer2[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ \varphi_1, \varphi_2, \varphi_3 \synvdash \varphi_1 \synwedge \varphi_2 \synwedge \varphi_3 }
    \end{prooftree}
  \end{equation*}

  We can then combine the two trees:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {\( R \)} { \varphi_1, \cdots, \varphi_n \synvdash \varphi_1 \synwedge \cdots \synwedge \varphi_n }

      \hypo{}
      \ellipsis {\( P \)} { \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n }

      \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \varphi_1, \cdots, \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n }
    \end{prooftree}
  \end{equation*}

  We then similarly unravel the right context using \ref{inf:def:classical_propositional_sequent_calculus/or/left}.
\end{proof}

\begin{proposition}\label{thm:propositional_sequent_calculus_and_natural_deduction}
  A \hyperref[def:propositional_formula]{propositional formula} \( \varphi \) can be derived from \( \Gamma \) in \hyperref[def:propositional_natural_deduction]{classical natural deduction} if and only if it can be derived in \hyperref[def:classical_propositional_sequent_calculus]{classical sequent calculus}.
\end{proposition}
\begin{comments}
  \item We do not state explicit conversion algorithms because some of the transformations are tedious to fully formalize and implement programmatically.
\end{comments}
\begin{proof}
  \SufficiencySubProof Let \( N \) be a \hyperref[def:propositional_natural_deduction_proof_tree]{natural deduction proof tree} deriving \( \varphi \) from \( \Gamma \). We assume here that \( \Gamma \) is an \hyperref[def:logical_context]{ordered logical context}.

  Via \fullref{thm:induction_on_abstract_syntax}, we will build a \hyperref[def:sequent_calculus_proof_tree]{sequent calculus proof tree} \( S \) deriving \( \Gamma \synvdash \varphi \). Let \( N_1, \ldots, N_n \) be the premises of \( N \), and let \( S_1, \ldots, S_n \) be the corresponding sequent calculus proofs obtained from the inductive hypothesis.

  \begin{itemize}
    \item If \( N \) is an assumption tree, we must apply \ref{inf:def:abstract_sequent_calculus_system/ax} to obtain \( S \).

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/top/intro}, we must apply \ref{inf:def:classical_propositional_sequent_calculus/top/right} to obtain \( S \).

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/bot/raa}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma, \synneg \varphi \synvdash \synbot }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/bot/right}]{ \Gamma, \synneg \varphi \synvdash }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \Gamma \synvdash \synneg \synneg \varphi }

        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/left}]{ \synvdash \varphi, \synneg \varphi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \synneg \synneg \varphi \synvdash \varphi }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma \synvdash \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/neg/intro}, the construction is much simpler:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma, \varphi \synvdash \synbot }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/bot/right}]{ \Gamma, \varphi \synvdash }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \Gamma \synvdash \synneg \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/neg/elim}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma \synvdash \synneg \varphi }

        \hypo{}
        \ellipsis {\( S_2 \)} { \Gamma \synvdash \varphi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/left}]{ \synneg \varphi, \Gamma \synvdash }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma, \Gamma \synvdash }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/bot/right}]{ \Gamma, \Gamma \synvdash \synbot }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \Gamma', \Gamma \synvdash \synbot }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/contr/left}*]{ \Gamma \synvdash \synbot }
      \end{prooftree}
    \end{equation*}

    Here \( \Gamma' \) is the reversed list of \( \Gamma \).

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/and/intro}, we must apply \ref{inf:def:classical_propositional_sequent_calculus/and/right} to the recursively obtained subtrees.

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/and/elim_left}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma \synvdash \varphi \synwedge \psi }

        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi, \psi \synvdash \varphi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ \varphi \synwedge \psi \synvdash \varphi }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma \synvdash \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/and/elim_right}, we proceed analogously.

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/or/intro_left}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \Gamma \synvdash \varphi, \psi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \Gamma \synvdash \varphi \synvee \psi }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/or/intro_right}, we proceed analogously.

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/or/elim}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma \synvdash \varphi \synvee \psi }

        \hypo{}
        \ellipsis {\( S_2 \)} { \Gamma, \varphi \synvdash \theta }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \varphi, \Gamma \synvdash \theta }

        \hypo{}
        \ellipsis {\( S_3 \)} { \Gamma, \psi \synvdash \theta }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \psi, \Gamma \synvdash \theta }

        \infer2[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ (\varphi \synvee \psi), \Gamma \synvdash \theta }
        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma, \Gamma \synvdash \theta }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \Gamma', \Gamma \synvdash \theta }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/contr/left}*]{ \Gamma \synvdash \theta }
      \end{prooftree}
    \end{equation*}

    Here \( \Gamma' \) is the reversed list of \( \Gamma \).

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/imp/intro}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma, \varphi \synvdash \psi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \varphi, \Gamma \synvdash \psi }
        \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \Gamma \synvdash \varphi \synimplies \psi }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/imp/elim}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma \synvdash (\varphi \synimplies \psi) }

        \hypo{}
        \ellipsis {\( S_2 \)} { \Gamma \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \Gamma \synimplies \psi, \varphi }

        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \psi \synimplies \psi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}*]{ \psi, \Gamma \synimplies \psi }

        \infer2[\ref{inf:def:classical_propositional_sequent_calculus/imp/left}]{ (\varphi \synimplies \psi), \Gamma \synvdash \psi }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma \synvdash \psi }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/iff/intro}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma, \varphi \synvdash \psi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \varphi, \Gamma \synvdash \psi }

        \hypo{}
        \ellipsis {\( S_2 \)} { \Gamma, \psi \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \psi, \Gamma \synvdash \varphi }

        \infer2[\ref{inf:def:classical_propositional_sequent_calculus/iff/right}]{ \Gamma \synvdash (\varphi \syniff \psi) }
      \end{prooftree}
    \end{equation*}

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/iff/elim_left}, let \( S \) be the following:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( S_1 \)} { \Gamma \synvdash (\varphi \synimplies \psi) }

        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}*]{ \varphi, \psi, \Gamma \synvdash \varphi }

        \hypo{}
        \ellipsis {\( S_2 \)} { \Gamma \synvdash \psi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \Gamma \synvdash \varphi, \varphi, \psi }

        \infer2[\ref{inf:def:classical_propositional_sequent_calculus/iff/left}]{ (\varphi \syniff \psi), \Gamma \synvdash \varphi }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma, \Gamma \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}*]{ \Gamma', \Gamma \synvdash \varphi }
        \infer1[\ref{inf:def:abstract_sequent_calculus_system/contr/left}*]{ \Gamma \synvdash \varphi }
      \end{prooftree}
    \end{equation*}

    Here \( \Gamma' \) is the reversed list of \( \Gamma \).

    \item If \( N \) is an application of \ref{inf:def:propositional_natural_deduction/iff/elim_right}, we proceed analogously.
  \end{itemize}

  \NecessitySubProof Conversely, let \( S \) be a sequent calculus proof tree deriving \( \Gamma \synvdash \Delta \). Denote by \( \Delta^\vee \) the disjunction of the formulas in \( \Delta \), with \( \synbot \) as a fallback in case \( \Delta \) is empty. This is justified by \cref{thm:propositional_sequent_calculus_characterization}.

  Via \fullref{thm:induction_on_abstract_syntax}, we will build a natural deduction proof tree \( N \) deriving \( \Delta^\vee \) from \( \Gamma \). Let \( S_1, \ldots, S_n \) be the premises of \( S \), and let \( N_1, \ldots, N_n \) be the corresponding natural deduction proofs obtained from the inductive hypothesis, with transformations from \cref{thm:propositional_sequent_calculus_characterization} applied to the right side so that

  Using this approach, formally we have to do case analysis on every rule to distinguish cases where the contexts on the right are empty.\fnote{An alternative is to use a different set of sequent calculus rules, where there is exactly one formula on the right of every rule. This is also the approach used for intuitionistic logic. Both are discussed in \cite[ch. 3]{TroelstraSchwichtenberg2000BasicProofTheory}. We avoid it because it would require us to show equivalence of the sequent calculus rules.} We will show such an analysis for the case where \( S \) is an application of \ref{inf:def:abstract_sequent_calculus_system/cut}, and will only consider the simplest cases later on.

  \begin{itemize}
    \item If \( \Delta_1 \) is empty, we want \( N \) to derive \( \Delta_2^\vee \). Since \( N_2 \) derives \( \Delta_2^\vee \) from \( \varphi \), and since \( N_1 \) derives \( \varphi \), we can replace the open assumptions of \( \varphi \) in \( N_2 \) with \( N_1 \).

    \item If \( \Delta_1 \) is not empty but \( \Delta_2 \) is, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Gamma_1 }
        \ellipsis {\( N_1 \)} { \Delta_1^\vee \synvee \varphi }

        \hypo{ [\Delta_1^\vee]^u }

        \hypo{ [\varphi]^v, \Gamma_2 }
        \ellipsis {\( N_2 \)} { \synbot }
        \infer1[\ref{inf:def:propositional_natural_deduction/bot/raa}]{ \Delta_1^\vee }

        \infer[left label={\( u, v \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \Delta_1^\vee }
      \end{prooftree}
    \end{equation*}

    \item If both \( \Delta_1 \) and \( \Delta_2 \) are empty, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Gamma_1 }
        \ellipsis {\( N_1 \)} { \Delta_1^\vee \synvee \varphi }

        \hypo{ [\Delta_1^\vee]^u }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_left}]{ \Delta_1^\vee \synvee \Delta_2^\vee }

        \hypo{ [\varphi]^v, \Gamma_2 }
        \ellipsis {\( N_2 \)} { \Delta_2^\vee }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_right}]{ \Delta_1^\vee \synvee \Delta_2^\vee }

        \infer[left label={\( u, v \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \Delta_1^\vee \synvee \Delta_2^\vee }
      \end{prooftree}
    \end{equation*}
  \end{itemize}

  Not that it is clear how to handle nonempty contexts, we will present a proof for the other rules assuming that the contexts are empty:
  \begin{itemize}
    \item If \( S \) is an application of \ref{inf:def:abstract_sequent_calculus_system/ax}, let \( N \) be the assumption \( [\varphi]^{\synu} \).

    \item In natural deduction, \( \Gamma \) is an unordered context computed from the undischarged hypotheses of the proof tree. So, if \( S \) is an application of \ref{inf:def:abstract_sequent_calculus_system/weak/left}, \ref{inf:def:abstract_sequent_calculus_system/contr/left} or \ref{inf:def:abstract_sequent_calculus_system/inter/left}, simply let \( N \coloneqq N_1 \).

    \item If \( S \) is an application of \ref{inf:def:abstract_sequent_calculus_system/weak/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( N_1 \)} { \synbot }
        \infer1[\ref{inf:def:propositional_natural_deduction/bot/raa}]{ \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:abstract_sequent_calculus_system/contr/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( N_1 \)} { \varphi \synvee \varphi }

        \hypo{ [\varphi]^u }
        \hypo{ [\varphi]^v }
        \infer[left label={\( u, v \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:abstract_sequent_calculus_system/inter/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( N_1 \)} { \varphi \synvee \psi }

        \hypo{ [\psi]^u }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_left}]{ \psi \synvee \varphi }

        \hypo{ [\varphi]^v }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_right}]{ \psi \synvee \varphi }

        \infer[left label={\( u, v \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \psi \synvee \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/top/left}, to obtain \( N \) we can replace any assumption for \( \syntop \) in \( N_1 \) with an application of \ref{inf:def:propositional_natural_deduction/top/intro}.

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/top/right}, let \( N \) be an application of \ref{inf:def:propositional_natural_deduction/top/intro}.

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/bot/left}, we suppose that all contexts are nonempty since otherwise the construction becomes meaningless. Let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Gamma_1 }
        \ellipsis {\( N_1 \)} { \Delta_1^\vee \synvee \varphi }

        \hypo{ [\Delta_1^\vee]^u }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_left}]{ \Delta_1^\vee \synvee \Delta_2^\vee }

        \hypo{ [\varphi]^v, \Gamma_2 }
        \ellipsis {\( N_2 \)} { \Delta_2^\vee }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_right}]{ \Delta_1^\vee \synvee \Delta_2^\vee }

        \infer[left label={\( u, v \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \Delta_1^\vee \synvee \Delta_2^\vee }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/bot/right}, we suppose that all contexts are nonempty since otherwise the construction becomes meaningless. Let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \Gamma }
        \ellipsis {\( N_1 \)} { \Delta_1^\vee \synvee \synbot \synvee \Delta_2^\vee }

        \hypo{ [\Delta_1^\vee]^u }
        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_left}]{ \Delta_1^\vee \synvee \Delta_2^\vee }

        \hypo{ [\synbot \synvee \Delta_2^\vee]^v }
        \hypo{ [\synbot]^w }
        \infer1[\ref{inf:def:propositional_natural_deduction/bot/raa}]{ \Delta_2^\vee }
        \hypo{ [\Delta_2^\vee]^x }
        \infer[left label={\( w, x \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \Delta_2^\vee }

        \infer1[\ref{inf:def:propositional_natural_deduction/or/intro_right}]{ \Delta_1^\vee \synvee \Delta_2^\vee }

        \infer[left label={\( u, v \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \Delta_1^\vee \synvee \Delta_2^\vee }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/neg/left}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\synneg \varphi]^v }
        \hypo{}
        \ellipsis {\( N_1 \)} { \varphi }
        \infer2[\ref{inf:def:propositional_natural_deduction/neg/elim}]{ \synbot }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/neg/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi]^u }
        \ellipsis {\( N_1 \)} { \synbot }
        \infer[left label={\( u \)}]1[\ref{inf:def:propositional_natural_deduction/neg/intro}]{ \synneg \varphi }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/and/left}, we want \( N \) to derive \( \synbot \) from \( \varphi \synwedge \psi \). Since \( N_1 \) derives \( \synbot \) from \( \varphi, \psi \), it is sufficient to replace every open assumption of \( \varphi \) with
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi \synvee \psi]^u }
        \infer1[\ref{inf:def:propositional_natural_deduction/and/elim_left}]{ \varphi }
      \end{prooftree}
    \end{equation*}
    and similarly for \( \psi \).

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/and/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( N_1 \)} { \varphi }

        \hypo{}
        \ellipsis {\( N_2 \)} { \psi }

        \infer2[\ref{inf:def:propositional_natural_deduction/and/intro}]{ \varphi \synwedge \psi }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/or/left}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi \synvee \psi]^u }

        \hypo{ [\varphi]^v }
        \ellipsis {\( N_1 \)} { \synbot }

        \hypo{ [\psi]^w }
        \ellipsis {\( N_1 \)} { \synbot }

        \infer[left label={\( v, w \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \synbot }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/or/right}, then \( N_1 \) already derives \( \varphi \synvee \psi \) due to our convention of treating contexts like disjunctions.

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/imp/left}, let \( N' \) be the auxiliary
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi \synimplies \psi]^u }

        \hypo{}
        \ellipsis {\( N_1 \)} { \varphi }

        \infer2[\ref{inf:def:propositional_natural_deduction/imp/elim}]{ \psi }
      \end{prooftree}
    \end{equation*}

    Let \( N \) is \( N_2 \) with every assumption \( \psi \) modified with \( N' \).

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/imp/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi]^u }
        \ellipsis {\( N_1 \)} { \psi }
        \infer[left label={\( u \)}]1[\ref{inf:def:propositional_natural_deduction/imp/elim}]{ \varphi \synimplies \psi }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/iff/left}, we will need several auxiliary trees.

    Let \( N_1^{L'} \) be \( N_1 \) where every open assumption \( [\varphi]^w \) is replaced by
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi \syniff \psi]^u }
        \hypo{ [\psi]^v }
        \infer2[\ref{inf:def:propositional_natural_deduction/iff/elim_left}]{ \varphi }
      \end{prooftree}
    \end{equation*}

    Dually, let \( N_1^{R'} \) be \( N_1 \) with every open assumption \( [\psi]^v \) replaced by
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi \syniff \psi]^u }
        \hypo{ [\varphi]^w }
        \infer2[\ref{inf:def:propositional_natural_deduction/iff/elim_right}]{ \psi }
      \end{prooftree}
    \end{equation*}

    Let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {\( N_2 \)} { \varphi \synvee \psi }

        \hypo{ [\varphi \syniff \psi]^u, [\psi]^v }
        \ellipsis {\( N_1^{L'} \)} { \synbot }

        \hypo{ [\varphi \syniff \psi]^u, [\varphi]^w }
        \ellipsis {\( N_1^{R'} \)} { \synbot }

        \infer[left label={\( v, w \)}]3[\ref{inf:def:propositional_natural_deduction/or/elim}]{ \synbot }
      \end{prooftree}
    \end{equation*}

    \item If \( S \) is an application of \ref{inf:def:classical_propositional_sequent_calculus/iff/right}, let \( N \) be
    \begin{equation*}
      \begin{prooftree}
        \hypo{ [\varphi]^u }
        \ellipsis {\( N_1 \)} { \psi }

        \hypo{ [\psi]^v }
        \ellipsis {\( N_2 \)} { \varphi }

        \infer[left label={\( u, v \)}]2[\ref{inf:def:propositional_natural_deduction/iff/intro}]{ \varphi \syniff \psi }
      \end{prooftree}
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{theorem}[Classical propositional sequent calculus soundness]\label{thm:classical_propositional_sequent_calculus_soundness}
  \hyperref[def:classical_propositional_sequent_calculus]{Classical propositional sequent calculus} is \hyperref[def:general_logic]{sound} with respect to \hyperref[def:truth_value_algebra/classical]{classical semantics}.
\end{theorem}
\begin{comments}
  \item See \cref{rem:soundness_and_completeness_theorem_list} for a list of soundness and completeness theorems.
\end{comments}
\begin{proof}
  Follows from \fullref{thm:propositional_natural_deduction_soundness} via \cref{thm:propositional_sequent_calculus_and_natural_deduction}.
\end{proof}

\begin{theorem}[Propositional sequent calculus deduction theorem]\label{thm:propositional_sequent_calculus_deduction_theorem}
  For \hyperref[def:classical_propositional_sequent_calculus]{classical propositional sequent calculus}, we have
  \begin{equation*}
    \Gamma, \varphi \vdash \psi \T{if and only if} \Gamma \vdash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item This is one of several deduction theorems presented here --- see \cref{rem:deduction_theorem_list}.
\end{comments}
\begin{proof}
  \SufficiencySubProof Follows by an application of \ref{inf:def:classical_propositional_sequent_calculus/imp/right}.

  \NecessitySubProof Let \( P \) be a tree deriving \( \Gamma \synvdash (\varphi \synimplies \psi) \). Then we can construct
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {\( P \)} { \Gamma \synvdash (\varphi \synimplies \psi) }

      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi \synvdash \varphi }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \varphi \synvdash \psi, \varphi }

      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \psi \synvdash \psi }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \psi, \varphi \synvdash \psi }

      \infer2[\ref{inf:def:classical_propositional_sequent_calculus/imp/left}]{ (\varphi \synimplies \psi), \varphi \synvdash \psi }

      \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Gamma, \varphi \synvdash \psi }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{theorem}[Cut elimination]\label{thm:cut_elimination}
  The rule \ref{inf:def:abstract_sequent_calculus_system/cut} is \hyperref[con:inference_rule_admissibility]{admissible} with respect to the other rules of \hyperref[def:classical_propositional_sequent_calculus]{classical propositional sequent calculus}.
\end{theorem}
\begin{comments}
  \item Gerhard Gentzen introduced this theorem as \enquote{Hauptsatz} in \cite{Gentzen1935LogischeSchließen}. An extensive discussion is given in \cite[ch. 4]{TroelstraSchwichtenberg2000BasicProofTheory}. We will not prove the theorem since it requires extensive case analysis, but we will briefly justify it.

  The rules of propositional sequent calculus only allow producing longer formulas (unlike, for example, \ref{inf:def:axiomatic_derivation_as_natural_deduction/mp}). When translating the elimination rules of natural deduction in \cref{thm:propositional_sequent_calculus_and_natural_deduction}, we saw that, if \( \psi \) is a subformula of \( \varphi \), transforming a proof tree of \( \Gamma \synvdash \varphi \) into a proof tree of \( \Gamma \synvdash \psi \) amounts to deriving \( \varphi \synvdash \psi \) and applying \ref{inf:def:abstract_sequent_calculus_system/cut}. Similar usage of cuts can be found in \fullref{thm:propositional_sequent_calculus_deduction_theorem} and \cref{thm:propositional_sequent_calculus_characterization}.

  It is however also possible to construct a proof tree for \( \Gamma \synvdash \psi \) by cherry-picking rule applications from the proof tree for \( \Gamma \synvdash \varphi \). The generalization and systematization of this process is called cut elimination.
\end{comments}
