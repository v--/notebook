\section{Propositional sequent calculus}\label{sec:propositional_sequent_calculus}

\begin{remark}\label{rem:natural_deduction_in_sequent_style}
  We have formalized propositional natural deduction proof trees, with all their intricacies, in \cref{def:propositional_natural_deduction_proof_tree}.

  Then in \cref{def:propositional_natural_deduction_consequence} we have defined a \hyperref[def:consequence_relation]{consequence relation} by letting \( \Gamma \vdash \varphi \) whenever there is a proof tree whose conclusion is \( \varphi \) and whose open assumptions belong to \( \Gamma \).

  \Fullref{thm:recursively_defined_relations} suggests an alternative --- we can use \hyperref[def:inference_rule]{inference rules} whose entries are \hyperref[def:sequent]{sequents} in order to define the relation \( {\vdash} \) directly.

  For example, consider the \hyperref[def:axiomatic_derivation_as_natural_deduction/mp]{modus ponens} \hyperref[def:natural_deduction_rule]{natural deduction rule}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\varphi \synvee \syn\psi }

      \hypo{ [\syn\varphi] }
      \infer[dashed]1{ \syn\theta }

      \hypo{ [\syn\psi] }
      \infer[dashed]1{ \syn\theta }

      \infer3[\ensuremath{ \vee_- }]{ \syn\theta }
    \end{prooftree}
  \end{equation*}

  \incite[fig. 2.1]{Mimram2020ProgramEqualsProof} restates the above rule as follows\fnote{In order to explicitly distinguish sequents in a rule from \hyperref[con:judgment]{judgments} in the metalanguage a-la those discussed by Martin-L\"of in \cite[2]{MartinLöf1996LogicalLaws}, in accordance with \cref{rem:mathematical_logic_conventions/terminal_dots}, we put dots over the \hyperref[def:variable_identifier]{capital Greek identifiers} denoting \hyperref[def:logical_context]{logical context placeholders}, as well as over the sequent symbol \( {\synvdash} \). The rule presented can be written linearly (with parenthesized sequents) in accordance with \cref{def:inference_rule} as
  \begin{equation*}
    (\vee_-) (\syn\Gamma \synvdash \syn\varphi \synvee \syn\psi), (\syn\Gamma, \syn\varphi \synvdash \syn\theta), (\syn\Gamma, \syn\psi \synvdash \syn\theta) \synVdash (\syn\Gamma \synvdash \syn\theta)
  \end{equation*}}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma \synvdash \syn\varphi \synvee \syn\psi }
      \hypo{ \syn\Gamma, \syn\varphi \synvdash \syn\theta }
      \hypo{ \syn\Gamma, \syn\psi \synvdash \syn\theta }
      \infer3[\ensuremath{ \vee_- }]{ \syn\Gamma \synvdash \syn\theta }
    \end{prooftree}
  \end{equation*}

  This rule removes the need to handle dischargeable assumptions, with a certain hidden cost. Namely, ensuring that the logical contexts are well-behaved requires some care. This can be achieved by introducing additional rules modeling the set-based or list-valued instantiation presented in \cref{def:logical_context_semantics} --- the so-called \enquote{structural rules} presented \cref{def:abstract_sequent_calculus_system}.

  \incite[\S 2.1.8]{TroelstraSchwichtenberg2000BasicProofTheory} call this \enquote{natural deduction in sequent style}.
\end{remark}

\paragraph{Sequent schemas}

\begin{definition}\label{def:logical_context_schema}\mimprovised
  A \term{logical context} is a syntactic list generated by the corresponding grammar rule from the \hyperref[def:formal_grammar/schema]{schema}
  \begin{bnf*}
    \bnfprod{context placeholder} {\bnfpn{Capital Greek identifier}} \\
    \bnfprod{nonempty context}    {\bnfpn{context entry schema} \bnfor \bnfpn{context placeholder} \bnfor} \\
    \bnfmore                      {\bnfpn{nonempty context} \bnfsp \bnftsq{,} \bnfsp \bnfpn{nonempty context}} \\
    \bnfprod{empty context}       {\bnfves} \\
    \bnfprod{context}             {\bnfpn{empty context} \bnfor \bnfpn{nonempty context}}
  \end{bnf*}

  We have used the variable identifier rules from \cref{def:variable_identifier}.
\end{definition}

\begin{definition}\label{def:sequent_schema}\mimprovised
  A \term{sequent schema} is simply a \hyperref[def:sequent]{sequent} with \hyperref[def:logical_context_schema]{context schemas} rather than contexts.
\end{definition}

\begin{definition}\label{def:atomic_context_instantiation}
  Consider \hyperref[def:logical_context_schema]{logical context schemas} with a fixed syntax for entities, e.g. \hyperref[def:propositional_formula_schema]{propositional formula schemas} or \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \muplambda \)-term schemas}. We suppose that the entities are schemas and that \hyperref[con:schemas_and_instances]{instantiation} has been defined for them.

  An atomic instantiation for context schemas is then a pair \( \BbbI = (\BbbE, \BbbP) \), where \( \BbbE \) is an instantiation on entries and \( \BbbP \) is another \hyperref[def:set_valued_map/partial]{partial map} that sends context placeholders to \hyperref[def:ordered_tuple]{lists} of entities.
\end{definition}

\begin{algorithm}[Logical context schema instantiation]\label{alg:logical_context_instantiation}
  We can extend an \hyperref[def:atomic_context_instantiation]{atomic logical context instantiation} \( \BbbI = (\BbbE, \BbbP) \) to a compound \hyperref[def:logical_context_schema]{context schema} \( C \) as follows:
  \begin{empheq}[left={C[\BbbI]} \coloneqq \empheqlbrace]{align}
    &\bnfves,                      &&C \T{is empty}                  \label{eq:alg:logical_context_instantiation/empty} \\
    &C[\BbbE],                     &&C \T{is an entry}               \label{eq:alg:logical_context_instantiation/entry} \\
    &C[\BbbP],                     &&C \T{is a context placeholder}, \label{eq:alg:logical_context_instantiation/placeholder} \\
    &D_1[\BbbI] \ldots D_n[\BbbI], &&C = D_1 \ldots D_n.             \label{eq:alg:logical_context_instantiation/list}
  \end{empheq}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.instantiation.instantiate_context_schema} in \cite{notebook:code}.
\end{comments}

\paragraph{Abstract sequent calculus}

\begin{definition}\label{def:sequent_calculus_rule}\mimprovised
  A \term{sequent calculus rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[def:sequent_schema]{sequent schemas}.
\end{definition}
\begin{comments}
  \item We do not specify the base entries of the sequents. They may be, for example, \hyperref[def:propositional_formula_schema]{propositional formulas schema} or \hyperref[def:type_assertion]{type assertion schemas}.
\end{comments}

\begin{definition}\label{def:abstract_sequent_calculus_system}
  We define an \term{abstract sequent calculus system} as a collection of \hyperref[def:sequent_calculus_rule]{sequent calculus rules}.

  As discussed in \cref{rem:natural_deduction_in_sequent_style}, auxiliary rules are needed to ensure that contexts can be treated like we expect them to. In his original publication in \cite[192]{Gentzen1935LogischeSchließen}, Gentzen refers to these as \term[ru=структурные правила (\cite[97]{КолмогоровДрагалин2006Логика}), de=Struktur-Schlu\ss{}figuren (\cite[191]{Gentzen1935LogischeSchließen})]{structural rules}, and to other rules as \term[ru=логические правила (\cite[97]{КолмогоровДрагалин2006Логика}), de=Logische-Zeichen-Schlu\ss{}figuren (\cite[191]{Gentzen1935LogischeSchließen})]{logical rules}\fnote{If we are dealing with \hyperref[def:abstract_type_system]{abstract type systems}, it will be more appropriate to call non-structural rules \term{typing rules} instead.}. Additional structural rules may be considered; for example, \ref{inf:def:classical_propositional_sequent_calculus/top/left} and \ref{inf:def:classical_propositional_sequent_calculus/bot/right} for propositional logic.

  The same structural rules differ from author to authors, but the interaction between them makes the differences irrelevant. Different variations of structural and logical rules are discussed in detail in \cite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

  \begin{thmenum}
    \thmitem{def:abstract_sequent_calculus_system/ax}\mcite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory} The simplest structural rule, assumed implicit by Gentzen, is the \term{axiom rule}
    \begin{equation*}\taglabel[\ensuremath{ \logic{Ax} }]{inf:def:abstract_sequent_calculus_system/ax}
      \begin{prooftree}
        \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \syn\varphi \synvdash \syn\varphi }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:abstract_sequent_calculus_system/weak}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} The following are called \term[ru=правила добавления (\cite[217]{КолмогоровДрагалин2006Логика})]{weakening rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Weak}_L }]{inf:def:abstract_sequent_calculus_system/weak/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \syn\Gamma_1, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Weak}_R }]{inf:def:abstract_sequent_calculus_system/weak/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \syn\Delta_2 }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    These can be avoided if the other rules are chosen properly.

    \thmitem{def:abstract_sequent_calculus_system/contract}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} The following are called \term[ru=правила сокращения (\cite[218]{КолмогоровДрагалин2006Логика})]{contraction rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Contr}_L }]{inf:def:abstract_sequent_calculus_system/contract/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syn\varphi, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/contract/left}]{ \syn\Gamma_1, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Contr}_R }]{inf:def:abstract_sequent_calculus_system/contract/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\varphi, \syn\Delta_2 }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/contract/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:abstract_sequent_calculus_system/inter}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} The following are called \term[en=interchange rules (\cite[296]{Gentzen1964LogicalDeduction})]{interchange rules}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Inter}_L }]{inf:def:abstract_sequent_calculus_system/inter/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syn\varphi, \syn\psi, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}]{ \syn\Gamma_1, \syn\psi, \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \logic{Inter}_R }]{inf:def:abstract_sequent_calculus_system/inter/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \syn\varphi, \syn\psi, \syn\Delta_2 }
            \infer1[\ref{inf:def:abstract_sequent_calculus_system/inter/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\psi, \syn\varphi, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    These rules must be avoided if the order of entries is significant, like in \hyperref[def:type_context]{type contexts}.

    \thmitem{def:abstract_sequent_calculus_system/cut}\mcite[192]{Gentzen1935LogischeSchließen} Finally, we have the \term[ru=правило сечения (\cite[219]{КолмогоровДрагалин2006Логика})]{cut rule}:
    \begin{equation*}\taglabel[\logic{Cut}]{inf:def:abstract_sequent_calculus_system/cut}
      \begin{prooftree}
        \hypo{ \syn\Gamma_1 \synvdash \syn\Delta_1, \syn\varphi }
        \hypo{ \syn\varphi, \syn\Gamma_2 \synvdash \syn\Delta_2 }
        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \syn\Gamma_1, \syn\Gamma_2 \synvdash \syn\Delta_1, \syn\Delta_2 }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}

  If the weakening or contraction rules are not present and not \hyperref[con:admissible_inference_rule]{admissible}, we refer to the resulting system as \term[en=substructural (\cite[91]{TroelstraSchwichtenberg2000BasicProofTheory})]{substructural}.
\end{definition}

\begin{definition}\label{def:sequent_calculus_proof_tree}\mimprovised
  For a \hyperref[def:abstract_sequent_calculus_system]{sequent calculus system}, proof trees are particularly simple to define, based entirely on \cref{con:proof_tree}.

  We do not need assumption trees. Every tree is thus a rule application tree, whose conclusion is a \hyperref[def:sequent]{sequent} \( \Gamma \synvdash \Delta \).

  Consider the following sequent calculus rule, where all metalingual variables are \hyperref[def:logical_context_schema]{logical context schemas}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ A_1 \synvdash B_1 }
      \hypo{ \cdots }
      \hypo{ A_n \synvdash B_n }
      \infer3[\logic{ R }]{ C \synvdash D }
    \end{prooftree}
  \end{equation*}

  Fix an \hyperref[def:atomic_context_instantiation]{atomic context instantiation} \( \BbbI \). Suppose we already have proof trees \( P_1, \ldots, P_n \) such that, for \( i = 1, \ldots, n \), the conclusion of \( P_i \) is \( A_i[\BbbI] \synvdash B_i[\BbbI] \). Then, as long as our instantiation is defined for \( C \) and \( D \), we can \hyperref[def:ordered_tree_grafting_product]{graft} these premises to a new root whose rule name is \( \logic{R} \) and whose conclusion is \( C[\BbbI] \synvdash D[\BbbI] \).
\end{definition}
\begin{comments}
  \item We have distinct formalisms for \hyperref[def:propositional_natural_deduction_proof_tree]{propositional natural deduction proof trees} and \hyperref[def:fol_natural_deduction_proof_tree]{their first-order counterparts}, as well as for \hyperref[def:type_derivation_tree]{type derivation trees}.

  Sequent calculus instead does not require such adaptations. For example, as described in \cref{def:abstract_sequent_calculus_system_eigenvariables}, the eigenvariable conditions can be captured by the formalism presented in this definition.
\end{comments}

\begin{definition}\label{def:sequent_calculus_consequence}\mimprovised
  For a \hyperref[def:abstract_sequent_calculus_system]{sequent calculus system}, we define a \hyperref[def:consequence_relation]{consequence relation} as follows: we let \( H \vdash \varphi \) if there exists a \hyperref[def:sequent_calculus_proof_tree]{proof tree} whose conclusion is \( \Gamma \synvdash \varphi \), where the entries of the \hi{context} \( \Gamma \) are contained in the \hi{set} \( H \).

  In accordance with \cref{def:general_logic}, we say that \( \varphi \) is \term{derivable} from \( H \) if this relation holds.
\end{definition}
\begin{comments}
  \item With this definition, we try to fit sequent calculus into the wider framework of consequence relations. In particular, through this chapter, we use a distinct notation for the set \( H \) of hypotheses, which is unordered and possibly infinite, and the context \( \Gamma \), which is by definition a list.
\end{comments}
\begin{defproof}
  We must show that \( {\vdash} \) is indeed a consequence relation. We noted that these conditions are modeled on structural rules.

  \SubProofOf[def:consequence_relation/reflexivity]{reflexivity} Follows by applying \ref{inf:def:abstract_sequent_calculus_system/ax}.

  \SubProofOf[def:consequence_relation/monotonicity]{monotonicity} This is trivial considering our definition.

  If \( H \) is finite, we could have required the entries of \( H \) and of \( \Gamma \) to match, and repeatedly apply \ref{inf:def:abstract_sequent_calculus_system/weak/left} if necessary. But if \( H \) is infinite, then a finite list cannot have the same entries.

  \SubProofOf[def:consequence_relation/transitivity]{transitivity} Suppose that \( B, C \vdash \varphi \) and that, for every \( \psi \in B \), we have \( A, C \vdash \psi \).

  Let \( P \) be a tree deriving \( \theta_1, \ldots, \theta_n \synvdash \varphi \), where each \( \theta_k \) is in \( B \cup C \).

  Recursively on \( k = 1, \ldots, n \), we will build a context \( \Gamma_k \) of entries of \( A \cup C \) and a tree \( P_k \) deriving \( \theta_{k+1}, \ldots, \theta_n, \Gamma_k \synvdash \varphi \). Let \( \Gamma_0 \coloneqq \bnfves \) and \( P_0 \coloneqq P \).
  \begin{itemize}
    \item If \( \theta_k \) is in \( C \), simply let \( \Gamma_k \coloneqq \theta_k, \Gamma_{k-1} \) and \( P_k \coloneqq P_{k-1} \).

    \item Otherwise, \( \theta_k \) belongs to \( B \). Let \( R \) be a tree deriving \( \Delta \synvdash \theta_k \), where the entries of \( \Delta \) are in \( A \cup C \).

    Let \( P_k \) be the tree
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis{ \( R \) } { \Delta \synvdash \theta_k }

        \hypo{}
        \ellipsis{ \( P_{k-1} \) } { \theta_k, \theta_{k+1}, \ldots, \theta_n, \Gamma_{k-1} \synvdash \varphi }

        \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \Delta, \theta_{k+1}, \ldots, \theta_n, \Gamma_{k-1} \synvdash \varphi }
        \infer[left label={Repeated}]1[\ref{inf:def:abstract_sequent_calculus_system/inter/left}]{ \theta_{k+1}, \ldots, \theta_n, \Delta, \Gamma_{k-1} \synvdash \varphi }
      \end{prooftree}
    \end{equation*}

    Finally, let \( \Gamma_k \coloneqq \Delta, \Gamma_{k-1} \).
  \end{itemize}
\end{defproof}

\begin{proposition}\label{thm:sequent_calculus_consequence_compact}
  Every \hyperref[def:sequent_calculus_consequence]{sequent calculus consequence relation} is \hyperref[def:consequence_relation/compactness]{compact}.
\end{proposition}
\begin{comments}
  \item This is one of several compactness theorems presented here --- see \cref{rem:logical_compactness_theorems}.
\end{comments}
\begin{proof}
  A context is by definition a finite list.
\end{proof}

\paragraph{Propositional sequent calculus}

\begin{definition}\label{def:classical_propositional_sequent_calculus}\mimprovised
  We present a \hyperref[def:sequent_calculus_system]{sequent calculus system} for  \hyperref[def:propositional_logic]{propositional logic} based on \logic{G3c} from \cite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory}, with some additional rules from \cite[\S 2.6.2]{Mimram2020ProgramEqualsProof}.

  We restrict ourselves to \hyperref[con:classical_logic]{classical logic} here. Unlike for natural deduction, \hyperref[con:intuitionistic_logic]{intuitionistic} and \hyperref[con:minimal_logic]{minimal logic} require nontrivial adaptations.

  \begin{thmenum}
    \thmitem{def:classical_propositional_sequent_calculus/top} Rules for the \hyperref[def:propositional_alphabet/constants/verum]{verum}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \top_L }]{inf:def:classical_propositional_sequent_calculus/top/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma_1, \syntop, \syn\Gamma_2 \synvdash \syn\Delta }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/top/left}]{ \syn\Gamma_1, \syn\Gamma_2 \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \top_R }]{inf:def:classical_propositional_sequent_calculus/top/right}
          \begin{prooftree}
            \infer0[\ref{inf:def:classical_propositional_sequent_calculus/top/right}]{ \synvdash \syntop }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    Since \ref{inf:def:classical_propositional_sequent_calculus/top/left} modifies the structure of sequents, we regard it as a structural (and not a logical) rule.

    \thmitem{def:classical_propositional_sequent_calculus/bot} Rules for the \hyperref[def:propositional_alphabet/constants/verum]{falsum}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \bot_L }]{inf:def:classical_propositional_sequent_calculus/bot/left}
          \begin{prooftree}
            \infer0[\ref{inf:def:classical_propositional_sequent_calculus/bot/left}]{ \synbot \synvdash }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \bot_R }]{inf:def:classical_propositional_sequent_calculus/bot/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta_1, \synbot, \syn\Delta_2 }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/bot/right}]{ \syn\Gamma \synvdash \syn\Delta_1, \syn\Delta_2 }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    We regard \ref{inf:def:classical_propositional_sequent_calculus/bot/right} as a structural (and not a logical) rule.

    \thmitem{def:classical_propositional_sequent_calculus/negation}\mcite[\S 2.6.2]{Mimram2020ProgramEqualsProof} Rules for \hyperref[def:propositional_alphabet/negation]{negation}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \neg_L }]{inf:def:classical_propositional_sequent_calculus/neg/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/left}]{ \synneg \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \neg_R }]{inf:def:classical_propositional_sequent_calculus/neg/right}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/neg/right}]{ \syn\Gamma \synvdash \syn\Delta, \synneg \syn\varphi }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/and}\mcite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for \hyperref[def:propositional_alphabet/connectives/conjunction]{conjunctions}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_L }]{inf:def:classical_propositional_sequent_calculus/and/left}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\psi, \syn\Gamma \synvdash \syn\Delta }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ (\syn\varphi \synwedge \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \wedge_R }]{inf:def:classical_propositional_sequent_calculus/and/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\psi }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/and/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synwedge \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/or}\mcite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for \hyperref[def:propositional_alphabet/connectives/disjunction]{disjunction}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_L }]{inf:def:classical_propositional_sequent_calculus/or/left}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta }
            \hypo{ \syn\psi, \syn\Gamma \synvdash \syn\Delta }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/or/left}]{ (\syn\varphi \synvee \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \vee_R }]{inf:def:classical_propositional_sequent_calculus/or/right}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi, \syn\psi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synvee \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    \thmitem{def:classical_propositional_sequent_calculus/imp}\mcite[def. 3.5.1]{TroelstraSchwichtenberg2000BasicProofTheory} Rules for \hyperref[def:propositional_alphabet/connectives/conditional]{conditional}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \rightarrow_L }]{inf:def:classical_propositional_sequent_calculus/imp/left}
          \begin{prooftree}
            \hypo{ \syn\Gamma \synvdash \syn\Delta, \syn\varphi }
            \hypo{ \syn\psi, \syn\Gamma \synvdash \syn\Delta }
            \infer2[\ref{inf:def:classical_propositional_sequent_calculus/imp/left}]{ (\syn\varphi \synimplies \syn\psi), \syn\Gamma \synvdash \syn\Delta }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \ParacolAlignmentHack
        \begin{equation*}\taglabel[\ensuremath{ \rightarrow_R }]{inf:def:classical_propositional_sequent_calculus/imp/right}
          \begin{prooftree}
            \hypo{ \syn\varphi, \syn\Gamma \synvdash \syn\Delta, \syn\psi }
            \infer1[\ref{inf:def:classical_propositional_sequent_calculus/imp/right}]{ \syn\Gamma \synvdash \syn\Delta, (\syn\varphi \synimplies \syn\psi) }
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The systems are mostly based on Gentzen's, with the following additions:
  \begin{itemize}
    \item The additional structural rules \ref{inf:def:classical_propositional_sequent_calculus/top/left} and \ref{inf:def:classical_propositional_sequent_calculus/bot/right} are based on \bycite[fig. 2.9]{Mimram2020ProgramEqualsProof}.

    \item The rule \ref{inf:def:classical_propositional_sequent_calculus/top/right} is based on \bycite[def. 3.1.1]{TroelstraSchwichtenberg2000BasicProofTheory}. Mimram instead presents this rule with the conclusion \( \syn\Gamma \synvdash \syntop, \syn\Delta \).

    We adapt the dual rule \ref{inf:def:classical_propositional_sequent_calculus/bot/left} is accordingly.

    \item The rules for \( \syniff \) are based on \bycite[99]{КолмогоровДрагалин2006Логика}.
  \end{itemize}
\end{comments}

\begin{proposition}\label{thm:propositional_sequent_calculus_characterization}
  In \hyperref[def:classical_propositional_sequent_calculus]{classical propositional sequent calculus}, we can derive the sequent
  \begin{equation*}
    \varphi_1, \ldots, \varphi_n \synvdash \psi_1, \ldots, \psi_n
  \end{equation*}
  if and only if we can derive
  \begin{equation*}
    \varphi_1 \synwedge \cdots \synwedge \varphi_n \synvdash \psi_1 \synvee \cdots \synvee \psi_n.
  \end{equation*}
\end{proposition}
\begin{proof}
  \SufficiencySubProof Let \( P \) be a tree deriving
  \begin{equation*}
    \varphi_1, \ldots, \varphi_n \synvdash \psi_1, \ldots, \psi_n.
  \end{equation*}

  We can transform it into the following:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {\( P \)} { \varphi_1, \ldots, \varphi_n \synvdash \psi_1, \ldots, \psi_n }
      \infer[left label={Repeated}]1[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1, \ldots, \psi_n }
      \infer[left label={Repeated}]1[\ref{inf:def:classical_propositional_sequent_calculus/or/right}]{ \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n }
    \end{prooftree}
  \end{equation*}

  \NecessitySubProof Let \( P \) be a tree deriving
  \begin{equation*}
    \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n.
  \end{equation*}

  The construction we need grows quickly in complexity, so we will only demonstrate it for \( n = 3 \). Let \( R \) be the following tree:
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi_1 \synvdash \varphi_1 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2 \synvdash \varphi_1 }

      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi_2 \synvdash \varphi_2 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2 \synvdash \varphi_2 }

      \infer2[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ \varphi_1, \varphi_2 \synvdash \varphi_1 \synwedge \varphi_2 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2, \varphi_3 \synvdash \varphi_1 \synwedge \varphi_2 }

      \infer0[\ref{inf:def:abstract_sequent_calculus_system/ax}]{ \varphi_3 \synvdash \varphi_3 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_2, \varphi_3 \synvdash \varphi_3 }
      \infer1[\ref{inf:def:abstract_sequent_calculus_system/weak/left}]{ \varphi_1, \varphi_2, \varphi_3 \synvdash \varphi_3 }

      \infer2[\ref{inf:def:classical_propositional_sequent_calculus/and/left}]{ \varphi_1, \varphi_2, \varphi_3 \synvdash \varphi_1 \synwedge \varphi_2 \synwedge \varphi_3 }
    \end{prooftree}
  \end{equation*}

  We can then combine the two trees:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {\( R \)} { \varphi_1, \cdots, \varphi_n \synvdash \varphi_1 \synwedge \cdots \synwedge \varphi_n }

      \hypo{}
      \ellipsis {\( P \)} { \varphi_1 \synwedge \ldots \synwedge \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n }

      \infer2[\ref{inf:def:abstract_sequent_calculus_system/cut}]{ \varphi_1, \cdots, \varphi_n \synvdash \psi_1 \synvee \ldots \synvee \psi_n }
    \end{prooftree}
  \end{equation*}

  We then similarly unravel the right context using \ref{inf:def:classical_propositional_sequent_calculus/or/left}.
\end{proof}
