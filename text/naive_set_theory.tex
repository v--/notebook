\section{Na\"ive set theory}\label{sec:naive_set_theory}

Na\"ive set theory is traditionally defined informally by only specifying that a set is an unordered collection of objects without repetition. It turns out that this can easily be formalized as a \hyperref[def:first_order_theory]{first-order theory}, albeit an inconsistent one. Still, this theory is useful for introducing important concepts that can ease the subsequent introduction of more elaborate theories like \hyperref[def:zfc]{\logic{ZFC}}. The definitions we introduce and the proofs we provide will turn out to be valid in \logic{ZFC} also. In other words, we will transparently utilize \hyperref[def:naive_set_theory/unrestricted_comprehension]{unrestricted comprehension} for constructing sets and later in \fullref{thm:zfc_existence_theorems} we will prove that they exist not only in na\"ive set theory, but also in \logic{ZFC}.

\begin{remark}\label{rem:pure_set_theory}\mcite[8]{Enderton1977Sets}
  What we lose in this formalization are objects which are not sets, usually called \term{atoms} or \term{urelements} (because of the German prefix \enquote{ur}, meaning primordial). It is not necessary for us to add such elements since we can encode everything via sets. Theories without atoms, like our versions of nai\"ve set theory and \hyperref[def:axiom_of_universes]{\logic{ZFC+U}}, are called \term{pure set theories}.
\end{remark}

\begin{remark}\label{rem:set_theory_formula_variables}
  In addition to using the symbols \( \synx \), \( \syny \), \( \synz \) for variables in logical formulas, as discussed in \fullref{rem:mathematical_logic_conventions/variable_symbols}, out of necessity we additionally use \( \sigma \) (from \enquote{\hi{s}et}), \( \tau \), \( \rho \) (from \enquote{\hi{r}esult}; in formulas like \( \ref{eq:def:basic_set_operations/union/predicate} \)).
\end{remark}

\begin{definition}\label{def:naive_set_theory}\mcite[subsec. 6.1]{Hinman2005Logic}
  The \term{language of na\"ive set theory} is a \hyperref[def:first_order_language]{first-order language} \( \mscrL \) with only a single \hyperref[rem:first_order_formula_conventions/infix]{infix} binary relation \( \in \) called \term{set membership}. If \( \Bracks{\synx \in \syny}_v = T \), we say that (under the \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \)) \( \synx \) is a \term{member} or \term{element} of \( \syny \) and that \( \syny \) \term{contains}\fnote{The term \enquote{contains} is used for both the membership relation and the subset relation. This tends not to cause confusion in practice.} \( \synx \).

  For the sake of simplicity, we will not introduce into the language any other functional or predicate symbols, but will use \hyperref[con:predicate_formula]{predicate formulas} when needed mostly for formulating axioms. See the \( \ref{eq:def:grothendieck_universe/predicate}[\upsilon] \) predicate for an extreme example.

  \term{Na\"ive set theory} is a \hyperref[def:first_order_theory]{first-order theory} axiomatized by the following:
  \begin{thmenum}
    \thmitem{def:naive_set_theory/extensionality} The \term{axiom of extensionality}, which states that two sets are equal if and only if they have the same members. Symbolically,
    \begin{equation}\label{eq:def:naive_set_theory/extensionality}
      \parens[\Big]{ \qforall \synz (\synz \in \synx \syniff \synz \in \syny) } \synimplies \parens[\Big]{ \synx \syneq \syny }.
    \end{equation}

    As a consequence, a set is only distinguished by what it contains and thus the ordering and repetition of members of a set play no role. This axiom is also important in \logic{ZFC} --- see \fullref{def:zfc/extensionality}.

    It is very common when dealing with sets, as in \eqref{eq:def:naive_set_theory/extensionality}, to use \hyperref[rem:first_order_formula_conventions/relativization]{relativization of quantifiers} with \( \in \).

    As explained in \fullref{rem:mathematical_logic_conventions/quantification}, we avoid excessive universal quantification. We actually add as an axiom of the theory the \hyperref[def:universal_closure]{universal closure} of \eqref{eq:def:naive_set_theory/extensionality}:
    \begin{equation}\label{eq:def:naive_set_theory/extensionality_quantified}
      \qforall \synx \qforall \syny \parens[\Bigg]{ \parens[\Big]{ \qforall \synz (\synz \in \synx \syniff \synz \in \syny) } \synimplies \parens[\Big]{ \synx \syneq \syny } }.
    \end{equation}

    The \hyperref[def:conditional_formula/converse]{converse} of \eqref{eq:def:naive_set_theory/extensionality} obvious.

    \thmitem{def:naive_set_theory/unrestricted_comprehension} The \term{axiom schema of unrestricted comprehension} states that any formula defines a set. For each formula \( \varphi \) not containing \( \rho \) as a free variable, but possibly containing \( \synx \), the following is an axiom:
    \begin{equation}\label{eq:def:naive_set_theory/unrestricted_comprehension}
      \qexists \rho \qforall \synx (\synx \in \rho \syniff \varphi).
    \end{equation}

    It is important to highlight that \( \varphi \) may have any number of free variables as long as \( \rho \) is not among them. Of course, this axiom is only interesting if \( \synx \) is free in \( \varphi \). If \( \syny_1, \ldots, \syny_n \) are all the other free variables of \( \varphi \), then the \hyperref[def:universal_closure]{universal closure} of the corresponding axiom is
    \begin{equation}\label{eq:def:naive_set_theory/unrestricted_comprehension_quantified}
      \qforall {\syny_1} \cdots \qforall {\syny_n} \qexists \rho \qforall \synx (\synx \in \rho \syniff \varphi).
    \end{equation}

    In other words, the set \( \rho \) is not unique in general, but may depend on some free variables, which we call \term{parameters} of the axiom.

    Compare this axiom schema to \hyperref[def:zfc/specification]{restricted comprehension}. In the context of na\"ive set theory they are equivalent because each is a special case of the other one.

    Because our goal is for all our constructions to be valid in \hyperref[def:zfc]{\logic{ZFC}}, we generally avoid using unrestricted comprehension.
  \end{thmenum}
\end{definition}

\begin{remark}\label{rem:epsilon_and_set_membership}
  The symbol \( \in \) is derived from \( \varepsilon \). Some older books like \cite{Kelley1975Topology} even use \( \varepsilon \) for set membership. \Fullref{thm:epsilon_induction} is named after set membership.
\end{remark}

\begin{definition}\label{def:set}\mimprovised
  Assume that we have a fixed \hyperref[rem:standard_model_of_set_theory]{standard} \hyperref[rem:transitive_model_of_set_theory]{transitive} model \( \mscrV = (V, I) \) of \hyperref[def:naive_set_theory]{na\"ive set theory} or \hyperref[def:zfc]{\logic{ZFC}}, with or without the \hyperref[def:axiom_of_universes]{axiom of universes}. We will assume \logic{ZFC+U} by default.

  We call any member of \( V \) a \term{set}, even though in a non-standard model it may not be a set within the metatheory (see \fullref{rem:standard_model_of_set_theory}).

  If \( x \) is related to \( A \) in the object theory, that is if \( \Bracks{\synx \in \syny}_{\synx \to x, \syny \to A} = T \), we say that \( x \) is a \term{member} or \term{element} of \( A \) or, in a geometric context, a \term{point} in \( A \).
\end{definition}

\begin{remark}\label{rem:standard_model_of_set_theory}
  We will say that a \hyperref[def:first_order_model]{model} \( \mscrV = (V, I) \) of set theory is \term{standard} if the interpretation \( I(\in) \) of the membership predicate symbol is precisely the membership relation in the metatheory. We will only consider standard models of set theory. This is immensely important for the following reasons:

  \begin{itemize}
    \thmitem{rem:standard_model_of_set_theory/set_builder_notation} \hyperref[def:set_builder_notation]{Set-builder notation} relies on constructing sets in the metatheory and then using them in the object theory. If the model is not standard, then, for any \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) in the model, it does not hold that \( \Bracks{\synx \in \syny}_{v_{\synx \mapsto x, \syny \mapsto y}} = T \) if and only if \( x \in y \).

    \thmitem{rem:standard_model_of_set_theory/skolems_paradox} It is possible that \hyperref[thm:cardinality_existence]{cardinality} is incompatible between the object theory and metatheory --- see \fullref{ex:skolems_paradox}. We want to avoid sets that are countable in the metatheory yet uncountable in the object theory, for example.
  \end{itemize}

  Therefore, it is reasonable to assume that all our models of set theory are standard. We also want their domains to be transitive sets -- see \fullref{rem:transitive_model_of_set_theory}.
\end{remark}

\begin{definition}\label{def:set_notation}\mimprovised
  We extend the \hyperref[def:naive_set_theory]{language of set theory} with the following notation:
  \begin{bnf*}
    \bnfprod{empty set}            {\bnftsq{\( \syn\varnothing \)}} \\
    \bnfprod{set list}             {\bnfpn{set} \bnfor \bnfpn{set list} \bnfsp \bnftsq{\( , \)} \bnfsp \bnfpn{set}} \\
    \bnfprod{set list notation}    {\bnftsq{\( \syn\lbrace \)} \bnfsp \bnfpn{set list} \bnfsp \bnftsq{\( \syn\rbrace \)}} \\
    \bnfprod{set builder notation} {\bnftsq{\( \syn\lbrace \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{\( \in \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{\( \vert \)} \bnfsp \bnfpn{formula} \bnfsp \bnftsq{\( \syn\rbrace \)}} \\
    \bnfprod{set}                  {\bnfpn{empty set} \bnfor} \\
    \bnfmore                       {\bnfpn{set list notation} \bnfor} \\
    \bnfmore                       {\bnfpn{set builder notation}}
  \end{bnf*}
\end{definition}

\begin{definition}\label{def:set_builder_notation}\mimprovised
  As mentioned in \fullref{rem:set_definition_recursion}, set theory somewhat blurs the line between logic and metalogic. In particular, some \hyperref[def:first_order_definability]{definable} subsets of the universe \( U \) of the fixed model \( \mscrU \) are themselves sets within the object logic.

  Fix a formula \( \varphi \) whose free variables are \( \synx \) and \( \syny_1, \ldots, \syny_n \). In the simplest case, \( n = 0 \) and \( \synx \) is the only free variable of \( \varphi \).

  Within the metatheory, fix an \( n \)-tuple \( u_1, \ldots, u_n \) of members of the universe \( U \), which we will call \term{parameters}. Denote by \( A \) the set of members \( x \) of \( U \) such that \( \Bracks{\varphi}(x, u_1, \ldots, u_n) = T \)\fnote{We have used the notation for formula valuation from \fullref{def:propositional_valuation/formula_valuation_function}}.

  We introduce a special convenience notation for \( A \) called \term{set-builder notation}:
  \begin{equation*}
    A \coloneqq \set{ x \given \Bracks{\varphi}(x, u_1, \ldots, u_n) }.
  \end{equation*}

  Since set-builder notation is metalogical, we do not impose strict syntax rules and use prose where it is straightforward to translate it into a logical formula.

  For example, the \hyperref[def:basic_set_operations/intersection]{intersection} of the sets \( B \) and \( C \) is given by the formula \( \synx \in \syny \synwedge \synx \in \synz \), where \( B \) is a value for the parameter \( \syny \) and \( C \) is a parameter for \( \synz \). The intersection can thus be written as
  \begin{equation*}
    A \coloneqq \set{ x \given x \in B \T{and} x \in C }.
  \end{equation*}

  Note that, in general, \( A \) is a set within the metatheory and its members are sets within the object logic, however \( A \) may not be a set within the object logic and its members may not be sets within the metatheory.

  Nonetheless, within na\"ive set theory, as a consequence of the \hyperref[def:naive_set_theory/unrestricted_comprehension]{axiom schema of unrestricted comprehension}, \( A \) is also a set within the object logic. More precisely, given our choice of parameters \( \syny_1, \ldots, \syny_n \), the axiom schema instance \eqref{eq:def:naive_set_theory/unrestricted_comprehension_quantified} guarantees the existence of a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) on \( U \), such that
  \begin{equation*}
    \Bracks{ \synx \in \sigma }_{ v_{\synx \mapsto x} } = T
    \T{if and only if}
    x \isinE A,
  \end{equation*}
  where we have denoted set membership within the object logic by \( \in \) and within the metatheory by \( \isinE \). We will not further use this symbol and the two membership relations will be used interchangeably.

  Here \( u_k \coloneqq v(\syny_k) \) are values of the corresponding parameters.

  This is where the line between logic and metalogic blurs --- we can speak about roughly the same sets within the object logic and the metatheory.

  Examples such as \fullref{thm:russels_paradox} show that unrestricted comprehension can easily lead to an inconsistent object logic. In more elaborate set theories like \hyperref[def:zfc]{\logic{ZFC}}, we only allow restricted comprehension via the \hyperref[def:zfc/specification]{axiom schema of specification}. Instead of defining \( A \) as a set of all members of \( U \) satisfying a certain property, restricted comprehension allows us to define \( A \) as a subset not of the universe \( U \), but of some well-behaved subset \( B \) of \( U \). The corresponding notation is based on \fullref{def:propositional_valuation/formula_valuation_function}:
  \begin{equation*}
    \set{ x \in B \given \Bracks{\varphi}(x, u_1, \ldots, u_n) }.
  \end{equation*}

  Of course, we may still use unrestricted comprehension of the result is guaranteed to be a set within the object logic.

  Within \logic{ZFC}, subsets of \( U \) which are not sets in the object logic are called \term{proper classes}. Sets and proper classes are collectively called \term{classes}. We avoid referencing proper classes because that can easily lead us to an inconsistent theory. See \fullref{def:large_and_small_sets} for a clever workaround.

  A bigger problem that may happen is described in \fullref{rem:transitive_model_of_set_theory}.

  Other liberties regarding set-builder notation include the following:
  \begin{itemize}
    \item We often place arbitrary terms on the left side rather than only sets. This is simply a convenient metalogical notation; the symbols that are used in these terms are often not part of the object language. For example, we write the odd integers as
    \begin{equation*}
      \set{ 2n + 1 \given n \in \BbbZ }.
    \end{equation*}

    \item Instead of using the delimiter \( \given \), we sometimes also use \( : \), especially when dealing with absolute values and divisibility:
    \begin{equation*}
      \set{ \abs{n} : n \mid 125 }
    \end{equation*}
    can be more readable than
    \begin{equation*}
      \set{ \abs{n} \given n \mid 125 }
    \end{equation*}

    \item If a set has only a small finite amount of members, we usually prefer to enumerate them as
    \begin{equation*}
      \set{ 1, 3, 9, 27 }.
    \end{equation*}

    Because of the \hyperref[def:naive_set_theory/extensionality]{axiom of extensionality}, the order and repetition of the objects inside the curly braces are irrelevant. Nevertheless, using any unconventional order does not benefit us in any way.

    \item We can also place an ellipsis if a certain pattern is obvious:
    \begin{equation*}
      \set{ 1, 3, 9, 27, \ldots }.
    \end{equation*}

    This works specifically for defining countable sets.
  \end{itemize}

  Note that we have used certain numbers, but this was only for illustrative purposes because even the \hyperref[def:natural_numbers]{natural numbers} are not yet defined in terms of sets.
\end{definition}

\begin{remark}\label{rem:multiple_set_membership_shorthand}
  Within the metatheory, we often use the notation \( x_1, \ldots, x_n \in A \) to mean that \( x_k \in A \) for \( k \in 1, \ldots, n \).
\end{remark}

\begin{remark}\label{rem:singleton_sets}
  Sets with a single elements are usually called \term{singletons}. It is sometimes convenient, especially with connection to \hyperref[ch:geometry]{geometry} or \hyperref[def:function]{set-valued maps} (e.g. when dealing with \hyperref[def:net_limit_point]{limits of nets} or \hyperref[def:subdifferentials]{subdifferentials}), to not distinguish between singleton sets and their corresponding element.
\end{remark}

\begin{definition}\label{def:empty_set}
  A very important set is the \term{empty set}
  \begin{equation*}
    \varnothing \coloneqq \set{ x \given \synbot },
  \end{equation*}
  which contains no elements. We will also find useful the \hyperref[con:predicate_formula]{predicate formula}
  \begin{equation*}\taglabel[\op{IsEmpty}]{eq:def:empty_set/predicate}
    \ref{eq:def:empty_set/predicate}[\sigma] \coloneqq \qforall \syny \synneg \syny \in \sigma.
  \end{equation*}

  We will often refer to \term{nonempty sets}, which are exactly what they sound --- sets that are not the empty set.
\end{definition}

\begin{theorem}[Russell's paradox]\label{thm:russels_paradox}
  \hyperref[def:naive_set_theory]{Na\"ive set theory} is \hyperref[def:first_order_theory/consistent]{inconsistent}. More precisely, the instance of the \hyperref[def:naive_set_theory/unrestricted_comprehension]{schema of unrestricted comprehension} with
  \begin{equation}\label{eq:thm:russels_paradox_comprehension_formula}
    \varphi = (\synx \not\in \synx)
  \end{equation}
  allows us to derive \( \synbot \) in \hyperref[def:classical_logic]{classical logic}.
\end{theorem}
\begin{comments}
  \item Thus, the set
  \begin{equation}\label{eq:thm:russels_paradox_set}
    R \coloneqq \set{ x \given x \not\in x }
  \end{equation}
  of all sets that do not contain themselves is not well-defined. Indeed, from \( R \not\in R \) it follows that \( R \in R \) and from \( R \in R \) it follows that \( R \not\in R \).
\end{comments}
\begin{proof}
  After substituting \eqref{eq:thm:russels_paradox_comprehension_formula} in \eqref{eq:def:naive_set_theory/unrestricted_comprehension}, we obtain the following axiom of na\"ive set theory:
  \begin{equation}\label{eq:thm:russels_paradox_comprehension_axiom}
    \psi \coloneqq \qexists \sigma \qforall \synx (\synx \in \sigma \syniff \synneg (\synx \in \synx)).
  \end{equation}

  We will show that the negation \( \synneg\psi \) of \( \psi \) is also derivable in this theory. An explicit form of the negation can be obtained by utilizing the equivalences from \fullref{thm:first_order_quantifiers_are_dual} and \fullref{thm:classical_equivalences/biconditional_negation}:
  \begin{equation*}
    \synneg\psi = \qforall \sigma \qexists \synx (\synx \in \sigma \syniff \synx \in \synx).
  \end{equation*}

  This holds when \( \synx \) and \( \sigma \) take on the same value, hence it is satisfiable in na\"ive set theory. \Fullref{thm:classical_first_order_logic_soundness_and_complete} implies that \( \synneg\psi \) is derivable in the theory.

  Thus, \( \psi \) and \( \synneg\psi \) are both derivable in the same theory, and we can use \ref{inf:def:propositional_natural_deduction_systems/neg/elim} to also derive \( \synbot \), which shows that na\"ive set theory is inconsistent.
\end{proof}

\begin{definition}\label{def:subset}\mcite[3]{Enderton1977Sets}
  We say that \( A \) is a \term{subset} of \( B \) and write \( A \subseteq B \) if every member of \( A \) is a member of \( B \). If \( A \) is a subset of \( B \), we say that B is a \term{superset} of \( A \).

  If \( A \subseteq B \) and \( A \neq B \), we say that \( A \) is a \term{proper subset} of \( B \) and write \( A \subsetneq B \).

  The relation \( \subseteq \) is called the \term{inclusion relation} or \term{subset relation}, and it gives a partial ordering between sets as shown in \fullref{thm:boolean_algebra_of_subsets}. If an entire family of sets are not pairwise comparable, we say that they are \term{disjoint}.

  The following \hyperref[con:predicate_formula]{predicate formula}
  \begin{equation*}\taglabel[\op{IsSubset}]{eq:def:subset/predicate}
    \ref{eq:def:subset/predicate}[\rho, \sigma] \coloneqq \qforall \synx (\synx \in \rho \synimplies \synx \in \sigma),
  \end{equation*}
  which is valid when \( \rho \) is a subset of \( \sigma \), will occasionally be useful for us.
\end{definition}
\begin{comments}
  \item Some authors, such as \cite{Kelley1975Topology}, use the notation \( A \subset B \) to mean \enquote{all elements of \( A \) belong to \( B \)}, even in the case when \( A = B \). To avoid ambiguity, we use the more explicit notations \( A \subseteq B \) and \( A \subsetneq B \).
\end{comments}

\begin{remark}\label{rem:family_of_sets}
  In a \hyperref[rem:pure_set_theory]{pure set theory}, everything is encoded as a set. However, it is often the case that we are not interested in how a set's elements are encoded as sets and only in how they behave, e.g. when working with \hyperref[def:natural_numbers]{natural numbers}, we are interested in the elements of \( \BbbN \) and not in the way every element of \( \BbbN \) is encoded as a set.

  In order to reduce repetitiveness, sets whose elements we consider to be other sets, are will called \term{families of sets}. In particular, if all (different) sets are \hyperref[def:subset]{disjoint}, we say that the family is a \term{disjoint family}. It is usually assumed that the sets are nonempty.

  We often consider \hyperref[def:cartesian_product/indexed_family]{indexed families}, i.e. sets which depend on a parameter, which further highlight our intention to distinguish between a member of some set, the set itself and some family of sets to which the latter belongs.
\end{remark}

\begin{definition}\label{def:basic_set_operations}
  We define the following operations:

  \begin{thmenum}
    \thmitem{def:basic_set_operations/union}\mcite[23]{Enderton1977Sets} We define the \term{union} of an arbitrary set \( \mscrA \) as
    \begin{equation*}
      \bigcup A \coloneqq \set{ x \given \qexists {A \in \mscrA} x \in A }.
    \end{equation*}

    The corresponding \hyperref[con:predicate_formula]{predicate formula} is
    \begin{equation*}\taglabel[\op{IsUnion}]{eq:def:basic_set_operations/union/predicate}
      \ref{eq:def:basic_set_operations/union/predicate}[\rho, \sigma] \coloneqq \qforall \synx \parens[\Big]{ \synx \in \rho \syniff \qexists {\syny \in \sigma} \synx \in \syny }.
    \end{equation*}

    In particular, \( \bigcup \varnothing = \varnothing \).

    For two sets \( A \) and \( B \), we define their \term{binary union} as
    \begin{equation*}
      A \cup B \coloneqq \bigcup \set{ A, B } = \set{ x \given x \in A \T{or} x \in B }.
    \end{equation*}

    \thmitem{def:basic_set_operations/intersection}\mcite[24]{Enderton1977Sets} Dually to \hyperref[def:basic_set_operations/union]{unions}, we define the \term{intersection} of a nonempty set \( \mscrA \) as
    \begin{equation*}
      \bigcap \mscrA \coloneqq \set{ x \given \qforall {A \in \mscrA} x \in A }.
    \end{equation*}

    We also introduce the \hyperref[con:predicate_formula]{predicate formula}
    \begin{equation*}\taglabel[\op{IsIntersection}]{eq:def:basic_set_operations/intersection/predicate}
      \ref{eq:def:basic_set_operations/intersection/predicate}[\rho, \sigma] \coloneqq \qforall \synx \parens[\Big]{ \synx \in \rho \syniff \qforall {\syny \in \sigma} \synx \in \syny }.
    \end{equation*}

    We leave \( \bigcap \varnothing \) undefined because it should be a \hyperref[def:extremal_points/top_and_bottom]{top element} in the \hyperref[thm:boolean_algebra_of_subsets]{Boolean algebra of all sets}, but the latter object is ambiguous and does not even exist in \logic{ZFC} --- see \fullref{thm:zfc_existence_theorems/set_containing_all}.

    For two sets \( A \) and \( B \), we define their \term{binary intersection} as
    \begin{equation*}
      A \cap B \coloneqq \bigcap \set{ A, B } = \set{ x \given x \in A \T{and} x \in B }.
    \end{equation*}

    \thmitem{def:basic_set_operations/difference}\mcite[27]{Enderton1977Sets} The \term{difference} of the sets \( A \) and \( B \) is
    \begin{equation*}
      A \setminus B \coloneqq \set{ x \in A \given x \not\in B }.
    \end{equation*}

    We define the \hyperref[con:predicate_formula]{predicate formula}
    \begin{equation*}\taglabel[\op{IsDifference}]{eq:def:basic_set_operations/difference/predicate}
      \ref{eq:def:basic_set_operations/difference/predicate}[\rho, \sigma, \tau] \coloneqq \qforall \synx \parens[\Big]{ \synx \in \rho \syniff (\synx \in \sigma \synwedge \synneg(\synx \in \tau)) }.
    \end{equation*}

    \thmitem{def:basic_set_operations/power_set}\mcite[4]{Enderton1977Sets} The \term{power set} \( \pow(A) \) of \( A \) is the family of all subsets of \( A \). Symbolically,
    \begin{equation*}
      \pow(A) \coloneqq \set{ B \given B \subseteq A }.
    \end{equation*}

    The operation \( \pow \) is not technically a function since its domain is supposed to be the set of all sets, whose existence contradicts \fullref{thm:russels_paradox}. Nevertheless, this notation makes sense and is justified by \fullref{rem:unbounded_transfinite_recursion} and \fullref{ex:unary_functors_in_set}.

    We define the \hyperref[con:predicate_formula]{predicate formula}
    \begin{equation*}\taglabel[\op{IsPowerSet}]{eq:def:basic_set_operations/power_set/predicate}
      \ref{eq:def:basic_set_operations/power_set/predicate}[\rho, \sigma] \coloneqq \qforall \synx \parens[\Big]{ \synx \in \rho \syniff \ref{eq:def:subset/predicate}[\synx, \sigma] }.
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:union_intersection_distributivity}
  \hyperref[def:basic_set_operations/union]{Set unions} and \hyperref[def:basic_set_operations/intersection]{set intersections} distribute over themselves and over each other. That is,
  \begin{align}
    X \cup \bigcup \mscrA &= \bigcup \set{ A \cup X \given A \in \mscrA }, \label{eq:thm:union_intersection_distributivity/union_over_union} \\
    X \cap \bigcup \mscrA &= \bigcup \set{ A \cap X \given A \in \mscrA }, \label{eq:thm:union_intersection_distributivity/intersection_over_union} \\
    X \cup \bigcap \mscrA &= \bigcap \set{ A \cup X \given A \in \mscrA }, \label{eq:thm:union_intersection_distributivity/union_over_intersection} \\
    X \cap \bigcap \mscrA &= \bigcap \set{ A \cap X \given A \in \mscrA }. \label{eq:thm:union_intersection_distributivity/intersection_over_intersection}
  \end{align}
\end{proposition}
\begin{proof}
  \SubProofOf{eq:thm:union_intersection_distributivity/union_over_union} Trivial.

  \SubProofOf{eq:thm:union_intersection_distributivity/union_over_intersection}
  \begin{align*}
    X \cap \bigcup \mscrA
    &=
    \set{ x \given x \in X \T{and} \qexists{A \in \mscrA} x \in A }
    = \\ &=
    \set{ x \given \qexists{A \in \mscrA} (x \in A \T{and} x \in X) }
    = \\ &=
    \bigcup \set{ A \cup X \given A \in \mscrA }.
  \end{align*}

  \SubProofOf{eq:thm:union_intersection_distributivity/intersection_over_union} Analogous.

  \SubProofOf{eq:thm:union_intersection_distributivity/intersection_over_intersection} Trivial.
\end{proof}

\begin{proposition}\label{thm:set_difference}
  \hyperref[def:basic_set_operations/difference]{Set difference} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:set_difference/intersection} If \( A \) and \( B \) are subsets of \( C \), then \( A \setminus B = A \cap (C \setminus B) \).

    \thmitem{thm:set_difference/superset} For any sets \( A \) and \( B \), we have \( A \setminus B = A \setminus (A \cap B) \).

    \thmitem{thm:set_difference/double_difference} If \( A \subseteq B \), then \( B \setminus (B \setminus A) = A \)
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:set_difference/intersection} Since \( a \in A \) implies \( a \in C \), we have
  \begin{align*}
    A \setminus B
    &=
    \set{ x \in A \given x \not\in B }
    = \\ &=
    \set{ x \in A \given x \in C \T{and} x \not\in B }
    = \\ &=
    A \cap (C \setminus B).
  \end{align*}

  \SubProofOf{thm:set_difference/superset} Follows from \fullref{thm:set_difference/intersection}.

  \SubProofOf{thm:set_difference/double_difference} By \hyperref[thm:minimal_propositional_negation_laws/dne]{double negation elimination},
  \begin{align*}
    B \setminus (B \setminus A)
    &=
    \set[\Big]{ x \in B \given x \not\in \set{ x \in B \given x \not\in A } }
    = \\ &=
    \set{ x \in B \given x \in A }
    = \\ &=
    A.
  \end{align*}
\end{proof}

\begin{proposition}\label{thm:boolean_algebra_of_subsets}
  Let \( X \) be an arbitrary set. Then the \hyperref[def:basic_set_operations/power_set]{power set} \( \pow(X) \) endowed with the \hyperref[def:subset]{inclusion} partial order \( \subseteq \) is a \hyperref[def:complete_lattice]{complete} \hyperref[def:boolean_algebra]{Boolean algebra}\fnote{We will not make use here of the full apparatus of Boolean algebras. Instead, we regard this statement as a shorthand that would otherwise require enumerating a lot of properties.}.

  Explicitly:
  \begin{thmenum}
    \thmitem{thm:boolean_algebra_of_subsets/join} The \hyperref[def:lattice/join]{join} of an arbitrary family \( \mscrA \) of subsets of \( X \) is simply the \hyperref[def:basic_set_operations/union]{union} \( \bigcap \mscrA \).

    \thmitem{thm:boolean_algebra_of_subsets/top} The \hyperref[def:extremal_points/top_and_bottom]{top element} is the set \( X \) itself.

    \thmitem{thm:boolean_algebra_of_subsets/meet} The \hyperref[def:lattice/meet]{meet} of an arbitrary family \( \mscrA \) of sets is simply the \hyperref[def:basic_set_operations/intersection]{intersection} \( \bigcup \mscrA \). Unlike for a general family of sets, we have no problem defining the intersection of an empty set to be the top element \( X \).

    \thmitem{thm:boolean_algebra_of_subsets/bottom} The \hyperref[def:extremal_points/top_and_bottom]{bottom element} is the empty set.

    \thmitem{thm:boolean_algebra_of_subsets/complement} The \hyperref[def:boolean_algebra]{complement} \( A^\complement \) of the subset \( A \) is the \hyperref[def:basic_set_operations/difference]{difference} \( X \setminus A \).
  \end{thmenum}

  \begin{figure}[!ht]
    \hfill
    \includegraphics[page=1]{output/thm__boolean_algebra_of_subsets}
    \hfill\hfill
    \caption{The \hyperref[def:hasse_diagram]{Hasse diagram} of \( \pow(\set{ A, B }) \) with respect to \hyperref[def:subset]{set inclusion}}
    \label{fig:thm:boolean_algebra_of_subsets}
  \end{figure}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:boolean_algebra_of_subsets/join} The union of \( \mscrA \) exists by \fullref{thm:zfc_existence_theorems/arbitrary_union}, and it is itself a subset of \( \mscrA \). Every set in \( \mscrA \) is contained in \( \bigcup \mscrA \), hence it is indeed a join.

  \SubProofOf{thm:boolean_algebra_of_subsets/top} Clearly \( X \) contains every subset of \( X \).

  \SubProofOf{thm:boolean_algebra_of_subsets/join} The intersection of \( \mscrA \) exists by \fullref{thm:zfc_existence_theorems/arbitrary_union}, and it is itself a subset of \( \mscrA \). Every set in \( \mscrA \) contains \( \bigcap \mscrA \), hence it is indeed a meet.

  \SubProofOf{thm:boolean_algebra_of_subsets/bottom} The empty set is contained in every set, in particular in every subset of \( A \).

  \SubProofOf[def:distributive_lattice]{distributivity} Follows from \fullref{thm:union_intersection_distributivity}.

  \SubProofOf{thm:boolean_algebra_of_subsets/complement} The operation \( A^\complement \) is well-defined for each subset \( A \) of \( X \) due to \fullref{thm:zfc_existence_theorems/difference}.

  By definition
  \begin{equation*}
    A \synvee A^\complement
    =
    A \cup (X \setminus A)
    =
    X
  \end{equation*}
  and
  \begin{equation*}
    A \synvee A^\complement
    =
    A \cup (X \setminus A)
    =
    X,
  \end{equation*}
  hence \( A^\complement \) is indeed the complement of \( A \).

  Therefore, \( \pow(X) \) is a Boolean algebra.
\end{proof}

\begin{theorem}[De Morgan's laws for sets]\label{thm:de_morgans_laws_for_sets}
  The following hold for any sets:
  \begin{align}
    X \setminus \bigcup \mscrA = \bigcap \set{ X \setminus A \given A \in \mscrA } \label{eq:thm:de_morgans_laws_for_sets/complement_of_union} \\
    X \setminus \bigcap \mscrA = \bigcup \set{ X \setminus A \given A \in \mscrA } \label{eq:thm:de_morgans_laws_for_sets/complement_of_intersection}
  \end{align}
\end{theorem}
\begin{comments}
  \item See \fullref{rem:de_morgans_laws} for a list of related theorems.
\end{comments}
\begin{proof}
  \SubProof{Direct proof} We have
  \begin{align*}
    X \setminus \bigcup \mscrA
    &=
    \set{ x \given x \in X \T{and} \synneg \qexists{A \in \mscrA} x \in A }
    \reloset {\eqref{eq:thm:first_order_quantifiers_are_dual/negation_of_universal}} = \\ &=
    \set{ x \given x \in X \T{and} \qforall{A \in \mscrA} {x \not\in A} }
    = \\ &=
    \set{ x \given \qforall{A \in \mscrA} (x \in X \T{and} x \not\in A) }
    = \\ &=
    \bigcap \set{ X \setminus A \given A \in \mscrA }
  \end{align*}
  and
  \begin{align*}
    X \setminus \bigcap \mscrA
    &=
    \set{ x \given x \in X \T{and} \synneg \qforall{A \in \mscrA} x \in A }
    \reloset {\eqref{eq:thm:first_order_quantifiers_are_dual/negation_of_universal}} = \\ &=
    \set{ x \given x \in X \T{and} \qexists{A \in \mscrA} {x \not\in A} }
    = \\ &=
    \set{ x \given \qforall{A \in \mscrA} (x \in X \T{and} x \not\in A) }
    = \\ &=
    \bigcup \set{ X \setminus A \given A \in \mscrA }.
  \end{align*}

  \SubProof{Consequence of \fullref{thm:de_morgans_laws}}
  All subsets of \( X \) form a Boolean algebra as a consequence of \fullref{thm:boolean_algebra_of_subsets}. Then
  \begin{equation*}
    \bigcup_{k \in \mscrK} (X \setminus A_k)
    \reloset {\ref{thm:set_difference/superset}} =
    \bigcup_{k \in \mscrK} (X \cap A_k)^\complement
    \reloset {\eqref{eq:thm:de_morgans_laws/complement_of_join}} =
    \parens*{ \bigcap_{k \in \mscrK} (X \cap A_k) }^\complement
    =
    \parens*{ X \cap \bigcap_{k \in \mscrK} A_k }^\complement
    \reloset {\ref{thm:set_difference/superset}} =
    X \setminus \parens*{ \bigcap_{k \in \mscrK} A_k }.
  \end{equation*}

  The other identity requires distributivity:
  \begin{equation*}
    \bigcap_{k \in \mscrK} (X \setminus A_k)
    \reloset {\ref{thm:set_difference/superset}} =
    \bigcap_{k \in \mscrK} (X \cap A_k)^\complement
    \reloset {\eqref{eq:thm:de_morgans_laws/complement_of_join}} =
    \parens*{ \bigcup_{k \in \mscrK} (X \cap A_k) }^\complement
    \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} =
    \parens*{ X \cap \bigcup_{k \in \mscrK} A_k }^\complement
    \reloset {\ref{thm:set_difference/superset}} =
    X \setminus \parens*{ \bigcup_{k \in \mscrK} A_k }.
  \end{equation*}
\end{proof}

\begin{remark}\label{rem:inductive_sets}
  We are now interested in the inductive axiom schema \eqref{eq:def:peano_arithmetic/PA3}, which will allow us to define, among other things, natural numbers. Induction is an important proof technique that is discussed in detail in our proof of \fullref{thm:nonzero_natural_numbers_have_predecessors}. There are more general forms of induction than \eqref{eq:def:peano_arithmetic/PA3} like \fullref{thm:well_founded_induction} and \fullref{thm:well_founded_induction}. They do, however, require concepts which in turn depend on the existence of natural numbers within set theory. As a consequence, we cannot prove \eqref{eq:def:peano_arithmetic/PA3} via \fullref{thm:well_founded_induction}.

  We will introduce the concept of inductive sets in \fullref{def:inductive_set} and prove in \fullref{thm:omega_induction} that a special inductive set \hyperref[thm:smallest_inductive_set_existence]{\( \omega \)}, which will be the universe of our model of \( \BbbN \), allows performing inductive proofs. The technique that allows us to perform inductive proofs on \( \omega \) can be seen in our proof of \fullref{thm:omega_is_transitive}. \Fullref{thm:omega_induction} will allow us to define natural numbers without relying on metalogical induction along the way. See our proof of \fullref{thm:omega_induction} for a description of natural number induction within set theory and \fullref{rem:standard_models_of_arithmetic} for a further discussion of the use of natural numbers in the metatheory and in the object logic.

  We also introduce \term{recursion} in parallel as a technique for constructing objects. See \fullref{thm:omega_recursion}.
\end{remark}

\begin{definition}\label{def:ordinal_successor}\mcite[68]{Enderton1977Sets}
  We define the \term[ru=операция следования (\cite[1.1.11]{КолмогоровДрагалин2006Логика})]{successor} \( \op{sc}(A) \) of a set \( A \) as the set
  \begin{equation*}
    \op{sc}(A) \coloneqq A \cup \set{ A }.
  \end{equation*}

  The following \hyperref[con:predicate_formula]{predicate formula}
  \begin{equation*}\taglabel[\op{IsSucc}]{eq:def:ordinal_successor/predicate}
    \ref{eq:def:ordinal_successor/predicate}[\rho, \sigma] \coloneqq \qforall \synx \parens[\Big]{ \synx \in \rho \syniff (\synx \in \sigma \synvee \synx = \sigma) },
  \end{equation*}
  which states that \( \rho \) is the successor of \( \sigma \), will be useful for us when working with \hyperref[def:inductive_set]{inductive sets}.
\end{definition}
\begin{comments}
  \item We also call it the \term{ordinal successor} operation since it is an important concept in the \hyperref[sec:ordinals]{theory of ordinals}. See \fullref{rem:def:ordinal_successor} for an example of how it naturally arises. It should be distinguished from successor cardinals defined in \fullref{def:successor_and_limit_cardinal}.
\end{comments}

\begin{definition}\label{def:inductive_set}\mcite[68]{Enderton1977Sets}
  A set is called \term{inductive} if contains the empty set and is closed under the \hyperref[def:ordinal_successor]{successor operator}.

  We introduce the following \hyperref[con:predicate_formula]{predicate formula}
  \begin{equation*}\taglabel[\op{IsInductive}]{eq:def:inductive_set/predicate}
    \ref{eq:def:inductive_set/predicate}[\sigma] \coloneqq
      \parens[\Big]{ \qexists {\synx \in \sigma} \ref{eq:def:empty_set/predicate}[\synx] }
      \synwedge
      \parens[\Big]{ \qforall {\synx \in \sigma} \qexists {\syny \in \sigma} \ref{eq:def:ordinal_successor/predicate}[\syny, \synx] }.
  \end{equation*}
\end{definition}

\begin{proposition}\label{thm:smallest_inductive_set_existence}
  There is a smallest (with respect to set inclusion) \hyperref[def:inductive_set]{inductive set}, which we denote by \( \omega \).
\end{proposition}
\begin{proof}
  We cannot directly define \( \omega \) as the intersection of all inductive sets since, in \logic{ZFC}, we want to avoid unrestricted comprehension. Fortunately, the existence of at least one inductive set is justified by the \hyperref[def:zfc/infinity]{axiom of infinity} (or by taking the entire universe in na\"ive set theory).

  Let \( A \) be an inductive set. We can now define \( \omega \) via restricted comprehension:
  \begin{equation*}
    \omega \coloneqq \set{ x \in A \given x \T{belongs to every inductive set} }.
  \end{equation*}

  To see that \( \omega \) is itself inductive, note that \( \varnothing \in \omega \) and that if \( x \in \omega \), then it also belongs to all inductive sets and hence \( \op{sc}(x) \) also belongs to all inductive sets, proving \( \op{sc}(x) \in \omega \).
\end{proof}

\begin{theorem}[Induction via inductive sets]\label{thm:omega_induction}\mcite[thm. 6.2.17]{Hinman2005Logic}
  We can perform induction on the \hyperref[thm:smallest_inductive_set_existence]{smallest inductive set} \( \omega \). We can prove that \( \omega \) is a subset of some set \( A \) by proving the following:
  \begin{itemize}
    \item \( A \) contains \( \varnothing \).
    \item If \( A \) contains \( n \), it also contains \( \op{sc}(n) \).
  \end{itemize}

  More precisely, the following is a theorem of both na\"ive set theory and \hyperref[def:zfc]{\logic{ZF}} (\( \omega \) satisfies \( \sigma \) and \( \synx \) plays the role of \( A \) above):
  \footnotesize
  \begin{equation}\label{eq:thm:omega_induction}
    \qexists \sigma
    \qforall \synx
    \parens[\Bigg]
      {
        \parens[\Bigg]
          {
            \parens[\Big]
            {
              \underbrace{ \qexists {\syny \in \synx} \ref{eq:def:empty_set/predicate}[\syny] }_{\mathclap{\T{base case}}}
            }
            \synwedge
            \qforall \syny \parens[\Big]
              {
                \overbrace
                  {
                    \underbrace{ \syny \in \synx }_{\mathclap{\substack{\T{inductive} \\ \T{hypothesis}}}}
                    \synimplies
                    \underbrace
                      {
                        \qexists {\synz \in \synx} \ref{eq:def:ordinal_successor/predicate}[\synz, \syny]
                      }_{\mathclap{\substack{\T{inductive step} \\ \T{conclusion}}}}
                  }^{\T{inductive step}}
              }
          }
        \synimplies
        \underbrace{ \ref{eq:def:subset/predicate}[\sigma, \synx] }_{\T{conclusion}}
      }
  \end{equation}
  \normalsize
\end{theorem}
\begin{comments}
  \item This is an analog of \eqref{eq:def:peano_arithmetic/PA3} and is actually used in \fullref{thm:omega_is_model_of_pa} to prove that \( \omega \) is a model of \hyperref[def:peano_arithmetic]{\logic{PA}}. Instead of an entire theorem schema, however, for this theorem it is sufficient to use one single formula. The more general induction principles that use theorem schemas cannot be proved without natural numbers, which are a model of \logic{PA} by virtue of this theorem.
\end{comments}
\begin{proof}
  The antecedent of (the inner formula in) \eqref{eq:thm:omega_induction} is a restatement of the predicate formula \( \ref{eq:def:inductive_set/predicate}[\synx] \). The situation resembles the \hyperref[eq:def:zfc/infinity]{axiom of infinity}, but, instead of existence of an inductive set \( \synx \), it states the existence of a set \( \sigma \) such that if \( \synx \) is an inductive set, then \( \sigma \) is a subset of \( \synx \) (if we restrict \( \syny \) to range only over members of \( \sigma \), then we would obtain equality of \( \synx \) and \( \sigma \) instead). In other words, we have reduced the verification of \eqref{eq:thm:omega_induction} to showing that there exists a minimal inductive set in both na\"ive set theory and \logic{ZF}.

  We have already proved in \fullref{thm:smallest_inductive_set_existence} that our fixed model \( \mscrV = (V, I) \) of set theory has a minimal inductive set \( \omega \). Thus, for any \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \), the modified assignment \( v_{\sigma \mapsto \omega} \) satisfies \eqref{eq:thm:omega_induction} with the outer existential quantifier removed. Hence, \( v \) satisfies the entire formula \eqref{eq:thm:omega_induction}.

  Both the assignment \( v \) and the model \( \mscrV \) were arbitrary, therefore we can conclude that \eqref{eq:thm:omega_induction} is a theorem of both na\"ive set theory and \logic{ZF}.
\end{proof}

\begin{definition}\label{def:transitive_set}\mcite[def. 6.1.3(i)]{Hinman2005Logic}
  We say that a set \( A \) is \term{transitive} if from \( B \in A \) it follows that \( B \subseteq A \).

  We introduce the following \hyperref[con:predicate_formula]{predicate formula}:
  \begin{equation*}\taglabel[\op{IsSetTransitive}]{eq:def:transitive_set/predicate}
    \ref{eq:def:transitive_set/predicate}[\sigma] \coloneqq \qforall {\synx \in \sigma} \qforall {\syny \in \synx} {\syny \in \sigma}
  \end{equation*}
\end{definition}
\begin{comments}
  \item See \fullref{rem:ordinal_definition} for a discussion of the motivation and terminology of transitive sets and \fullref{rem:transitive_model_of_set_theory} for their importance.
\end{comments}

\begin{proposition}\label{thm:omega_is_transitive}
  The set \( \omega \) is transitive and every member of \( \omega \) is transitive.
\end{proposition}
\begin{comments}
  \item This proof demonstrates how \fullref{thm:omega_induction} is used. From now on, we will not be as explicit about the use of induction on \( \omega \).
\end{comments}
\begin{proof}
  \SubProof{Proof that all members of \( \omega \) are transitive} In order to demonstrate how \fullref{thm:omega_induction} works in practice, we will use inductive sets directly. Let \( T \subseteq \omega \) be the subset of all transitive members of \( \omega \). We will show that \( T \) is inductive.

  Clearly \( \varnothing \in T \)  because every member of \( \varnothing \) vacuously is a subset of \( \varnothing \).

  Now suppose that \( n \in T \) and let \( m \in \op{sc}(n) = n \cup \set{ n } \). If \( m = n \), then \( m \in \op{sc}(n) \) by definition of the successor operation. If \( m \in n \), then \( m \subseteq n \) by the inductive hypothesis and hence also \( m \subseteq n \cup \set{ n } = \op{sc}(n) \). Thus, \( \op{sc}(n) \) is also transitive.

  We have shown that \( T \) is inductive. Therefore, \( \omega \subseteq T \), i.e. every member of \( \omega \) is transitive.

  \SubProof{Proof that \( \omega \) is transitive} We will show that, for all members \( n \) of \( \omega \), we have \( n \subseteq \omega \).

  The case \( n = \varnothing \) is again trivial.

  Now suppose that \( n \subseteq \omega \) and let \( m \in \op{sc}(n) \). If \( m = n \), clearly \( m \subseteq \omega \). If \( m \in n \), then \( m \subseteq n \) and, since \( n \subseteq \omega \), we have \( m \subseteq \omega \) by transitivity of \( \subseteq \).

  Therefore, \( \omega \) is transitive.
\end{proof}

\begin{remark}\label{rem:transitive_model_of_set_theory}
  As discussed in \fullref{def:set_builder_notation}, within the \hyperref[def:naive_set_theory/unrestricted_comprehension]{axiom schema of unrestricted comprehension} it may happen that \( U \subseteq V \) is not a set within the object logic.

  But there is a bigger problem that may happen even for \hyperref[rem:standard_model_of_set_theory]{standard models}. If \( A \in V \) and \( x \in A \) (in the metatheory), it is possible that \( x \) is not in \( V \). Therefore, if we have shown that \( A \) is a set within the object logic, it is possible that its members within the metatheory are not members in the object logic. On other words, it is possible for set membership itself to be incompatible between the metatheory and object logic.

  If \( V \) is a transitive set, however, we would not have such a problem. That is, if we construct a set \( A \) in the metatheory and show that it belongs to some set \( B \) in the object logic, then \( A \) itself would also be a set in the object logic.

  For this reason, it is very important to consider only transitive models of set theory.
\end{remark}

\begin{lemma}\label{thm:members_of_omega_do_not_contain_themselves}
  No element of \( \omega \) is a member of itself.
\end{lemma}
\begin{proof}
  We will again use \fullref{thm:omega_induction}.

  By definition, \( \omega \not\in \omega \). Now suppose that \( n \not\in n \) for some \( n \in \omega \).

  Aiming at a contradiction, suppose that \( \op{sc}(n) \in \op{sc}(n) \). The assumption that \( n = \op{sc}(n) = n \cup \set{ n } \) implies that \( n = \set{ n } \). The assumption that \( \op{sc}(n) \in n \) implies that \( n \in n \) since \( \op{sc}(n) \) is transitive by \fullref{thm:omega_is_transitive}. In both cases we have \( n \in n \), which contradicts our inductive hypothesis. This contradiction shows that \( \op{sc}(n) \not\in \op{sc}(n) \).

  \Fullref{thm:omega_induction} allows us to conclude that no member of \( \omega \) contains itself.
\end{proof}

\begin{theorem}\label{thm:omega_is_model_of_pa_without_operations}
  The \hyperref[thm:smallest_inductive_set_existence]{smallest inductive set} \( \omega \) satisfies the axioms \eqref{eq:def:peano_arithmetic/PA1}-\eqref{eq:def:peano_arithmetic/PA3} from \hyperref[def:peano_arithmetic]{Peano arithmetic} with the following interpretation:
  \begin{thmenum}
    \thmitem{thm:omega_is_model_of_pa_without_operations/zero} \hyperref[def:peano_arithmetic/zero]{Zero} is interpreted as \( \varnothing \).

    \thmitem{thm:omega_is_model_of_pa_without_operations/succ} The \hyperref[def:peano_arithmetic/succ]{successor} operation \( s \) is interpreted as \( \op{sc} \).
  \end{thmenum}

  We will generalize this theorem to \fullref{thm:omega_is_model_of_pa} after we are able to define the arithmetic operations in \( \omega \).
\end{theorem}
\begin{proof}
  \SubProofOf{eq:def:peano_arithmetic/PA1} Let \( n, m \in \omega \) and suppose that \( \op{sc}(n) = \op{sc}(m) \). If \( n = m \), there is nothing to prove.

  Suppose that \( n \neq m \). Thus, since
  \begin{equation*}
    n \cup \set{ n } = \op{sc}(n) = \op{sc}(m) = m \cup \set{ m },
  \end{equation*}
  we have both \( n \in m \) and \( m \in n \).

  \Fullref{thm:omega_is_transitive} implies that \( n \) is transitive and hence \( n \in n \), which contradicts \fullref{thm:members_of_omega_do_not_contain_themselves}.

  The obtained contradiction shows that \( n = m \).

  \SubProofOf{eq:def:peano_arithmetic/PA2} Suppose that \( \varnothing \) has a predecessor \( n \in \omega \). Then
  \begin{equation*}
    \varnothing = \op{sc}(n) = n \cup \set{ n },
  \end{equation*}
  which implies that \( n \in \varnothing \). But this contradicts the \hyperref[def:empty_set]{definition of \( \varnothing \)}.

  Therefore, \( \varnothing \) has no predecessor.

  \SubProofOf{eq:def:peano_arithmetic/PA3} It follows from \fullref{thm:omega_induction} that \eqref{eq:thm:omega_induction} is a theorem of \logic{ZF}. Let \( \mscrV = (V, I) \) be our ambient \hyperref[rem:standard_model_of_set_theory]{standard} \hyperref[rem:transitive_model_of_set_theory]{transitive} model of \logic{ZFC}.

  Fix any \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \). As in our proof of \fullref{thm:omega_induction}, we consider the modified assignment \( v_{\tau \mapsto \omega} \) that \enquote{eliminates} the outer existential quantifier in \eqref{eq:thm:omega_induction}.

  To show that \eqref{eq:thm:omega_induction} really corresponds to \eqref{eq:def:peano_arithmetic/PA3} (and hence that \( \omega \) satisfies \eqref{eq:def:peano_arithmetic/PA3}), fix some formula \( \varphi \) of \hyperref[def:peano_arithmetic]{Peano arithmetic} (\hi{not \logic{ZFC}!}) and suppose that \( \synx, \synz_1, \ldots, \synz_n \) are all of its free variables. Fix also some parameter values \( u_1, \ldots, u_n \in \omega \) and, as in \fullref{def:set_builder_notation}, define the set
  \begin{equation*}
    A \coloneqq \set{ x \in \omega \given \Bracks{\varphi}(x, u_1, \ldots, x_n) }.
  \end{equation*}

  Since \eqref{eq:thm:omega_induction} is satisfied by \( v \), the inner formula in \eqref{eq:thm:omega_induction} (without the quantifiers over \( \tau \) and \( \sigma \)) is satisfied by \( v_{\tau \mapsto \omega, \sigma \mapsto A} \).

  Since our choice of parameters \( u_1, \ldots, u_n \) was arbitrary, we can conclude that the universal closure \eqref{eq:def:peano_arithmetic/PA3_quantified} of \eqref{eq:def:peano_arithmetic/PA3} is satisfied by \( \omega \) for every formula \( \varphi \) of \logic{PA}.
\end{proof}

\begin{remark}\label{rem:set_theory_natural_numbers_without_operations}
  Due to \fullref{thm:omega_is_model_of_pa_without_operations}, we will henceforth identify the \hyperref[thm:smallest_inductive_set_existence]{smallest inductive set} \( \omega \) with the set \( \BbbN \) of \hyperref[def:natural_numbers]{natural numbers}.

  We are not yet able to add or multiply natural numbers, nor rely on their well-foundedness, however for all other purposes we are able to utilize them.

  Since the ordering in \fullref{def:natural_numbers_ordering} is defined via addition, we must define some other ordering. Luckily, as we shall see in \fullref{sec:ordinals}, \( n < m \) corresponds to \( n \in m \). In particular, the members of \( m \) are ordered.

  As a consequence, every natural number \( n \) equals the set of all smaller natural numbers by the \hyperref[def:naive_set_theory/extensionality]{axiom of extensionality}. It is conventional to write \( \set{ 0, 1, \ldots, n } \) rather than \( \set{ m \given m \in \op{sc}(n) } \). The former notation will be fully justified in \fullref{sec:ordinals}.

  Until then, natural numbers will be useful, for example, in \fullref{def:sequence}.
\end{remark}
