\section{Untyped \texorpdfstring{\( \muplambda \)}{λ}-terms}\label{sec:untyped_lambda_terms}

\paragraph{Syntax of \( \muplambda \)-terms}

\begin{concept}\label{con:variable}
  A \term[en=variable (\cite[9]{Church1956LogicVol1})]{variable} is an atomic \hyperref[con:expression]{expression}, usually a single symbol, whose intended interpretation is to take one of many possible values, collectively called the variable's \term[en=range (\cite[9]{Church1956LogicVol1})]{range}. If the expression is instead intended to always take the same value, it is called a \term[en=constant (\cite[9]{Church1956LogicVol1})]{constant}.
\end{concept}
\begin{comments}
  \item When defining substitution for \hyperref[def:lambda_term]{\( \muplambda \)-terms} in \fullref{alg:lambda_term_substitution}, we make it clear that variables are affected, but constants are invariant. In fact, the entire concept of substitution revolves around replacing variables with other \( \muplambda \)-terms.

  \item We describe in \cref{con:variable_dependence} how variables may depend on one another.

  \item A related notion is that of a \hyperref[def:random_variable]{random variables}, whose value is nondeterministic. They are neither dependent nor independent; in fact, they have their own notion of dependence that we define formally in \cref{def:random_variable_independence}.

  \item Variables and constants are \hyperref[con:assumed_knowledge]{assumed knowledge}, so definitions across the literature are scarce. \incite[9]{Church1956LogicVol1} writes
  \begin{displayquote}
    We adopt the mathematical usage according to which a proper name of a number is called a \textit{constant}, and in connection with formalized languages we extend this usage by removing the restriction to numbers, so that the term \textit{constant} becomes synonymous with \textit{proper name having a denotation}.
  \end{displayquote}
  and
  \begin{displayquote}
    As already familiar from ordinary mathematical usage, a \textit{variable} is a symbol whose meaning is like that of a proper name or constant except that the single denotation of the constant is replaced by the possibility of various \textit{values} of the variable.

    Because it is commonly necessary to restrict the values which a variable may take, we think of a variable as having associated with it a certain non-empty range of possible values, the \textit{range of} the variable as we shall call it.
  \end{displayquote}
\end{comments}

\begin{definition}\label{def:lambda_term_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} of \( \muplambda \)-calculus consists of the following:

  \begin{thmenum}
    \thmitem{def:lambda_term_alphabet/binder} The \hyperref[con:variable_binding]{variable binder} \( \synlambda \), after which \( \muplambda \)-calculus is named.

    \thmitem{def:lambda_term_alphabet/aux} Auxiliary symbols:
    \begin{thmenum}
      \thmitem{def:lambda_term_alphabet/aux/parentheses} Parentheses \enquote{\( ( \)} and \enquote{\( ) \)} for grouping terms unambiguously.

      \thmitem{def:lambda_term_alphabet/aux/colon} The colon \enquote{\( : \)} for \hyperref[def:type_assertion]{type assertions} in typed \( \muplambda \)-terms (these will be defined in \fullref{sec:simply_typed_lambda_terms}).

      \thmitem{def:lambda_term_alphabet/aux/dot} The dot \enquote{\( . \)} for separating variable binders from their bodies.
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item To highlight that the symbols belong to the object language and do not have implicitly associated semantics, we place dots over them; see \cref{rem:mathematical_logic_conventions/terminal_dots} for a general discussion of this convention.

  \item We will extend this alphabet with new \hyperref[con:variable_binding]{variable binders} in \fullref{sec:dependent_types}, and also adapt it for higher-order logic in \fullref{sec:higher_order_logic}.

  \item The auxiliary dot after the variable binders is not strictly necessary and may be omitted --- see \cref{rem:lambda_term_abstractor_dot}.
\end{comments}

\begin{definition}\label{def:lambda_term}\mimprovised
  Fix an \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Const} \), assumed by default to be finite, whose elements we will call \term[en=constant (\cite[202]{Andrews2002Logic})]{constant terms}. As per \cref{rem:improper_symbols_and_parsing}, we disallow the \hyperref[con:improper_symbol]{improper symbols} from the \hyperref[def:lambda_term_alphabet]{alphabet of \( \muplambda \)-calculus} and the \hyperref[def:inference_rule_alphabet]{alphabet of inference rules} as constants.

  We will introduce a \hyperref[def:formal_grammar/schema]{grammar schema} whose rules and generated languages we will collectively call \enquote{the \hyperref[con:syntax_semantics_duality]{syntax} of untyped lambda calculus}:
  \begin{bnf*}
    \bnfprod{variable}    {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{atom}        {\bnfpn{constant} \bnfor \bnfpn{variable}}, \\
    \bnfprod{application} {\bnftsq{\( ( \)} \bnfsp \bnfpn{term} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{abstraction} {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term}        {\bnfpn{atom} \bnfor \bnfpn{application} \bnfor \bnfpn{abstraction}}.
  \end{bnf*}

  We have used the variable identifier rules from \cref{def:variable_identifier}.

  We will denote the set of all \term[ru=переменные (\cite[268]{Герасимов2014Вычислимость}), en=variables (\cite[\S 3.1.1]{Mimram2020ProgramEqualsProof})]{variables} by \( \op*{Var} \). Similarly, we will denote the set of all \term[ru=\( \muplambda \)-терм (\cite[268]{Герасимов2014Вычислимость}), en=\( \muplambda \)-term (\cite[def. 1A1]{Hindley1997BasicSTT})]{\( \muplambda \)-terms} by \( \op*{Term} \), and by \( \op*{Atom} \) those that are \term[en=atomic (terms) (\cite[def. 1A1(i)]{Hindley1997BasicSTT})]{atomic}.
\end{definition}
\begin{comments}
  \item Technically, the definition of \( \muplambda \)-term depends on the set of constants. Constants are important in type systems, but less so in untyped \( \muplambda \)-terms. Thus, unless explicitly noted otherwise, we will assume that the set of constant terms is empty. Still, we want to explicitly handle constants in our definitions and proofs, so that they hold without modification in typed lambda calculus.

  \item Except for constant terms, these notions mostly coincide with their original definition in \cite[352]{Church1932LambdaCalculus}.

  Later, in \cite[56]{Church1940STT}, Church extends the syntax with constant terms and type annotations for what we now call \enquote{simply typed lambda calculus}, discussed in \fullref{sec:higher_order_logic} and \fullref{sec:simply_typed_lambda_terms}.

  The terminology itself is based on \cite[def. 1A1]{Hindley1997BasicSTT}, with the necessary changes made in order to accommodate constants.

  \item When \hyperref[def:typed_lambda_term]{typed \( \muplambda \)-term} are involved, we will refer to the ones defines here as \enquote{untyped}.

  \item We need all the parentheses so that we can prove unambiguity in \cref{thm:lambda_term_grammar/unambiguous}. In the metalanguage, we will use the conventions from \cref{rem:lambda_term_notation_conventions} regarding parentheses.

  \item Both typed and untyped \( \muplambda \)-terms are implemented in the module \identifier{math.lambda_.terms} in \cite{notebook:code}, with a parser in \identifier{math.lambda_.parsing}.
\end{comments}

\begin{remark}\label{rem:lambda_term_abstractor_dot}
  In \cref{def:lambda_term}, we have defined \( \muplambda \)-terms so that there is a dot after the abstractor's variable, i.e. \( \qabs x M \) rather than \( \synlambda x M \).

  This dot is not strictly necessary and was in fact not used in \incite{Church1932LambdaCalculus} where \( \muplambda \)-calculus was introduced. Including it has since become standard, as a leftover from a dated convention in logic --- see \cref{ex:dot_delimiters_in_logic/quantifiers}.

  Our main reference books --- \cite[def. 1A1]{Hindley1997BasicSTT}, \cite[22]{Barendregt1984LambdaCalculus}, \cite[15]{GirardEtAl1989ProofsAndTypes}, \cite[\S A.2.4]{UnivalentFoundationsProgram2013HoTT} and \cite[\S 4.1.3]{Mimram2020ProgramEqualsProof} --- all use dots.
\end{remark}

\begin{proposition}\label{thm:lambda_term_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:lambda_term]{\( \muplambda \)-terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:lambda_term_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:lambda_term_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:lambda_term_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  Similar to \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{definition}\label{def:lambda_term_ast}\mimprovised
  We implicitly associate with each \( \muplambda \)-term \( M \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(M) \) as follows:
  \begin{thmenum}
    \thmitem{def:lambda_term_ast/atom} If \( M \) is a variable or constant, we define \( T(M) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( M \).

    \thmitem{def:lambda_term_ast/application} If \( M = NK \), assuming we have already built \( T(N) \) and \( T(K) \), we define \( T(M) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} \( T(N) \) and \( T(K) \) to a new root labeled with the symbol \enquote{\( \anon \)}:
    \begin{equation*}
      \includegraphics[page=1]{output/def__lambda_term_ast}
    \end{equation*}

    \thmitem{def:lambda_term_ast/abstraction} If \( M = \qabs x N \), assuming we have already built \( T(N) \), we define \( T(M) \) by grafting \( T(N) \) to a new root labeled with \( \synlambda x \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__lambda_term_ast}
    \end{equation*}

    For the \hyperref[def:typed_lambda_term]{simply typed \( \muplambda \)-term} \( M = \qabs {x^\tau} N \), assuming we have already built \( T(\tau) \) in accordance with \cref{def:simple_type_ast}, we instead have
    \begin{equation*}
      \includegraphics[page=3]{output/def__lambda_term_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Formally our ASTs for abstractions require us to \enquote{parse} the string at the root. They are, however, convenient for defining variable occurrences in \cref{def:lambda_variable_occurrence}, and are also easier to parse visually.
\end{comments}

\begin{remark}\label{rem:lambda_term_notation_conventions}
  We will use some \enquote{abuse-of-notation} \hyperref[con:metalogic]{metalingual} syntactic conventions somewhat resembling those from \cref{rem:propositional_formula_notation_conventions}:
  \begin{thmenum}
    \thmitem{rem:lambda_term_notation_conventions/outermost} As in \cref{rem:propositional_formula_notation_conventions/outermost}, we avoid writing the outermost parentheses in terms like \( (\synx \syny) \) or \( ((\synx \syny) \synz) \).

    \thmitem{rem:lambda_term_notation_conventions/abstraction} We generally avoid writing parentheses around \( \muplambda \)-abstractions and assume that their body \enquote{extends to the right}.

    Actually, it is not necessary to put parentheses around \( \muplambda \)-abstractions in order for the grammar to be unambiguous. Not requiring them, however, leads to the following unintuitive artifact.

    Consider the term \( \qabs \synx \syny \synz \). If parentheses are required only for \( \muplambda \)-applications but not for \( \muplambda \)-abstractions, it would unambiguously correspond to the following \hyperref[def:lambda_term_ast]{abstract syntax tree}:
    \begin{equation*}
      \includegraphics[page=1]{output/rem__lambda_term_parentheses}
    \end{equation*}

    But it is reasonable to expect instead the following tree:
    \begin{equation*}
      \includegraphics[page=2]{output/rem__lambda_term_parentheses}
    \end{equation*}

    Since we will generally expect the latter, it is simpler to require parentheses around \( \muplambda \)-abstractions in the formal syntax and then, when convenient, avoid writing them within the metalogic.

    \thmitem{rem:lambda_term_notation_conventions/left_associative} We suppose that \( \muplambda \)-application is \hyperref[con:one_sided_associativity/left]{left-associative}, which allows us to simplify notation in some cases like \eqref{eq:ex:def:lambda_term/combinator/s}, where we use \( \synx \synz (\syny \synz) \) rather than \( (\synx \synz)(\syny \synz) \).

    This convention is used by Church himself in \incite[58]{Church1940STT}, as well as our main sources --- \incite[1]{Hindley1997BasicSTT}, \incite[notation 2.1.3]{Barendregt1984LambdaCalculus} and \incite[112]{Mimram2020ProgramEqualsProof}.

    It resembles the condensed notation for functions we describe in \cref{def:function_application_notation/condensed}.
  \end{thmenum}
\end{remark}

\paragraph{Subterms}

\begin{definition}\label{def:lambda_subterm}\mcite[def. 1A3]{Hindley1997BasicSTT}
  We define the set of all \term[ru=подтерм (\cite[269]{Герасимов2014Вычислимость})]{subterms} of a \( \muplambda \)-term \( M \) as follows:
  \begin{equation*}
    \op*{Subterm}(M) \coloneqq \begin{cases}
      \set{ M },                                             &M \in \op*{Atom}, \\
      \set{ M } \cup \op*{Subterm}(N) \cup \op*{Subterm}(K), &M = N K, \\
      \set{ M } \cup \op*{Subterm}(N),                       &M = \qabs x N.
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item Note that the analog of \cref{thm:propositional_formula_characterization} no longer holds --- a variable that is a substring of a term is not necessarily a subterm --- see \cref{ex:def:lambda_term/naive_subterm}.
\end{comments}

\begin{proposition}\label{thm:lambda_subterm_characterization}
  Suppose that the \hyperref[def:formal_language/substring]{substring} \( N \) of the \( \muplambda \)-term \( M \) is \hi{not a variable}. Then \( N \) is a \hyperref[def:lambda_subterm]{subterm} of \( M \) if and only if \( N \) is itself a \( \muplambda \)-term.
\end{proposition}
\begin{proof}
  We can give a proof similar to \cref{thm:propositional_formula_characterization}.
\end{proof}

\begin{proposition}\label{thm:lambda_term_ast_subterm}
  The \( \muplambda \)-term \( N \) is a \hyperref[def:lambda_subterm]{subterm} of \( M \) if and only if the \hyperref[def:lambda_term_ast]{abstract syntax tree} \( T(M) \) has a \hyperref[def:tree/subtree]{subtree} \hyperref[def:labeled_tree/homomorphism]{isomorphic} to \( T(N) \).
\end{proposition}
\begin{proof}
  Trivial.
\end{proof}

\begin{example}\label{ex:def:lambda_term}
  We list examples of \hyperref[def:lambda_term]{\( \muplambda \)-terms}:
  \begin{thmenum}
    \thmitem{ex:def:lambda_term/var} The simplest \( \muplambda \)-terms are the constants and variables.

    \thmitem{ex:def:lambda_term/naive_subterm} Suppose that, as in \cref{def:propositional_subformula} for propositional subformulas, we say that \( N \) is a subterm of \( M \) if it is itself a \hyperref[def:formal_language/substring]{substring} of \( M \).

    Then the term \( \qabs \synx \syny \) would have both \( \synx \) and \( \syny \) as subterms, while according to \cref{def:lambda_subterm}, only \( \syny \) is a subterm.

    \thmitem{ex:def:lambda_term/combinator}\mcite[def. 1A10.1]{Hindley1997BasicSTT} The following terms have established names:
    \begin{align*}
      \ref{eq:ex:def:lambda_term/combinator/i} &\coloneqq \qabs \synx \synx,                                                           \taglabel[\ensuremath{I}]{eq:ex:def:lambda_term/combinator/i} \\
      \ref{eq:ex:def:lambda_term/combinator/k} &\coloneqq \qabs \synx \qabs \syny \synx,                                               \taglabel[\ensuremath{K}]{eq:ex:def:lambda_term/combinator/k} \\
      \ref{eq:ex:def:lambda_term/combinator/s} &\coloneqq \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz),               \taglabel[\ensuremath{S}]{eq:ex:def:lambda_term/combinator/s} \\
      \ref{eq:ex:def:lambda_term/combinator/y} &\coloneqq \qabs \synx (\qabs \syny \synx \syny \syny) (\qabs \syny \synx \syny \syny). \taglabel[\ensuremath{Y}]{eq:ex:def:lambda_term/combinator/y}
    \end{align*}

    They are combinators in the sense that will be defined in \cref{def:lambda_combinator}, and are referred to as such. We will further discuss them in \cref{ex:def:beta_eta_reduction}.

    Another useful family of combinators is the following, taken from \cite[\S 3.1.21; \S 6.2.1]{Barendregt1984LambdaCalculus}:
    \begin{align*}
      \ref{eq:ex:def:lambda_term/combinator/omega_n}   &\coloneqq \qabs \synx \synx^n,     \taglabel[\ensuremath{ \omega_n }]{eq:ex:def:lambda_term/combinator/omega_n} \\
      \ref{eq:ex:def:lambda_term/combinator/omega}     &\coloneqq \qabs \synx \synx \synx, \taglabel[\ensuremath{ \omega }]{eq:ex:def:lambda_term/combinator/omega} \\
      \ref{eq:ex:def:lambda_term/combinator/big_omega} &\coloneqq \omega \omega.           \taglabel[\ensuremath{ \Omega }]{eq:ex:def:lambda_term/combinator/big_omega}
    \end{align*}
  \end{thmenum}
\end{example}

\paragraph{Variable binding}

\begin{concept}\label{con:variable_binding}
  Consider the \hyperref[con:expression]{expression}
  \begin{equation*}
    \sum_{k=1}^n x_k.
  \end{equation*}

  The \hyperref[con:variable]{variable} \( k \) is bound by the summation operator, but \( n \) is not --- its interpretation is not determined by the expression alone.

  In some \hyperref[con:logical_system]{logical systems} like \( \muplambda \)-calculus and higher-order logic, this can be formalized --- we can associate variables with scopes in which they are bound. Within this scope, their interpretation will be determined by the rules of the logical system alone.

  Correspondingly, in the \( \muplambda \)-term \( \qabs x M \), we call \( \muplambda \) the \term[en=binder (\cite[23]{UnivalentFoundationsProgram2013HoTT})]{binder}. We will also encounter other binders --- \( \synprod \) in \( \synsum \) in \fullref{sec:dependent_types}, as well as the \hyperref[def:predicate_logic_alphabet/quantifiers]{quantifiers} \( \synforall \) and \( \synexists \) in \fullref{sec:first_order_logic}.

  Variables that are not bound will be called \term{free}, and for determining their interpretation we will need additional machinery.
\end{concept}
\begin{comments}
  \item The algebraic analogue of free variables are indeterminates --- see \cref{con:free_construction}.
\end{comments}

\begin{remark}\label{rem:variable_binding_properties}
  We will use several variable binders --- the \( \muplambda \)-abstraction terms in \cref{def:lambda_abstractor}, dependent and polymorphic types in \fullref{sec:dependent_types}, first-order formulas in \fullref{sec:first_order_logic} and higher-order formulas in \fullref{sec:higher_order_logic}. In all those cases, we will find useful the same patterns of definitions:
  \begin{itemize}
    \item Binder scope as defined in \cref{def:lambda_abstractor}.
    \item Free and bound variables as defined in \cref{def:lambda_variable_freeness}.
    \item Capture-avoiding substitution as defined in \cref{def:atomic_lambda_term_substitution}, with properties like \cref{thm:lambda_substitution_noop}, \cref{thm:lambda_substitution_free_variables_single} and \cref{thm:lambda_substitution_single_rule}.
    \item \( \alpha \)-equivalence as defined in \cref{def:lambda_term_alpha_equivalence}, with properties like \cref{thm:def:lambda_term_alpha_equivalence}, \cref{thm:nary_substitution_composition_is_alpha_equivalent}, \cref{thm:substitution_on_alpha_equivalent_terms}, \cref{thm:alpha_conversion} and \fullref{alg:separation_of_free_and_bound_variables}.
  \end{itemize}

  We will study all of these in depth in the simple case of \( \muplambda \)-terms and, whenever we define another binder, we will extend the above by analogy.
\end{remark}

\begin{remark}\label{rem:apparent_variables}
  According to \cite[11]{Church1956LogicVol1}, in a tradition due to Peano and Russell, \hyperref[con:variable_binding]{bound variables} used to be called \enquote{apparent variables} and free variables used to be called \enquote{real variables}.

  \incite[228]{Russell1908TypeTheory} himself attributes the terminology to Peano, and gives the following characterization:
  \begin{displayquote}
    \ldots when \textit{any} value of a propositional function is asserted, the argument (e.g., \( f \) in the above) is called a \textit{real} variable; whereas, when a function is said to be \textit{always} true, or to be not always true, the argument is called an \textit{apparent} variable. Thus in the above definition, \( f \) is a real variable, and \( \sigma \), \( \varepsilon \) and \( \delta \) are apparent variables.
  \end{displayquote}

  In the above, he refers to the following definition:
  \begin{displayquote}
    \enquote{We call \( f(x) \) continuous for \( x = a \) if, for every positive number \( \sigma \), different from \( 0 \), there exists a positive number \( \varepsilon \), different from \( 0 \), such that, for all values of \( \delta \) which are numerically less than \( \varepsilon \), the difference \( f(a + \delta) - f(a) \) is numerically less than \( \sigma \)}.
  \end{displayquote}

  Although no explicit variable binders are involved, it is clear that, in modern terms, \( \sigma \) and \( \delta \) are universally quantified and \( \varepsilon \) is existentially quantifier, while \( f \) is free.
\end{remark}

\begin{definition}\label{def:lambda_abstractor}\mcite[def. 1A5]{Hindley1997BasicSTT}
  Given an abstraction \( M = \qabs x N \), we call \( \synlambda x \) the \term{abstractor} and \( N \) --- the \term{body} of \( M \).

  We say that the body \( N \) is the \term[ru=область действия (квантора) (\cite[87]{Герасимов2014Вычислимость})]{scope} of the abstractor \( \synlambda x \) and that the abstractor \term{binds} the variable \( x \) in \( N \).
\end{definition}

\begin{definition}\label{def:lambda_variable_occurrence}\mimprovised
  An \term[en=occurrence (\cite[9A2]{Hindley1997BasicSTT})]{occurrence} of a variable \( x \) in a \( \muplambda \)-term \( M \) is a variable node with label \( x \) in the \hyperref[def:lambda_term_ast]{abstract syntax tree} of \( M \).

  Variable occurrences in \( \muplambda \)-terms can be free and bound. We say that the occurrence is \term[en=free (occurrence) (\cite[1A6]{Hindley1997BasicSTT})]{free} in \( M \) if the root of the AST can be reached without passing through a corresponding abstractor. If a occurrence is not free, there exists an abstractor that binds it, and we say that the occurrence is \term[en=bound (occurrence) (\cite[1A6]{Hindley1997BasicSTT})]{bound} in \( M \).
\end{definition}
\begin{comments}
  \item We give a similar definition for first-order formulas in \cref{def:fol_variable_occurrence}.
\end{comments}

\begin{definition}\label{def:lambda_variable_freeness}\mcite[16A]{Hindley1997BasicSTT}
  We say that a variable \( x \) is \term{free} in a \( \muplambda \)-term \( M \) if \( x \) has at least one \hyperref[def:lambda_variable_occurrence]{free occurrence} in \( M \) and \term{bound} if it has a \hyperref[def:lambda_variable_occurrence]{bound occurrence} in \( M \).
\end{definition}
\begin{comments}
  \item We may use the recursive definitions from \cref{thm:lambda_variable_freeness_characterization} instead.
  \item We give a similar definition for first-order formulas in \cref{def:fol_variable_occurrence}.
\end{comments}

\begin{example}\label{ex:def:lambda_variable_freeness}
  We list examples of free and bound variables and variables occurrences:
  \begin{thmenum}
    \thmitem{ex:def:lambda_variable_freeness/abstractor} The term \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) has exactly one occurrence of \( \synx \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__lambda_variable_freeness}
    \end{equation*}

     This occurrence is bound in the term \( I \) and free in the subterm \( \synx \). Then \( \synx \) is a bound variable in \( I \) and a free variable in \( I \).

    \thmitem{ex:def:lambda_variable_freeness/both} The term \( M = I \synx = (\qabs \synx \synx) \synx \) has two occurrences of the variable \( \synx \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__lambda_variable_freeness}
    \end{equation*}

    One of the occurrences is free, which makes \( \synx \) a free variable of \( M \), and one of the occurrences if bound, which makes \( \synx \) a bound variable of \( M \).

    \thmitem{ex:def:lambda_variable_freeness/binds} In the term \( \qabs \synx \qabs \synx \synx \), only the second abstractor is binding for \( \synx \).
  \end{thmenum}
\end{example}

\begin{remark}\label{rem:barendregt_variable_convention}
  \incite*[\S 2.1.13]{Barendregt1984LambdaCalculus} assumes the following variable convention:
  \begin{displayquote}
    If \( M_1, \ldots, M_n \) occur in a certain mathematical context (e.g. definition, proof), then in these terms all bound variables are chosen to be different from the free variables.
  \end{displayquote}

  \incite*[\S 3.6.1]{Mimram2020ProgramEqualsProof} calls this the \enquote{Barendregt convention} and rephrases it as follows:
  \begin{displayquote}
    \ldots all variables which are \( \muplambda \)-abstracted should be pairwise distinct and distinct from all free variables.
  \end{displayquote}

  We will aim to follow this convention when providing explicit terms, but not assume it for arbitrary terms that may not follow it.
\end{remark}
\begin{comments}
  \item This is not to be confused with Barendregt's \( \alpha \)-equivalence convention described in \cref{rem:barendregt_convention}.
\end{comments}

\begin{proposition}\label{thm:lambda_variable_freeness_characterization}
  The set of all \hyperref[def:lambda_variable_freeness]{free variables} of a \( \muplambda \)-term can be characterized as follows:
  \begin{equation*}
    \op*{Free}(M) \coloneqq \begin{cases}
      \varnothing,                       &M \in \op*{Const}, \\
      \set{ M },                         &M \in \op*{Var}, \\
      \op*{Free}(N) \cup \op*{Free}(K),  &M = N K, \\
      \op*{Free}(N) \setminus \set{ x }, &M = \qabs x N. \\
    \end{cases}
  \end{equation*}

  Similarly, the bound variables can be characterized via
  \begin{equation*}
    \op*{Bound}(M) \coloneqq \begin{cases}
      \varnothing,                        &M \in \op*{Const}, \\
      \varnothing,                        &M \in \op*{Var}, \\
      \op*{Bound}(N) \cup \op*{Bound}(K), &M = N K, \\
      \op*{Bound}(N) \cup \set{ x },      &M = \qabs x N. \\
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item We show an analogous result for first-order formulas in \cref{thm:fol_variable_freeness_characterization}.
\end{comments}
\begin{proof}
  Straightforward.
\end{proof}

\begin{definition}\label{def:lambda_combinator}\mcite[def. 1A10]{Hindley1997BasicSTT}
  We say that a \( \muplambda \)-term is \term{closed} if it has no \hyperref[def:lambda_variable_freeness]{free variables}. Closed terms are also called \term[ru=комбинаторы (\cite[269]{Герасимов2014Вычислимость})]{combinators}.
\end{definition}

\paragraph{Simultaneous substitution}

\begin{concept}\label{con:lambda_conversion}
  A fundamental feature of \hyperref[def:lambda_term]{\( \muplambda \)-terms} is \enquote{conversion} --- the ability to transform terms into other terms with simpler syntax and similar semantics. Thus, \enquote{conversion} is synonymous with \enquote{rewriting} in the \hyperref[def:rewriting_system]{rewriting systems} for \( \muplambda \)-terms that we will discuss.

  This usage originates from Alonzo Church himself. When introducing \( \lambda \)-calculus in \cite[357]{Church1932LambdaCalculus}, he defines \hyperref[def:atomic_lambda_term_substitution]{single-variable substitution} as the first three of five postulates, and later states
  \begin{displayquote}
    If \( M \) and \( N \) are well-formed and if \( N \) can be derived from \( M \) by successive applications of the rules of procedure \logic{I}, \logic{II}, and \logic{III}, then \( M \) is said to be convertible into \( N \), and the process is spoken of as a conversion of \( M \) into \( N \).
  \end{displayquote}

  Later, different authors introduced \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}, \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} and \hyperref[def:beta_eta_reduction]{\( \eta \)-reduction}. This lead to variations of the word \enquote{conversion} which refer to other rewriting systems and not only substitution. For example, \enquote{\( \alpha \)-conversion} is used by \incite[\S 2.1.11]{Barendregt1984LambdaCalculus}, \incite[def. 1A8]{Hindley1997BasicSTT}, \incite[114]{Mimram2020ProgramEqualsProof} and \incite[5]{Pollack2005AlphaConversion} (with subtle differences as discussed in \cref{def:lambda_term_alpha_equivalence}).

  When the intention of a conversion procedure is for terms to become shorter, we call the procedure a \term{reduction}, and we call the reverse procedure an \term{expansion}. If both are possible, we call the procedure an \term{equivalence}.
\end{concept}

\begin{definition}\label{def:atomic_lambda_term_substitution}\mimprovised
  For \hyperref[con:syntactic_substitution]{simultaneous substitution} of \hyperref[def:lambda_term]{\( \muplambda \)-terms}, we will need a pair \( (\Bbbs, \sharp) \), where
  \begin{thmenum}[series=def:atomic_lambda_term_substitution]
    \thmitem{def:atomic_lambda_term_substitution/atomic} \( \Bbbs: \op*{Var} \to \op*{Term} \) is a function specifying how variables need to be replaced with terms. We allow only finitely many variables to not be fixed by \( \Bbbs \). We call \( \Bbbs \) an \term{atomic substitution}.

    \thmitem{def:atomic_lambda_term_substitution/sharp} \( \sharp: F \to \op*{Var} \), where \( F \) is the family of all finite sets of \( \op*{Var} \), is a function providing us with a fresh variable identifier not present in a given set of variables.

    By default, we suppose that \( \sharp(V) \) is the smallest, with respect to the \hyperref[def:variable_identifier]{identifier order}, variable not in \( V \).
  \end{thmenum}

  For \fullref{alg:lambda_term_substitution}, we will need the following auxiliary definitions:
  \begin{thmenum}[resume=def:atomic_lambda_term_substitution]
    \thmitem{def:atomic_lambda_term_substitution/modified} We will find useful the concept of \term{modifying} \( \Bbbs \) at \( x \) with \( y \):
    \begin{equation}\label{eq:alg:lambda_term_substitution/modified}
      \Bbbs_{x \mapsto y}(u) \coloneqq \begin{cases}
        y,        &u = x, \\
        \Bbbs(u), &u \neq x.
      \end{cases}
    \end{equation}

    \thmitem{def:atomic_lambda_term_substitution/free} In order to be able to define substitutions for arbitrary terms, we will also need the following auxiliary definition:
    \begin{equation}\label{eq:alg:lambda_term_substitution/free}
      \op*{Free}_\Bbbs(M) \coloneqq \bigcup_{\mathclap{v \in \op*{Free}(M)}} \op*{Free}(\Bbbs(v)).
    \end{equation}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The auxiliary function \( \sharp \) allows determinism when choosing a new variable during renaming in \fullref{alg:lambda_term_substitution}. This enables programmatic implementations. A more theoretical consequence of this determinism is \cref{thm:lambda_substitution_restriction}.
\end{comments}

\begin{algorithm}[\( \muplambda \)-term substitution]\label{alg:lambda_term_substitution}\mimprovised
  We can extend a \hyperref[def:atomic_lambda_term_substitution]{simultaneous substitution} \( (\Bbbs, \sharp) \) to an arbitrary \( \muplambda \)-term \( M \) as follows:
  \begin{empheq}[left={M[\Bbbs]} \coloneqq \empheqlbrace]{align}
    &M,                              &&M \in \op*{Const},                                   \label{eq:alg:lambda_term_substitution/const}               \\
    &\Bbbs(x),                       &&M = x \in \op*{Var},                                     \label{eq:alg:lambda_term_substitution/var}                 \\
    &N[\Bbbs] \thinspace K[\Bbbs],   &&M = NK,                                              \label{eq:alg:lambda_term_substitution/application}         \\
    &\qabs x N[\Bbbs_{x \mapsto x}], &&M = \qabs x N \T{and} x \not\in \op*{Free}_\Bbbs(M), \label{eq:alg:lambda_term_substitution/abstraction/direct}  \\
    &\qabs n N[\Bbbs_{x \mapsto n}], &&M = \qabs x N \T{and} x \in \op*{Free}_\Bbbs(M),     \label{eq:alg:lambda_term_substitution/abstraction/renaming}
  \end{empheq}
  where \( n = \sharp(\op*{Free}_\Bbbs(M)) \).
\end{algorithm}
\begin{comments}
  \item In practice, we use the more convenient notational convention from \cref{rem:substitution_notation}, i.e. \( M[x \mapsto N] \) when \( \Bbbs(x) = N \) and the other points are fixed.

  \item In \eqref{eq:alg:lambda_term_substitution/abstraction/direct} we modify \( \Bbbs \) to fix \( x \), while in \eqref{eq:alg:lambda_term_substitution/abstraction/renaming} we modify it to send \( x \) to \( n \). We will refer to the latter rule as \enquote{substitution with renaming}. Whenever it will be sufficient, \cref{thm:lambda_substitution_single_rule} will allow us to compress them into one rule with a looser condition.

  \item This definition is loosely based on \cite[def. 1A7]{Hindley1997BasicSTT}, but is modified to allow substituting multiple variables simultaneously, as well as to handle constants. This results in less rules since \eqref{eq:alg:lambda_term_substitution/abstraction/direct} subsumes three of the four cases.

  \item Due to how fresh variables are chosen, the substitution \( M[x \mapsto N, y \mapsto K] \) cannot be properly emulated by iterated substitution as in \cref{rem:simulating_simultaneous_substitution} --- this can only be done \enquote{up to \( \alpha \)-equivalence}, as shown in \cref{thm:nary_substitution_composition_is_alpha_equivalent}. \Cref{ex:alg:lambda_term_substitution/composed_vs_iterated} demonstrates subtleties that arise.

  \item In \fullref{alg:simply_typed_substitution} we will show how \hyperref[def:type_derivation_tree]{type derivation trees} for \( M \) and \( L \) can be used to build a derivation tree for \( M[x \mapsto L] \) .

  \item This algorithm can be found as \identifier{math.lambda_.untyped.substitution.apply_term_substitution} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:renaming_substitution_rules}
  The substitution rules for abstractions from \cref{def:atomic_lambda_term_substitution} are adjusted so that \cref{thm:lambda_substitution_free_variables} and \cref{thm:lambda_substitution_noop} hold.

  The bare minimum we need is to avoid \enquote{variable capturing} as discussed in \cref{ex:alg:lambda_term_substitution/capture}. As we can see in the proof of \cref{thm:lambda_substitution_free_variables}, the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming} is by itself sufficient for this. Thus, we may choose to always rename the abstractor variable. See \cref{ex:alg:lambda_term_substitution/ignoring} for concrete examples.

  In practice, however, we would prefer to not rename bound variables unless absolutely necessary, especially in \hyperref[def:lambda_combinator]{combinators}. One immediate benefit is that the rule \eqref{eq:alg:lambda_term_substitution/abstraction/direct} allows us to prove \cref{thm:lambda_substitution_noop}.

  We say that the variable \( x \) is \term[en=free for (\cite[213]{Andrews2002Logic})]{free for} \( N \) in \( M \) if no bound variable needs to be renamed during the substitution \( M[x \mapsto N] \). In such cases the direct substitution rule \eqref{eq:alg:lambda_term_substitution/abstraction/direct} is sufficient.
\end{remark}

\begin{proposition}\label{thm:lambda_substitution_free_variables}
  For any \( \muplambda \)-term \( M \) and any atomic substitution \( \Bbbs \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables}
    \op*{Free}( M[\Bbbs] ) = \overbrace{\bigcup_{\mathclap{v \in \op*{Free}(M)}} \op*{Free}(\Bbbs(v))}^{\op*{Free}_\Bbbs(M)}.
  \end{equation}

  This also holds if we always use the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming}.
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_abstract_syntax} on of \( M \) simultaneously for all possible substitutions:
  \begin{itemize}
    \item If \( M \) is a constant, then both sides of \eqref{eq:thm:lambda_substitution_free_variables} are the empty set.

    \item If \( M \) is a variable, say \( M = x \), then \( \op*{Free}(M) = \set{ x } \) and thus
    \begin{equation*}
      \op*{Free}(M[\Bbbs])
      \reloset {\eqref{eq:alg:lambda_term_substitution/var}} =
      \op*{Free}(\Bbbs(x)).
    \end{equation*}

    Hence, \eqref{eq:thm:lambda_substitution_free_variables} is satisfied.

    \item Suppose that \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \).

    We have
    \begin{equation*}
      \op*{Free}(M[\Bbbs])
      \reloset {\eqref{eq:alg:lambda_term_substitution/application}} =
      \op*{Free}(N[\Bbbs] \thinspace K[\Bbbs])
      =
      \op*{Free}(N[\Bbbs]) \cup \op*{Free}(K[\Bbbs]).
    \end{equation*}

    Since, by definition, \( \op*{Free}(M) = \op*{Free}(N) \cup \op*{Free}(K) \), from the inductive hypothesis it follows that \eqref{eq:thm:lambda_substitution_free_variables} holds.

    \item Suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \). We have the following possibilities:
    \begin{itemize}
      \item Suppose first that \( x \not\in \op*{Free}_\Bbbs(M) \). We must thus use \eqref{eq:alg:lambda_term_substitution/abstraction/direct}. We have
      \begin{align*}
        \op*{Free}(M[\Bbbs])
        &\reloset{\eqref{eq:alg:lambda_term_substitution/abstraction/direct}} =
        \op*{Free}(\qabs x N[\Bbbs_{x \mapsto x}])
        = \\ &=
        \op*{Free}(N[\Bbbs_{x \mapsto x}]) \setminus \set{ x }
        \reloset{\T{ind.}} = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{v \in \op*{Free}(N)}} \op*{Free}(\Bbbs_{x \mapsto x}(v)) } \setminus \set{ x }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N)}} \parens[\Big]{ \op*{Free}(\Bbbs_{x \mapsto x}(v)) \setminus \set{ x } }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\underbrace{\Bbbs_{x \mapsto x}(v)}_{\Bbbs(v)}) \setminus \set{ x } } \cup \underbrace{\parens[\Big]{ \op*{Free}(\Bbbs_{x \mapsto x}(x)) \setminus \set{ x } }}_\varnothing.
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\Bbbs(v)) },
      \end{align*}
      where at the last step we have used that, for \( v \in \op*{Free}(N) \), \( x \) is free in \( \Bbbs(v) \) only when \( v = x \).

      This demonstrates \eqref{eq:thm:lambda_substitution_free_variables}.

      \item Otherwise, \( x \in \op*{Free}_\Bbbs(M) \), and we must use \eqref{eq:alg:lambda_term_substitution/abstraction/renaming}. As discussed in \cref{rem:renaming_substitution_rules}, the assumption itself is irrelevant for proving \eqref{eq:thm:lambda_substitution_free_variables}.

      Let \( n \) be the renamed abstractor variable. Then
      \begin{align*}
        \op*{Free}(M[\Bbbs])
        &=
        \op*{Free}(\qabs n N[\Bbbs_{x \mapsto n}])
        = \\ &=
        \op*{Free}(N[\Bbbs_{x \mapsto n}]) \setminus \set{ n }
        \reloset {\T{ind.}} = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{v \in \op*{Free}(N)}} \op*{Free}(\Bbbs_{x \mapsto n}(v)) } \setminus \set{ n }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N)}} \parens[\Big]{ \op*{Free}(\Bbbs_{x \mapsto n}(v)) \setminus \set{ n } }
        = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\Bbbs_{x \mapsto n}(v)) \setminus \set{ n } } } \cup \parens[\Big]{ \underbrace{\op*{Free}(\Bbbs_{x \mapsto n}(x)) \setminus \set{ n }}_\varnothing }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\Bbbs(v)) \setminus \set{ x } },
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(M) \setminus \set{ x }}} \op*{Free}(\Bbbs(v)),
      \end{align*}
      where in the last step we have used that \( n \) is not free in \( \Bbbs(v) \) because it does not, by definition, belong to \( \op*{Free}_\Bbbs(N) \).

      This demonstrates \eqref{eq:thm:lambda_substitution_free_variables}.
    \end{itemize}
  \end{itemize}

  The induction is complete.
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_free_variables_single}
  For any two \( \muplambda \)-terms \( M \) and \( N \) and any variable \( x \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables_single}
    \op*{Free}( M[x \mapsto N] ) = \begin{cases}
      \parens[\Big]{ \op*{Free}(M) \setminus \set{ x } } \cup \op*{Free}(N), &x \in \op*{Free}(M) \\
      \op*{Free}(M),                                                         &\T{otherwise.}
    \end{cases}
  \end{equation}

  In both cases,
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables_single/subset}
    \op*{Free}( M[x \mapsto N] ) \subseteq \parens[\Big]{ \op*{Free}(M) \setminus \set{ x } } \cup \op*{Free}(N).
  \end{equation}
\end{corollary}
\begin{proof}
  Denote by \( \Bbbs \) the substitution sending \( x \) to \( N \). If \( x \) is free in \( M \), then
  \begin{equation*}
    \op*{Free}(M[x \mapsto N])
    \reloset{\eqref{eq:thm:lambda_substitution_free_variables}} =
    \bigcup_{\mathclap{v \in \op*{Free}(M)}} \op*{Free}(\Bbbs(v))
    =
    \op*{Free}(\overbrace{\Bbbs(x)}^N) \cup \bigcup_{\mathclap{v \in \op*{Free}(M) \setminus \set{ x }}} \overbrace{\op*{Free}(\Bbbs(v))}^{\set{ v }}.
  \end{equation*}

  Otherwise,
  \begin{equation*}
    \op*{Free}(M[v \mapsto N])
    \reloset{\eqref{eq:thm:lambda_substitution_free_variables}} =
    \bigcup_{\mathclap{v \in \op*{Free}(M)}} \overbrace{\op*{Free}(\Bbbs(v))}^{\set{ v }}
    =
    \op*{Free}(M).
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_single_rule}
  For any abstraction \( M = \qabs x N \) and substitution \( \Bbbs \), there exists a variable \( v \not\in \op*{Free}_\Bbbs(M) \) such that
  \begin{equation}\label{eq:thm:lambda_substitution_single_rule}
    M[\Bbbs] = \qabs v N[\Bbbs_{x \mapsto v}].
  \end{equation}
\end{proposition}
\begin{comments}
  \item \Cref{thm:lambda_substitution_free_variables} implies that \( \op*{Free}_\Bbbs(M) = \op*{Free}(M[\Bbbs]) \).

  \item The variable \( v \) may be \( x \) or it may be a fresh variable. This unifies the two distinct cases from \cref{def:atomic_lambda_term_substitution}.
\end{comments}
\begin{proof}
  We have two cases to consider:
  \begin{itemize}
    \item If \( x \in \op*{Free}_\Bbbs(M) \), we must use the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming}. Let \( n \) be the renamed abstractor variable. Then
    \begin{equation*}
      M[\Bbbs] = \qabs n N[\Bbbs_{x \mapsto n}].
    \end{equation*}

    The new variable \( n \) is by construction not in \( \op*{Free}_\Bbbs(M) \).

    \item Otherwise, \( x \not\in \op*{Free}_\Bbbs(M) \) and we must use \eqref{eq:alg:lambda_term_substitution/abstraction/direct}:
    \begin{equation*}
      M[\Bbbs] = \qabs x N[\Bbbs_{x \mapsto x}].
    \end{equation*}

    In this case there is nothing to prove.
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_restriction}
  If the substitutions \( \Bbbs \) and \( \Bbbt \) agree on the free variables of \( M \), then
  \begin{equation}\label{eq:thm:lambda_substitution_restriction}
    M[\Bbbs] = M[\Bbbt].
  \end{equation}
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_abstract_syntax} on of \( M \) to show \eqref{eq:thm:lambda_substitution_restriction} simultaneously for all suitable substitutions.

  \begin{itemize}
    \item If \( M \) is a constant, it is invariant under substitution and
    \begin{equation*}
      M[\Bbbs] = M = M[\Bbbt].
    \end{equation*}

    \item If \( M \) is a variable, it is a free variable of itself, and hence \( \Bbbs \) and \( \Bbbt \) agree on it.

    \item If \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \), then
    \begin{equation*}
      M[\Bbbs]
      =
      N[\Bbbs] \thinspace K[\Bbbs]
      \reloset {\T{ind.}} =
      N[\Bbbs] \thinspace K[\Bbbs]
      =
      M[\Bbbs],
    \end{equation*}
    as desired.

    \item The final case \( M = \qabs x N \) is a little more complicated. By assumption, we have the equality
    \begin{equation*}
      \op*{Free}_\Bbbs(M) = \op*{Free}_\Bbbt(M),
    \end{equation*}

    \begin{itemize}
      \item If \( x \) is in \( \op*{Free}_\Bbbs(M) \), we must use the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming} with the same variable
      \begin{equation*}
        n \coloneqq \sharp(\op*{Free}_\Bbbs(M)) = \sharp(\op*{Free}_\Bbbt(M)).
      \end{equation*}

      We have
      \begin{align*}
        M[\Bbbs] &= \qabs n N[\Bbbs_{x \mapsto n}], \\
        M[\Bbbt] &= \qabs n N[\Bbbt_{x \mapsto n}].
      \end{align*}

      Since the inductive hypothesis holds for \( N \), we have
      \begin{equation*}
        N[\Bbbs_{x \mapsto u}] = N[\Bbbt_{x \mapsto u}],
      \end{equation*}
      hence \( M[\Bbbs] = M[\Bbbt] \).

      \item If \( x \) is not in \( \op*{Free}_\Bbbs(M) \), we must use the non-renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/direct}:
      \begin{align*}
        M[\Bbbs] &= \qabs x N[\Bbbs_{x \mapsto x}], \\
        M[\Bbbt] &= \qabs x N[\Bbbt_{x \mapsto x}].
      \end{align*}

      Then \( M[\Bbbs] = M[\Bbbt] \) again follows from the inductive hypothesis.
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_noop}
  We have \( M[\Bbbs] = M \) if and only if the free variables of \( M \) are fixed by the substitution \( \Bbbs \).
\end{proposition}
\begin{proof}
  \SufficiencySubProof Suppose that \( M[\Bbbs] = M \). We will use \fullref{thm:induction_on_abstract_syntax} on of \( M \) to show that \( \Bbbs(x) = x \) whenever \( x \) is free in \( M \):
  \begin{itemize}
    \item If \( M \) is a constant, it has no free variables, so the statement vacuously holds.
    \item If \( M \) is a variable, then \( \Bbbs(M) = M[\Bbbs] = M \), proving the statement.
    \item If \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \), then
    \begin{equation*}
      N[\Bbbs] \thinspace K[\Bbbs]
      =
      M[\Bbbs]
      \reloset {\T{ind.}} =
      M
      =
      N \thinspace K.
    \end{equation*}

    Thus, \( N[\Bbbs] = N \) and \( K[\Bbbs] = K \). Applying the inductive hypothesis, we conclude that \( \Bbbs \) fixes the free variables of both \( N \) and \( K \), and hence of \( M \).

    \item Suppose that \( M = \qabs x N \) and the inductive hypothesis holds for \( N \).

    \Cref{thm:lambda_substitution_single_rule} implies that, for some variable \( v \) not in \( \op*{Free}_\Bbbs(M) \), we have
    \begin{equation*}
      M[\Bbbs] = \qabs v N[\Bbbs_{x \mapsto v}].
    \end{equation*}

    Since \( M = M[\Bbbs] \), however, \( v \) must be equal to \( x \) and \( N[\Bbbs_{x \mapsto x}] \) to \( N \).

    The inductive hypothesis on \( N \) implies that \( \Bbbs_{x \mapsto x} \) fixes all free variables of \( N \). Then \( \Bbbs \) fixes all free variables of \( M \).
  \end{itemize}

  \NecessitySubProof We will use \fullref{thm:induction_on_abstract_syntax} on of \( M \) to show that \( M[\Bbbs] = M \) for all \( \Bbbs \) that fix the free variables of \( M \):
  \begin{itemize}
    \item If \( M \) is a constant, then \( M[\Bbbs] = M \) by definition.
    \item If \( M \) is a variable, then \( M[\Bbbs] = \Bbbs(M) = M \) by assumption.
    \item If \( M = NK \) and if the inductive hypothesis holds for \( N \) and \( K \), then
    \begin{equation*}
      M[\Bbbs]
      \reloset {\eqref{eq:alg:lambda_term_substitution/application}} =
      N[\Bbbs] \thinspace K[\Bbbs]
      \reloset {\T{ind.}} =
      N K
      =
      M.
    \end{equation*}

    \item Suppose that \( M = \qabs x N \) and the inductive hypothesis holds for \( N \).

    Aiming at a contradiction, suppose that \( x \) is in \( \op*{Free}_\Bbbs(M) \), that is, there exists a free variable \( y \) of \( M \) such that \( x \) is free in \( \Bbbs(y) \). We have assumed that \( \Bbbs \) fixes the free variables of \( M \), thus \( y = \Bbbs(y) \), and we thus conclude that \( x = y \). In particular, \( x \) is free in \( M \). But, by \cref{thm:lambda_variable_freeness_characterization}, \( x \) cannot be free in \( M \).

    Therefore, \( x \) cannot be in \( \op*{Free}_\Bbbs(M) \), and we must use the direct substitution rule \eqref{eq:alg:lambda_term_substitution/abstraction/direct}. The free variables of \( N \) are those of \( N \) with the eventual addition of \( x \), all of which are fixed by \( \Bbbs_{x \mapsto x} \). Hence,
    \begin{equation*}
      M[\Bbbs]
      =
      \qabs x N[\Bbbs_{x \mapsto x}]
      \reloset {\T{ind.}} =
      \qabs x N
      =
      M.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_combinators}
  For any \hyperref[def:lambda_combinator]{combinator} \( M \) and any atomic substitution \( \Bbbs \), we have \( M[\Bbbs] = M \).
\end{corollary}
\begin{proof}
  Vacuously follows from \cref{thm:lambda_substitution_noop} since combinators simply have no free variables.
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_identity}
  For any term \( M \), we have \( M[\id] = M \) for the identity substitution \( \id \).
\end{corollary}
\begin{proof}
  Follows from \cref{thm:lambda_substitution_noop}.
\end{proof}

\begin{example}\label{ex:alg:lambda_term_substitution}
  We list examples of \hyperref[def:atomic_lambda_term_substitution]{atomic substitution} of \( \muplambda \)-terms:
  \begin{thmenum}
    \thmitem{ex:alg:lambda_term_substitution/simultaneous} We start with an example where we analyze the abstraction rules in detail. Consider
    \begin{equation*}
      \parens[\Big]{ \underbrace{\qabs \synx \synx \syny \synz}_M }[\underbrace{\synx \mapsto \syna, \syny \mapsto \synb, \synz \mapsto \sync}_\Bbbs].
    \end{equation*}

    We have \( \op*{Free}_\Bbbs(M) = \set{ \synb, \sync } \). Since \( \synx \) does not belong to this set, no renaming is necessary; we must apply \eqref{eq:alg:lambda_term_substitution/abstraction/direct}:
    \begin{equation*}
      \parens[\Big]{ \qabs \synx \synx \syny \synz }[\synx \mapsto \syna, \syny \mapsto \synb, \synz \mapsto \sync]
      =
      \qabs \synx \parens[\Big]{ (\synx \syny \synz)[\synx \mapsto \synx, \syny \mapsto \synb, \synz \mapsto \sync] }
      =
      \qabs \synx \synx \synb \sync.
    \end{equation*}

    \thmitem{ex:alg:lambda_term_substitution/nested_noop} Consider the substitution \( \ref{eq:ex:def:lambda_term/combinator/k}[\syny \mapsto \synx] \). Since \( K \) is a combinator, \cref{thm:lambda_substitution_combinators} holds and \( K[\syny \mapsto \synx] = K \).

    We will show this explicitly. Denote the substitution \( \id_{\syny \mapsto \synx} \) by \( \Bbbs \). Then
    \begin{equation*}
      \op*{Free}_\Bbbs(K)
      =
      \bigcup_{v \in \varnothing} \op*{Free}(\Bbbs(v))
      =
      \varnothing,
    \end{equation*}
    thus we must use the non-renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/direct}:
    \begin{equation*}
      K[\Bbbs]
      =
      K[\syny \mapsto \synx]
      =
      (\qabs \synx \qabs \syny \synx)[\syny \mapsto \synx]
      =
      \qabs \synx \parens[\Big]{ (\qabs \syny \synx)[\syny \mapsto \synx] }.
    \end{equation*}

    We have
    \begin{equation*}
      \op*{Free}_\Bbbs(\qabs \syny \synx)
      =
      \op*{Free}(\Bbbs(\synx))
      =
      \op*{Free}(\synx)
      =
      \set{ \synx },
    \end{equation*}
    hence
    \begin{align*}
      (\qabs \syny \synx)[\syny \mapsto \synx]
      =
      \qabs \syny (\synx[\syny \mapsto \synx])
      =
      \qabs \syny \synx.
    \end{align*}

    Therefore,
    \begin{equation*}
      K[\syny \mapsto \synx] = K.
    \end{equation*}

    We will show in \cref{ex:alg:lambda_term_substitution/composed_vs_iterated} how this becomes more subtle when two variables are substituted simultaneously.

    \thmitem{ex:alg:lambda_term_substitution/capture} The gist of \cref{thm:lambda_substitution_free_variables} is that substitution avoids \enquote{capturing} free variables under the scope of some abstraction.

    Inappropriately using the rule \eqref{eq:alg:lambda_term_substitution/abstraction/direct} in
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synx]
    \end{equation*}
    would give
    \begin{equation*}
      \qabs \synx (\synx \syny[\syny \mapsto \synx]) = \qabs \synx \synx \synx,
    \end{equation*}
    which \enquote{captures} the corresponding occurrence of \( \synx \) in the scope of the closest abstractor.

    Let \( M \coloneqq \qabs \synx \synx \syny \) and let \( \Bbbs \) be the substitution \( \id_{\syny \mapsto \synx} \). The above is then equivalent to \( M[\Bbbs] \).

    Since \( \op*{Free}(M) = \set{ \syny } \), which \( \Bbbs \) does not fix, we must use the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming}. To obtain a fresh variable, we must first note that \( \op*{Free}_\Bbbs(M) = \set{ \synx } \).

    In accordance with \cref{def:atomic_lambda_term_substitution/sharp}, \( \sharp(\set{ \synx }) \) must the smallest variable identifier (with respect to the \hyperref[def:lexicographic_order]{reverse lexicographic order}) not in \( \set{ \synx } \). This happens to be the smallest identifier overall --- \( \syna \).

    Therefore,
    \begin{equation*}
      M[\Bbbs] = (\qabs \synx \synx \syny)[\syny \mapsto \synx] = \qabs \syna ((\synx \syny)[\syny \mapsto \synx, \synx \mapsto \syna]) = \qabs \syna \syna \synx.
    \end{equation*}

    \thmitem{ex:alg:lambda_term_substitution/ignoring} We discussed in \cref{rem:renaming_substitution_rules} that we can ignore \eqref{eq:alg:lambda_term_substitution/abstraction/direct} and always use the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming}.

    \Cref{thm:lambda_substitution_combinators} would immediately fail:
    \begin{equation*}
      \ref{eq:ex:def:lambda_term/combinator/i}[\syny \mapsto \synz]
      =
      (\qabs \synx \synx)[\syny \mapsto \synz]
      \reloset {\eqref{eq:alg:lambda_term_substitution/abstraction/renaming}} =
      \qabs \syna (\synx[\syny \mapsto \synz, \synx \mapsto \syna])
      =
      \qabs \syna \syna.
    \end{equation*}

    In a slightly more complicated example where substitution is actually performed, we would obtain
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synz]
      \reloset {\eqref{eq:alg:lambda_term_substitution/abstraction/renaming}} =
      \qabs \syna (\synx \syny[\syny \mapsto \synz, \synx \mapsto a])
      =
      \qabs \syna \syna \synz
      =
      \qabs \syna \syna \synz.
    \end{equation*}
    rather than
    \begin{equation*}
      \qabs \synx \synx \synz.
    \end{equation*}

    \thmitem{ex:alg:lambda_term_substitution/composed_vs_iterated} We will show some subtleties of renaming during simultaneous substitution. Consider
    \begin{equation*}
      (\underbrace{\qabs \syna \synx \synb}_M)[\underbrace{\synx \mapsto \syna, \synb \mapsto \synx}_\Bbbs].
    \end{equation*}

    The free variables of both \( M \) and its abstractor's body are \( \synx \) and \( \synb \), hence
    \begin{equation*}
      \op*{Free}_\Bbbs(M) = \set{ \syna, \synx }.
    \end{equation*}

    The abstractor variable \( \syna \) is in \( \op*{Free}_\Bbbs(M) \), thus we must use the renaming rule \eqref{eq:alg:lambda_term_substitution/abstraction/renaming}. This new variable must be \( \sharp(\set{ \syna, \synx }) \), which per our remarks in \cref{def:atomic_lambda_term_substitution/sharp} must be \( \synb \). Then
    \begin{equation*}
      M[\Bbbs] = \qabs \synb \syna \synx.
    \end{equation*}

    Note how \( \synx \) got renamed to \( \syna \) and \( \synb \) got renamed to \( \synx \) simultaneously, without any collision. This allowed us to use \( \synb \) as a binding variable despite it originally being free.

    We could try emulating this substitution as in \cref{rem:simulating_simultaneous_substitution}:
    \begin{equation*}
      M[\synx \mapsto \syna][\synb \mapsto \synx].
    \end{equation*}

    In this case the fresh variable in the first substitution would be \( \sharp(\set{ \syna, \synb }) = \sync \), hence
    \begin{equation*}
      M[\synx \mapsto \syna][\synb \mapsto \synx]
      =
      (\qabs \sync \syna \synb)[\synb \mapsto \synx]
      =
      \qabs \sync \syna \synx.
    \end{equation*}

    This differs from \( M[\synx \mapsto \syna, \synb \mapsto \synx] \) by the choice of bound variable. This similarity is called \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}.

    We will generalize this observation to arbitrary substitutions in \cref{thm:nary_substitution_composition_is_alpha_equivalent}.
  \end{thmenum}
\end{example}
