\subsection{Lambda calculus reductions}\label{subsec:lambda_calculus_reductions}

\paragraph{\( \beta \) and \( \eta \)-reductions}

\begin{definition}\label{def:alpha_reflexive_closure}\mimprovised
  Let \( {\sim} \) be a binary relation between \( \synlambda \)-terms. The \term{\( \alpha \)-reflexive} closure of \( {\sim} \) is the set-theoretic union of \( {\sim} \) and \( {\aequiv} \).
\end{definition}
\begin{comments}
  \item The definition is based on reflexive closures defined in \fullref{def:relation_closures/reflexive}. This rule allows us to make explicit the dependency on \( \alpha \)-equivalence, which is implicit in our primary sources --- \cite[ch. 3]{Barendregt1984}, \cite[1B2]{Hindley1997} and \cite[191]{Герасимов2011}.
\end{comments}

\begin{definition}\label{def:beta_eta_reduction}
  We will define several relations simultaneously.
  \begin{thmenum}
    \thmitem{def:beta_eta_reduction/main}\mcite[1B1; 1C1]{Hindley1997} The essence of this definition is in the following two rules:
    \begin{TwoColumns}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\beta }]{def:beta_eta_reduction/beta}
        \begin{prooftree}
          \infer0[\ref{def:beta_eta_reduction/beta}]{ \underbrace{(\qabs x M) N}_{\T{\term{\( \beta \)-redex}}} \bred \underbrace{M[x \mapsto N]}_{\T{\term{\( \beta \)-contractum}}} }.
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\eta }]{def:beta_eta_reduction/eta}
        \begin{prooftree}
          \infer0[\ref{def:beta_eta_reduction/eta}]{ \underbrace{\qabs x M x}_{\T{\term{\( \eta \)-redex}}} \ered \underbrace{M}_{\mathclap{\T{\term{\( \eta \)-contractum}}}} }.
        \end{prooftree}
      \end{equation*}
    \end{TwoColumns}

    The \term{single-step \( \beta \)-reduction} is the relation generated by \ref{def:beta_eta_reduction/beta}, as well as the auxiliary rules discussed next. The \term{single-step \( \eta \)-reduction} is instead generated by \ref{def:beta_eta_reduction/eta}, while the \term{single-step \( \beta\eta \)-reduction} is generated by both.

    \thmitem{def:beta_eta_reduction/aux}\mcite[315]{Barendregt1984} In the following auxiliary rules, \enquote{\( \rho \)} may refer to \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}:
    \begin{ThreeColumns}
      \begin{equation*}\taglabel[\ensuremath{ \logic{App}_\rho^L }]{def:beta_eta_reduction/app_left}
        \begin{prooftree}
          \hypo{ M \redrel{\rho} N }
          \infer1[\ref{def:beta_eta_reduction/app_left}]{ LM \redrel{\rho} LN }
        \end{prooftree}
      \end{equation*}
    \BeginSecondColumn
      \begin{equation*}\taglabel[\ensuremath{ \logic{App}_\rho^R }]{def:beta_eta_reduction/app_right}
        \begin{prooftree}
          \hypo{ M \redrel{\rho} N }
          \infer1[\ref{def:beta_eta_reduction/app_right}]{ ML \redrel{\rho} NL }
        \end{prooftree}
      \end{equation*}
    \BeginThirdColumn
      \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_\rho }]{def:beta_eta_reduction/abs}
        \begin{prooftree}
          \hypo{ M \redrel{\rho} N }
          \infer1[\ref{def:beta_eta_reduction/abs}]{ \qabs x M \redrel{\rho} \qabs x N }
        \end{prooftree}
      \end{equation*}
    \end{ThreeColumns}

    We make the reliance on \( \alpha \)-equivalence explicit via the following rule:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Alpha}_\rho }]{def:beta_eta_reduction/alpha}
      \begin{prooftree}
        \hypo{ A \aequiv B }
        \hypo{ B \redrel{\rho} C }
        \hypo{ C \aequiv D }
        \infer3[\ref{def:beta_eta_reduction/alpha}]{ A \redrel{\rho} D }.
      \end{prooftree}
    \end{equation*}

    \thmitem{def:beta_eta_reduction/reduction}\mcite[315]{Barendregt1984} For each single-step reduction \( {\redrel{\rho}} \) defined above, we define the corresponding \term{multi-step reduction} \( {\redrel*{\rho}} \) as the \hyperref[def:relation_closures/transitive]{transitive} and \hyperref[def:alpha_reflexive_closure]{\( \alpha \)-reflexive closure} of \( {\redrel{\rho}} \). Which closure is taken first is immaterial due to \ref{def:beta_eta_reduction/alpha} --- \( A \aequiv B \redrel{\rho} C \) already implies \( A \redrel{\rho} C \).

    Without further context, \enquote{\( \rho \)-reduction} we will refer to the multi-step \( \rho \)-reduction.

    \thmitem{def:beta_eta_reduction/equivalence}\mcite[315]{Barendregt1984} If we instead take the
    \hyperref[def:relation_closures/transitive]{transitive} and \hyperref[def:alpha_reflexive_closure]{\( \alpha \)-reflexive} closure of the \hyperref[def:relation_closures/symmetric]{symmetric closure} of \( \redrel{\rho} \), we obtain \term{\( \rho \)-equivalence}, which we denote by \( {\equivrel{\rho}} \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item These relations can be obtained via \fullref{thm:least_fixed_point_recursion}, similarly to what is described in \fullref{ex:fixed_point_recursion_for_relations}.
\end{comments}

\begin{example}\label{ex:def:beta_eta_reduction}
  We list examples of \hyperref[def:beta_eta_reduction]{\( \beta \) and \( \eta \)-reductions}:
  \begin{thmenum}
    \thmitem{ex:def:beta_eta_reduction/i} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \).

    For every \( \synlambda \)-term \( A \) we have \( IA \bred A \). This explains the naming --- \( I \) stands for \enquote{identity}.

    \thmitem{ex:def:beta_eta_reduction/k} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \syny \synx \).

    For every pair of combinators \( A \) and \( B \) where \( \syny \) is not free, we have
    \begin{equation*}
      KAB
      =
      (\qabs {\hi{\synx}} \qabs \syny \hi{\synx}) \hi{A} B
      \bred
      (\qabs {\hi{\syny}} A) \hi{B}
      \bred
      A.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/s} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/s} = \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz) \).

    For every triple of \( \synlambda \)-terms \( A \), \( B \) and \( C \) where \( \syny \) and \( \synz \) are not free, we have
    \begin{balign*}
      SABC
      &=
      \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \qabs \synz \hi{\synx} \synz (\syny \synz) } \hi{A}BC
      \bred \\ &\bred
      \parens[\Big]{ \qabs {\hi{\syny}} \qabs \synz A \synz (\hi{\syny} \synz) } \hi{B}C
      \bred \\ &\bred
      \parens[\Big]{ \qabs {\hi{\synz}} A \hi{\synz} (B \hi{\synz}) } \hi{C}
      \bred \\ &\bred
      A C (B C).
    \end{balign*}

    \thmitem{ex:def:beta_eta_reduction/skk} \Fullref{ex:def:beta_eta_reduction/k} and \fullref{ex:def:beta_eta_reduction/s} imply that
    \begin{equation*}
      SKK \bred* \qabs \synz K \synz (K \synz) \bred* \qabs \synz \synz \aequiv I.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/boolean}\mcite[6.2.2]{Barendregt1984} We can encode the \hyperref[con:boolean_value]{Boolean values} via the combinators
    \begin{subequations}
      \begin{align}
        T \coloneqq \overbrace{\qabs \synx \qabs \syny \synx}^{\ref{eq:ex:def:lambda_term/combinator/k}} \label{ex:def:beta_eta_reduction/boolean/t}, \\
        F \coloneqq \qabs \synx \qabs \syny \syny \label{ex:def:beta_eta_reduction/boolean/f}.
      \end{align}

      Fix \( \synlambda \)-terms \( A \) and \( B \) where \( \syny \) is not free. If the term \( C \) can be either \( T \) or \( F \), \( \beta \)-reduction allows us to \enquote{select} either \( A \) or \( B \) based on the value of \( V \):
      \begin{equation}\label{ex:def:beta_eta_reduction/boolean/if}
        VAB \bred* \begin{cases}
          A, &C = T, \\
          B, &C = F.
        \end{cases}
      \end{equation}

      This allows us to implement \hyperref[def:boolean_function]{Boolean functions}, for example negation:
      \begin{equation}\label{ex:def:beta_eta_reduction/boolean/negation}
        NV \coloneqq VFT.
      \end{equation}

      Indeed, \( NT = TFT \bred* F \) and \( NF = FFT \bred* T \).
    \end{subequations}

    \thmitem{ex:def:beta_eta_reduction/numerals}\mcite[6.4.4]{Barendregt1984} For every natural number \( n \), we can define the \term{Church numeral}
    \begin{equation}\label{eq:ex:def:beta_eta_reduction/numerals}
      c_n \coloneqq \qabs \synx \qabs \syny \underbrace{\synx^n \syny}_{\mathclap{(\synx \cdots (\synx (\synx \syny)) \cdots)}}.
    \end{equation}

    Note that in this definition \( \synx^n \syny \) associates to the right, technically breaking our convention from \fullref{rem:lambda_term_parentheses/left_associative}.

    For the base case we have \( c_0 = F \).

    Consider the \term{successor} term
    \begin{equation}\label{eq:ex:def:beta_eta_reduction/succ}
      S^+ \coloneqq \qabs \synx \qabs \syny \qabs \synz \syny (\synx \syny \synz).
    \end{equation}

    Then
    \begin{balign*}
      S^+ c_n
      &=
      \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \qabs \synz \syny (\hi{\synx} \syny \synz) } c_n
      \bred \\ &\bred
      \qabs \syny \qabs \synz \syny \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \hi{\synx}^n \syny } \hi{\syny} \synz }
      \bred \\ &\bred
      \qabs \syny \qabs \synz \syny \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\syna}} \syny^n \hi{\syna} } \hi{\synz} }
      \bred \\ &\bred
      \qabs \syny \qabs \synz \syny (\syny^n \synz)
      \aequiv \\ &\aequiv
      c_{n+1}.
    \end{balign*}

    \thmitem{ex:def:beta_eta_reduction/omega} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/omega_n} = (\qabs \synx \synx^n) \).

    We have
    \begin{equation*}
      \omega_n \omega_n
      =
      (\qabs {\hi{\synx}} \hi{\synx^n}) \hi{\omega}
      \bred
      \omega_n^n.
    \end{equation*}

    In particular, for \( \Omega = \omega \omega = \omega_2 \omega_2 \),
    \begin{equation*}
      \Omega \bred \Omega \bred \Omega \bred \Omega \bred \cdots
    \end{equation*}
    and, for \( \omega_3 \omega_3 \),
    \begin{equation*}
      (\omega_3)^2 \bred (\omega_3)^3 \bred (\omega_3)^4 \bred \cdots.
    \end{equation*}
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:beta_reduction_free_variables}
  \begin{subequations}
    Let \( M = (\qabs x N) K \). Then
    \begin{equation}\label{eq:thm:beta_reduction_free_variables/equality}
      \op*{Free}(N[x \mapsto K]) = \begin{cases}
        \op*{Free}(M), &x \in \op*{Free}(N), \\
        \op*{Free}(N), &\T{otherwise.} \\
      \end{cases}
    \end{equation}

    Both cases can be summarized via the inequality
    \begin{equation}\label{eq:thm:beta_reduction_free_variables/inequality}
      \op*{Free}(N[x \mapsto K]) \subseteq \op*{Free}(M).
    \end{equation}
  \end{subequations}
\end{proposition}
\begin{proof}
  The equality \eqref{eq:thm:beta_reduction_free_variables/equality} follows from \eqref{eq:thm:lambda_substitution_free_variables_single} by noting that
  \begin{equation*}
    \op*{Free}(M)
    =
    \op*{Free}((\qabs x N) K)
    =
    \op*{Free}(\qabs x N) \cup \op*{Free}(K)
    =
    \parens[\Big]{ \op*{Free}(N) \setminus \set{ x } } \cup \op*{Free}(K).
  \end{equation*}
\end{proof}

\begin{corollary}\label{thm:beta_reduction_free_variables_contra}
  If \( M \bred* N \), then \( \op*{Free}(N) \subseteq \op*{Free}(M) \).
\end{corollary}
\begin{proof}
  Follows from \fullref{thm:beta_reduction_free_variables} via induction.
\end{proof}

\begin{example}\label{ex:thm:beta_reduction_free_variables}
  We list examples related to \fullref{thm:beta_reduction_free_variables}:
  \begin{thmenum}
    \thmitem{ex:thm:beta_reduction_free_variables/free} The \( \beta \)-contraction of \( (\qabs \synx \synx \syny) \synz \) is \( \synz \syny \). Both have \( \syny \) and \( \synz \) as their free variables.

    \thmitem{ex:thm:beta_reduction_free_variables/not_free} The \( \beta \)-contraction of \( (\qabs \synx \synz \syny) \synz \) is \( \synz \synz \). Both have \( \synz \) as a free variable, but the \( \beta \)-redex also has \( \syny \).
  \end{thmenum}
\end{example}

\paragraph{Fixed point combinators}

\begin{definition}\label{def:fixed_point_combinator}\mimprovised
  We say that the combinator \( M \) is a \term{fixed point combinator} if, for every \( \synlambda \)-term \( F \), we have \( MF \beequiv F(MF) \).
\end{definition}
\begin{comments}
  \item The definition is based on \cite[6.1.2]{Barendregt1984}, but is adapted to handle equivalences explicitly.
\end{comments}

\begin{example}\label{ex:def:fixed_point_combinator}
  We list examples of how \hyperref[def:fixed_point_combinator]{fixed point combinators} can be used:
  \begin{thmenum}
    \thmitem{ex:def:fixed_point_combinator/neg} Let \( M \) be a fixed point combinator. Consider the negation term \( N = VFT \) from \eqref{ex:def:beta_eta_reduction/boolean/negation}.

    Then \( MN \) is its own negation because \( MN \beequiv N(MN) \).

    If we regard \( N \) as a function on \( \synlambda \)-terms, \( MN \) corresponds to a fixed point of \( N \). Since neither Boolean value is a fixed point of negation, we conclude that \( N \) actually corresponds to generalization of negation from \hyperref[def:classical_semantics]{classical semantics}.

    \thmitem{ex:def:fixed_point_combinator/succ} Again, let \( M \) be a fixed point combinator.

    For the successor combinator \( S^+ \) from \eqref{eq:ex:def:beta_eta_reduction/succ}, the fixed point \( MS^+ \) corresponds to a generalized numeral that is its own successor.
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:y_is_a_fixed_point_combinator}
  The term \( \ref{eq:ex:def:lambda_term/combinator/y} = \qabs \synx (\qabs \syny \synx \syny \syny) (\qabs \syny \synx \syny \syny) \) is a \hyperref[def:fixed_point_combinator]{fixed point combinator}.
\end{proposition}
\begin{proof}
  Let \( F \) be a \( \synlambda \)-term where \( \synx \) and \( \syny \) are not free. We have
  \begin{equation*}
    YF
    =
    \parens[\Big]{ \qabs {\hi{\synx}} (\qabs \syny \hi{\synx} \syny \syny) (\qabs \syny \hi{\synx} \syny \syny) } \hi{F}
    \bred
    (\qabs v F v v) (\qabs v F v v),
  \end{equation*}
  where \( v = \syny \) if \( \syny \) is not free in \( F \) and is a fresh variable otherwise.

  Denote this reduct by \( P \). Then
  \begin{equation*}
    P =
    (\qabs {\hi{v}} F \hi{v} \hi{v}) \hi{(\qabs v F v v)}
    \bred
    F (\qabs v F v v) (\qabs v F v v)
    =
    FP.
  \end{equation*}

  Since \( YF \bequiv P \) and \( P \bequiv FP \), we conclude that \( YF \bequiv F(YF) \).
\end{proof}

\paragraph{Parallel \( \beta \)-reductions}

\begin{definition}\label{def:parallel_beta_reduction}
  We define \term{parallel \( \beta \)-reduction} via the following rules:

  \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\Vert }]{def:parallel_beta_reduction/red}
    \begin{prooftree}
      \hypo{ A \pred C }
      \hypo{ B \pred D }
      \infer2[\ref{def:parallel_beta_reduction/red}]{ (\qabs x A)B \pred C[x \mapsto D] }
    \end{prooftree}
  \end{equation*}

  \begin{ThreeColumns}
    \begin{equation*}\taglabel[\ensuremath{ \logic{Var}_\Vert }]{def:parallel_beta_reduction/var}
      \begin{prooftree}
        \infer0[\ref{def:parallel_beta_reduction/var}]{ x \pred x }
      \end{prooftree}
    \end{equation*}
  \BeginSecondColumn
    \begin{equation*}\taglabel[\ensuremath{ \logic{App}_\Vert }]{def:parallel_beta_reduction/app}
      \begin{prooftree}
        \hypo{ A \pred C }
        \hypo{ B \pred D }
        \infer2[\ref{def:parallel_beta_reduction/app}]{ AB \pred CD }
      \end{prooftree}
    \end{equation*}
  \BeginThirdColumn
    \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_\Vert }]{def:parallel_beta_reduction/abs}
      \begin{prooftree}
        \hypo{ A \pred B }
        \infer1[\ref{def:parallel_beta_reduction/abs}]{ \qabs x A \pred \qabs x B }
      \end{prooftree}
    \end{equation*}
  \end{ThreeColumns}

  \begin{equation*}\taglabel[\ensuremath{ \logic{Alpha}_\Vert }]{def:parallel_beta_reduction/alpha}
    \begin{prooftree}
      \hypo{ A \aequiv B }
      \hypo{ B \pred C }
      \hypo{ C \aequiv D }
      \infer3[\ref{def:parallel_beta_reduction/alpha}]{ C \pred D }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item The rules are based on \cite[3.2.3]{Barendregt1984}, but with \ref{def:parallel_beta_reduction/alpha} being made explicit and with \ref{def:parallel_beta_reduction/var} holding only for variables.
\end{comments}

\begin{proposition}\label{thm:def:parallel_beta_reduction}
  \hyperref[def:parallel_beta_reduction]{Parallel \( \beta \)-reduction} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:parallel_beta_reduction/reflexive} It is \hyperref[def:binary_relation/reflexive]{reflexive}.
    \thmitem{thm:def:parallel_beta_reduction/free} If \( M \pred N \), then \( \op*{Free}(N) \subseteq \op*{Free}(M) \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:parallel_beta_reduction/reflexive} We will use induction on \( M \) to show that \( M \pred M \).

  \begin{itemize}
    \item If \( M \) is a variable, \ref{def:parallel_beta_reduction/var} implies that \( M = M \).
    \item If \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \), \ref{def:parallel_beta_reduction/app} implies that \( M = NK \pred NK = M \).
    \item If \( M = \qabs x N \), where the inductive hypothesis holds for \( N \), \ref{def:parallel_beta_reduction/abs} implies that \( M \pred M \).
  \end{itemize}

  \SubProofOf{thm:def:parallel_beta_reduction/free} We will use \fullref{thm:least_fixed_point_induction} on \( M \pred N \):
  \begin{itemize}
    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/var}, then \( M = N \) and hence their free variables coincide.

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/app}, the inductive hypothesis implies that their free variables coincide.

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/abs}, the inductive hypothesis implies that their free variables coincide.

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/alpha}, then \( M \aequiv B \pred C \aequiv N \). Suppose that the inductive hypothesis holds for \( B \pred C \).

    Then
    \begin{equation*}
      \op*{Free}(N)
      \reloset {\ref{thm:def:lambda_term_alpha_equivalence/free}} =
      \op*{Free}(C)
      \reloset {\T{ind.}} \subseteq
      \op*{Free}(B)
      \reloset {\ref{thm:def:lambda_term_alpha_equivalence/free}} =
      \op*{Free}(M).
    \end{equation*}

    \item Finally, if \( M \pred N \) due to \ref{def:parallel_beta_reduction/red}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \pred C \) and \( B \pred D \). Suppose that the inductive hypothesis holds for \( A \pred C \) and \( B \pred D \).

    Then
    \begin{align*}
      \op*{Free}(C[x \mapsto D])
      &\reloset {\eqref{eq:thm:beta_reduction_free_variables/inequality}} \subseteq
      \op*{Free}((\qabs x C) D)
      = \\ &=
      \parens[\Big]{ \op*{Free}(C) \setminus \set{ x } } \cup \op*{Free}(D)
      \reloset {\T{ind.}} \subseteq \\ &\subseteq
      \parens[\Big]{ \op*{Free}(A) \setminus \set{ x } } \cup \op*{Free}(B)
      = \\ &=
      \op*{Free}((\qabs x A) B).
    \end{align*}
  \end{itemize}
\end{proof}

\begin{lemma}\label{thm:substitution_on_parallel_reduction}\mcite[3.2.4]{Barendregt1984}
  Fix \( \synlambda \)-terms \( M \) and \( N \) such that \( M \pred N \). Fix substitutions \( \sigma \) and \( \rho \) such that \( \sigma(u) \pred \rho(u) \) for every variable \( u \).

  Then \( M[\sigma] \pred N[\rho] \).
\end{lemma}
\begin{proof}
  We will use \fullref{thm:least_fixed_point_induction} on \( M \pred N \) simultaneously on all compatible substitutions:
  \begin{itemize}
    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/var}, then \( M \) and \( N \) are identical variables. Thus, \( \sigma(M) \pred \rho(N) \).

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/app}, then \( M = AB \) and \( N = CD \), where \( A \pred C \) and \( B \pred D \). Suppose that the inductive hypothesis holds for \( A \pred C \) and \( B \pred D \). Then \( A[\sigma] \pred C[\rho] \) and \( B[\sigma] \pred D[\rho] \), hence \( M[\sigma] \pred N[\rho] \).

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/abs}, then \( M = \qabs x A \) and \( N = \qabs x B \) and \( A \pred B \). Suppose the inductive hypothesis holds for \( A \pred B \).

    We will utilize \fullref{thm:lambda_substitution_single_rule} twice:
    \begin{align*}
      M[\sigma] &= \qabs u A[\sigma_{x \mapsto u}], &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
      N[\rho]   &= \qabs v B[\rho_{x \mapsto v}],   &&v \not\in \op*{Free}(N) \cup \op*{Free}(N[\rho]).
    \end{align*}

    The inductive hypothesis implies that
    \begin{equation*}
      A[\sigma_{x \mapsto u}] \pred B[\sigma_{x \mapsto u}].
    \end{equation*}

    \begin{itemize}
      \item If \( u \) is free in \( B[\rho_{x \mapsto v}] \), then it must be equal to \( v \), and \ref{def:parallel_beta_reduction/abs} implies that \( M[\sigma] \pred N[\rho] \).

      To show that \( u = v \), suppose instead that \( u \neq v \). Then \( u \) is free in \( \rho(w) \) for some \( w \) free in \( B \), and \fullref{thm:def:parallel_beta_reduction/free} implies that \( u \) is free in \( \sigma(w) \). But, again by \fullref{thm:def:parallel_beta_reduction/free}, the free variables of \( B \) are free in \( A \). Then \( u \) must be free in \( \sigma(w) \) for \( w \) free in \( A \). But this contradicts our assumption that \( u \) is not free in \( \op*{Free}(M[\sigma]) \).

      \item If \( u \) is not free in \( B[\rho_{x \mapsto v}] \), \fullref{thm:alpha_conversion_modified} implies that
      \begin{equation*}
        \qabs u B[\rho_{x \mapsto u}]
        \aequiv
        \qabs v B[\rho_{x \mapsto v}].
      \end{equation*}

      Then
      \begin{equation*}
        M[\sigma]
        =
        \qabs u A[\sigma_{x \mapsto u}]
        \pred
        \qabs u B[\sigma_{x \mapsto v}]
        \aequiv
        \qabs v B[\rho_{x \mapsto v}]
        =
        N[\rho]
      \end{equation*}
      and \ref{def:parallel_beta_reduction/alpha} implies that \( M[\sigma] \pred N[\rho] \).
    \end{itemize}

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/alpha}, then \( M \aequiv B \pred C \aequiv N \), where the inductive hypothesis holds for \( B \pred C \).

    \Fullref{thm:substitution_on_alpha_equivalent_terms} implies that \( M[\sigma] \aequiv B[\sigma] \) and \( C[\rho] \aequiv N[\rho] \), and the inductive hypothesis implies that \( B[\sigma] \pred C[\rho] \). Then \ref{def:parallel_beta_reduction/alpha} allows us to conclude that \( M[\sigma] \aequiv N[\rho] \).

    \item Finally, if \( M \pred N \) due to \ref{def:parallel_beta_reduction/red}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \pred C \) and \( B \pred D \). Suppose that the inductive hypothesis holds for \( A \pred C \) and \( B \pred D \).

    \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{equation*}
      M[\sigma] = \parens[\Big]{ \qabs u A[\sigma_{x \mapsto u}] } B[\sigma],
    \end{equation*}
    where \( u \not\in \op*{Free}(\qabs x A) \cup \op*{Free}_\sigma(\qabs x A) \).

    The inductive hypothesis implies that \( A[\sigma_{x \mapsto u}] \pred C[\rho_{x \mapsto u}] \) and \( B[\sigma] \pred D[\rho] \). Then \ref{def:parallel_beta_reduction/red} implies that
    \begin{equation*}
      M[\sigma]
      =
      \parens[\Big]{ \qabs u A[\sigma_{x \mapsto u}] } B[\sigma]
      \pred
      C[\rho_{x \mapsto u}][u \mapsto D[\rho]].
    \end{equation*}

    Furthermore,
    \begin{equation*}
      N[\rho]
      =
      C[x \mapsto D][\rho]
      \reloset {\eqref{eq:thm:substitution_composition_is_alpha_equivalent}} \aequiv
      C[\rho_{x \mapsto D[\rho]}]
      \reloset {\eqref{eq:thm:substitution_chain_contraction/contraction}} \aequiv
      C[\rho_{x \mapsto u}][u \mapsto D[\rho]].
    \end{equation*}

    Therefore, \ref{def:parallel_beta_reduction/alpha} allows us to conclude that \( M[\sigma] \pred N[\rho] \).
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:parallel_beta_reduction_transitive_closure}\mcite[3.2.7]{Barendregt1984}
  The \hyperref[def:relation_closures/transitive]{transitive closure} of the \hyperref[def:parallel_beta_reduction]{parallel \( \beta \)-reduction} \( {\pred} \) coincides with the \hyperref[def:beta_eta_reduction/reduction]{multi-step \( \beta \)-reduction} \( {\bred*} \).
\end{proposition}
\begin{proof}
  We will show that, when regarded as sets, the relations obey the following inequalities:
  \begin{equation*}
    {\bred} \subseteq {\pred} \subseteq {\bred*}.
  \end{equation*}

  Taking their transitive closures will then give us
  \begin{equation*}
    {\bred*} \subseteq \cl_T({\pred}) \subseteq {\bred*},
  \end{equation*}
  which is the required result.

  \SubProof{Proof that \( M \bred N \) implies \( M \pred N \)} We will use \fullref{thm:least_fixed_point_induction} on \( M \bred N \):
  \begin{itemize}
    \item If \( M \bred N \) due to \ref{def:beta_eta_reduction/app_left}, then \( M = LA \) and \( N = LB \), where \( A \bred B \). Suppose that the inductive hypothesis holds for the latter, so that \( A \pred B \).

    Since \( {\pred} \) is reflexive, we have \( L \pred L \). Then \ref{def:parallel_beta_reduction/app} implies that \( M \pred N \).

    \item If \( M \bred N \) due to \ref{def:beta_eta_reduction/app_right}, we act analogously.

    \item If \( M \bred N \) due to \ref{def:beta_eta_reduction/abs}, we use \ref{def:parallel_beta_reduction/abs} to conclude that \( M \pred N \).

    \item If \( M \bred N \) due to \ref{def:beta_eta_reduction/alpha}, we use \ref{def:parallel_beta_reduction/alpha}.

    \item Finally, if \( M \bred N \) due to \ref{def:beta_eta_reduction/beta}, then \( M = (\qabs x A) B \) and \( N = A[x \mapsto B] \). Again, since \( {\pred} \) is reflexive, we have \( A \pred A \) and \( B \pred B \), hence \ref{def:parallel_beta_reduction/red} allows us to conclude that \( M \pred N \).
  \end{itemize}

  \SubProof{Proof that \( M \pred N \) implies \( M \bred* N \)} We will use \fullref{thm:least_fixed_point_induction} on \( M \pred N \):
  \begin{itemize}
    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/var}, then \( M = N \) and, since \( {\bred*} \) is reflexive by definition, \( M \bred* N \).

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/app}, then \( M = AB \) and \( N = CD \), where \( A \pred C \) and \( B \pred D \) and the inductive hypothesis holds for the latter two.

    Then \( A \bred* C \) and \( B \bred* D \). If
    \begin{equation*}
      A = A_1 \bred \cdots \bred A_n = C,
    \end{equation*}
    then \ref{def:beta_eta_reduction/app_left} allows us to conclude that
    \begin{equation*}
      AB = A_1 B \bred \cdots \bred A_n B = CB.
    \end{equation*}

    If
    \begin{equation*}
      B = B_1 \bred \cdots \bred B_m = D,
    \end{equation*}
    then \ref{def:beta_eta_reduction/app_right} allows us to conclude that
    \begin{equation*}
      CB = C B_1 \bred \cdots \bred C B_m = CD.
    \end{equation*}

    Therefore, \( AB \bred* CD \).

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/abs}, we can similarly chain the individual reductions to conclude that \( M \bred* N \) using \ref{def:beta_eta_reduction/abs}.

    \item If \( M \pred N \) due to \ref{def:parallel_beta_reduction/alpha}, then \( M \aequiv A \pred B \aequiv N \). The inductive hypothesis on \( A \pred B \) gives us \( A \bred* B \). Suppose that
    \begin{equation*}
      A = A_1 \bred \cdots \bred A_n = B.
    \end{equation*}

    \begin{itemize}
      \item If \( n = 1 \), then \( A = B \) and thus \( M \aequiv N \). Then \( M \bred* N \) since the latter is an \hyperref[def:alpha_reflexive_closure]{\( \alpha \)-reflexive closure}.

      \item Otherwise, we have
      \begin{equation*}
        M \aequiv A_1 \bred A_2 \aequiv A_2,
      \end{equation*}
      hence \ref{def:beta_eta_reduction/alpha} implies \( M \bred A_2 \). Analogously, we can apply \ref{def:beta_eta_reduction/alpha} to
      \begin{equation*}
        A_{n-1} \bred A_n = B \aequiv N
      \end{equation*}
      to obtain \( A_{n-1} \bred N \).

      By transitivity, we conclude \( M \bred* N \).
    \end{itemize}

    \item Finally, if \( M \pred N \) due to \ref{def:parallel_beta_reduction/red}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \pred C \) and \( B \pred D \). The inductive hypothesis implies that \( A \bred* C \) and \( B \bred* D \).

    Applying \ref{def:beta_eta_reduction/abs} and \ref{def:beta_eta_reduction/app_left} successively, we conclude that
    \begin{equation*}
      (\qabs x A) B \bred* (\qabs x C) B.
    \end{equation*}

    Similarly, applying \ref{def:beta_eta_reduction/app_right} successively, we conclude that
    \begin{equation*}
      (\qabs x C) B \bred* (\qabs x C) D.
    \end{equation*}

    Then \ref{def:beta_eta_reduction/beta} implies that
    \begin{equation*}
      (\qabs x C) D \bred C[x \mapsto D].
    \end{equation*}

    Chaining the above, we obtain \( M \bred* N \).
  \end{itemize}
\end{proof}

\paragraph{The Church-Rosser theorem}

\begin{theorem}[Church-Rosser theorem]\label{thm:church_rosser_theorem}
  As in \fullref{def:beta_eta_reduction}, let \enquote{\( \rho \)} be either \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  If \( M \) \( \rho \)-reduces to both \( N \) and \( K \) in multiple steps, then there exists a \( \synlambda \)-term \( L \) towards which both \( N \) and \( K \) \( \rho \)-reduce in multiple steps.

  \begin{figure}[!ht]
    \centering
    \includegraphics[page=1]{output/thm__church_rosser_theorem}
    \caption{An illustration of \fullref{thm:church_rosser_theorem}}\label{fig:thm:church_rosser_theorem}
  \end{figure}
\end{theorem}
\begin{comments}
  \item \incite[ch. 3]{Barendregt1984} and \incite[1B5]{Hindley1997} call this property \enquote{the Church-Rosser property}, while \incite[130]{Mimram2020} and \incite[14]{TroelstraSchwichtenberg2000} call it \enquote{confluence}.
\end{comments}
