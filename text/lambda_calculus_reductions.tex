\subsection{Lambda calculus reductions}\label{subsec:lambda_calculus_reductions}

\paragraph{Subterm occurrences}

\begin{definition}\label{def:lambda_subterm_occurrence}\mimprovised
  An \term{occurrence} of a subterm \( N \) of \( M \) is a \hyperref[def:tree/subtree]{subtree} of the \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(M) \) of that is \hyperref[def:labeled_tree/homomorphism]{isomorphic} to \( T(N) \).
\end{definition}
\begin{comments}
  \item From \fullref{thm:propositional_ast_subformula} we conclude that \( N \) is a subterm of \( M \) if and only if it has at least one occurrence in \( M \).
\end{comments}

\begin{definition}\label{def:subterm_occurrence_ordering}\mimprovised
  We will introduce two \hyperref[def:partially_ordered_set]{partial orders} on the \hyperref[def:lambda_subterm_occurrence]{subterm occurrences} of \( M \).

  Consider the occurrences \( R \) and \( S \) of (possibly different) subterms of \( T(M) \).

  \begin{thmenum}
    \thmitem{def:subterm_occurrence_ordering/vertical} Under the \term{vertical ordering}, \( R \leq S \) if \( R \) is a \hyperref[def:tree/subtree]{subtree} of \( S \).

    We call the \hyperref[def:extremal_points/maximal_and_minimal_element]{maximal} occurrences under this ordering \term{outermost} and the minimal occurrences --- \term{innermost}. This terminology is useful mostly when restricted to certain kinds of subterms like \hyperref[def:beta_eta_reduction]{\( \beta \)-redexes}.

    \thmitem{def:subterm_occurrence_ordering/horizontal} Under the \term{horizontal ordering}, \( R \leq S \) if there exist an application subtree
    \begin{equation*}
      \begin{aligned}
        \includegraphics[page=1]{output/def__subterm_occurrence_ordering}
      \end{aligned}
    \end{equation*}
    of \( T(M) \) where \( R \) is a subtree of \( A \) and \( S \) is a subtree of \( B \).

    We call the maximal and minimal elements under this ordering \term{leftmost} and \term{rightmost}, respectively. Again, this terminology is useful mostly when restricted to certain kinds of subterms.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is loosely based on \cite[138]{Mimram2020}, but differs in several aspects:
  \begin{itemize}
    \item We consider arbitrary subterm occurrences rather than redexes.
    \item We use syntax trees for formalizing subterm occurrences.
    \item We call \enquote{vertical order} what Mimram calls \enquote{imbrication order}.
  \end{itemize}

  Other authors like \incite[8.4.7]{Barendregt1984} only consider horizontal ordering.
\end{comments}

\begin{example}\label{ex:def:subterm_occurrence_ordering}
  We list examples of \hyperref[def:subterm_occurrence_ordering]{subterm ordering}:
  \begin{thmenum}
    \thmitem{ex:def:subterm_occurrence_ordering/omega} Consider the term \( \ref{eq:ex:def:lambda_term/combinator/big_omega} = \omega \omega \), where \( \ref{eq:ex:def:lambda_term/combinator/omega} = \qabs \synx \synx \synx \).

    It consists of two occurrences of \( \omega \), so naturally one of them is leftmost and one is rightmost.

    On the other hand, two occurrences of the same subterm are not comparable with respect to vertical ordering. We can compare instead the leftmost occurrence of \( \omega \), which is an outermost occurrence of a proper subterm, and the leftmost occurrence of \( \synx \), which is instead an innermost occurrence.

    \thmitem{ex:def:subterm_occurrence_ordering/foi} Consider the term
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/boolean/f} \ref{eq:ex:def:lambda_term/combinator/big_omega} \ref{eq:ex:def:lambda_term/combinator/i}
      =
      (F \Omega) I
      =
      \parens[\Bigg]{ \parens[\Big]{ \qabs \synx \syny \syny } \parens[\Big]{ (\qabs \synx \synx \synx) (\qabs \synx \synx \synx) } } \parens[\Bigg]{ \qabs \synx \synx }.
    \end{equation*}

    Its abstract syntax tree in given in \cref{fig:ex:def:subterm_occurrence_ordering/foi}.

    \begin{figure}[!ht]
      \hfill
      \includegraphics[align=t, page=1]{output/ex__def__subterm_occurrence_ordering}
      \hfill
      \includegraphics[align=t, page=2]{output/ex__def__subterm_occurrence_ordering}
      \hfill
      \hfill
      \caption{The abstract syntax tree of the \( \synlambda \)-term \( F \Omega I \) from \fullref{ex:def:subterm_occurrence_ordering/foi}.}\label{fig:ex:def:subterm_occurrence_ordering/foi}
    \end{figure}

    \begin{itemize}
      \item As discussed in \fullref{ex:def:subterm_occurrence_ordering/omega}, \( \Omega \) has two occurrences of \( \omega \), and hence so does \( F \Omega I \).

      \item \( F \Omega I \) has five occurrences of \( \synx \) --- the leftmost one is in the leftmost occurrence of \( \Omega \), while the rightmost one is in the (only) occurrence of \( I \).
    \end{itemize}
  \end{thmenum}
\end{example}

\paragraph{\( \beta \) and \( \eta \)-reductions}

\begin{definition}\label{def:alpha_reflexive}\mimprovised
  We say that the binary relation \( {\sim} \) between \( \synlambda \)-terms is \term{\( \alpha \)-reflexive} if \( M \aequiv N \) implies \( M \sim N \).

  Correspondingly, we define the \term{\( \alpha \)-reflexive closure} of a binary relation as its set-theoretic union with \( {\aequiv} \).
\end{definition}
\begin{comments}
  \item This definition is not established. It is based on reflexive closures discussed in \fullref{def:relation_closures/reflexive}. It allows us to make explicit the dependency on \( \alpha \)-equivalence, which is implicit in our primary sources --- \cite[ch. 3]{Barendregt1984}, \cite[1B2]{Hindley1997} and \cite[191]{Герасимов2011}.
\end{comments}

\begin{definition}\label{def:lambda_reduction}\mcite[315]{Barendregt1984}
  Via \fullref{thm:recursively_defined_relations}, we will define different kinds of \enquote{\( {\anon} \)-reduction} relations simultaneously. The symbol \enquote{\( {\anon} \)} is inessential to the formalisms presented here; we use it as a placeholder for \enquote{\( \beta \)}, \enquote{\( \eta \)}, \enquote{\( \beta\eta \)} and potentially other kinds of reductions.

  \begin{thmenum}
    \thmitem{def:lambda_reduction/single} A \term{single-step reduction} is a relation generated by or otherwise satisfying the following rules:
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \begin{equation*}\taglabel[\ensuremath{ \logic{App}_{\anon}^L }]{inf:def:lambda_reduction/app_left}
          \begin{prooftree}
            \hypo{ A \pred C }
            \infer1[\ref{inf:def:lambda_reduction/app_left}]{ AB \pred CB }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \begin{equation*}\taglabel[\ensuremath{ \logic{App}_{\anon}^R }]{inf:def:lambda_reduction/app_right}
          \begin{prooftree}
            \hypo{ B \pred D }
            \infer1[\ref{inf:def:lambda_reduction/app_right}]{ AB \pred AD }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_{\anon} }]{inf:def:lambda_reduction/abs}
          \begin{prooftree}
            \hypo{ A \pred B }
            \infer1[\ref{inf:def:lambda_reduction/abs}]{ \qabs x A \pred \qabs x B }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}

    We make the reliance on \( \alpha \)-equivalence explicit via the following rule:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Alpha}_{\anon} }]{inf:def:lambda_reduction/alpha}
      \begin{prooftree}
        \hypo{ A \aequiv B }
        \hypo{ B \pred C }
        \hypo{ C \aequiv D }
        \infer3[\ref{inf:def:lambda_reduction/alpha}]{ A \pred D }.
      \end{prooftree}
    \end{equation*}

    \thmitem{def:lambda_reduction/multi} For each single-step reduction \( {\pred} \) defined above, we define the corresponding \term{multi-step \( {\anon} \)-reduction} \( {\pred*} \) as the \hyperref[def:relation_closures/transitive]{transitive} and \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive closure} of \( {\pred} \). Which closure is taken first is immaterial due to \ref{inf:def:lambda_reduction/alpha} --- \( A \aequiv B \pred C \) already implies \( A \pred C \).

    Without further context, \enquote{\( {\anon} \)-reduction} we will refer to the multi-step \( {\anon} \)-reduction.

    \thmitem{def:lambda_reduction/equivalence} If we instead take the
    \hyperref[def:relation_closures/transitive]{transitive} and \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive} closure of the \hyperref[def:relation_closures/symmetric]{symmetric closure} of \( \pred \), we obtain \term{\( {\anon} \)-equivalence}, which we denote by \( {\requiv} \).
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:beta_eta_reduction}\mcite[1B1; 1C1]{Hindley1997}
  Consider the following rules:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\beta }]{inf:def:beta_eta_reduction/beta}
        \begin{prooftree}
          \infer0[\ref{inf:def:beta_eta_reduction/beta}]{ \underbrace{(\qabs x M) N}_{\T{\term{\( \beta \)-redex}}} \bred \underbrace{M[x \mapsto N]}_{\T{\term{\( \beta \)-contractum}}} },
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\eta }]{inf:def:beta_eta_reduction/eta}
        \begin{prooftree}
          \hypo{ x \not\in \op*{Free}(M) }
          \infer1[\ref{inf:def:beta_eta_reduction/eta}]{ \underbrace{\qabs x M x}_{\T{\term{\( \eta \)-redex}}} \ered \underbrace{M}_{\mathclap{\T{\term{\( \eta \)-contractum}}}} }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  Here \( \beta \)-redexes and \( \eta \)-redexes are \hyperref[def:lambda_subterm_occurrence]{subterm occurrences} rather than subterms, so a single term may have isomorphic redexes.

  We define \term{\( \beta \)-reduction} \( {\bred} \) as the relation generated by the rules of \fullref{def:lambda_reduction/single} extended with \ref{inf:def:beta_eta_reduction/beta}. We similarly define \term{\( \eta \)-reduction} \( {\ered} \) based on \ref{inf:def:beta_eta_reduction/eta}. Combining both, we obtain \term{\( \beta\eta \)-reduction} \( {\bered} \).
\end{definition}
\begin{comments}
  \item Of course, we also consider equivalences and multi-step reductions based on the above single-step reductions.
\end{comments}

\begin{example}\label{ex:def:beta_eta_reduction}
  We list examples of \hyperref[def:lambda_reduction]{\( \beta \) and \( \eta \)-reductions}:
  \begin{thmenum}
    \thmitem{ex:def:beta_eta_reduction/i} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \).

    For every \( \synlambda \)-term \( A \) we have \( IA \bred A \). This explains the naming --- \( I \) stands for \enquote{identity}.

    \thmitem{ex:def:beta_eta_reduction/k} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \syny \synx \).

    For every pair of combinators \( A \) and \( B \) where \( \syny \) is not free, we have
    \begin{equation*}
      KAB
      =
      (\qabs {\hi{\synx}} \qabs \syny \hi{\synx}) \hi{A} B
      \bred
      (\qabs {\hi{\syny}} A) \hi{B}
      \bred
      A.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/s} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/s} = \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz) \).

    For every triple of \( \synlambda \)-terms \( A \), \( B \) and \( C \) where \( \syny \) and \( \synz \) are not free, we have
    \begin{balign*}
      SABC
      &=
      \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \qabs \synz \hi{\synx} \synz (\syny \synz) } \hi{A}BC
      \bred \\ &\bred
      \parens[\Big]{ \qabs {\hi{\syny}} \qabs \synz A \synz (\hi{\syny} \synz) } \hi{B}C
      \bred \\ &\bred
      \parens[\Big]{ \qabs {\hi{\synz}} A \hi{\synz} (B \hi{\synz}) } \hi{C}
      \bred \\ &\bred
      A C (B C).
    \end{balign*}

    \thmitem{ex:def:beta_eta_reduction/skk} \Fullref{ex:def:beta_eta_reduction/k} and \fullref{ex:def:beta_eta_reduction/s} imply that
    \begin{equation*}
      SKK \bred* \qabs \synz K \synz (K \synz) \bred* \qabs \synz \synz \aequiv I.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/boolean}\mcite[6.2.2]{Barendregt1984} We can encode the \hyperref[con:boolean_value]{Boolean values} via the combinators
    \begin{subequations}
      \begin{align}
        T \coloneqq \overbrace{\qabs \synx \qabs \syny \synx}^{\ref{eq:ex:def:lambda_term/combinator/k}} \label{ex:def:beta_eta_reduction/boolean/t}\tag{\ensuremath{ T }}, \\
        F \coloneqq \qabs \synx \qabs \syny \syny \label{ex:def:beta_eta_reduction/boolean/f}\tag{\ensuremath{ F }}.
      \end{align}

      Fix \( \synlambda \)-terms \( A \) and \( B \) where \( \syny \) is not free. If the term \( C \) can be either \( T \) or \( F \), \( \beta \)-reduction allows us to \enquote{select} either \( A \) or \( B \) based on the value of \( V \):
      \begin{equation}\label{ex:def:beta_eta_reduction/boolean/if}
        VAB \bred* \begin{cases}
          A, &C = T, \\
          B, &C = F.
        \end{cases}
      \end{equation}

      This allows us to implement \hyperref[def:boolean_function]{Boolean functions}, for example negation:
      \begin{equation}\label{ex:def:beta_eta_reduction/boolean/negation}
        NV \coloneqq VFT.
      \end{equation}

      Indeed, \( NT = TFT \bred* F \) and \( NF = FFT \bred* T \).
    \end{subequations}

    \thmitem{ex:def:beta_eta_reduction/numerals}\mcite[6.4.4]{Barendregt1984} For every natural number \( n \), we can define the \term{Church numeral}
    \begin{equation}\label{eq:ex:def:beta_eta_reduction/numerals}
      c_n \coloneqq \qabs \synx \qabs \syny \underbrace{\synx^n \syny}_{\mathclap{(\synx \cdots (\synx (\synx \syny)) \cdots)}}.
    \end{equation}

    Note that in this definition \( \synx^n \syny \) associates to the right, technically breaking our convention from \fullref{rem:lambda_term_parentheses/left_associative}.

    For the base case we have \( c_0 = F \).

    Consider the \term{successor} term
    \begin{equation}\label{eq:ex:def:beta_eta_reduction/succ}
      S^+ \coloneqq \qabs \synf \qabs \synx \qabs \syny \synx (\synf \synx \syny).
    \end{equation}

    Then
    \begin{balign*}
      S^+ c_n
      &=
      \parens[\Big]{ \qabs {\hi{\synf}} \qabs \synx \qabs \syny \synx (\hi{\synf} \synx \syny) } \hi{c_n}
      \bred \\ &\bred
      \qabs \synx \qabs \syny \synx \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \hi{\synx}^n \synf } \hi{\synx} \syny }
      \bred \\ &\bred
      \qabs \synx \qabs \syny \synx \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\syny}} \synx^n \hi{\syny} } \hi{\syny} }
      \bred \\ &\bred
      \underbrace{\qabs \synx \qabs \syny \synx (\synx^n \syny)}_{c_{n+1}}.
    \end{balign*}

    \thmitem{ex:def:beta_eta_reduction/omega} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/omega_n} = (\qabs \synx \synx^n) \).

    We have
    \begin{equation*}
      \omega_n \omega_n
      =
      (\qabs {\hi{\synx}} \hi{\synx^n}) \hi{\omega}
      \bred
      \omega_n^n.
    \end{equation*}

    In particular, for \( \Omega = \omega \omega = \omega_2 \omega_2 \),
    \begin{equation*}
      \Omega \bred \Omega \bred \Omega \bred \Omega \bred \cdots
    \end{equation*}
    and, for \( \omega_3 \omega_3 \),
    \begin{equation*}
      (\omega_3)^2 \bred (\omega_3)^3 \bred (\omega_3)^4 \bred \cdots.
    \end{equation*}
  \end{thmenum}
\end{example}

\paragraph{Reduction strategies}

\begin{definition}\label{def:reduction_strategy}\mcite[13.1]{Barendregt1984}
  We can regard a \hyperref[def:lambda_reduction]{reduction relation} \( {\pred} \) as a \hyperref[def:set_valued_map]{set-valued function} on \( \synlambda \)-terms. A \hyperref[def:function/selection]{selection} of \( {\pred} \) is then a \hyperref[def:set_valued_map/partial]{single-valued partial function}.

  We call such a selection a \term{single-step reduction strategy}. A \term{multi-step reduction strategy} is instead a selection of \( {\pred*} \).
\end{definition}

\begin{definition}\label{def:normal_order_reduction}\mcite[142]{Mimram2020}
  The \term{normal order} \hyperref[def:reduction_strategy]{reduction strategy} for \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} reduces the \hyperref[def:subterm_occurrence_ordering/horizontal]{leftmost} among the \hyperref[def:subterm_occurrence_ordering/vertical]{outermost} \( \beta \)-redexes.
\end{definition}

\begin{definition}\label{def:applicative_order_reduction}\mcite[141]{Mimram2020}
  The \term{applicative order} \hyperref[def:reduction_strategy]{reduction strategy} for \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} reduces the \hyperref[def:subterm_occurrence_ordering/horizontal]{leftmost} among the \hyperref[def:subterm_occurrence_ordering/vertical]{innermost} \( \beta \)-redexes.
\end{definition}

\begin{example}\label{ex:reduction_strategies}
  One notable difference between \hyperref[def:normal_order_reduction]{normal order reduction} and \hyperref[def:applicative_order_reduction]{applicative order reduction} can be seen when evaluating the term \( \ref{ex:def:beta_eta_reduction/boolean/f} \ref{eq:ex:def:lambda_term/combinator/big_omega} \ref{eq:ex:def:lambda_term/combinator/i} \) discussed in \fullref{ex:def:subterm_occurrence_ordering/foi}.

  There is a unique outermost \( \beta \)-redex --- \( F \Omega \) --- and a unique innermost redex --- \( \Omega \) itself.

  The normal order strategy suggests reducing as follows:
  \begin{balign*}
    (F \Omega) I
    &=
    \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \syny } \hi{\Omega} } I
    \bred \\ &\bred
    (\qabs {\hi{\syny}} \hi{\syny}) \hi{I}
    \bred \\ &\bred
    I.
  \end{balign*}

  On the other hand, the applicative order strategy instead suggests reducing \( \Omega \) first. As per our discussion in \fullref{ex:def:beta_eta_reduction/omega}, this leads to the chain
  \begin{equation*}
    (F \Omega) I \bred (F \Omega) I \bred (F \Omega) I \bred \cdots.
  \end{equation*}
\end{example}

\paragraph{Reductions and free variables}

\begin{proposition}\label{thm:eta_reduction_free_variables}
  If \( M \ered N \), then \( \op*{Free}(M) = \op*{Free}(N) \).
\end{proposition}
\begin{proof}
  Follows via \fullref{thm:induction_on_recursively_defined_relations} by noting that \( x \) is not free in \( M \) if and only if it is not free in \( \qabs x M x \).
\end{proof}

\begin{lemma}\label{thm:beta_contractum_free_variables}
  \begin{subequations}
    Let \( M = (\qabs x N) K \). Then
    \begin{equation}\label{eq:thm:beta_contractum_free_variables/equality}
      \op*{Free}(N[x \mapsto K]) = \begin{cases}
        \op*{Free}(M), &x \in \op*{Free}(N), \\
        \op*{Free}(N), &\T{otherwise.} \\
      \end{cases}
    \end{equation}

    Both cases can be summarized via the inequality
    \begin{equation}\label{eq:thm:beta_contractum_free_variables/inequality}
      \op*{Free}(N[x \mapsto K]) \subseteq \op*{Free}(M).
    \end{equation}
  \end{subequations}
\end{lemma}
\begin{proof}
  The equality \eqref{eq:thm:beta_contractum_free_variables/equality} follows from \eqref{eq:thm:lambda_substitution_free_variables_single} by noting that
  \begin{equation*}
    \op*{Free}(M)
    =
    \op*{Free}((\qabs x N) K)
    =
    \op*{Free}(\qabs x N) \cup \op*{Free}(K)
    =
    \parens[\Big]{ \op*{Free}(N) \setminus \set{ x } } \cup \op*{Free}(K).
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:lambda_reduction_free_variables}
  Let \enquote{\( {\anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  If \( M \pred N \), then \( \op*{Free}(N) \subseteq \op*{Free}(M) \).
\end{proposition}
\begin{proof}
  Follows from \fullref{thm:beta_contractum_free_variables} and \fullref{thm:lambda_reduction_free_variables}.
\end{proof}

\begin{example}\label{ex:thm:lambda_reduction_free_variables}
  We list examples related to \fullref{thm:lambda_reduction_free_variables}:
  \begin{thmenum}
    \thmitem{ex:thm:lambda_reduction_free_variables/free} The \( \beta \)-contraction of \( (\qabs \synx \synx \syny) \synz \) is \( \synz \syny \). Both have \( \syny \) and \( \synz \) as their free variables.

    \thmitem{ex:thm:lambda_reduction_free_variables/not_free} The \( \beta \)-contraction of \( (\qabs \synx \synz \syny) \synz \) is \( \synz \synz \). Both have \( \synz \) as a free variable, but the \( \beta \)-redex also has \( \syny \).
  \end{thmenum}
\end{example}

\paragraph{Fixed point combinators}

\begin{definition}\label{def:fixed_point_combinator}\mimprovised
  We say that the combinator \( M \) is a \term{fixed point combinator} if, for every \( \synlambda \)-term \( F \), we have \( MF \beequiv F(MF) \).
\end{definition}
\begin{comments}
  \item The definition is based on \cite[6.1.2]{Barendregt1984}, but is adapted to handle equivalences explicitly.
\end{comments}

\begin{example}\label{ex:def:fixed_point_combinator}
  We list examples of how \hyperref[def:fixed_point_combinator]{fixed point combinators} can be used:
  \begin{thmenum}
    \thmitem{ex:def:fixed_point_combinator/neg} Let \( M \) be a fixed point combinator. Consider the negation term \( N = VFT \) from \eqref{ex:def:beta_eta_reduction/boolean/negation}.

    Then \( MN \) is its own negation because \( MN \beequiv N(MN) \).

    If we regard \( N \) as a function on \( \synlambda \)-terms, \( MN \) corresponds to a fixed point of \( N \). Since neither Boolean value is a fixed point of negation, we conclude that \( N \) actually corresponds to generalization of negation from \hyperref[def:propositional_semantics/classical]{classical semantics}.

    \thmitem{ex:def:fixed_point_combinator/succ} Again, let \( M \) be a fixed point combinator.

    For the successor combinator \( S^+ \) from \eqref{eq:ex:def:beta_eta_reduction/succ}, the fixed point \( MS^+ \) corresponds to a generalized numeral that is its own successor.
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:y_is_a_fixed_point_combinator}
  The term \( \ref{eq:ex:def:lambda_term/combinator/y} = \qabs \synx (\qabs \syny \synx \syny \syny) (\qabs \syny \synx \syny \syny) \) is a \hyperref[def:fixed_point_combinator]{fixed point combinator}.
\end{proposition}
\begin{proof}
  Let \( F \) be a \( \synlambda \)-term where \( \synx \) and \( \syny \) are not free. We have
  \begin{equation*}
    YF
    =
    \parens[\Big]{ \qabs {\hi{\synx}} (\qabs \syny \hi{\synx} \syny \syny) (\qabs \syny \hi{\synx} \syny \syny) } \hi{F}
    \bred
    (\qabs v F v v) (\qabs v F v v),
  \end{equation*}
  where \( v = \syny \) if \( \syny \) is not free in \( F \) and is a fresh variable otherwise.

  Denote this reduct by \( P \). Then
  \begin{equation*}
    P =
    (\qabs {\hi{v}} F \hi{v} \hi{v}) \hi{(\qabs v F v v)}
    \bred
    F (\qabs v F v v) (\qabs v F v v)
    =
    FP.
  \end{equation*}

  Since \( YF \bequiv P \) and \( P \bequiv FP \), we conclude that \( YF \bequiv F(YF) \).
\end{proof}

\paragraph{Parallel reductions}

\begin{definition}\label{def:parallel_reduction}
  Between single-step and multi-step reductions, there are \term{parallel reductions}, which allow reducing different subterms simultaneously.

  \begin{thmenum}
    \thmitem{def:parallel_reduction/base} We reuse \ref{inf:def:lambda_reduction/abs} and \ref{inf:def:lambda_reduction/alpha}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}\taglabel[\ensuremath{ \logic{ParAbs}_{\anon}^L }]{inf:def:parallel_reduction/abs}
          \begin{prooftree}
            \hypo{ A \pred B }
            \infer1[\ref{inf:def:lambda_reduction/abs}]{ \qabs x A \pred \qabs x B }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}\taglabel[\ensuremath{ \logic{ParAlpha}_{\anon} }]{inf:def:parallel_reduction/alpha}
          \begin{prooftree}
            \hypo{ A \aequiv B }
            \hypo{ B \pred C }
            \hypo{ C \aequiv D }
            \infer3[\ref{inf:def:parallel_reduction/alpha}]{ A \pred D }.
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    We combine \ref{inf:def:lambda_reduction/app_left} and \ref{inf:def:lambda_reduction/app_right} into
    \begin{equation*}\taglabel[\ensuremath{ \logic{ParApp}_{\anon} }]{inf:def:parallel_reduction/app}
      \begin{prooftree}
        \hypo{ A \ppred C }
        \hypo{ B \ppred D }
        \infer2[\ref{inf:def:parallel_reduction/app}]{ AB \ppred CD }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:parallel_reduction/refl} In order for parallel reduction to extend single-step reductions, \ref{inf:def:parallel_reduction/app} must hold when \( A = C \) or \( B = D \). We achieve this by ensuring that parallel reductions are \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive}, for which the following rule is sufficient:
    \begin{equation*}\taglabel[\ensuremath{ \logic{ParVar}_{\anon} }]{inf:def:parallel_reduction/var}
      \begin{prooftree}
        \infer0[\ref{inf:def:parallel_reduction/var}]{ x \ppred x }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}

  \thmitem{def:parallel_reduction/beta_eta} Additionally, we replace \ref{inf:def:beta_eta_reduction/beta} and \ref{inf:def:beta_eta_reduction/eta} with
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{ParRed}_\beta }]{inf:def:parallel_reduction/beta}
        \begin{prooftree}
          \hypo{ A \pbred C }
          \hypo{ B \pbred D }
          \infer2[\ref{inf:def:parallel_reduction/beta}]{ (\qabs x A) B \pbred C[x \mapsto D] }.
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{ParRed}_\eta }]{inf:def:parallel_reduction/eta}
        \begin{prooftree}
          \hypo{ x \not\in \op*{Free}(A) }
          \hypo{ A \pered B }
          \infer2[\ref{inf:def:parallel_reduction/eta}]{ \qabs x A x \pered B }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item This definition is based on \cite[3.2.3]{Barendregt1984}, where only parallel \( \beta \)-reduction is considered.
  \item Of course, we also consider equivalences and multi-step reductions based on the above single-step reductions.
\end{comments}

\begin{proposition}\label{thm:def:parallel_reduction}
  Let \enquote{\( {\anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  The \hyperref[def:parallel_reduction]{parallel reduction relation} \( {\ppred} \) has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:parallel_reduction/alpha_reflexive} It is \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive}.
    \thmitem{thm:def:parallel_reduction/extends_single_step} It extends single-step reduction: if \( M \pred N \), then \( M \ppred N \).
    \thmitem{thm:def:parallel_reduction/extends_to_multi_step} It extends to multi-step reduction: if \( M \ppred N \), then \( M \pred* N \).
    \thmitem{thm:def:parallel_reduction/multi} The multi-step reductions of \( {\pred} \) and \( {\ppred} \) coincide.
    \thmitem{thm:def:parallel_reduction/free} A generalization of \fullref{thm:lambda_reduction_free_variables} holds: if \( M \ppred N \), then \( \op*{Free}(N) \subseteq \op*{Free}(M) \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:parallel_reduction/alpha_reflexive} We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \aequiv N \) to show that \( M \ppred N \):
  \begin{itemize}
    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/var}, then \( M \) and \( N \) are equal variables. The rule \ref{inf:def:parallel_reduction/var} implies that \( M \ppred M \).

    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/app}, then \( M = AB \) and \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \). The inductive hypothesis implies that \( A \ppred C \) and \( B \ppred D \). We then use \ref{inf:def:parallel_reduction/app} to conclude that \( M = AB \ppred CD = N \).

    \item If \( M \aequiv N \) due to \ref{inf:thm:alpha_equivalence_simplified/lift}, then \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \aequiv B \). The inductive hypothesis implies that \( A \ppred B \), and \ref{inf:def:parallel_reduction/abs} implies that \( M \ppred N \).

    \item Finally, if \( M \aequiv N \) due to \ref{inf:thm:alpha_equivalence_simplified/ren}, then \( M = \qabs a A \), \( N = \qabs b B \), \( a \) is not free in \( B \) and \( A \aequiv B[b \mapsto a] \).

    The inductive hypothesis implies that \( A \ppred B[b \mapsto a] \) and \ref{inf:def:parallel_reduction/abs} implies that
    \begin{equation*}
      \qabs a A \ppred \qabs a B[b \mapsto a].
    \end{equation*}

    Furthermore, \fullref{thm:alpha_conversion} implies that \( \qabs b B \aequiv \qabs a B[b \mapsto a] \). We can thus use \ref{inf:def:lambda_reduction/alpha} to conclude that
    \begin{equation*}
      M = \qabs a A \ppred \qabs b B.
    \end{equation*}
  \end{itemize}

  \SubProofOf{thm:def:parallel_reduction/extends_single_step} Follows from \fullref{thm:def:parallel_reduction/alpha_reflexive}.

  \SubProofOf{thm:def:parallel_reduction/extends_to_multi_step} We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \ppred N \) to show that \( M \pred* N \):
  \begin{itemize}
    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/var}, then \( M \) and \( N \) are equal variables, hence \( M \pred* N \) due to the latter being reflexive.

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/app}, then \( M = AB \) and \( N = CD \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    Then \( A \pred* C \), hence there exists some reduction sequence
    \begin{equation*}
      A = C_0 \pred C_1 \pred \cdots \pred C_n = C.
    \end{equation*}

    We can show that \( AB \pred C_i B \) by induction on \( i \):
    \begin{itemize}
      \item If \( i = 0 \), then \( AB = C_i B \), and \( AB \pred C_i B \) follows from reflexivity shown in \fullref{thm:def:parallel_reduction/alpha_reflexive}.

      \item If \( AB \pred* C_i B \), then \ref{inf:def:lambda_reduction/app_right} implies that \( AB \pred* C_{i+1} B \).
    \end{itemize}

    Therefore, \( AB \pred* CB \). Similarly, we can use induction on the numbers of steps in \( B \pred* D \) to conclude via \ref{inf:def:lambda_reduction/app_right} that
    \begin{equation*}
      M = AB \pred* CB \pred* CD = N.
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/abs}, then \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \ppred B \) and the inductive hypothesis holds for the latter.

    Using the same rule, by induction on the number of steps in \( A \pred* B \) we can show that
    \begin{equation*}
      M = \qabs x A \pred* \qabs x B = N.
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, we proceed analogously.

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    We can show by induction on the number of steps in \( A \pred* C \) that
    \begin{equation*}
      (\qabs x A)B \pred* (\qabs x C)B
    \end{equation*}
    and similarly that
    \begin{equation*}
      (\qabs x C)B \pred* (\qabs x C)D.
    \end{equation*}

    Applying \ref{inf:def:beta_eta_reduction/beta}, we obtain
    \begin{equation*}
      M = (\qabs x A) B \pred* C[x \mapsto D] = N.
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/eta}, then \( M = \qabs x A x \), where \( x \) is not free in \( A \) and \( A \ppred N \) and the inductive hypothesis holds for the latter.

    Via induction on the number of steps in \( A \pred* N \) we conclude that
    \begin{equation*}
      M = \qabs x A x \pred* \qabs x N x.
    \end{equation*}

    By \fullref{thm:lambda_reduction_free_variables}, every free variable in \( N \) is also free in \( A \), thus \( x \) cannot be free in \( N \). Then we can apply \ref{inf:def:beta_eta_reduction/eta} to obtain \( M \pred* N \).
  \end{itemize}

  \SubProofOf{thm:def:parallel_reduction/multi} Follows from \fullref{thm:def:parallel_reduction/extends_to_multi_step}.

  \SubProofOf{thm:def:parallel_reduction/free} Follows from \fullref{thm:lambda_reduction_free_variables} and \fullref{thm:def:parallel_reduction/extends_single_step}.
\end{proof}

\begin{proposition}\label{thm:substitution_on_parallel_reduction}
  Let \enquote{\( {\anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  Fix \( \synlambda \)-terms \( M \) and \( N \) such that \( M \ppred N \). Fix also substitutions \( \sigma \) and \( \rho \) such that, for every variable \( u \), we have \( \sigma(u) \ppred \rho(u) \).

  Then \( M[\sigma] \ppred N[\rho] \).
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \ppred N \) simultaneously on all compatible substitutions to show that \( M[\sigma] \pred N[\rho] \).
  \begin{itemize}
    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/var}, then \( M \) and \( N \) are equal variables, thus
    \begin{equation*}
      M[\sigma] = \sigma(M) \pred \rho(N) = N[\sigma].
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/app}, then \( M = AB \) and \( N = CD \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two. Then
    \begin{equation*}
      M[\sigma]
      =
      A[\sigma] \thinspace B[\sigma]
      \reloset {\T{ind.}} \ppred
      A[\rho] \thinspace D[\rho]
      =
      N[\rho].
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, we use \fullref{thm:substitution_on_alpha_equivalent_terms}.

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/abs}, we have \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \ppred B \) and the inductive hypothesis holds for the latter. \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{align*}
      M[\sigma] &= \qabs u A[\sigma_{x \mapsto u}], &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
      N[\rho]   &= \qabs v B[\rho_{x \mapsto v}],   &&v \not\in \op*{Free}(N) \cup \op*{Free}(N[\rho]).
    \end{align*}

    We consider two cases:
    \begin{itemize}
      \item If \( u = v \), the inductive hypothesis implies that \( A[\sigma_{x \mapsto u}] \ppred B[\rho_{x \mapsto u}] \), hence we can apply \ref{inf:def:lambda_reduction/abs} to obtain \( M[\sigma] \ppred N[\rho] \).

      \item Otherwise, by \fullref{thm:lambda_reduction_free_variables}, \( v \) is not free in \( M \), and we have
      \begin{equation*}
        M[\sigma]
        =
        \qabs u A[\sigma_{x \mapsto u}]
        \reloset {\eqref{eq:thm:alpha_conversion_modified}} \aequiv
        \qabs v A[\sigma_{x \mapsto v}]
        \reloset {\T{ind.}} \ppred
        \qabs v B[\rho_{x \mapsto v}]
        =
        N[\sigma].
      \end{equation*}

      We can apply \ref{inf:def:lambda_reduction/alpha} to obtain \( M[\sigma] \ppred N[\sigma] \).
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{equation*}
      M[\sigma] = \parens[\Big]{ \qabs u A[\sigma_{x \mapsto u}] } B[\sigma],
    \end{equation*}
    where \( u \not\in \op*{Free}(\qabs x A) \cup \op*{Free}_\sigma(\qabs x A) \).

    The inductive hypothesis implies that \( A[\sigma_{x \mapsto u}] \ppred C[\rho_{x \mapsto u}] \) and \( B[\sigma] \ppred D[\rho] \). Then \ref{inf:def:parallel_reduction/beta} implies that
    \begin{equation*}
      M[\sigma]
      =
      \parens[\Big]{ \qabs u A[\sigma_{x \mapsto u}] } B[\sigma]
      \ppred
      C[\rho_{x \mapsto u}][u \mapsto D[\rho]].
    \end{equation*}

    Furthermore,
    \begin{equation*}
      N[\rho]
      =
      C[x \mapsto D][\rho]
      \reloset {\eqref{eq:thm:substitution_composition_is_alpha_equivalent}} \aequiv
      C[\rho_{x \mapsto D[\rho]}]
      \reloset {\eqref{eq:thm:substitution_chain_contraction/contraction}} \aequiv
      C[\rho_{x \mapsto u}][u \mapsto D[\rho]].
    \end{equation*}

    Therefore, \ref{inf:def:lambda_reduction/alpha} allows us to conclude that \( M[\sigma] \ppred N[\rho] \).

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/eta}, then \( M = \qabs x Ax \), where \( x \) is not free in \( A \) and \( A \ppred N \) and the inductive hypothesis holds for the latter.

    \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{equation*}
      M[\sigma] = \qabs u A[\sigma_{x \mapsto u}] \thinspace u
    \end{equation*}
    where \( u \) is not free in \( A[\sigma] \).

    Furthermore, \fullref{thm:lambda_substitution_restriction} implies that \( A[\sigma_{x \mapsto u}] = A[\sigma] \), thus
    \begin{equation*}
      M[\sigma] = \qabs u A[\sigma] \thinspace u.
    \end{equation*}

    The inductive hypothesis implies that \( A[\sigma] \ppred N[\rho] \). Therefore, \ref{inf:def:parallel_reduction/eta} allows us to conclude that \( M[\sigma] \ppred N[\rho] \).
  \end{itemize}
\end{proof}

\begin{lemma}\label{thm:parallel_reduction_deconstruction}
  Let \enquote{\( {\anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  If \( M \ppred N \), depending on the structure of \( M \), we have the following possibilities:
  \begin{thmenum}
    \thmitem{thm:parallel_reduction_deconstruction/var} If \( M \) is a variable, then \( M = N \).

    \thmitem{thm:parallel_reduction_deconstruction/app} If \( M = AB \), we have two possibilities:
    \begin{thmenum}
      \thmitem{thm:parallel_reduction_deconstruction/app/direct} \( N = CD \), where \( A \ppred C \) and \( B \ppred D \).

      \thmitem{thm:parallel_reduction_deconstruction/app/beta} In case \( {\anon} \) is \enquote{\( \beta \)} or \enquote{\( \beta\eta \)}, it is possible that \( A = \qabs x E \) and \( N \aequiv F[x \mapsto G] \), where \( B \ppred G \) and \( E \ppred F \).
    \end{thmenum}

    \thmitem{thm:parallel_reduction_deconstruction/abs} If \( M = \qabs x A \), we again have two possibilities:
    \begin{thmenum}
      \thmitem{thm:parallel_reduction_deconstruction/abs/lift} \( N \aequiv \qabs x B \), where \( A \ppred B \).

      \thmitem{thm:parallel_reduction_deconstruction/abs/eta} In case \( {\anon} \) is \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}, it is possible that \( A \aequiv Nx \) and \( x \not\in \op*{Free}(N) \).
    \end{thmenum}
  \end{thmenum}
\end{lemma}
\begin{comments}
  \item The main purpose of this lemma is to simplify handling \ref{inf:def:lambda_reduction/alpha} in the proof of \fullref{thm:church_rosser_theorem}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:parallel_reduction_deconstruction/var} The only rules applicable to \( x \ppred N \) are \ref{inf:def:parallel_reduction/var} and \ref{inf:def:lambda_reduction/alpha}, and both directly imply that \( N = x \).

  \SubProofOf{thm:parallel_reduction_deconstruction/app} Let \( M = AB \). We will use \fullref{thm:induction_on_recursively_defined_relations} on \( AB \ppred N \):
  \begin{itemize}
    \item If \( AB \ppred N \) due to \ref{inf:def:parallel_reduction/app}, then \fullref{thm:parallel_reduction_deconstruction/app/direct} holds.

    \item If \( AB \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \fullref{thm:parallel_reduction_deconstruction/app/beta} holds.

    \item If \( AB \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( AB \aequiv A' B' \) and \( N \aequiv N' \), where \( A' B' \ppred N' \) and the inductive hypothesis holds for the latter.

    \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities:
    \begin{itemize}
      \item The possibility \fullref{thm:parallel_reduction_deconstruction/app/direct} for \( A' B' \ppred N' \) implies that \( N' \) is an application, say \( N' = C' D' \), such that \( A' \ppred C' \) and \( B' \ppred D' \). Furthermore, due to \ref{inf:def:lambda_term_alpha_equivalence/app}, we conclude that \( N \) is also an application, say \( N = CD \), where \( C \aequiv C' \) and \( D \aequiv D' \).

      Then \ref{inf:def:lambda_reduction/alpha} implies that \( A \ppred C \) and \( B \ppred D \), which is the desired result.

      \item The possibility \fullref{thm:parallel_reduction_deconstruction/app/beta} for \( A' B' \ppred N' \) implies that \( A' = \qabs y E' \) and \( N' \aequiv F'[y \mapsto G'] \), where \( B' \ppred G' \) and \( E' \ppred F' \).

      \begin{itemize}
        \item If \( A \aequiv A' \) due to \ref{inf:thm:alpha_equivalence_simplified/lift}, then \( A = \qabs y E \), where \( E \aequiv E' \). Via \ref{inf:def:lambda_reduction/alpha} we conclude that \( E \ppred F' \).

        Then \fullref{thm:parallel_reduction_deconstruction/app/beta} holds with \( x \coloneqq y \), \( G \coloneqq G' \) and \( F \coloneqq F' \).

        \item If \( A \aequiv A' \) due to \ref{inf:thm:alpha_equivalence_simplified/ren}, then \( A = \qabs x E \), where \( x \) is not free in \( E' \) and \( E \aequiv E'[y \mapsto x] \).

        Let \( F \coloneqq F'[y \mapsto x] \). Since \( E' \ppred F' \), we have \( E'[y \mapsto x] \ppred F \) due to \fullref{thm:substitution_on_parallel_reduction} and \( E \ppred F \) due to \ref{inf:def:lambda_reduction/alpha}.

        By \fullref{thm:def:parallel_reduction/free}, \( x \) is not free in \( F' \) since otherwise it would be free in \( E' \). Let \( G \coloneqq G' \). Then
        \begin{equation*}
          N
          \aequiv
          N'
          \aequiv
          F'[y \mapsto G']
          \reloset {\eqref{eq:thm:substitution_chain_contraction/contraction}} \aequiv
          F'[y \mapsto x][x \mapsto G']
          =
          F[x \mapsto G],
        \end{equation*}
        thus \fullref{thm:parallel_reduction_deconstruction/app/beta} holds.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \SubProofOf{thm:parallel_reduction_deconstruction/abs} Let \( M = \qabs x A \). We will use \fullref{thm:induction_on_recursively_defined_relations} on \( (\qabs x A) \ppred N \):
  \begin{itemize}
    \item If \( (\qabs x A) \ppred N \) due to \ref{inf:def:lambda_reduction/abs}, then \fullref{thm:parallel_reduction_deconstruction/abs/lift} holds.

    \item If \( (\qabs x A) \ppred N \) due to \ref{inf:def:beta_eta_reduction/eta}, then \fullref{thm:parallel_reduction_deconstruction/abs/eta} holds.

    \item If \( (\qabs x A) \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( \qabs x A = M \aequiv M' \) and \( N \aequiv N' \), where \( M' \ppred N' \) and the inductive hypothesis holds for the latter.

    Furthermore, \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( M' = \qabs y A' \), where \( A[x \mapsto n] \aequiv A'[y \mapsto n] \) for every \( n \) not free in \( M \). In particular, \( A \aequiv A'[y \mapsto x] \).

    \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( (\qabs y A') \ppred N' \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, we have \( N' \aequiv \qabs y B' \), where \( A' \ppred B' \).

      Let \( B \coloneqq B'[y \mapsto x] \). Then \fullref{thm:substitution_on_parallel_reduction} implies that \( A'[y \mapsto x] \ppred B \) and \ref{inf:def:lambda_reduction/alpha} implies that \( A \ppred B \).

      Furthermore, we have
      \begin{equation*}
        N
        \aequiv
        N'
        \aequiv
        \qabs y B'
        \reloset {\eqref{eq:thm:alpha_conversion}} \aequiv
        \qabs x B.
      \end{equation*}

      We conclude that \fullref{thm:parallel_reduction_deconstruction/abs/lift} holds.

      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, we have \( A' \aequiv N'y \) and \( y \not\in \op*{Free}(N') \). Then
      \begin{equation*}
        A
        \aequiv
        A'[y \mapsto x]
        \reloset {\ref{thm:substitution_on_alpha_equivalent_terms}} \aequiv
        N'[y \mapsto x] \thinspace x
        \reloset {\ref{thm:lambda_substitution_noop}} =
        N' x
        \aequiv
        N x.
      \end{equation*}

      It remains to show that \( x \) is not free in \( N \). Suppose that it is. \Fullref{thm:def:parallel_reduction/free} implies that it is free in \( M' \) also, and \Fullref{thm:def:lambda_term_alpha_equivalence/free} implies that it is free in \( M \), which is a contradiction.

      Therefore, \( x \) is not free in \( N \), and \fullref{thm:parallel_reduction_deconstruction/abs/eta} follows.
    \end{itemize}
  \end{itemize}
\end{proof}

\paragraph{Church-Rosser theorem}\hfill

\begin{definition}\label{def:reduction_confluence}\mcite[14]{TroelstraSchwichtenberg2000}
  We say that a \hyperref[def:lambda_reduction]{reduction relation} \( {\pred} \) is \term{confluent} if, whenever \( M \pred N \) and \( M \pred K \), there exists a \( \synlambda \)-term \( L \) such that \( N \pred L \) and \( K \pred L \). We call this term a  \term{confluence point} of \( N \) and \( K \).

  A \term{weak confluence point} is instead a \( \synlambda \)-term \( L \) such that \( M \pred* N \) and \( K \pred* L \). We define weak confluence analogously.

  \begin{figure}[!ht]
    \hfill
    \hfill
    \includegraphics[page=1]{output/def__reduction_confluence}
    \hfill
    \includegraphics[page=2]{output/def__reduction_confluence}
    \hfill
    \caption{\hyperref[def:reduction_confluence]{Confluence} and \hyperref[def:reduction_confluence]{weak confluence} as \hyperref[def:hasse_diagram]{Hasse diagrams}.}\label{fig:def:relation_confluence}
  \end{figure}
\end{definition}
\begin{comments}
  \item Every confluence point of \( N \) and \( K \) is an upper bound. The concept of confluence does not make sense, however, unless \( N \) and \( K \) already have a lower bound. If they do, then any upper bound is a confluence point.

  \item The terminology regarding confluence is inconsistent across the literature. A major distinction is that the authors we will list consider binary relations on plain sets, while we explicitly restrict ourselves to \( \synlambda \)-reductions in order to handle \( \alpha \)-equivalence explicitly.

  We mostly follow \incite[14]{TroelstraSchwichtenberg2000}, who use the term \enquote{(weak) Church-Rosser property} synonymously with \enquote{(weak) confluence}.
  \begin{itemize}
    \item \incite[ch. 3]{Barendregt1984} uses the term \enquote{(weak) diamond property} for what we call \enquote{confluence} applied to general binary relations, while defining a relation to have the (weak) \enquote{Church-Rosser property} if its reflexive and transitive closure has the (weak) diamond property.

    \item \incite[3.4.1]{Mimram2020} uses \enquote{confluence} for what Barendregt calls the \enquote{Church-Rosser property}.
  \end{itemize}

  The term \enquote{confluence point} is used in a more informal context by \incite[630]{Aho2006}.
\end{comments}

\begin{proposition}\label{thm:def:reduction_confluence}
  \hyperref[def:reduction_confluence]{Confluence} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:reduction_confluence/normal_implies_weak} If a \hyperref[def:lambda_reduction/single]{single-step reduction relation} is confluent, it is also weakly confluent.

    \thmitem{thm:def:reduction_confluence/multi_implies_weak} If a \hyperref[def:lambda_reduction/single]{multi-step reduction relation} is confluent, the corresponding single-step relation is weakly confluent.

    \thmitem{thm:def:reduction_confluence/weak_implies_multi} If a single-step reduction relation is weakly confluent, the corresponding multi-step relation is confluent.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:reduction_confluence/normal_implies_weak} Trivial.
  \SubProofOf{thm:def:reduction_confluence/multi_implies_weak} Trivial.
  \SubProofOf{thm:def:reduction_confluence/weak_implies_multi} Suppose \( {\pred} \) is weakly confluent and let \( M \pred* N \) and \( M \pred* K \).

  If \( M \pred* N \) because \( M \aequiv N \), then \ref{inf:def:lambda_reduction/alpha} implies that \( N \pred* K \) and thus \( K \) is a weak confluence point of \( N \) and \( K \).

  Otherwise, there exist reduction sequences
  \begin{equation*}
    M = N_0 \pred N_1 \pred \cdots \pred N_n = N
  \end{equation*}
  and
  \begin{equation*}
    M = K_0 \pred K_1 \pred \cdots \pred K_k = K.
  \end{equation*}

  We will use induction on \( i = 0, \ldots, \min\set{ n, k } \) to show that there exists a weak confluence point \( L_i \) such that \( N_i \pred* L_i \) and \( K_i \pred* L_i \).

  \begin{itemize}
    \item In the base case \( i = 0 \), \( M = N_i = K_i \), thus we can take \( L_i \) to be \( M \) itself.

    \item Suppose that the inductive hypothesis holds for \( i < \min\set{ n, k } \) and let \( L_i \) be the weak confluence point of \( N_i \) and \( K_i \).

    We thus have \( N_i \pred N_{i+1} \) and \( N_i \pred* L_i \). Since \( {\pred} \) is weakly confluent, there exist a weak confluence points \( A \) of \( N_{i+1} \) and \( L_i \) and \( B \) of \( K_{i+1} \) and \( L_i \).

    Finally, let \( L_{i+1} \) be a weak confluence point of \( A \) and \( B \). Then \( N_{i+1} \pred* A \pred* L_{i+1} \) and \( K_{i+1} \pred* B \pred* L_{i+1} \).

    \begin{figure}[!ht]
      \centering
      \includegraphics[page=1]{output/thm__def__reduction_confluence}
      \caption{An illustration of the inductive step in our proof of \fullref{thm:def:reduction_confluence/weak_implies_multi}}\label{fig:thm:confluence_of_reflexive_transitive_closure}
    \end{figure}
  \end{itemize}

  We now have the following possibilities:
  \begin{itemize}
    \item If \( n = k \), let \( L \coloneqq L_n = L_k \).
    \item If \( n > k \), for \( i > k \) let \( L_{i+1} \) be a weak confluence point of \( N_{i+1} \) and \( L_i \), and let \( L \coloneqq L_n \).
    \item If \( n < k \), for \( i > n \) let \( L_{i+1} \) be a weak confluence point of \( K_{i+1} \) and \( L_i \), and let \( L \coloneqq L_k \).
  \end{itemize}

  In all cases, \( N \pred* L \) and \( K \pred* L \).
\end{proof}

\begin{theorem}[Church-Rosser theorem]\label{thm:church_rosser_theorem}
  Let \enquote{\( {\anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  \begin{thmenum}
    \thmitem{thm:church_rosser_theorem/parallel} \hyperref[def:parallel_reduction]{Parallel \( \anon \)-reduction} is \hyperref[def:reduction_confluence]{confluent}.

    \thmitem{thm:church_rosser_theorem/multi_step} \hyperref[def:lambda_reduction/multi]{Multi-step \( \anon \)-reduction} is \hyperref[def:reduction_confluence]{confluent}.

    \thmitem{thm:church_rosser_theorem/single_step} \hyperref[def:lambda_reduction/single]{Single-step \( \anon \)-reduction} is only \hyperref[def:reduction_confluence]{weakly confluent}.
  \end{thmenum}
\end{theorem}
\begin{proof}
  \SubProofOf{thm:church_rosser_theorem/parallel} Suppose that \( M \ppred N \) and \( M \ppred K \). We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \ppred N \) simultaneously on all \( K \) to show the existence of the desired confluence point \( L \) such that \( N \ppred L \) and \( N \ppred L \):
  \begin{itemize}
    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/var}, then \( M \) and \( N \) are identical variables. Furthermore, \fullref{thm:parallel_reduction_deconstruction/var} implies the same for \( M \) and \( K \), hence \( M = N = K \).

    Define \( L \coloneqq M \) so that \( N \ppred L \) and \( K \ppred L \), again due to \ref{inf:def:parallel_reduction/var}.

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( M \aequiv B \ppred C \aequiv N \), where the inductive hypothesis holds for \( B \ppred C \).

    Then \( B \ppred K \) due to \ref{inf:def:lambda_reduction/alpha}, and the inductive hypothesis implies that there exists some \( \synlambda \)-term \( L \) such that \( C \ppred L \) and \( K \ppred L \).

    We can use \ref{inf:def:lambda_reduction/alpha} again to conclude that \( N \ppred L \).

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/app}, we have \( M = AB \) and \( N = CD \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities for \( AB \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct}, we have \( K = EF \), where \( A \ppred E \) and \( B \ppred F \).

      The inductive hypothesis implies the existence of confluence points \( G \) of \( C \) and \( E \) and \( H \) of \( D \) and \( F \).

      Let \( L \coloneqq GH \). Then \ref{inf:def:parallel_reduction/app} allows us to conclude that \( N \ppred L \) and \( K \ppred L \).

      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta}, we have \( A = \qabs x E \) and \( K \aequiv F[x \mapsto G] \), where \( B \ppred G \) and \( E \ppred F \).

      Since \( E \ppred F \), \ref{inf:def:lambda_reduction/abs} implies that \( A = \qabs x E \ppred \qabs x F \). By the inductive hypothesis, there exists a confluence point \( P \) of \( C \) and \( \qabs x F \). Furthermore, by the inductive hypothesis on \( B \ppred D \), there exists a confluence point \( R \) of \( D \) and \( G \).

      This leads to the following diagrams:
      \begin{equation*}
        \includegraphics[page=2]{output/thm__church_rosser_theorem}
        \quad\quad
        \includegraphics[page=3]{output/thm__church_rosser_theorem}
      \end{equation*}

      We need to consider different cases for \( C \) and \( P \).

      \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( A = (\qabs x E) \ppred C \):
      \begin{itemize}
        \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, we have \( C \aequiv \qabs x H \), where \( E \ppred H \).

        \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( C = (\qabs x H) \ppred P \):
        \begin{itemize}
          \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, we have \( P \aequiv \qabs x Q \), where \( H \ppred Q \). This leads to the following diagram:
          \begin{equation*}
            \includegraphics[page=4]{output/thm__church_rosser_theorem}
          \end{equation*}

          Let \( L \coloneqq Q[x \mapsto R] \). By \ref{inf:def:parallel_reduction/beta} we have
          \begin{equation*}
            N = CD \aequiv (\qabs x H) D \ppred Q[x \mapsto R] = L
          \end{equation*}
          and by \fullref{thm:substitution_on_parallel_reduction} we have
          \begin{equation*}
            K \aequiv F[x \mapsto G] \ppred Q[x \mapsto R] = L.
          \end{equation*}

          So \( L \) is the desired confluence point.

          \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, \( x \) is not free in \( P \) and \( F \aequiv Px \).

          Let \( L \coloneqq PR \). Then
          and
          \begin{equation*}
            N
            =
            CD
            \ppred
            PR
            =
            L
          \end{equation*}
          and
          \begin{equation*}
            K
            \aequiv
            F[x \mapsto G]
            \reloset {\ref{thm:substitution_on_alpha_equivalent_terms}} \aequiv
            P[x \mapsto G] \thinspace G
            \reloset {\ref{thm:lambda_substitution_noop}} =
            PG
            \ppred
            PR
            =
            L.
          \end{equation*}
        \end{itemize}
      \end{itemize}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{def:lambda_reduction/abs}, then \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \ppred B \) and the inductive hypothesis holds for the latter.

    \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( M \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, \( K \aequiv \qabs x C \), where \( A \ppred C \).

      By the inductive hypothesis on \( A \ppred B \), there exists a confluence point \( D \) of \( B \) and \( C \).

      Let \( L \coloneqq \qabs x D \). Then \ref{inf:def:parallel_reduction/abs} implies that \( N \ppred L \) and \( K \ppred L \).

      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, \( x \) is not free in \( K \) and \( A \aequiv Kx \).

      By \ref{inf:def:lambda_reduction/alpha}, \( Kx \ppred B \). \Fullref{thm:parallel_reduction_deconstruction/app} lists two possibilities, but \fullref{thm:parallel_reduction_deconstruction/app/beta} is not possible, so it remains for \fullref{thm:parallel_reduction_deconstruction/app/direct} to hold. Thus, we have \( B = Lx \), where \( K \ppred L \).

      Then \( L \) is a confluence point of \( N \) and \( K \), as can be seen from following diagram:
      \begin{equation*}
        \includegraphics[page=5]{output/thm__church_rosser_theorem}
      \end{equation*}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities for \( M \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct}, we have \( K = EF \), where \( \qabs x A \ppred E \) and \( B \ppred F \). By the inductive hypothesis on \( B \ppred D \), there exists a confluence point \( Q \) of \( D \) and \( F \).

      \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( \qabs x A \ppred E \):
      \begin{itemize}
        \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, \( K \aequiv \qabs x H \), where \( A \ppred H \).

        By the inductive hypothesis on \( A \ppred C \), there exists a confluence point \( P \) of \( C \) and \( H \).

        Then \( L \coloneqq P[x \mapsto Q] \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
        \begin{equation*}
          \includegraphics[page=6]{output/thm__church_rosser_theorem}
        \end{equation*}

        \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, \( x \) is not free in \( E \) and \( A \aequiv Ex \).

        By \ref{inf:def:lambda_reduction/alpha}, \( Ex \ppred C \). \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities:
        \begin{itemize}
          \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct}, \( C \aequiv Px \) for some term \( P \) such that \( E \pred P \). In particular, \( x \) is not free in \( P \), so
          \begin{equation*}
            N = CD \aequiv (\qabs x P x) D \ppred PD.
          \end{equation*}

          Then \( L \coloneqq PQ \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
          \begin{equation*}
            \includegraphics[page=7]{output/thm__church_rosser_theorem}
          \end{equation*}

          \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta}, \( E \aequiv \qabs y P \) and \( C \aequiv R[y \mapsto S] \), where \( P \ppred R \) and \( y \ppred S \). It follows from \fullref{thm:parallel_reduction_deconstruction/var} that \( S = y \), and from \fullref{thm:lambda_substitution_noop} that \( R[y \mapsto y] = R \). We can apply \ref{inf:def:lambda_reduction/alpha} to conclude that \( P \ppred C \).

          Then \( L \coloneqq C[x \mapsto Q] \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
          \begin{equation*}
            \includegraphics[page=8]{output/thm__church_rosser_theorem}
          \end{equation*}
        \end{itemize}
      \end{itemize}

      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta}, we have \( K \aequiv E[x \mapsto F] \), where \( B \ppred F \) and \( A \ppred E \).

      By the inductive hypothesis on \( A \ppred C \), there exists a confluence point \( P \) for \( C \) and \( E \). By the inductive hypothesis on \( B \ppred D \), there exists a confluence point \( Q \) of \( D \) and \( F \).

      Then \fullref{thm:substitution_on_parallel_reduction} allows us to conclude that \( L \coloneqq P[x \mapsto Q] \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
      \begin{equation*}
        \includegraphics[page=9]{output/thm__church_rosser_theorem}
      \end{equation*}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/eta}, then \( M = \qabs x A x \), where \( x \) is not free in \( A \) and \( A \ppred N \) and the inductive hypothesis holds for the latter.

    \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( M \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, \( K \aequiv \qabs x B \), where \( Ax \ppred B \).

      \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities for \( Ax \ppred B \):
      \begin{itemize}
        \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct}, \( B = Cx \), where \( A \ppred C \).

        By the inductive hypothesis on \( A \ppred N \), there exists a confluence point \( L \) of \( N \) and \( C \). It is also a confluence point of \( N \) and \( K \) because
        \begin{equation*}
          K \aequiv \qabs x Cx \ppred L.
        \end{equation*}

        \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta}, \( K \aequiv F[x \mapsto G] \), where \( A \ppred F \) and \( B \ppred G \).

        Since \( x \) is not free in \( A \), it is also not free in \( F \), thus \( K \aequiv F \), which in turn implies that \( A \ppred K \).

        By the inductive hypothesis on \( A \ppred N \), there exists a confluence point \( L \) of \( N \) and \( K \).
      \end{itemize}

      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, \( x \) is not free in \( K \) and \( A \aequiv K \). \Fullref{thm:def:parallel_reduction/alpha_reflexive} implies that \( A \ppred K \).

      By the inductive hypothesis on \( A \ppred N \), there exists a confluence point \( L \) of \( N \) and \( K \).
    \end{itemize}
  \end{itemize}

  \SubProofOf{thm:church_rosser_theorem/multi_step} The parallel reduction \( {\ppred} \) is confluent as a consequence of \fullref{thm:church_rosser_theorem/parallel}. \Fullref{thm:def:parallel_reduction/extends_to_multi_step} implies that the corresponding multi-step reduction coincides with \( {\pred*} \), hence \fullref{thm:def:reduction_confluence/weak_implies_multi} implies that \( {\pred*} \) is confluent.

  \SubProofOf{thm:church_rosser_theorem/single_step} Follows from \fullref{thm:church_rosser_theorem/multi_step} and \fullref{thm:def:reduction_confluence/multi_implies_weak}.
\end{proof}
