\section{Lambda calculus reductions}\label{sec:lambda_calculus_reductions}

\paragraph{Subterm occurrences}

\begin{definition}\label{def:lambda_subterm_occurrence}\mimprovised
  An \term{occurrence} of a subterm \( N \) of \( M \) is a \hyperref[def:tree/subtree]{subtree} of the \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(M) \) of that is \hyperref[def:labeled_tree/homomorphism]{isomorphic} to \( T(N) \).
\end{definition}
\begin{comments}
  \item From \fullref{thm:propositional_ast_subformula} we conclude that \( N \) is a subterm of \( M \) if and only if it has at least one occurrence in \( M \).
\end{comments}

\begin{definition}\label{def:subterm_occurrence_ordering}\mimprovised
  We will introduce two \hyperref[def:partially_ordered_set]{partial orders} on the \hyperref[def:lambda_subterm_occurrence]{subterm occurrences} of \( M \).

  Consider the occurrences \( R \) and \( S \) of (possibly different) subterms of \( T(M) \).

  \begin{thmenum}
    \thmitem{def:subterm_occurrence_ordering/vertical} Under the \term{vertical ordering}, \( R \leq S \) if \( R \) is a \hyperref[def:tree/subtree]{subtree} of \( S \).

    We call the \hyperref[def:extremal_points/maximal_and_minimal_element]{maximal} occurrences under this ordering \term{outermost} and the minimal occurrences --- \term{innermost}. This terminology is useful mostly when restricted to certain kinds of subterms like \hyperref[def:beta_eta_reduction]{\( \beta \)-redexes}.

    \thmitem{def:subterm_occurrence_ordering/horizontal} Under the \term{horizontal ordering}, \( R \leq S \) if there exist an application subtree
    \begin{equation*}
      \begin{aligned}
        \includegraphics[page=1]{output/def__subterm_occurrence_ordering}
      \end{aligned}
    \end{equation*}
    of \( T(M) \) where \( R \) is a subtree of \( A \) and \( S \) is a subtree of \( B \).

    We call the maximal and minimal elements under this ordering \term{leftmost} and \term{rightmost}, respectively. Again, this terminology is useful mostly when restricted to certain kinds of subterms.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This definition is loosely based on \cite[138]{Mimram2020Types}, but differs in several aspects:
  \begin{itemize}
    \item We consider arbitrary subterm occurrences rather than redexes.
    \item We use syntax trees for formalizing subterm occurrences.
    \item We call \enquote{vertical order} what Mimram calls \enquote{imbrication order}.
  \end{itemize}

  Other authors like \incite[\S 8.4.7]{Barendregt1984LambdaCalculus} only consider horizontal ordering.
\end{comments}

\begin{example}\label{ex:def:subterm_occurrence_ordering}
  We list examples of \hyperref[def:subterm_occurrence_ordering]{subterm ordering}:
  \begin{thmenum}
    \thmitem{ex:def:subterm_occurrence_ordering/omega} Consider the term \( \ref{eq:ex:def:lambda_term/combinator/big_omega} = \omega \omega \), where \( \ref{eq:ex:def:lambda_term/combinator/omega} = \qabs \synx \synx \synx \).

    It consists of two occurrences of \( \omega \), so naturally one of them is leftmost and one is rightmost.

    On the other hand, the two occurrences are not comparable with respect to vertical ordering. Both occurrences of \( \omega \) are outermost and innermost, as are all \( 4 \) occurrences of \( \synx \).

    \thmitem{ex:def:subterm_occurrence_ordering/cdr_omega_i} Consider the term
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pair/cdr} \ref{eq:ex:def:lambda_term/combinator/big_omega} \ref{eq:ex:def:lambda_term/combinator/i}
      =
      (C_{\T{dr}} \Omega) I
      =
      \parens[\Bigg]{ \parens[\Big]{ \qabs \synx \syny \syny } \parens[\Big]{ (\qabs \synx \synx \synx) (\qabs \synx \synx \synx) } } \parens[\Bigg]{ \qabs \synx \synx }.
    \end{equation*}

    Its abstract syntax tree in given in \cref{fig:ex:def:subterm_occurrence_ordering/cdr_omega_i}.

    \begin{figure}[!ht]
      \hfill
      \includegraphics[align=t, page=1]{output/ex__def__subterm_occurrence_ordering}
      \hfill
      \includegraphics[align=t, page=2]{output/ex__def__subterm_occurrence_ordering}
      \hfill
      \hfill
      \caption{The abstract syntax tree of the \( \synlambda \)-term \( C_{\T{dr}} \Omega I \) from \fullref{ex:def:subterm_occurrence_ordering/cdr_omega_i}.}\label{fig:ex:def:subterm_occurrence_ordering/cdr_omega_i}
    \end{figure}

    \begin{itemize}
      \item As discussed in \fullref{ex:def:subterm_occurrence_ordering/omega}, \( \Omega \) has two occurrences of \( \omega \), and hence so does \( C_{\T{dr}} \Omega I \).

      \item \( C_{\T{dr}} \Omega I \) has five occurrences of \( \synx \) --- the leftmost one is in the leftmost occurrence of \( \Omega \), while the rightmost one is in the (only) occurrence of \( I \).
    \end{itemize}
  \end{thmenum}
\end{example}

\paragraph{\( \beta \) and \( \eta \)-reductions}

\begin{definition}\label{def:alpha_reflexive}\mimprovised
  We say that the binary relation \( {\sim} \) between \( \synlambda \)-terms is \term{\( \alpha \)-reflexive} if \( M \aequiv N \) implies \( M \sim N \).

  Correspondingly, we define the \term{\( \alpha \)-reflexive closure} of a binary relation as its set-theoretic union with \( {\aequiv} \).
\end{definition}
\begin{comments}
  \item This definition is not established. It is based on reflexive closures discussed in \fullref{def:relation_closures/reflexive}. It allows us to make explicit the dependency on \( \alpha \)-equivalence, which is implicit in our primary sources --- \cite[ch. 3]{Barendregt1984LambdaCalculus}, \cite[def. 1B2]{Hindley1997STT} and \cite[191]{Герасимов2011Вычислимость}.
\end{comments}

\begin{definition}\label{def:lambda_reduction}\mcite[315]{Barendregt1984LambdaCalculus}
  Via \fullref{thm:recursively_defined_relations}, we will define different kinds of \enquote{\( {\Anon} \)-reduction} relations simultaneously. The symbol \enquote{\( {\Anon} \)} is inessential to the formalisms presented here; we use it as a placeholder for \enquote{\( \beta \)}, \enquote{\( \eta \)}, \enquote{\( \beta\eta \)} and potentially other kinds of reductions.

  \begin{thmenum}
    \thmitem{def:lambda_reduction/single} A \term{single-step reduction} is a relation generated by or otherwise satisfying the following rules:
    \begin{paracol}{3}
      \begin{nthcolumn}{0}
        \begin{equation*}\taglabel[\ensuremath{ \logic{App}_{\Anon}^L }]{inf:def:lambda_reduction/app_left}
          \begin{prooftree}
            \hypo{ A \pred C }
            \infer1[\ref{inf:def:lambda_reduction/app_left}]{ AB \pred CB }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{1}
        \begin{equation*}\taglabel[\ensuremath{ \logic{App}_{\Anon}^R }]{inf:def:lambda_reduction/app_right}
          \begin{prooftree}
            \hypo{ B \pred D }
            \infer1[\ref{inf:def:lambda_reduction/app_right}]{ AB \pred AD }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}

      \begin{nthcolumn}{2}
        \begin{equation*}\taglabel[\ensuremath{ \logic{Abs}_{\Anon} }]{inf:def:lambda_reduction/abs}
          \begin{prooftree}
            \hypo{ A \pred B }
            \infer1[\ref{inf:def:lambda_reduction/abs}]{ \qabs x A \pred \qabs x B }
          \end{prooftree}
        \end{equation*}
      \end{nthcolumn}
    \end{paracol}

    We make the reliance on \( \alpha \)-equivalence explicit via the following rule:
    \begin{equation*}\taglabel[\ensuremath{ \logic{Alpha}_{\Anon} }]{inf:def:lambda_reduction/alpha}
      \begin{prooftree}
        \hypo{ A \aequiv B }
        \hypo{ B \pred C }
        \hypo{ C \aequiv D }
        \infer3[\ref{inf:def:lambda_reduction/alpha}]{ A \pred D }.
      \end{prooftree}
    \end{equation*}

    Since \hyperref[def:simple_type_system/atom]{atomic terms} are \( \alpha \)-equivalent to themselves, there is no need to separately consider them.

    \thmitem{def:lambda_reduction/multi} For each single-step reduction \( {\pred} \) defined above, we define the corresponding \term{multi-step \( {\Anon} \)-reduction} \( {\pred*} \) as the \hyperref[def:relation_closures/transitive]{transitive} and \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive closure} of \( {\pred} \). Which closure is taken first is immaterial due to \ref{inf:def:lambda_reduction/alpha} --- \( A \aequiv B \pred C \) already implies \( A \pred C \).

    Without further context, \enquote{\( {\Anon} \)-reduction} we will refer to the multi-step \( {\Anon} \)-reduction.

    \thmitem{def:lambda_reduction/equivalence} If we instead take the
    \hyperref[def:relation_closures/transitive]{transitive} and \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive} closure of the \hyperref[def:relation_closures/symmetric]{symmetric closure} of \( \pred \), we obtain \term{\( {\Anon} \)-equivalence}, which we denote by \( {\requiv} \).
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:beta_eta_reduction}\mcite[def. 1B1; 1C1]{Hindley1997STT}
  Consider the following rules:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\beta }]{inf:def:beta_eta_reduction/beta}
        \begin{prooftree}
          \infer0[\ref{inf:def:beta_eta_reduction/beta}]{ \underbrace{(\qabs x M) N}_{\T{\term{\( \beta \)-redex}}} \bred \underbrace{M[x \mapsto N]}_{\T{\term{\( \beta \)-contractum}}} },
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\eta }]{inf:def:beta_eta_reduction/eta}
        \begin{prooftree}
          \hypo{ x \not\in \op*{Free}(M) }
          \infer1[\ref{inf:def:beta_eta_reduction/eta}]{ \underbrace{\qabs x M x}_{\T{\term{\( \eta \)-redex}}} \ered \underbrace{M}_{\mathclap{\T{\term{\( \eta \)-contractum}}}} }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  Here \( \beta \)-redexes and \( \eta \)-redexes are \hyperref[def:lambda_subterm_occurrence]{subterm occurrences} rather than subterms, so a single term may have isomorphic redexes.

  We define \term{\( \beta \)-reduction} \( {\bred} \) as the relation generated by the rules of \fullref{def:lambda_reduction/single} extended with \ref{inf:def:beta_eta_reduction/beta}. We similarly define \term{\( \eta \)-reduction} \( {\ered} \) based on \ref{inf:def:beta_eta_reduction/eta}. Combining both, we obtain \term{\( \beta\eta \)-reduction} \( {\bered} \).
\end{definition}
\begin{comments}
  \item Of course, we also consider equivalences and multi-step reductions based on the above single-step reductions.
\end{comments}

\begin{example}\label{ex:def:beta_eta_reduction}
  We list examples of \hyperref[def:beta_eta_reduction]{\( \beta \) and \( \eta \)-reduction}:
  \begin{thmenum}
    \thmitem{ex:def:beta_eta_reduction/i} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \).

    For every \( \synlambda \)-term \( A \) we have \( IA \bred A \). This explains the naming --- \( I \) stands for \enquote{identity}.

    \thmitem{ex:def:beta_eta_reduction/k} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \syny \synx \).

    For every pair of terms \( A \) and \( B \), we have
    \begin{equation*}
      KAB
      =
      (\qabs {\hi{\synx}} \qabs \syny \hi{\synx}) \hi{A} B
      \bred
      (\qabs {\hi{v}} A) \hi{B}
      \bred
      A.
    \end{equation*}

    In accordance with \fullref{thm:lambda_substitution_single_rule}, \( v \) is a variable that is not free in \( A \). If \( A \) is a combinator, then \( v = \syny \).

    \thmitem{ex:def:beta_eta_reduction/s} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/s} = \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz) \).

    For every triple of \( \synlambda \)-terms \( A \), \( B \) and \( C \), we have
    \begin{balign*}
      SABC
      &=
      \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \qabs \synz \hi{\synx} \synz (\syny \synz) } \hi{A}BC
      \bred \\ &\bred
      \parens[\Big]{ \qabs {\hi{u}} \qabs v A v (\hi{u} v) } \hi{B}C
      \bred \\ &\bred
      \parens[\Big]{ \qabs {\hi{w}} A \hi{w} (B \hi{w}) } \hi{C}
      \bred \\ &\bred
      A C (B C).
    \end{balign*}

    Again, the variables \( u \), \( v \) and \( w \) are chosen in accordance with \fullref{thm:lambda_substitution_single_rule}.

    \thmitem{ex:def:beta_eta_reduction/skk} \Fullref{ex:def:beta_eta_reduction/k} and \fullref{ex:def:beta_eta_reduction/s} imply that
    \begin{equation*}
      SKK \bred* \qabs \synz \underbrace{K \synz (K \synz)}_\synz \bred* \qabs \synz \synz \aequiv I.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/beta_and_eta} There may be multiple ways to derive the same term, especially with both \( \beta \)-reduction and \( \eta \)-reduction available.

    For example, we have
    \begin{equation*}
      (\qabs {\hi{\synx}} \qabs \syny \hi{\synx} \syny) \hi{A} B \bred (\qabs v A v) B,
    \end{equation*}
    where \( v \) is not free in \( A \).

    The latter term is a \( \beta \)-redex, hence we can use \( \beta \)-reduction again:
    \begin{equation*}
      (\qabs {\hi{v}} A \hi{v}) \hi{B} \bred AB.
    \end{equation*}

    But the first component is an \( \eta \)-redex, and we can also use \( \eta \)-reduction to achieve the same result:
    \begin{equation*}
      (\qabs v A v) B \ered AB.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/omega} Consider the combinator \( \ref{eq:ex:def:lambda_term/combinator/omega_n} = (\qabs \synx \synx^n) \).

    We have
    \begin{equation*}
      \omega_n \omega_n
      =
      (\qabs {\hi{\synx}} \hi{\synx^n}) \hi{\omega}
      \bred
      \omega_n^n.
    \end{equation*}

    In particular, for \( \Omega = \omega \omega = \omega_2 \omega_2 \),
    \begin{equation*}
      \Omega \bred \Omega \bred \Omega \bred \Omega \bred \cdots
    \end{equation*}
    and, for \( \omega_3 \omega_3 \),
    \begin{equation*}
      (\omega_3)^2 \bred (\omega_3)^3 \bred (\omega_3)^4 \bred \cdots.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/pair} We can encode the \hyperref[def:ordered_tuple]{ordered pairs} via the combinators
    \begin{align}
      C_{\T{ons}} &\coloneqq \qabs \synx \qabs \syny \qabs \synp \synp \synx \syny \label{ex:def:beta_eta_reduction/pair/cons}\tag{\ensuremath{ C_{\T{ons}} }}, \\
      C_{\T{ar}}  &\coloneqq \qabs \synx \qabs \syny \synx \label{ex:def:beta_eta_reduction/pair/car}\tag{\ensuremath{ C_{\T{ar}} }}, \\
      C_{\T{dr}}  &\coloneqq \qabs \synx \qabs \syny \syny \label{ex:def:beta_eta_reduction/pair/cdr}\tag{\ensuremath{ C_{\T{dr}} }}.
    \end{align}

    The names of the combinators are based on pairs in the programming language Scheme. According to \incite[115]{AbelsonSussman2012eSICP}:
    \begin{itemize}
      \item \enquote{cons} stands for \enquote{construct}.
      \item \enquote{car} is an abbreviation for \enquote{\hi{c}ontents of \hi{a}ddress part of \hi{r}egister}.
      \item \enquote{cdr} stands for \enquote{\hi{c}ontents of \hi{d}escriptor part of \hi{r}egister}.
    \end{itemize}

    In Scheme, the following encodes a pair consisting of \( A \) and \( B \):
    \begin{verbatim}
      (cons A B)
    \end{verbatim}

    We can retrieve the first component as
    \begin{verbatim}
      (car (cons A B))
    \end{verbatim}
    and similarly for the second component. Thus, we expect the combinators \( C_{\T{ar}} \) and \( C_{\T{dr}} \) to act as projections.

    The corresponding implementations via \( \synlambda \)-terms are based on \cite[exerc. 2.5]{AbelsonSussman2012eSICP} and \cite[def. 6.2.4]{Barendregt1984LambdaCalculus}.

    The projection combinators act as expected on terms \( A \) and \( B \):
    \begin{equation*}
      C_{\T{ar}} A B \bred* A
    \end{equation*}
    and
    \begin{equation*}
      C_{\T{dr}} A B \bred* B.
    \end{equation*}

    The combinator \( C_{\T{ons}} \) allows combining \( A \) and \( B \) into a single term to which we can apply \( C_{\T{ar}} \) and \( C_{\T{dr}} \). Thus, \( C_{\T{ar}} \) must be \enquote{applied} via \hyperref[rem:postfix_notation]{postfix notation}, unlike in Scheme, but the overall idea is similar:
    \begin{equation*}
      (C_{\T{cons}} A B) C_{\T{ar}}
      \bred*
      (\qabs v v A B) C_{\T{ar}}
      \bred*
      C_{\T{ar}} A B
      \bred*
      A.
    \end{equation*}

    \thmitem{ex:def:beta_eta_reduction/boolean}\mcite[\S 6.2.2]{Barendregt1984LambdaCalculus} We can use \ref{ex:def:beta_eta_reduction/pair/car} and \ref{ex:def:beta_eta_reduction/pair/cdr} as \hyperref[con:boolean_value]{Boolean values}.

    Indeed, denote \( C_{\T{ar}} \) by \( T \) and \( C_{\T{dr}} \) by \( F \). If the term \( V \) can be either \( T \) or \( F \), \( \beta \)-reduction allows us to \enquote{select} either \( A \) or \( B \) based on the value of \( V \):
    \begin{equation}\label{ex:def:beta_eta_reduction/boolean/if}
      VAB \bred* \begin{cases}
        A, &V = T, \\
        B, &V = F.
      \end{cases}
    \end{equation}

    This allows us to implement \hyperref[def:boolean_function]{Boolean functions}. For example, if we denote \( FT \) by \( N \), we obtain negation:
    \begin{equation*}
      VN = \begin{cases}
        TFT \bred* F, &V = T, \\
        FFT \bred* T, &V = F.
      \end{cases}
    \end{equation*}

    As in \fullref{ex:def:beta_eta_reduction/pair}, \( N \) must be used via postfix notation, unlike the Scheme equivalent
    \begin{verbatim}
      (not V)
    \end{verbatim}

    We will define truth values differently in \fullref{sec:simple_type_theory}, for which reason we avoid using these terms as boolean more generally.

    \thmitem{ex:def:beta_eta_reduction/numerals}\mcite[\S 6.4.4]{Barendregt1984LambdaCalculus} For every natural number \( n \), we can define the \term{Church numeral}
    \begin{align}
      \qabs \synx \qabs \syny \underbrace{\synx^n \syny}_{\mathclap{(\synx \cdots (\synx (\synx \syny)) \cdots)}} \label{eq:ex:def:beta_eta_reduction/numerals} \tag{\ensuremath{ c_n }}
    \end{align}

    Note that in this definition \( \synx^n \syny \) associates to the right, technically breaking our convention from \fullref{rem:lambda_term_parentheses/left_associative}.

    For the base case we have
    \begin{equation*}
      c_0 = \ref{ex:def:beta_eta_reduction/pair/cdr} = \qabs \synx \qabs \syny \syny.
    \end{equation*}

    Consider the \term{successor} term
    \begin{align}
      \qabs \synf \qabs \synx \qabs \syny \synx (\synf \synx \syny). \label{eq:ex:def:beta_eta_reduction/numerals/succ} \tag{\ensuremath{ S^+ }}
    \end{align}

    Then
    \begin{balign*}
      S^+ c_n
      &=
      \parens[\Big]{ \qabs {\hi{\synf}} \qabs \synx \qabs \syny \synx (\hi{\synf} \synx \syny) } \hi{c_n}
      \bred \\ &\bred
      \qabs \synx \qabs \syny \synx \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \hi{\synx}^n \synf } \hi{\synx} \syny }
      \bred \\ &\bred
      \qabs \synx \qabs \syny \synx \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\syny}} \synx^n \hi{\syny} } \hi{\syny} }
      \bred \\ &\bred
      \underbrace{\qabs \synx \qabs \syny \synx (\synx^n \syny)}_{c_{n+1}}.
    \end{balign*}
  \end{thmenum}
\end{example}

\paragraph{Reduction strategies}

\begin{definition}\label{def:reduction_strategy}\mcite[\S 13.1]{Barendregt1984LambdaCalculus}
  We can regard a \hyperref[def:lambda_reduction]{reduction relation} \( {\pred} \) as a \hyperref[def:set_valued_map]{set-valued function} on \( \synlambda \)-terms. A \hyperref[def:function/selection]{selection} of \( {\pred} \) is then a \hyperref[def:set_valued_map/partial]{single-valued partial function}.

  We call such a selection a \term{single-step reduction strategy}. A \term{multi-step reduction strategy} is instead a selection of \( {\pred*} \).
\end{definition}

\begin{definition}\label{def:normal_order_reduction}\mcite[142]{Mimram2020Types}
  We define the \term{normal order} \hyperref[def:reduction_strategy]{reduction strategy} for \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} as the one selecting \hyperref[def:subterm_occurrence_ordering/horizontal]{leftmost} among the \hyperref[def:subterm_occurrence_ordering/vertical]{outermost} \( \beta \)-redexes.
\end{definition}

\begin{definition}\label{def:applicative_order_reduction}\mcite[141]{Mimram2020Types}
  We define the \term{applicative order} \hyperref[def:reduction_strategy]{reduction strategy} for \hyperref[def:beta_eta_reduction]{\( \beta \)-reduction} as the one selecting the \hyperref[def:subterm_occurrence_ordering/horizontal]{leftmost} among the \hyperref[def:subterm_occurrence_ordering/vertical]{innermost} \( \beta \)-redexes.
\end{definition}

\begin{example}\label{ex:reduction_strategies}
  One notable difference between \hyperref[def:normal_order_reduction]{normal order reduction} and \hyperref[def:applicative_order_reduction]{applicative order reduction} can be seen when evaluating the term \( \ref{ex:def:beta_eta_reduction/pair/cdr} \ref{eq:ex:def:lambda_term/combinator/big_omega} \ref{eq:ex:def:lambda_term/combinator/i} \) discussed in \fullref{ex:def:subterm_occurrence_ordering/cdr_omega_i}.

  There is a unique outermost \( \beta \)-redex --- \( C_{\T{dr}} \Omega \) --- and a unique innermost redex --- \( \Omega \) itself.

  The normal order strategy suggests reducing as follows:
  \begin{balign*}
    (C_{\T{dr}} \Omega) I
    &=
    \parens[\Big]{ \parens[\Big]{ \qabs {\hi{\synx}} \qabs \syny \syny } \hi{\Omega} } I
    \bred \\ &\bred
    (\qabs {\hi{\syny}} \hi{\syny}) \hi{I}
    \bred \\ &\bred
    I.
  \end{balign*}

  On the other hand, the applicative order strategy instead suggests reducing \( \Omega \) first. As per our discussion in \fullref{ex:def:beta_eta_reduction/omega}, this leads to the chain
  \begin{equation*}
    (C_{\T{dr}} \Omega) I \bred (C_{\T{dr}} \Omega) I \bred (C_{\T{dr}} \Omega) I \bred \cdots.
  \end{equation*}
\end{example}

\paragraph{Reductions and free variables}

\begin{proposition}\label{thm:eta_reduction_free_variables}
  If \( M \ered N \), then \( \op*{Free}(M) = \op*{Free}(N) \).
\end{proposition}
\begin{proof}
  Follows via \fullref{thm:induction_on_recursively_defined_relations} by noting that \( x \) is not free in \( M \) if and only if it is not free in \( \qabs x M x \).
\end{proof}

\begin{lemma}\label{thm:beta_contractum_free_variables}
  Let \( M = (\qabs x N) K \). Then
  \begin{equation}\label{eq:thm:beta_contractum_free_variables/equality}
    \op*{Free}(N[x \mapsto K]) = \begin{cases}
      \op*{Free}(M), &x \in \op*{Free}(N), \\
      \op*{Free}(N), &\T{otherwise.} \\
    \end{cases}
  \end{equation}

  Both cases can be summarized by the inequality
  \begin{equation}\label{eq:thm:beta_contractum_free_variables/inequality}
    \op*{Free}(N[x \mapsto K]) \subseteq \op*{Free}(M).
  \end{equation}
\end{lemma}
\begin{proof}
  If \( x \) is not free in \( N \), \fullref{thm:lambda_substitution_noop} implies that
  \begin{equation*}
    \op*{Free}(N[x \mapsto K]) = \op*{Free}(N).
  \end{equation*}

  Otherwise, \fullref{thm:lambda_substitution_free_variables_single} implies that the set
  \begin{equation*}
    \op*{Free}(M)
    =
    \op*{Free}((\qabs x N) K)
  \end{equation*}
  equals
  \begin{equation*}
    \op*{Free}(\qabs x N) \cup \op*{Free}(K)
    =
    \parens[\Big]{ \op*{Free}(N) \setminus \set{ x } } \cup \op*{Free}(K),
  \end{equation*}
  which is precisely \( \op*{Free}(M) \).
\end{proof}

\begin{proposition}\label{thm:lambda_reduction_free_variables}
  Let \enquote{\( {\Anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  Then, if \( M \pred N \), we have \( \op*{Free}(N) \subseteq \op*{Free}(M) \).
\end{proposition}
\begin{proof}
  Follows from \fullref{thm:beta_contractum_free_variables} and \fullref{thm:lambda_reduction_free_variables}.
\end{proof}

\begin{example}\label{ex:thm:lambda_reduction_free_variables}
  The following table illustrates the different possible cases from \fullref{thm:lambda_reduction_free_variables}:
  \begin{equation*}
    \begin{array}{*{4}{l}}
      \toprule
      \T{\( \beta \)-redex}     & \T{\( \beta \)-redex free variables} & \T{\( \beta \)-contraction} & \T{\( \beta \)-contraction free variables} \\
      \midrule
      (\qabs \synx \synx) \synz & \synz                                & \synz                       & \synz                                      \\
      (\qabs \synx \syny) \synz & \syny \T{and} \synz                  & \syny                       & \syny                                      \\
      \bottomrule
    \end{array}
  \end{equation*}
\end{example}

\paragraph{Fixed point combinators}

\begin{definition}\label{def:fixed_point_combinator}\mimprovised
  We say that the combinator \( M \) is a \term{fixed point combinator} if, for every \( \synlambda \)-term \( F \), we have \( MF \beequiv F(MF) \).
\end{definition}
\begin{comments}
  \item The definition is based on \cite[\S 6.1.2]{Barendregt1984LambdaCalculus}, but is adapted to handle equivalences explicitly.
\end{comments}

\begin{example}\label{ex:def:fixed_point_combinator}
  We list examples of how \hyperref[def:fixed_point_combinator]{fixed point combinators} can be used:
  \begin{thmenum}
    \thmitem{ex:def:fixed_point_combinator/succ} Let \( M \) be a fixed point combinator.

    For the successor combinator \( S^+ \) from \eqref{eq:ex:def:beta_eta_reduction/succ}, the fixed point \( MS^+ \) corresponds to a generalized numeral that is its own successor.
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:y_is_a_fixed_point_combinator}
  The term \( \ref{eq:ex:def:lambda_term/combinator/y} = \qabs \synx (\qabs \syny \synx \syny \syny) (\qabs \syny \synx \syny \syny) \) is a \hyperref[def:fixed_point_combinator]{fixed point combinator}.
\end{proposition}
\begin{proof}
  Let \( F \) be a \( \synlambda \)-term. We have
  \begin{equation*}
    YF
    =
    \parens[\Big]{ \qabs {\hi{\synx}} (\qabs \syny \hi{\synx} \syny \syny) (\qabs \syny \hi{\synx} \syny \syny) } \hi{F}
    \bred
    (\qabs v F v v) (\qabs v F v v),
  \end{equation*}
  where \( v = \syny \) if \( \syny \) is not free in \( F \) and is a fresh variable otherwise.

  Denote this reduct by \( P \). Then
  \begin{equation*}
    P =
    (\qabs {\hi{v}} F \hi{v} \hi{v}) \hi{(\qabs v F v v)}
    \bred
    F (\qabs v F v v) (\qabs v F v v)
    =
    FP.
  \end{equation*}

  Since \( YF \bequiv P \) and \( P \bequiv FP \), we conclude that \( YF \bequiv F(YF) \).
\end{proof}

\paragraph{Parallel reductions}

\begin{definition}\label{def:parallel_reduction}
  Between single-step and multi-step reductions, there are \term{parallel reductions}, which allow reducing different subterms simultaneously.

  \begin{thmenum}
    \thmitem{def:parallel_reduction/base} We reuse \ref{inf:def:lambda_reduction/abs} and \ref{inf:def:lambda_reduction/alpha}:
    \begin{paracol}{2}
      \begin{leftcolumn}
        \begin{equation*}\taglabel[\ensuremath{ \logic{ParAbs}_{\Anon} }]{inf:def:parallel_reduction/abs}
          \begin{prooftree}
            \hypo{ A \pred B }
            \infer1[\ref{inf:def:lambda_reduction/abs}]{ \qabs x A \ppred \qabs x B }
          \end{prooftree}
        \end{equation*}
      \end{leftcolumn}

      \begin{rightcolumn}
        \begin{equation*}\taglabel[\ensuremath{ \logic{ParAlpha}_{\Anon} }]{inf:def:parallel_reduction/alpha}
          \begin{prooftree}
            \hypo{ A \aequiv B }
            \hypo{ B \ppred C }
            \hypo{ C \aequiv D }
            \infer3[\ref{inf:def:parallel_reduction/alpha}]{ A \ppred D }.
          \end{prooftree}
        \end{equation*}
      \end{rightcolumn}
    \end{paracol}

    We combine \ref{inf:def:lambda_reduction/app_left} and \ref{inf:def:lambda_reduction/app_right} into
    \begin{equation*}\taglabel[\ensuremath{ \logic{ParApp}_{\Anon} }]{inf:def:parallel_reduction/app}
      \begin{prooftree}
        \hypo{ A \ppred C }
        \hypo{ B \ppred D }
        \infer2[\ref{inf:def:parallel_reduction/app}]{ AB \ppred CD }
      \end{prooftree}
    \end{equation*}

    \thmitem{def:parallel_reduction/refl} \ref{inf:def:parallel_reduction/app} introduces a subtlety.

    If \( A \pred C \) and \( B = D \), the single-step rule \ref{inf:def:lambda_reduction/app_left} implies that \( AB \pred CD \). The corresponding parallel rule \ref{inf:def:parallel_reduction/alpha}, however, only implies that \( AB \ppred CD \) if \( A \ppred C \) and \( B \ppred D \). In order to use \ref{inf:def:parallel_reduction/alpha}, we must ensure that \( B \ppred D \) if \( B = D \).

    Because we have \ref{inf:def:parallel_reduction/alpha}, it is sufficient to ensure that parallel reductions are \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive}. To achieve this, we introduce the following rule based on \ref{inf:def:lambda_term_alpha_equivalence/atom}:
    \begin{equation*}\taglabel[\ensuremath{ \logic{ParAtom}_{\Anon} }]{inf:def:parallel_reduction/atom}
      \begin{prooftree}
        \hypo{ M \in \op*{Atom} }
        \infer1[\ref{inf:def:parallel_reduction/atom}]{ M \ppred M }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}

  \thmitem{def:parallel_reduction/beta_eta} Additionally, we replace \ref{inf:def:beta_eta_reduction/beta} and \ref{inf:def:beta_eta_reduction/eta} with
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{ParRed}_\beta }]{inf:def:parallel_reduction/beta}
        \begin{prooftree}
          \hypo{ A \pbred C }
          \hypo{ B \pbred D }
          \infer2[\ref{inf:def:parallel_reduction/beta}]{ (\qabs x A) B \pbred C[x \mapsto D] }.
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{ParRed}_\eta }]{inf:def:parallel_reduction/eta}
        \begin{prooftree}
          \hypo{ x \not\in \op*{Free}(A) }
          \hypo{ A \pered B }
          \infer2[\ref{inf:def:parallel_reduction/eta}]{ \qabs x A x \pered B }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item This definition is based on \cite[\S 3.2.3]{Barendregt1984LambdaCalculus}, where only parallel \( \beta \)-reduction is considered.
  \item Of course, we also consider equivalences and multi-step reductions based on the above single-step reductions.
\end{comments}

\begin{example}\label{ex:def:parallel_reduction}
  We list examples of \hyperref[def:parallel_reduction]{parallel \( \beta \) and \( \eta \)-reduction}:
  \begin{thmenum}
    \thmitem{ex:def:parallel_reduction/two}\mcite[\S 3.4.2]{Mimram2020Types} Consider the term
    \begin{equation*}
      M = (\qabs \synx \qabs \syny I \synx \syny)(I I),
    \end{equation*}
    where \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \).

    We saw in \fullref{ex:def:beta_eta_reduction/i} that \( I A \bred A \) for any term \( A \), thus \( I I \bred I \) and \( I \synx \bred \synx \) are two possible \( \beta \)-reductions in \( M \).

    With single-step \( \beta \)-reduction, \ref{inf:def:lambda_reduction/app_left} and \ref{inf:def:lambda_reduction/app_right} allow us to only perform a reduction in the first or second component of \( M \), thus the two reductions discussed above have to be performed sequentially.

    With parallel \( \beta \)-reduction, however, \ref{inf:def:parallel_reduction/app} allows us to perform both single-step reductions in parallel, thus
    \begin{equation*}
      M \pbred (\qabs \synx \qabs \syny \synx \syny) I.
    \end{equation*}

    Furthermore, the entire term \( M \) is a \( \beta \)-redex, and \ref{inf:def:parallel_reduction/beta} allows us to perform all three single-step reductions in one parallelized step:
    \begin{equation*}
      M \pbred \qabs \syny I \syny.
    \end{equation*}

    The obtained term is again a \( \beta \)-redex, however no rule for parallel reduction allows us to reduce it during the first step. This is desired because it does not correspond to a \( \beta \)-redex in \( M \). So, a reduction of \( \qabs \syny I \syny \) to \( \qabs \syny \syny \) must be performed in a second step.
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:def:parallel_reduction}
  Let \enquote{\( {\Anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}. Then the \hyperref[def:parallel_reduction]{parallel reduction relation} \( {\ppred} \) has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:parallel_reduction/alpha_reflexive} It is \hyperref[def:alpha_reflexive]{\( \alpha \)-reflexive}.
    \thmitem{thm:def:parallel_reduction/extends_single_step} It extends single-step reduction: if \( M \pred N \), then \( M \ppred N \).
    \thmitem{thm:def:parallel_reduction/extends_to_multi_step} It extends to multi-step reduction: if \( M \ppred N \), then \( M \pred* N \).
    \thmitem{thm:def:parallel_reduction/multi} The multi-step extensions of \( {\pred} \) and \( {\ppred} \) coincide.
    \thmitem{thm:def:parallel_reduction/free} A generalization of \fullref{thm:lambda_reduction_free_variables} holds: if \( M \ppred N \), then \( \op*{Free}(N) \subseteq \op*{Free}(M) \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:parallel_reduction/alpha_reflexive} We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \aequiv N \) to show that \( M \ppred N \):
  \begin{itemize}
    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/atom}, then \( M \) and \( N \) are equal. The rule \ref{inf:def:parallel_reduction/atom} specifically crafted for this purpose implies that \( M \ppred M \).

    \item If \( M \aequiv N \) due to \ref{inf:def:lambda_term_alpha_equivalence/app}, then \( M = AB \) and \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \). The inductive hypothesis implies that \( A \ppred C \) and \( B \ppred D \). We then use \ref{inf:def:parallel_reduction/app} to conclude that \( M = AB \ppred CD = N \).

    \item If \( M \aequiv N \) due to \ref{inf:thm:alpha_equivalence_simplified/lift}, then \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \aequiv B \). The inductive hypothesis implies that \( A \ppred B \), and \ref{inf:def:parallel_reduction/abs} implies that \( M \ppred N \).

    \item Finally, if \( M \aequiv N \) due to \ref{inf:thm:alpha_equivalence_simplified/ren}, then \( M = \qabs a A \), \( N = \qabs b B \), \( a \) is not free in \( B \) and \( A \aequiv B[b \mapsto a] \).

    The inductive hypothesis implies that \( A \ppred B[b \mapsto a] \) and \ref{inf:def:parallel_reduction/abs} implies that
    \begin{equation*}
      \qabs a A \ppred \qabs a B[b \mapsto a].
    \end{equation*}

    Furthermore, \fullref{thm:alpha_conversion} implies that \( \qabs b B \aequiv \qabs a B[b \mapsto a] \). We can thus use \ref{inf:def:lambda_reduction/alpha} to conclude that
    \begin{equation*}
      M = \qabs a A \ppred \qabs b B = N.
    \end{equation*}
  \end{itemize}

  \SubProofOf{thm:def:parallel_reduction/extends_single_step} This is straightforward once we have mitigated the subtlety discussed in \fullref{def:parallel_reduction/refl}.

  \SubProofOf{thm:def:parallel_reduction/extends_to_multi_step} We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \ppred N \) to show that \( M \pred* N \):
  \begin{itemize}
    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/atom}, then \( M \) and \( N \) are equal, hence \( M \pred* N \) due to the latter being reflexive.

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/app}, then \( M = AB \) and \( N = CD \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    Then \( A \pred* C \), hence there exists some reduction sequence
    \begin{equation*}
      A = C_0 \pred C_1 \pred \cdots \pred C_n = C.
    \end{equation*}

    We can show that \( AB \pred C_i B \) by induction on \( i \):
    \begin{itemize}
      \item If \( i = 0 \), then \( AB = C_i B \), and \( AB \pred C_i B \) follows from the reflexivity shown in \fullref{thm:def:parallel_reduction/alpha_reflexive}.

      \item If \( AB \pred* C_i B \), then \ref{inf:def:lambda_reduction/app_left} implies that \( AB \pred* C_{i+1} B \).
    \end{itemize}

    Therefore, \( AB \pred* CB \). Similarly, we can use induction on the numbers of steps in \( B \pred* D \) to conclude via \ref{inf:def:lambda_reduction/app_right} that
    \begin{equation*}
      M = AB \pred* CB \pred* CD = N.
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/abs}, then \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \ppred B \) and the inductive hypothesis holds for the latter.

    Using the corresponding single-step rule \ref{inf:def:lambda_reduction/abs}, by induction on the number of steps in \( A \pred* B \) we can show that
    \begin{equation*}
      M = \qabs x A \pred* \qabs x B = N.
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/alpha}, we proceed analogously.

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    We can show by induction on the number of steps in \( A \pred* C \) that
    \begin{equation*}
      (\qabs x A)B \pred* (\qabs x C)B
    \end{equation*}
    and similarly that
    \begin{equation*}
      (\qabs x C)B \pred* (\qabs x C)D.
    \end{equation*}

    Then
    \begin{equation*}
      M = (\qabs x A) B \pred* (\qabs x C)D
    \end{equation*}
    and we can apply \ref{inf:def:beta_eta_reduction/beta} to conclude that
    \begin{equation*}
      M \pred* (\qabs x C)D \pred C[x \mapsto D] = N.
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/eta}, then \( M = \qabs x A x \), where \( x \) is not free in \( A \), \( A \ppred N \), and the inductive hypothesis holds for the latter.

    Via induction on the number of steps in \( A \pred* N \) we conclude that
    \begin{equation*}
      M = \qabs x A x \pred* \qabs x N x.
    \end{equation*}

    By \fullref{thm:lambda_reduction_free_variables}, every free variable in \( N \) is also free in \( A \), thus \( x \) cannot be free in \( N \). Then we can apply \ref{inf:def:beta_eta_reduction/eta} to obtain \( M \pred* N \).
  \end{itemize}

  \SubProofOf{thm:def:parallel_reduction/multi} Follows from \fullref{thm:def:parallel_reduction/extends_to_multi_step}.

  \SubProofOf{thm:def:parallel_reduction/free} Follows from \fullref{thm:lambda_reduction_free_variables} and \fullref{thm:def:parallel_reduction/extends_single_step}.
\end{proof}

\begin{proposition}\label{thm:substitution_on_parallel_reduction}
  Let \enquote{\( {\Anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  Fix \( \synlambda \)-terms \( M \) and \( N \) such that \( M \ppred N \). Fix also substitutions \( \sigma \) and \( \rho \) such that, for every variable \( u \), we have \( \sigma(u) \ppred \rho(u) \).

  Then \( M[\sigma] \ppred N[\rho] \).
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \ppred N \) simultaneously on all compatible substitutions to show that \( M[\sigma] \pred N[\rho] \).
  \begin{itemize}
    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/atom}, then \( M \) and \( N \) are equal atomic terms, thus
    \begin{equation*}
      M[\sigma] = \sigma(M) \pred \rho(N) = N[\sigma].
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/app}, then \( M = AB \) and \( N = CD \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    Then, by the inductive hypothesis,
    \begin{equation*}
      M[\sigma]
      =
      A[\sigma] \thinspace B[\sigma]
      \ppred
      A[\rho] \thinspace D[\rho]
      =
      N[\rho].
    \end{equation*}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/alpha}, we use \fullref{thm:substitution_on_alpha_equivalent_terms}.

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/abs}, we have \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \ppred B \) and the inductive hypothesis holds for the latter. \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{align*}
      M[\sigma] &= \qabs u A[\sigma_{x \mapsto u}], &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
      N[\rho]   &= \qabs v B[\rho_{x \mapsto v}],   &&v \not\in \op*{Free}(N) \cup \op*{Free}(N[\rho]).
    \end{align*}

    We consider two cases:
    \begin{itemize}
      \item If \( u = v \), the inductive hypothesis implies that \( A[\sigma_{x \mapsto u}] \ppred B[\rho_{x \mapsto u}] \), hence we can directly apply \ref{inf:def:parallel_reduction/abs} to obtain \( M[\sigma] \ppred N[\rho] \).

      \item Otherwise, by \fullref{thm:def:parallel_reduction/free}, \( v \) is not free in \( M \), and \fullref{thm:alpha_conversion_modified} implies that
      \begin{equation*}
        M[\sigma]
        =
        \qabs u A[\sigma_{x \mapsto u}]
        \aequiv
        \qabs v A[\sigma_{x \mapsto v}]
      \end{equation*}

      We can apply the inductive hypothesis to the following modified substitutions:
      \begin{equation*}
        A[\sigma_{x \mapsto v}] \ppred B[\rho_{x \mapsto v}].
      \end{equation*}

      We can apply \ref{inf:def:parallel_reduction/abs} to obtain
      \begin{equation*}
        \qabs v A[\sigma_{x \mapsto v}] \ppred \qabs v B[\rho_{x \mapsto v}].
      \end{equation*}

      Finally, we can apply \ref{inf:def:parallel_reduction/alpha} to
      \begin{equation*}
        M[\sigma] \aequiv \qabs v A[\sigma_{x \mapsto v}]
      \end{equation*}
      and
      \begin{equation*}
        N[\sigma] = \qabs v B[\rho_{x \mapsto v}]
      \end{equation*}
      to obtain
      \begin{equation*}
        M[\sigma] \ppred N[\sigma].
      \end{equation*}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{equation*}
      M[\sigma] = \parens[\Big]{ \qabs u A[\sigma_{x \mapsto u}] } B[\sigma],
    \end{equation*}
    where \( u \not\in \op*{Free}(\qabs x A) \cup \op*{Free}_\sigma(\qabs x A) \).

    The inductive hypothesis implies that \( A[\sigma_{x \mapsto u}] \ppred C[\rho_{x \mapsto u}] \) and \( B[\sigma] \ppred D[\rho] \). Then \ref{inf:def:parallel_reduction/beta} implies that
    \begin{equation*}
      M[\sigma]
      =
      \parens[\Big]{ \qabs u A[\sigma_{x \mapsto u}] } B[\sigma]
      \ppred
      C[\rho_{x \mapsto u}][u \mapsto D[\rho]].
    \end{equation*}

    Furthermore,
    \begin{equation*}
      N[\rho]
      =
      C[x \mapsto D][\rho]
      \reloset {\eqref{eq:thm:substitution_composition_is_alpha_equivalent}} \aequiv
      C[\rho_{x \mapsto D[\rho]}]
      \reloset {\eqref{eq:thm:substitution_chain_contraction/contraction}} \aequiv
      C[\rho_{x \mapsto u}][u \mapsto D[\rho]].
    \end{equation*}

    Therefore, \ref{inf:def:lambda_reduction/alpha} allows us to conclude that \( M[\sigma] \ppred N[\rho] \).

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/eta}, then \( M = \qabs x Ax \), where \( x \) is not free in \( A \), \( A \ppred N \), and the inductive hypothesis holds for the latter.

    \Fullref{thm:lambda_substitution_single_rule} implies that
    \begin{equation*}
      M[\sigma] = \qabs u A[\sigma_{x \mapsto u}] \thinspace u
    \end{equation*}
    where \( u \) is not free in \( A[\sigma] \).

    Furthermore, \fullref{thm:lambda_substitution_restriction} implies that \( A[\sigma_{x \mapsto u}] = A[\sigma] \), thus
    \begin{equation*}
      M[\sigma] = \qabs u A[\sigma] \thinspace u.
    \end{equation*}

    The inductive hypothesis implies that \( A[\sigma] \ppred N[\rho] \). Therefore, \ref{inf:def:parallel_reduction/eta} allows us to conclude that \( M[\sigma] \ppred N[\rho] \).
  \end{itemize}
\end{proof}

\begin{lemma}\label{thm:parallel_reduction_deconstruction}
  Let \enquote{\( {\Anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  If \( M \ppred N \), depending on the structure of \( M \), we have the following possibilities:
  \begin{thmenum}
    \thmitem{thm:parallel_reduction_deconstruction/atom} If \( M \) is atomic, then \( M = N \).

    \thmitem{thm:parallel_reduction_deconstruction/app} If \( M = AB \), we have two possibilities:
    \begin{thmenum}
      \thmitem{thm:parallel_reduction_deconstruction/app/direct} \( N = CD \), where \( A \ppred C \) and \( B \ppred D \).

      \thmitem{thm:parallel_reduction_deconstruction/app/beta} In case \( {\Anon} \) is \enquote{\( \beta \)} or \enquote{\( \beta\eta \)}, it is possible that \( A = \qabs x E \) and \( N \aequiv F[x \mapsto G] \), where \( B \ppred G \) and \( E \ppred F \).
    \end{thmenum}

    \thmitem{thm:parallel_reduction_deconstruction/abs} If \( M = \qabs x A \), we again have two possibilities:
    \begin{thmenum}
      \thmitem{thm:parallel_reduction_deconstruction/abs/lift} \( N \aequiv \qabs x B \), where \( A \ppred B \).

      \thmitem{thm:parallel_reduction_deconstruction/abs/eta} In case \( {\Anon} \) is \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}, it is possible that \( A \aequiv Nx \) and \( x \not\in \op*{Free}(N) \).
    \end{thmenum}
  \end{thmenum}
\end{lemma}
\begin{comments}
  \item The main purpose of this lemma is to simplify handling \ref{inf:def:lambda_reduction/alpha} in the proof of \fullref{thm:church_rosser_theorem}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:parallel_reduction_deconstruction/atom} If \( M \) is atomic, the only rules applicable to \( M \ppred N \) are \ref{inf:def:parallel_reduction/atom} and \ref{inf:def:lambda_reduction/alpha}, and both imply that \( M = N \).

  \SubProofOf{thm:parallel_reduction_deconstruction/app} Let \( M = AB \). We will use \fullref{thm:induction_on_recursively_defined_relations} on \( AB \ppred N \):
  \begin{itemize}
    \item If \( AB \ppred N \) due to \ref{inf:def:parallel_reduction/app}, then \fullref{thm:parallel_reduction_deconstruction/app/direct} holds.

    \item If \( AB \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \fullref{thm:parallel_reduction_deconstruction/app/beta} holds.

    \item If \( AB \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( AB \aequiv A' B' \) and \( N \aequiv N' \), where \( A' B' \ppred N' \) and the inductive hypothesis holds for the latter.

    \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities:
    \begin{itemize}
      \item The possibility \fullref{thm:parallel_reduction_deconstruction/app/direct} for \( A' B' \ppred N' \) implies that \( N' \) is an application, say \( N' = C' D' \), such that \( A' \ppred C' \) and \( B' \ppred D' \). Furthermore, due to \ref{inf:def:lambda_term_alpha_equivalence/app}, we conclude that \( N \) is also an application, say \( N = CD \), where \( C \aequiv C' \) and \( D \aequiv D' \).

      Then \ref{inf:def:lambda_reduction/alpha} implies that \( A \ppred C \) and \( B \ppred D \), which is the desired result since it leads to \fullref{thm:parallel_reduction_deconstruction/app/direct}.

      \item The possibility \fullref{thm:parallel_reduction_deconstruction/app/beta} for \( A' B' \ppred N' \) implies that \( A' = \qabs y E' \) and \( N' \aequiv F'[y \mapsto G'] \), where \( B' \ppred G' \) and \( E' \ppred F' \).

      \begin{itemize}
        \item If \( A \aequiv A' \) due to \ref{inf:thm:alpha_equivalence_simplified/lift}, then \( A = \qabs y E \), where \( E \aequiv E' \). Via \ref{inf:def:lambda_reduction/alpha} we conclude that \( E \ppred F' \).

        Then \fullref{thm:parallel_reduction_deconstruction/app/beta} holds with \( x \coloneqq y \), \( G \coloneqq G' \) and \( F \coloneqq F' \).

        \item If \( A \aequiv A' \) due to \ref{inf:thm:alpha_equivalence_simplified/ren}, then \( A = \qabs x E \), where \( x \) is not free in \( E' \), and \( E \aequiv E'[y \mapsto x] \).

        Let \( F \coloneqq F'[y \mapsto x] \). Since \( E' \ppred F' \), we have \( E'[y \mapsto x] \ppred F \) due to \fullref{thm:substitution_on_parallel_reduction} and \( E \ppred F \) due to \ref{inf:def:lambda_reduction/alpha}.

        By \fullref{thm:def:parallel_reduction/free}, \( x \) is not free in \( F' \) since otherwise it would be free in \( E' \). Let \( G \coloneqq G' \). Then
        \begin{equation*}
          N
          \aequiv
          N'
          \aequiv
          F'[y \mapsto G']
          \reloset {\eqref{eq:thm:substitution_chain_contraction/contraction}} \aequiv
          F'[y \mapsto x][x \mapsto G']
          =
          F[x \mapsto G],
        \end{equation*}
        thus \fullref{thm:parallel_reduction_deconstruction/app/beta} holds.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \SubProofOf{thm:parallel_reduction_deconstruction/abs} Let \( M = \qabs x A \). We will use \fullref{thm:induction_on_recursively_defined_relations} on \( (\qabs x A) \ppred N \):
  \begin{itemize}
    \item If \( (\qabs x A) \ppred N \) due to \ref{inf:def:lambda_reduction/abs}, then \fullref{thm:parallel_reduction_deconstruction/abs/lift} holds.

    \item If \( (\qabs x A) \ppred N \) due to \ref{inf:def:beta_eta_reduction/eta}, then \fullref{thm:parallel_reduction_deconstruction/abs/eta} holds.

    \item If \( (\qabs x A) \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( \qabs x A = M \aequiv M' \) and \( N \aequiv N' \), where \( M' \ppred N' \) and the inductive hypothesis holds for the latter.

    Furthermore, \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( M' = \qabs y A' \), where \( A[x \mapsto n] \aequiv A'[y \mapsto n] \) for every \( n \) not free in \( M \). In particular, \( A \aequiv A'[y \mapsto x] \).

    \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( (\qabs y A') \ppred N' \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift}, we have \( N' \aequiv \qabs y B' \), where \( A' \ppred B' \).

      Let \( B \coloneqq B'[y \mapsto x] \). Then \fullref{thm:substitution_on_parallel_reduction} implies that \( A'[y \mapsto x] \ppred B \) and \ref{inf:def:lambda_reduction/alpha} implies that \( A \ppred B \).

      Furthermore, we have
      \begin{equation*}
        N
        \aequiv
        N'
        \aequiv
        \qabs y B'
        \reloset {\eqref{eq:thm:alpha_conversion}} \aequiv
        \qabs x B.
      \end{equation*}

      We conclude that \fullref{thm:parallel_reduction_deconstruction/abs/lift} holds.

      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, we have \( A' \aequiv N'y \) and \( y \not\in \op*{Free}(N') \). Then
      \begin{equation*}
        A
        \aequiv
        A'[y \mapsto x]
        \reloset {\ref{thm:substitution_on_alpha_equivalent_terms}} \aequiv
        N'[y \mapsto x] \thinspace x
        \reloset {\ref{thm:lambda_substitution_noop}} =
        N' x
        \aequiv
        N x.
      \end{equation*}

      It remains to show that \( x \) is not free in \( N \). Suppose that it is. \Fullref{thm:def:parallel_reduction/free} implies that it is free in \( M' \) also, and \Fullref{thm:def:lambda_term_alpha_equivalence/free} implies that it is free in \( M \), which is a contradiction.

      Therefore, \( x \) is not free in \( N \), and \fullref{thm:parallel_reduction_deconstruction/abs/eta} follows.
    \end{itemize}
  \end{itemize}
\end{proof}

\paragraph{Church-Rosser theorem}

\begin{definition}\label{def:reduction_confluence}\mcite[14]{TroelstraSchwichtenberg2000Proofs}
  We say that a \hyperref[def:lambda_reduction]{reduction relation} \( {\pred} \) is \term{confluent} if, whenever \( M \pred N \) and \( M \pred K \), there exists a \( \synlambda \)-term \( L \) such that \( N \pred L \) and \( K \pred L \). We call this term a  \term{confluence point} of \( N \) and \( K \).

  A \term{weak confluence point} is instead a \( \synlambda \)-term \( L \) such that \( M \pred* N \) and \( K \pred* L \). We define weak confluence analogously.

  \begin{figure}[!ht]
    \hfill
    \includegraphics[page=1]{output/def__reduction_confluence}
    \hfill
    \includegraphics[page=2]{output/def__reduction_confluence}
    \hfill
    \hfill
    \caption{\hyperref[def:reduction_confluence]{Confluence} and \hyperref[def:reduction_confluence]{weak confluence} as \hyperref[def:hasse_diagram]{Hasse diagrams}.}\label{fig:def:relation_confluence}
  \end{figure}
\end{definition}
\begin{comments}
  \item Every confluence point of \( N \) and \( K \) is an upper bound. The concept of confluence does not make sense, however, unless \( N \) and \( K \) already have a lower bound. If they do, then any upper bound is a confluence point.

  \item The terminology regarding confluence is inconsistent across the literature. A major distinction is that the authors we will list consider binary relations on plain sets, while we explicitly restrict ourselves to \( \synlambda \)-reductions in order to handle \( \alpha \)-equivalence explicitly.

  We mostly follow \incite[14]{TroelstraSchwichtenberg2000Proofs}, who use the term \enquote{(weak) Church-Rosser property} synonymously with \enquote{(weak) confluence}.
  \begin{itemize}
    \item \incite[ch. 3]{Barendregt1984LambdaCalculus} uses the term \enquote{(weak) diamond property} for what we call \enquote{confluence} applied to general binary relations, while defining a relation to have the (weak) \enquote{Church-Rosser property} if its reflexive and transitive closure has the (weak) diamond property.

    \item \incite[3.4.1]{Mimram2020Types} uses \enquote{confluence} for what Barendregt calls the \enquote{Church-Rosser property}.
  \end{itemize}

  The term \enquote{confluence point} is used in a more informal context by \incite[630]{AhoEtAl2006Compilers}.
\end{comments}

\begin{proposition}\label{thm:def:reduction_confluence}
  \hyperref[def:reduction_confluence]{Confluence} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:reduction_confluence/normal_implies_weak} If a \hyperref[def:lambda_reduction/single]{single-step reduction relation} is confluent, it is also weakly confluent.

    \thmitem{thm:def:reduction_confluence/multi_implies_weak} If a \hyperref[def:lambda_reduction/single]{multi-step reduction relation} is confluent, the corresponding single-step relation is weakly confluent.

    \thmitem{thm:def:reduction_confluence/weak_implies_multi} If a single-step reduction relation is weakly confluent, the corresponding multi-step relation is confluent.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:reduction_confluence/normal_implies_weak} Trivial.
  \SubProofOf{thm:def:reduction_confluence/multi_implies_weak} Trivial.
  \SubProofOf{thm:def:reduction_confluence/weak_implies_multi} Suppose \( {\pred} \) is weakly confluent and let \( M \pred* N \) and \( M \pred* K \).

  If \( M \pred* N \) because \( M \aequiv N \), then \ref{inf:def:lambda_reduction/alpha} implies that \( N \pred* K \) and thus \( K \) is a weak confluence point of \( N \) and \( K \). Analogously, if \( M \pred* K \) because \( M \aequiv K \), then \( N \) is a confluence point.

  Otherwise, there exist reduction sequences
  \begin{equation*}
    M = N_0 \pred N_1 \pred \cdots \pred N_n = N
  \end{equation*}
  and
  \begin{equation*}
    M = K_0 \pred K_1 \pred \cdots \pred K_k = K.
  \end{equation*}

  We will use induction on \( i = 0, \ldots, \min\set{ n, k } \) to show that there exists a weak confluence point \( L_i \) such that \( N_i \pred* L_i \) and \( K_i \pred* L_i \).

  \begin{itemize}
    \item In the base case \( i = 0 \), \( M = N_i = K_i \), thus we can take \( L_i \) to be \( M \) itself.

    \item Suppose that the inductive hypothesis holds for \( i < \min\set{ n, k } \) and let \( L_i \) be the weak confluence point of \( N_i \) and \( K_i \).

    We thus have \( N_i \pred N_{i+1} \) and \( N_i \pred* L_i \). Since \( {\pred} \) is weakly confluent, there exist weak confluence points \( A \) of \( N_{i+1} \) and \( L_i \) and \( B \) of \( K_{i+1} \) and \( L_i \).

    Finally, let \( L_{i+1} \) be a weak confluence point of \( A \) and \( B \). Then \( N_{i+1} \pred* A \pred* L_{i+1} \) and \( K_{i+1} \pred* B \pred* L_{i+1} \).

    \begin{figure}[!ht]
      \centering
      \includegraphics[page=1]{output/thm__def__reduction_confluence}
      \caption{An illustration of the inductive step in our proof of \fullref{thm:def:reduction_confluence/weak_implies_multi}}\label{fig:thm:confluence_of_reflexive_transitive_closure}
    \end{figure}
  \end{itemize}

  We now have the following possibilities:
  \begin{itemize}
    \item If \( n = k \), let \( L \coloneqq L_n = L_k \).
    \item If \( n > k \), for \( i > k \) let \( L_{i+1} \) be a weak confluence point of \( N_{i+1} \) and \( L_i \), and let \( L \coloneqq L_n \).
    \item If \( n < k \), for \( i > n \) let \( L_{i+1} \) be a weak confluence point of \( K_{i+1} \) and \( L_i \), and let \( L \coloneqq L_k \).
  \end{itemize}

  In all cases, \( N \pred* L \) and \( K \pred* L \).
\end{proof}

\begin{theorem}[Church-Rosser theorem]\label{thm:church_rosser_theorem}
  Let \enquote{\( {\Anon} \)} be \enquote{\( \beta \)}, \enquote{\( \eta \)} or \enquote{\( \beta\eta \)}.

  \begin{thmenum}
    \thmitem{thm:church_rosser_theorem/parallel} \hyperref[def:parallel_reduction]{Parallel \( \Anon \)-reduction} is \hyperref[def:reduction_confluence]{confluent}.

    \thmitem{thm:church_rosser_theorem/multi_step} \hyperref[def:lambda_reduction/multi]{Multi-step \( \Anon \)-reduction} is \hyperref[def:reduction_confluence]{confluent}.

    \thmitem{thm:church_rosser_theorem/single_step} \hyperref[def:lambda_reduction/single]{Single-step \( \Anon \)-reduction} is only \hyperref[def:reduction_confluence]{weakly confluent}.
  \end{thmenum}
\end{theorem}
\begin{proof}
  \SubProofOf{thm:church_rosser_theorem/parallel} Suppose that \( M \ppred N \) and \( M \ppred K \). We will use \fullref{thm:induction_on_recursively_defined_relations} on \( M \ppred N \) simultaneously on all \( K \) to show the existence of the desired confluence point \( L \) such that \( N \ppred L \) and \( N \ppred L \):
  \begin{itemize}
    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/atom}, then \( M \) and \( N \) are identical atomic terms. Furthermore, \fullref{thm:parallel_reduction_deconstruction/atom} implies the same for \( M \) and \( K \), hence \( M = N = K \).

    Define \( L \coloneqq M \) so that \( N \ppred L \) and \( K \ppred L \), again due to \ref{inf:def:parallel_reduction/atom}.

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/alpha}, then \( M \aequiv B \ppred C \aequiv N \), where the inductive hypothesis holds for \( B \ppred C \).

    Then \( B \ppred K \) due to \ref{inf:def:lambda_reduction/alpha}, and the inductive hypothesis implies that there exists some \( \synlambda \)-term \( L \) such that \( C \ppred L \) and \( K \ppred L \).

    We can use \ref{inf:def:lambda_reduction/alpha} again to conclude that \( N \ppred L \).

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/app}, we have \( M = AB \) and \( N = CD \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities for \( M = AB \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct} for \( AB \ppred K \), we have \( K = EF \), where \( A \ppred E \) and \( B \ppred F \).

      The inductive hypotheses on \( A \ppred C \) implies the existence of a confluence point \( G \) of \( C \) and \( E \), and similarly the hypothesis on \( B \ppred D \) implies the existence of a confluence point \( H \) of \( D \) and \( F \).

      Let \( L \coloneqq GH \). Then \ref{inf:def:parallel_reduction/app} allows us to conclude that \( N \ppred L \) and \( K \ppred L \).

      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta} for \( AB \ppred K \), which requires the \( \beta \)-reduction rule \ref{inf:def:parallel_reduction/eta}, we have \( A = \qabs x E \) and \( K \aequiv F[x \mapsto G] \), where \( B \ppred G \) and \( E \ppred F \).

      To summarize:
      \begin{align*}
        M &= (\qabs x E) B,           &&\qabs x E \ppred C,            \\
        N &= C D,                     &&B \ppred D \T{and} B \ppred G, \\
        K &\aequiv F[x \mapsto G],    &&E \ppred F.
      \end{align*}

      Since \( E \ppred F \), \ref{inf:def:lambda_reduction/abs} implies that \( A = \qabs x E \ppred \qabs x F \). Then, by the inductive hypothesis on \( A \ppred C \), there exists a confluence point \( P \) of \( C \) and \( \qabs x F \). Furthermore, by the inductive hypothesis on \( B \ppred D \), there exists a confluence point \( R \) of \( D \) and \( G \).

      This leads to the following diagrams:
      \begin{equation*}
        \includegraphics[page=2]{output/thm__church_rosser_theorem}
        \quad\quad
        \includegraphics[page=3]{output/thm__church_rosser_theorem}
      \end{equation*}

      We need to consider different cases for \( C \) and \( P \).

      \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( A = (\qabs x E) \ppred C \):
      \begin{itemize}
        \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift} for \( (\qabs x E) \ppred C \), we have \( C \aequiv \qabs x H \), where \( E \ppred H \).

        \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( C \aequiv (\qabs x H) \ppred P \):
        \begin{itemize}
          \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift} for \( (\qabs x E) \ppred C \), we have \( P \aequiv \qabs x Q \), where \( H \ppred Q \). This leads to the following diagram:
          \begin{equation*}
            \includegraphics[page=4]{output/thm__church_rosser_theorem}
          \end{equation*}

          Let \( L \coloneqq Q[x \mapsto R] \). Since \( D \ppred R \), by \ref{inf:def:parallel_reduction/beta} we have
          \begin{equation*}
            N = CD \aequiv (\qabs x H) D \ppred Q[x \mapsto R] = L
          \end{equation*}
          and, since \( G \ppred R \), by \fullref{thm:substitution_on_parallel_reduction} we have
          \begin{equation*}
            K \aequiv F[x \mapsto G] \ppred Q[x \mapsto R] = L.
          \end{equation*}

          So \( L \) is the desired confluence point of \( N \) and \( K \).

          \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta}, which requires the \( \eta \)-reduction rule \ref{inf:def:parallel_reduction/eta}, \( x \) is not free in \( P \) and \( F \aequiv Px \).

          Let \( L \coloneqq PR \). Then
          \begin{equation*}
            N
            =
            CD
            \ppred
            PR
            =
            L
          \end{equation*}
          and
          \begin{equation*}
            K
            \aequiv
            F[x \mapsto G]
            \reloset {\ref{thm:substitution_on_alpha_equivalent_terms}} \aequiv
            P[x \mapsto G] \thinspace G
            \reloset {\ref{thm:lambda_substitution_noop}} =
            PG
            \ppred
            PR
            =
            L.
          \end{equation*}
        \end{itemize}
      \end{itemize}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:lambda_reduction/abs}, then \( M = \qabs x A \) and \( N = \qabs x B \), where \( A \ppred B \) and the inductive hypothesis holds for the latter.

    \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( M \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift} for \( M \ppred K \), we have \( K \aequiv \qabs x C \), where \( A \ppred C \).

      By the inductive hypothesis on \( A \ppred B \), there exists a confluence point \( D \) of \( B \) and \( C \).

      Let \( L \coloneqq \qabs x D \). Then \ref{inf:def:parallel_reduction/abs} implies that \( N \ppred L \) and \( K \ppred L \).

      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta} for \( M \ppred K \), which requires the \( \eta \)-reduction rule \ref{inf:def:parallel_reduction/eta}, \( x \) is not free in \( K \) and \( A \aequiv Kx \).

      Applying \ref{inf:def:lambda_reduction/alpha}, we obtain \( Kx \ppred B \). \Fullref{thm:parallel_reduction_deconstruction/app} lists two possibilities for \( Kx \ppred B \), however \fullref{thm:parallel_reduction_deconstruction/app/beta} is not possible because it requires \( Kx \) to be an abstraction. Then \fullref{thm:parallel_reduction_deconstruction/app/direct} holds, and \( B = Lx \), where the first component \( L \) of \( B \) satisfies \( K \ppred L \).

      To summarize:
      \begin{align*}
        M &= \qabs x A \aequiv \qabs x Kx, \\
        N &= \qabs x B = \qabs x Lx. \\
      \end{align*}

      Then \( L \) happens to be a confluence point of \( N \) and \( K \), as can be seen in the following diagram:
      \begin{equation*}
        \includegraphics[page=5]{output/thm__church_rosser_theorem}
      \end{equation*}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/beta}, then \( M = (\qabs x A)B \) and \( N = C[x \mapsto D] \), where \( A \ppred C \) and \( B \ppred D \) and the inductive hypothesis holds for the latter two.

    \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities for \( M \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct} for \( M \ppred K \), we have \( K = EF \), where \( \qabs x A \ppred E \) and \( B \ppred F \). To summarize:
      \begin{align*}
        M &= (\qabs x A) B,           &&A \ppred C \T{and} \qabs x A \ppred E, \\
        N &= C[x \mapsto D],          &&B \ppred D \T{and} B \ppred F, \\
        K &= E F.                     &&
      \end{align*}

      By the inductive hypothesis on \( B \ppred D \), there exists a confluence point \( Q \) of \( D \) and \( F \).

      \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( \qabs x A \ppred E \):
      \begin{itemize}
        \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift} for \( \qabs x A \ppred E \), we have \( E \aequiv \qabs x H \), where \( A \ppred H \).

        By the inductive hypothesis on \( A \ppred C \), there exists a confluence point \( P \) of \( C \) and \( H \).

        Then \( L \coloneqq P[x \mapsto Q] \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
        \begin{equation*}
          \includegraphics[page=6]{output/thm__church_rosser_theorem}
        \end{equation*}

        \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta} for \( \qabs x A \ppred E \), which requires the \( \eta \)-reduction rule \ref{inf:def:parallel_reduction/eta}, \( x \) is not free in \( E \) and \( A \aequiv Ex \), i.e.
        \begin{equation*}
          M = (\qabs x A) B \aequiv (\qabs x E x) B
        \end{equation*}
        and
        \begin{equation*}
          Ex \aequiv A \ppred C.
        \end{equation*}

        For the latter, \fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities:
        \begin{itemize}
          \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct} for \( Ex \ppred C \), we have \( C \aequiv Px \) for some term \( P \) such that \( E \pred P \). In particular, since \( x \) is not free in \( E \), \fullref{thm:def:parallel_reduction/free} implies it is not free in \( P \), so
          \begin{equation*}
            N
            =
            C[x \mapsto D]
            \reloset {\ref{thm:substitution_on_alpha_equivalent_terms}} \aequiv
            (Px)[x \mapsto D]
            =
            P[x \mapsto D] \thinspace D
            \reloset {\ref{thm:lambda_substitution_noop}} \aequiv
            PD.
          \end{equation*}

          Then, since \( Q \) is a confluence point of \( D \) and \( F \), \( L \coloneqq PQ \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
          \begin{equation*}
            \includegraphics[page=7]{output/thm__church_rosser_theorem}
          \end{equation*}

          \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta} for \( Ex \ppred C \), we have \( E \aequiv \qabs y P \) and \( C \aequiv R[y \mapsto S] \), where \( x \ppred S \) and \( P \ppred R \).

          It follows from \fullref{thm:parallel_reduction_deconstruction/atom} that \( S = x \), thus \( C \aequiv R[y \mapsto x] \). Then
          \begin{equation*}
            N = C[x \mapsto D] \aequiv R[y \mapsto x][x \mapsto D].
          \end{equation*}

          We will show that
          \begin{equation*}
            N \aequiv R[y \mapsto D].
          \end{equation*}

          This follows from \fullref{thm:substitution_chain_contraction} if \( x \) is not free in \( R \).

          Otherwise, since \( P \ppred R \), \fullref{thm:def:parallel_reduction/free} implies that \( x \) is free in \( P \). Since \( E \aequiv y P \) and \( x \) is not free in \( E \), \fullref{thm:def:lambda_term_alpha_equivalence/free} implies that \( x \) is not free in \( \qabs y P \).

          Then \( x \) is free in \( P \) but not in \( \qabs y P \), implying that \( x = y \). Then
          \begin{equation*}
            N
            \aequiv
            R[y \mapsto x][x \mapsto D]
            =
            R[y \mapsto y][y \mapsto D]
            \reloset {\ref{thm:substitution_chain_contraction}} \aequiv
            R[y \mapsto D].
          \end{equation*}

          Since \( Q \) is a confluence point of \( D \) and \( F \), \fullref{thm:substitution_on_parallel_reduction} implies that
          \begin{equation*}
            R[y \mapsto D] \ppred R[y \mapsto Q].
          \end{equation*}

          Therefore, since \( P \ppred R \), \( L \coloneqq R[y \mapsto Q] \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
          \begin{equation*}
            \includegraphics[page=8]{output/thm__church_rosser_theorem}
          \end{equation*}
        \end{itemize}
      \end{itemize}

      \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta} for \( M \ppred K \), we have \( K \aequiv E[x \mapsto F] \), where \( B \ppred F \) and \( A \ppred E \).

      By the inductive hypothesis on \( A \ppred C \), there exists a confluence point \( P \) for \( C \) and \( E \). By the inductive hypothesis on \( B \ppred D \), there exists a confluence point \( Q \) of \( D \) and \( F \).

      Then \fullref{thm:substitution_on_parallel_reduction} allows us to conclude that \( L \coloneqq P[x \mapsto Q] \) is the desired confluence point for \( N \) and \( K \), as can be seen from the following diagram:
      \begin{equation*}
        \includegraphics[page=9]{output/thm__church_rosser_theorem}
      \end{equation*}
    \end{itemize}

    \item If \( M \ppred N \) due to \ref{inf:def:parallel_reduction/eta}, then \( M = \qabs x A x \), where \( x \) is not free in \( A \), \( A \ppred N \), and the inductive hypothesis holds for the latter.

    \Fullref{thm:parallel_reduction_deconstruction/abs} lists the following possibilities for \( M \ppred K \):
    \begin{itemize}
      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/lift} for \( M \ppred K \), we have \( K \aequiv \qabs x B \), where \( Ax \ppred B \).

      To summarize:
      \begin{align*}
        M &= \qabs x A x,        &&A \ppred N, \\
        K &\aequiv \qabs x B,    &&Ax \ppred B.
      \end{align*}

      \Fullref{thm:parallel_reduction_deconstruction/app} lists the following possibilities for \( Ax \ppred B \):
      \begin{itemize}
        \item In the case \fullref{thm:parallel_reduction_deconstruction/app/direct} for \( Ax \ppred B \), we have \( B = Cx \), where \( A \ppred C \).

        By the inductive hypothesis on \( A \ppred N \), there exists a confluence point \( L \) of \( N \) and \( C \). It is also a confluence point of \( N \) and \( K \) because
        \begin{equation*}
          K \aequiv \qabs x B = \qabs x Cx \ppred L.
        \end{equation*}

        \item In the case \fullref{thm:parallel_reduction_deconstruction/app/beta} for \( Ax \ppred B \), which requires the \( \beta \)-reduction rule \ref{inf:def:parallel_reduction/eta}, we have \( A = \qabs y E \) and also \( B \aequiv F[y \mapsto G] \), where \( x \ppred G \) and \( E \ppred F \).

        \Fullref{thm:parallel_reduction_deconstruction/atom} implies that \( G = x \), hence \( B \aequiv F[y \mapsto x] \). We can thus apply \ref{inf:thm:alpha_equivalence_simplified/lift} to conclude that
        \begin{equation*}
          \qabs x B \aequiv \qabs x F[y \mapsto x].
        \end{equation*}

        But \( K \aequiv \qabs x B \) and, due to \fullref{thm:alpha_conversion}, \( \qabs x F[y \mapsto x] \aequiv \qabs y F \), thus
        \begin{equation*}
          K \aequiv \qabs y F.
        \end{equation*}

        Furthermore, since \( E \pred F \), \ref{inf:def:parallel_reduction/abs} implies that \( A = \qabs y E \pred \qabs y F \). The inductive hypothesis on \( A \pred N \) implies that there exists a confluence point \( L \) of \( N \) and \( \qabs y F \). It is also a confluence point for \( N \) and \( K \) since \( K \aequiv \qabs y F \).
      \end{itemize}

      \item In the case \fullref{thm:parallel_reduction_deconstruction/abs/eta} for \( M \ppred K \), \( x \) is not free in \( K \) and \( A \aequiv K \). \Fullref{thm:def:parallel_reduction/alpha_reflexive} implies that \( A \ppred K \).

      By the inductive hypothesis on \( A \ppred N \), there exists a confluence point \( L \) of \( N \) and \( K \).
    \end{itemize}
  \end{itemize}

  \SubProofOf{thm:church_rosser_theorem/multi_step} The parallel reduction \( {\ppred} \) is confluent as a consequence of \fullref{thm:church_rosser_theorem/parallel}. \Fullref{thm:def:parallel_reduction/extends_to_multi_step} implies that the corresponding multi-step reduction coincides with \( {\pred*} \), hence \fullref{thm:def:reduction_confluence/weak_implies_multi} implies that \( {\pred*} \) is confluent.

  \SubProofOf{thm:church_rosser_theorem/single_step} Follows from \fullref{thm:church_rosser_theorem/multi_step} and \fullref{thm:def:reduction_confluence/multi_implies_weak}.
\end{proof}
