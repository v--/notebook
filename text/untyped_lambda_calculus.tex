\subsection{Untyped lambda calculus}\label{subsec:untyped_lambda_calculus}

\paragraph{Untyped \( \synlambda \)-terms}

\begin{definition}\label{def:untyped_lambda_term}\mimprovised
  We introduce \enquote{\( \synlambda \)-terms}, \enquote{\( \synlambda \)-applications} and \enquote{\( \synlambda \)-abstractions} via the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{variable}    {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{application} {\bnftsq{\( ( \)} \bnfsp \bnfpn{term} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}} \\
    \bnfprod{abstraction} {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term}        {\bnfpn{variable} \bnfor \bnfpn{application} \bnfor \bnfpn{abstraction}},
  \end{bnf*}
  where we have used variable identifier rules from \fullref{def:variable_identifier}.

  \begin{thmenum}
    \thmitem{def:untyped_lambda_term/var} We will denote by \( \op*{Var} \) the set of all \( \synlambda \)-variables.
    \thmitem{def:untyped_lambda_term/term} Similarly, we will denote by \( \op*{Term} \) the set of all \( \synlambda \)-terms.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item These notions are based on \cite[352]{Church1932}. It is not clear why has Church used \( \synlambda \) as part of the grammar.

  \item We need all the parentheses so that we can prove unambiguity in \fullref{thm:lambda_terms_are_unambiguous}. Informally, we will use the conventions from \fullref{rem:propositional_formula_parentheses} regarding parentheses.
\end{comments}

\begin{proposition}\label{thm:lambda_terms_are_unambiguous}
  The grammar of \hyperref[def:untyped_lambda_term]{\( \synlambda \)-terms} is \hyperref[def:grammar_ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  Similarly to \fullref{thm:propositional_formulas_are_unambiguous}, the proof is again based on \fullref{ex:natural_number_arithmetic_grammar/unambiguous}.
\end{proof}

\begin{definition}\label{def:untyped_lambda_term_ast}
  We implicitly associate with each \( \synlambda \)-term \( M \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(M) \) defined as follows:
  \begin{thmenum}
    \thmitem{def:untyped_lambda_term_ast/variable} If \( M \) is a variable, let \( T(M) \) be the singleton tree with value \( M \).

    \thmitem{def:untyped_lambda_term_ast/application} If \( M = NK \), assuming we have already built \( T(N) \) and \( T(K) \), we obtain \( T(M) \) by joining them by a new root with value \( \cdot \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__lambda_term_ast}
    \end{equation*}

    \thmitem{def:untyped_lambda_term_ast/abstraction} If \( \varphi = \qabs x N \), assuming we have already built \( T(N) \), we obtain \( T(M) \) by adding a new root with value \( \qabs* x \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__lambda_term_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Formally our ASTs for abstractions are not ideal because we need to \enquote{parse} the string at the root. They are, however, convenient for defining variable occurrences in \fullref{def:lambda_variable_occurrence}, and are also easier to parse visually.
\end{comments}

\begin{remark}\label{rem:lambda_term_parentheses}
  We use some \enquote{abuse-of-notation} syntactic conventions somewhat resembling \fullref{rem:propositional_formula_parentheses}:
  \begin{thmenum}
    \thmitem{rem:lambda_term_parentheses/outermost} As in \fullref{rem:propositional_formula_parentheses/outermost}, we avoid writing the outermost parentheses in terms like \( (\synx \syny) \) or \( ((\synx \syny) \synz) \).

    \thmitem{rem:lambda_term_parentheses/abstraction} We generally avoid writing parentheses around \( \synlambda \)-abstractions.

    Actually, it is not necessary to put parentheses around \( \synlambda \)-abstractions in order for the grammar to be unambiguous. Not requiring them, however, leads to the following unintuitive artifact.

    Consider the term \( \qabs x y z \). If parentheses are required only for \( \synlambda \)-abstractions but not for \( \synlambda \)-applications, it would unambiguously correspond to the following \hyperref[rem:lambda_term_ast]{abstract syntax tree}:
    \begin{equation*}
      \includegraphics[page=1]{output/rem__lambda_term_parentheses}
    \end{equation*}

    But it is reasonable to expect instead the following tree:
    \begin{equation*}
      \includegraphics[page=2]{output/rem__lambda_term_parentheses}
    \end{equation*}

    Since we will generally expect the latter, it is simpler to require parentheses around \( \synlambda \)-abstractions in the formal syntax and then, when convenient, avoid writing them within the metalogic.

    \thmitem{rem:lambda_term_parentheses/left_associative} We suppose that \( \synlambda \)-application is \hyperref[rem:binary_operation_syntax_trees/associativity]{left-associative}, which allows us to simplify notation in some cases like \eqref{eq:ex:def:untyped_lambda_term/combinator/s}, where we use \( xz(yz) \) rather than \( (xz)(yz) \).
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:lambda_subterm}\mcite[def. 1A3]{Hindley1997}
  We define the set of all \term[ru=подтерм (\cite[189]{Герасимов2011})]{subterms} of a term \( M \) as follows:
  \begin{equation*}
    \op*{Subterm}(M) \coloneqq \begin{cases}
      \set{ M },                                             &M \in \op*{Var}, \\
      \set{ M } \cup \op*{Subterm}(N) \cup \op*{Subterm}(K), &M = N K, \\
      \set{ M } \cup \op*{Subterm}(N),                       &M = \qabs x N.
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item Note that the analog of \fullref{thm:propositional_formula_characterization} no longer holds --- a variable that is a substring of a term is not necessarily a subterm --- see \fullref{ex:def:untyped_lambda_term/naive_subterm}.
\end{comments}

\begin{proposition}\label{thm:lambda_subterm_characterization}
  Suppose that the \hyperref[def:formal_language/substring]{substring} \( N \) of the \( \synlambda \)-term \( M \) is \hi{not a variable}. Then \( N \) is a \hyperref[def:lambda_subterm]{subterm} of \( M \) if and only if \( N \) is itself a \( \synlambda \)-term.
\end{proposition}
\begin{proof}
  We can give a proof similar to \fullref{thm:propositional_formula_characterization}.
\end{proof}

\begin{example}\label{ex:def:untyped_lambda_term}
  We list examples of \hyperref[def:untyped_lambda_term]{\( \synlambda \)-terms}:
  \begin{thmenum}
    \thmitem{ex:def:untyped_lambda_term/var} The simplest \( \synlambda \)-terms are the variables themselves, for example \( \synx \) or \( \syny \).

    \thmitem{ex:def:untyped_lambda_term/naive_subterm} Suppose that, as in \fullref{def:propositional_subformula} for propositional subformulas, we say that \( N \) is a subterm of \( M \) if it is itself a \hyperref[def:formal_language/substring]{substring} of \( M \).

    Then the term \( \qabs \synx \syny \) would have both \( \synx \) and \( \syny \) as subterms, while according to \fullref{def:untyped_lambda_term/subterm}, only \( \syny \) is a subterm.

    \thmitem{ex:def:untyped_lambda_term/combinator}\mcite[def. 1A10.1]{Hindley1997} The following terms have established names:
    \begin{align}
      &\qabs \synx \synx, \label{eq:ex:def:untyped_lambda_term/combinator/i}\tag{I} \\
      &\qabs \synx \qabs \syny \syny \synx, \nonumber\label{eq:ex:def:untyped_lambda_term/combinator/k}\tag{K} \\
      &\qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz), \label{eq:ex:def:untyped_lambda_term/combinator/s}\tag{S} \\
      &\qabs \synx (\qabs \syny \synx \syny \syny) (\qabs \syny \synx \syny \syny). \label{eq:ex:def:untyped_lambda_term/combinator/y}\tag{Y}
    \end{align}

    They are combinators in the sense that will be defined in \fullref{def:lambda_combinator}, and are referred to as such.
  \end{thmenum}
\end{example}

\paragraph{Variable scope}

\begin{definition}\label{def:lambda_abstractor}\mcite[def. 1A5]{Hindley1997}
  Given an abstraction \( M = \qabs x N \), we call \( \qabs* x \) the \term{abstractor} and \( N \) --- the \term{body} of \( M \).

  We say that the body \( N \) is the \term[ru=область действия (\cite[64]{Герасимов2011})]{scope} of the abstractor \( \quantifier* \synlambda \synx \) and that the abstractor \term{binds} the variable \( \synx \) in \( N \).
\end{definition}

\begin{definition}\label{def:lambda_variable_occurrence}\mimprovised
  Similarly to \hyperref[def:propositional_variable_occurrence]{propositional variable occurrences}, we define aj \term{occurrence} of a variable \( x \) in a \( \synlambda \)-term \( M \) to be a variable node with value \( x \) in the \hyperref[def:untyped_lambda_term_ast]{abstract syntax tree} of \( M \).

  Unlike in propositional logic, variable occurrences in \( \synlambda \)-terms can be free and bound. We say that the occurrence is \term[ru=свободное (вхождение) (\cite[64]{Герасимов2011})]{free} in \( M \) if the root of the AST can be reached without passing through a corresponding abstractor. If a variable is not free, there exists an abstractor that binds it, and we say that the occurrence is \term[ru=связанное (вхождение) (\cite[64]{Герасимов2011})]{bound} in \( M \).
\end{definition}

\begin{definition}\label{def:lambda_variable_freeness}\mimprovised
  We say that a variable \( \synx \) is \term{free} in a \( \synlambda \)-term \( M \) if \( \synx \) has at least one \hyperref[def:lambda_variable_occurrence]{free occurrence} in \( M \) and \term{bound} if it has a \hyperref[def:lambda_variable_occurrence]{bound occurrence} in \( M \).
\end{definition}
\begin{comments}
  \item We may use the recursive definitions from \fullref{thm:lambda_variable_freeness_characterization} instead.
\end{comments}

\begin{example}\label{ex:def:lambda_variable_freeness}
  We list examples of free and bound variables and variables occurrences:
  \begin{thmenum}
    \thmitem{ex:def:lambda_variable_freeness/abstractor} The term \( \ref{eq:ex:def:untyped_lambda_term/combinator/i} = \qabs \synx \synx \) has exactly one occurrence of \( \synx \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__lambda_variable_freeness}
    \end{equation*}

     This occurrence is bound in the term \( I \) and free in the subterm \( \synx \). Then \( \synx \) is a bound variable in \( I \) and a free variable in \( I \).

    \thmitem{ex:def:lambda_variable_freeness/both} The term \( M = I \synx = (\qabs \synx \synx) \synx \) has two occurrences of the variable \( \synx \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__lambda_variable_freeness}
    \end{equation*}

    One of the occurrences is free, which makes \( \synx \) a free variable of \( M \), and one of the occurrences if bound, which makes \( \synx \) a bound variable of \( M \).
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:lambda_variable_freeness_characterization}
  The set of all \hyperref[def:lambda_variable_freeness]{free variables} of a \( \synlambda \)-term can be characterized as follows:
  \begin{equation*}
    \op*{Free}(M) \coloneqq \begin{cases}
      \set{ M },                         &M \in \op*{Var}, \\
      \op*{Free}(N) \cup \op*{Free}(K),  &M = N K, \\
      \op*{Free}(N) \setminus \set{ x }, &M = \qabs x N. \\
    \end{cases}
  \end{equation*}

  Similarly, the bound variables can be characterized via
  \begin{equation*}
    \op*{Bound}(M) \coloneqq \begin{cases}
      \varnothing,                        &M \in \op*{Var}, \\
      \op*{Bound}(N) \cup \op*{Bound}(K), &M = N K, \\
      \op*{Bound}(N) \cup \set{ x },      &M = \qabs x N. \\
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{proof}
  Straightforward.
\end{proof}

\begin{definition}\label{def:lambda_combinator}\mcite[def. 1A10]{Hindley1997}
  If a \( \synlambda \)-term has no \hyperref[def:lambda_variable_freeness]{free variables}, we say that it is \term{closed}. Closed terms are also called \term[ru=комбинаторы (\cite[188]{Герасимов2011})]{combinators}.
\end{definition}

\paragraph{Simultaneous substitution}

\begin{definition}\label{def:lambda_substitution}\mimprovised
  A \term{simultaneous substitution} of \( \synlambda \)-terms is a pair \( (\sigma, \sharp) \), where
  \begin{thmenum}[series=def:lambda_substitution]
    \thmitem{def:lambda_substitution/sigma} \( \sigma: \op*{Var} \to \op*{Term} \) is a function specifying how variables need to be replaced with terms. We allow only finitely many variables to not be fixed by \( \sigma \).
    \thmitem{def:lambda_substitution/sharp} \( \sharp: F \to \op*{Var} \), where \( F \) is the family of all variable contexts (i.e. finite subsets of \( \op*{Var} \)), is a function providing us with a new variable identifier not present in some given context.

    As discussed in \fullref{def:variable_identifier}, unless otherwise noted, will suppose that this function simply provides the smallest variable identifier with respect to the \hyperref[def:lexicographic_order]{reverse lexicographic order}.
  \end{thmenum}

  In order to be able to define substitutions for arbitrary terms, we will need the following auxiliary definition:
  \begin{equation}\label{eq:def:lambda_substitution/free}
    \op*{Free}_\sigma(M) \coloneqq \bigcup_{\mathclap{x \in \op*{Free}(M)}} \op*{Free}(\sigma(x)).
  \end{equation}

  For an arbitrary \( \synlambda \)-term \( M \), we define the following operation (for which will use the notational convention from \fullref{rem:substitution_notation}):
  \begin{subequations}
    \begin{empheq}[left={M[\sigma]} \coloneqq \empheqlbrace]{align}
      &\sigma(M),                      &&M \in \op*{Var},                                      \label{eq:def:lambda_substitution/var} \\
      &N[\sigma] \thinspace K[\sigma], &&M = NK,                                               \label{eq:def:lambda_substitution/application} \\
      &\qabs x N[\sigma, x \mapsto x], &&M = \qabs x N \T{and} x \not\in \op*{Free}_\sigma(M), \label{eq:def:lambda_substitution/abstraction/direct} \\
      &\qabs n N[\sigma, x \mapsto n], &&M = \qabs x N \T{and} x \in \op*{Free}_\sigma(M),     \label{eq:def:lambda_substitution/abstraction/renaming}
    \end{empheq}
    where \( n = \sharp(\op*{Free}_\sigma(N) \cup \op*{Free}(N)) \).
  \end{subequations}
\end{definition}
\begin{comments}
  \item In \eqref{eq:def:lambda_substitution/abstraction/direct} we modify \( \sigma \) to fix \( x \), while in \eqref{eq:def:lambda_substitution/abstraction/renaming} we modify it to send \( x \) to \( n \). We will refer to the latter rule as \enquote{substitution with renaming}.
  \item This definition is loosely based on \cite[def. 1A7]{Hindley1997}, but is modified to allow substituting multiple variables. This results in less rules since \eqref{eq:def:lambda_substitution/abstraction/direct} subsumes three of the four cases. Furthermore, our substitution rules also allow proving \fullref{thm:lambda_substitution_combinators}.
\end{comments}

\begin{remark}\label{rem:renaming_substitution_rules}
  The substitution rules for abstractions from \fullref{def:lambda_substitution} are adjusted so that \fullref{thm:lambda_substitution_free_variables} and \fullref{thm:lambda_substitution_combinators} hold.

  The bare minimum we need is to avoid \enquote{variable capturing} as discussed in \fullref{ex:def:lambda_substitution/capture}. As we can see in the proof of \fullref{thm:lambda_substitution_free_variables}, the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming} is by itself sufficient for this. Thus, we may choose to always rename the abstractor variable.

  In practice, however, we would prefer to not rename bound variables, especially in \hyperref[def:lambda_combinator]{combinators}; the rule \eqref{eq:def:lambda_substitution/abstraction/direct} allow us to prove \fullref{thm:lambda_substitution_combinators}.

  See \fullref{ex:def:lambda_substitution/ignoring} for concrete examples of ignoring the latter rule.
\end{remark}

\begin{proposition}\label{thm:lambda_substitution_combinators}
  For any \hyperref[def:lambda_combinator]{combinator} \( M \) and any substitution \( \sigma \), we have \( M[\sigma] = M \).
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_syntax_trees} on \( M \) simultaneously for all possible substitutions:
  \begin{itemize}
    \item \( M \) cannot be a variable because it is a combinator.
    \item Suppose that \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \). The subterms \( N \) and \( K \) are necessarily combinators, hence
    \begin{equation*}
      M[\sigma]
      \reloset {\eqref{eq:def:lambda_substitution/application}} =
      N[\sigma] \thinspace K[\sigma]
      \reloset {\T{ind.}} =
      N K
      =
      M.
    \end{equation*}

    \item Suppose that \( M = \qabs x N \), where the inductive hypothesis holds for \( N \).

    Since \( M \) has no free variables, \( \op*{Free}_\sigma(M) \), and we must use \eqref{eq:def:lambda_substitution/abstraction/direct}:
    \begin{equation*}
      M[\sigma] = \qabs x N[\sigma, x \mapsto x] = \qabs x N = M.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_free_variables}
  For any \( \synlambda \)-term \( M \) and any substitution \( \sigma \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables}
    \op*{Free}( M[\sigma] ) = \overbrace{\bigcup_{\mathclap{x \in \op*{Free}(M)}} \op*{Free}(\sigma(x))}^{\op*{Free}_\sigma(M)}.
  \end{equation}

  This also holds if we always use the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming} and ignore the other abstraction substitution rules. It also holds if we ignore only \eqref{eq:def:lambda_substitution/abstraction/noop}.
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_syntax_trees} on \( M \) simultaneously for all possible substitutions:
  \begin{itemize}
    \item If \( M \) is a variable, say \( M = y \), then \( \op*{Free}(M) = \set{ y } \) and thus
    \begin{equation*}
      \op*{Free}(M[\sigma])
      \reloset {\eqref{eq:def:lambda_substitution/var}} =
      \op*{Free}(\sigma(y)).
    \end{equation*}

    Hence, \eqref{eq:thm:lambda_substitution_free_variables} is satisfied.

    \item Suppose that \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \).

    We have
    \begin{equation*}
      \op*{Free}(M[\sigma])
      \reloset {\eqref{eq:def:lambda_substitution/application}} =
      \op*{Free}(N[\sigma] \thinspace K[\sigma])
      =
      \op*{Free}(N[\sigma]) \cup \op*{Free}(K[\sigma]).
    \end{equation*}

    Since, by definition, \( \op*{Free}(M) = \op*{Free}(N) \cup \op*{Free}(K) \), from the inductive hypothesis it follows that \eqref{eq:thm:lambda_substitution_free_variables} holds.

    \item Suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \). We have the following possibilities:
    \begin{itemize}
      \item Suppose first that \( x \not\in \op*{Free}_\sigma(M) \). We must thus use \eqref{eq:def:lambda_substitution/abstraction/direct}.

      Define the substitution
      \begin{equation*}
        \rho(y) \coloneqq \begin{cases}
          x,         &y = x, \\
          \sigma(y), &\T{otherwise}
        \end{cases}
      \end{equation*}
      so that \( N[\sigma, x \mapsto x] = N[\rho] \). Then
      \begin{align*}
        \op*{Free}(M[\sigma])
        &\reloset{\eqref{eq:def:lambda_substitution/abstraction/direct}} =
        \op*{Free}(\qabs x N[\rho])
        = \\ &=
        \op*{Free}(N[\rho]) \setminus \set{ x }
        \reloset{\T{ind.}} = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{y \in \op*{Free}(N)}} \op*{Free}(\rho(y)) } \setminus \set{ x }
        = \\ &=
        \bigcup_{\mathclap{y \in \op*{Free}(N)}} \parens[\Big]{ \op*{Free}(\rho(y)) \setminus \set{ x } }
        = \\ &=
        \bigcup_{\mathclap{y \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\underbrace{\rho(y)}_{\sigma(y)}) \setminus \set{ x } } \cup \underbrace{\parens[\Big]{ \op*{Free}(\rho(x)) \setminus \set{ x } }}_\varnothing.
        = \\ &=
        \bigcup_{\mathclap{y \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\sigma(y)) },
      \end{align*}
      where at the last step we have used that, for \( y \in \op*{Free}(N) \), \( x \) is free in \( \sigma(y) \) only when \( y = x \).

      This demonstrates \eqref{eq:thm:lambda_substitution_free_variables}.

      \item Otherwise, \( x \in \op*{Free}_\sigma(M) \), and we must use \eqref{eq:def:lambda_substitution/abstraction/renaming}. As discussed in \fullref{rem:renaming_substitution_rules}, the assumption itself is irrelevant for proving \eqref{eq:thm:lambda_substitution_free_variables}.

      Let \( n \coloneqq \sharp(\op*{Free}_\sigma(N) \cup \op*{Free}(N)) \) and define the substitution
      \begin{equation*}
        \rho(y) \coloneqq \begin{cases}
          n,         &y = x, \\
          \sigma(y), &\T{otherwise}
        \end{cases}
      \end{equation*}
      so that \( N[\sigma, x \mapsto n] = N[\rho] \). Then
      \begin{align*}
        \op*{Free}(M[\sigma])
        &=
        \op*{Free}(\qabs n N[x \mapsto n][\sigma])
        = \\ &=
        \op*{Free}(\qabs n N[\rho])
        = \\ &=
        \op*{Free}(N[\rho]) \setminus \set{ n }
        \reloset {\T{ind.}} = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{y \in \op*{Free}(N)}} \op*{Free}(\rho(y)) } \setminus \set{ n }
        = \\ &=
        \bigcup_{\mathclap{y \in \op*{Free}(N)}} \parens[\Big]{ \op*{Free}(\rho(y)) \setminus \set{ n } }
        = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{y \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\underbrace{\rho(y)}_{\sigma(y)}) \setminus \set{ n } } } \cup \parens[\Big]{ \underbrace{\op*{Free}(\rho(x)) \setminus \set{ n }}_\varnothing }
        = \\ &=
        \bigcup_{\mathclap{y \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\sigma(y)) \setminus \set{ x } },
        = \\ &=
        \bigcup_{\mathclap{y \in \op*{Free}(M) \setminus \set{ x }}} \op*{Free}(\sigma(y)),
      \end{align*}
      where in the last step we have used that \( n \) is not free in \( \sigma(y) \) because it does not, by definition, belong to \( \op*{Free}_\sigma(N) \).

      This demonstrates \eqref{eq:thm:lambda_substitution_free_variables}.
    \end{itemize}
  \end{itemize}

  The induction is complete.
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_free_variables_single}
  For any \( \synlambda \)-terms \( M \) and \( L \) and any variable \( y \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables_single}
    \op*{Free}( M[y \mapsto L] ) = \begin{cases}
      \parens[\Big]{ \op*{Free}(M) \setminus \set{ y } } \cup \op*{Free}(L), &y \T{is free in} M \\
      \op*{Free}(M),                                                         &\T{otherwise.}
    \end{cases}
  \end{equation}
\end{corollary}
\begin{proof}
  Denote by \( \sigma \) the substitution sending \( y \) to \( L \). If \( y \) is free in \( M \), then
  \begin{equation*}
    \op*{Free}(M[y \mapsto L])
    \reloset{\eqref{eq:thm:lambda_substitution_free_variables}} =
    \bigcup_{\mathclap{x \in \op*{Free}(M)}} \op*{Free}(\sigma(x))
    =
    \bigcup_{\mathclap{x \in \op*{Free}(M) \setminus \set{ y }}} \overbrace{\op*{Free}(\sigma(x))}^{\set{ x }} \cup \op*{Free}(\overbrace{\sigma(y)}^L).
  \end{equation*}

  Otherwise,
  \begin{equation*}
    \op*{Free}(M[y \mapsto L])
    \reloset{\eqref{eq:thm:lambda_substitution_free_variables}} =
    \bigcup_{\mathclap{x \in \op*{Free}(M)}} \overbrace{\op*{Free}(\sigma(x))}^{\set{ x }}
    =
    \op*{Free}(M).
  \end{equation*}
\end{proof}

\begin{example}\label{ex:def:lambda_substitution}
  We list examples of \hyperref[def:lambda_substitution]{substitution} of \( \synlambda \)-terms:
  \begin{thmenum}
    \thmitem{ex:def:lambda_substitution/simultaneous} We start with an example where we analyze the abstraction rules in detail. Consider
    \begin{equation*}
      \parens[\Big]{ \qabs \synx (xyz) }[\synx \mapsto a, \syny \mapsto b, \synz \mapsto c].
    \end{equation*}

    We have \( \op*{Free}_\sigma(M) = \set{ b, c } \). Since \( \synx \) does not belong to this set, we must apply \eqref{eq:def:lambda_substitution/abstraction/direct}:
    \begin{equation*}
      \parens[\Big]{ \qabs \synx (xyz) }[\synx \mapsto a, \syny \mapsto b, \synz \mapsto c]
      =
      \qabs \synx \parens[\Big]{ (xyz)[\syny \mapsto b, \synz \mapsto c] }
      =
      \qabs \synx \synx b c.
    \end{equation*}

    \thmitem{ex:def:lambda_substitution/nested_noop} Consider the substitution \( \ref{eq:ex:def:untyped_lambda_term/combinator/k}[\syny \mapsto \synx] \). Since  \( K \) is a combinator, \fullref{thm:lambda_substitution_combinators} holds and \( K[\syny \mapsto \synx] = K \). We will show this explicitly:
    \begin{align*}
      K[\syny \mapsto \synx]
      &=
      (\qabs \synx \qabs \syny yx)[\syny \mapsto \synx]
      = \\ &=
      (\qabs \synx \qabs \syny yx)[\syny \mapsto \synx]
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/direct}} = \\ &=
      \qabs \synx \parens[\Big]{ (\qabs \syny yx)[\syny \mapsto \synx] }
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/direct}} = \\ &=
      \underbrace{\qabs \synx (\qabs \syny \syny \synx)}_{K}.
    \end{align*}

    \thmitem{ex:def:lambda_substitution/capture} The gist of \fullref{thm:lambda_substitution_free_variables} is that substitution avoids \enquote{capturing} free variables under the scope of some abstraction.

    Inappropriately using the rule \eqref{eq:def:lambda_substitution/abstraction/direct} in
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synx]
    \end{equation*}
    would give
    \begin{equation*}
      \qabs \synx (\synx \syny[\syny \mapsto \synx]) = \qabs \synx \synx \synx,
    \end{equation*}
    which \enquote{captures} the corresponding occurrence of \( \synx \) in the scope of the closest abstractor.

    The renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming} instead gives
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synx] = \qabs a (\synx \syny[\synx \mapsto a][\syny \mapsto \synx]) = \qabs a ax,
    \end{equation*}
    where \( a \) is the smallest suitable identifier.

    \thmitem{ex:def:lambda_substitution/ignoring} We discussed in \fullref{rem:renaming_substitution_rules} that we can ignore \eqref{eq:def:lambda_substitution/abstraction/direct} and always use the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming}.

    \Fullref{thm:lambda_substitution_combinators} would immediately fail:
    \begin{equation*}
      \ref{eq:ex:def:untyped_lambda_term/combinator/i}[\syny \mapsto \synz]
      =
      (\qabs \synx \synx)[\syny \mapsto \synz]
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/renaming}} =
      \qabs a (\synx[\synx \mapsto a][\syny \mapsto \synz])
      =
      \qabs a a.
    \end{equation*}

    In a slightly more complicated example where substitution is actually performed, we would obtain
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synz]
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/renaming}} =
      \qabs a (\synx \syny[\synx \mapsto a][\syny \mapsto \synz])
      =
      \qabs a a \synz
      =
      \qabs a a \synz.
    \end{equation*}
    rather than
    \begin{equation*}
      \qabs \synx \synx \synz.
    \end{equation*}
  \end{thmenum}
\end{example}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:untyped_lambda_term_alpha_equivalence}\mimprovised
  We say that the \( \synlambda \)-terms \( M \) and \( N \) are \( \alpha \)-\term{equivalent} and write \( M \aequiv N \) if any of the following conditions hold:
  \begin{thmenum}
    \thmitem{def:untyped_lambda_term_alpha_equivalence/variable} If both \( M = \synx = N \) for some variable \( \synx \).
    \thmitem{def:untyped_lambda_term_alpha_equivalence/application} If \( M = A B \) and \( N = C D \) and both \( A \aequiv C \) and \( B \aequiv D \).
    \thmitem{def:untyped_lambda_term_alpha_equivalence/abstraction} If \( M = \qabs a A \) and \( N = \qabs b B \) and \( A[a \mapsto c] \aequiv B[b \mapsto c] \) for every variable \( c \) free in neither \( A \) nor \( B \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Two terms are \( \alpha \)-equivalent if they are \enquote{essentially the same} in the sense that they differ only by the names of the variables bound by abstractors.

  \item \Fullref{thm:def:untyped_lambda_term_alpha_equivalence/matching_abstraction} gives us an additional rule that can be used for simplifying induction proofs. We choose not to include it, however.
\end{comments}

\begin{example}\label{ex:def:untyped_lambda_term_alpha_equivalence}
  We list examples of \hyperref[def:untyped_lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}:
  \begin{thmenum}
    \thmitem{ex:def:untyped_lambda_term_alpha_equivalence/combinator} The combinator \( \ref{eq:ex:def:untyped_lambda_term/combinator/i} \) has the same essential structure regardless of how we name its variables:
    \begin{equation*}
      I = \qabs \synx \synx \aequiv \qabs \syny \syny \aequiv \qabs {\syn a} \syn a \aequiv \cdots
    \end{equation*}

    \thmitem{ex:def:untyped_lambda_term_alpha_equivalence/freeing} In \fullref{ex:def:lambda_variable_freeness/both} we discussed how \( \synx \) is both bound and free in \( M = I \synx = (\qabs \synx \synx) \synx \).

    We can use the term \( M' = (\qabs \syny \syny) \synx \) instead, where all occurrences of \( \synx \) are free and all occurrences of \( \syny \) are bound.

    This is generalized by \fullref{alg:alpha_equivalent_term_with_distinct_variables}.
  \end{thmenum}
\end{example}

\begin{algorithm}\label{alg:alpha_equivalent_term_with_distinct_variables}
  Fix a \( \synlambda \)-term \( M \). We will build an \hyperref[def:untyped_lambda_term_alpha_equivalence]{\( \alpha \)-equivalent} term \( M' \) where the \hyperref[def:lambda_variable_freeness]{free and bound variables} are distinct.

  We will use the auxiliary function
  \begin{equation*}
    D(M, G) \coloneqq \begin{cases}
      M,                                          &M \in \op*{Var}, \\
      D(N, G) \thinspace D(K, G),                 &M = NK, \\
      \qabs y D(N, G \cup \set{ y })[x \mapsto y] &M = \qabs x N,
    \end{cases}
  \end{equation*}
  where \( G \) is a set of variables that should be avoided and \( y \not\in G \).

  We then simply define
  \begin{equation*}
    M' \coloneqq D(M, \op*{Free}(M)).
  \end{equation*}
\end{algorithm}

\paragraph{\( \beta \)-reduction}

\begin{definition}\label{def:beta_redex}\mcite[def. 1B1]{Hindley1997}
  A \( \beta \)-regex is a \( \synlambda \)-application whose first term is a \( \synlambda \)-abstraction, that is, a \( \synlambda \)-term of the form \( (\qabs x M) N \)
\end{definition}
