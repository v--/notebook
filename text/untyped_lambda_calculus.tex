\subsection{Untyped lambda calculus}\label{subsec:untyped_lambda_calculus}

\paragraph{Untyped \( \synlambda \)-terms}

\begin{definition}\label{def:lambda_term}\mimprovised
  We introduce \enquote{\( \synlambda \)-terms}, \enquote{\( \synlambda \)-applications} and \enquote{\( \synlambda \)-abstractions} via the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{variable}    {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{application} {\bnftsq{\( ( \)} \bnfsp \bnfpn{term} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{abstraction} {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term}        {\bnfpn{variable} \bnfor \bnfpn{application} \bnfor \bnfpn{abstraction}},
  \end{bnf*}
  where we have used variable identifier rules from \fullref{def:variable_identifier}.

  \begin{thmenum}
    \thmitem{def:lambda_term/var} We will denote by \( \op*{Var} \) the set of all \( \synlambda \)-variables.
    \thmitem{def:lambda_term/term} Similarly, we will denote by \( \op*{Term} \) the set of all \( \synlambda \)-terms.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item These notions are based on \cite[352]{Church1932}. It is not clear why has Church used \( \synlambda \) as part of the grammar.

  \item We need all the parentheses so that we can prove unambiguity in \fullref{thm:lambda_terms_are_unambiguous}. Informally, we will use the conventions from \fullref{rem:propositional_formula_parentheses} regarding parentheses.

  \item The dot is not strictly necessary, and was in fact not used in \incite{Church1932} where \( \synlambda \)-calculus was introduced. It later became standard to include it. Our main references --- \incite[1A1]{Hindley1997}, \incite[22]{Barendregt1984} and \incite[188]{Герасимов2011} --- all use it.
\end{comments}

\begin{proposition}\label{thm:lambda_terms_are_unambiguous}
  The grammar of \hyperref[def:lambda_term]{\( \synlambda \)-terms} is \hyperref[def:grammar_ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  Similarly to \fullref{thm:propositional_formulas_are_unambiguous}, the proof is again based on \fullref{ex:natural_number_arithmetic_grammar/unambiguous}.
\end{proof}

\begin{definition}\label{def:lambda_term_ast}
  We implicitly associate with each \( \synlambda \)-term \( M \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(M) \) defined as follows:
  \begin{thmenum}
    \thmitem{def:lambda_term_ast/variable} If \( M \) is a variable, let \( T(M) \) be the singleton tree with value \( M \).

    \thmitem{def:lambda_term_ast/application} If \( M = NK \), assuming we have already built \( T(N) \) and \( T(K) \), we obtain \( T(M) \) by joining them by a new root with value \( \cdot \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__lambda_term_ast}
    \end{equation*}

    \thmitem{def:lambda_term_ast/abstraction} If \( \varphi = \qabs x N \), assuming we have already built \( T(N) \), we obtain \( T(M) \) by adding a new root with value \( \qabs* x \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__lambda_term_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Formally our ASTs for abstractions are not ideal because we need to \enquote{parse} the string at the root. They are, however, convenient for defining variable occurrences in \fullref{def:lambda_variable_occurrence}, and are also easier to parse visually.
\end{comments}

\begin{remark}\label{rem:lambda_term_parentheses}
  We use some \enquote{abuse-of-notation} syntactic conventions somewhat resembling \fullref{rem:propositional_formula_parentheses}:
  \begin{thmenum}
    \thmitem{rem:lambda_term_parentheses/outermost} As in \fullref{rem:propositional_formula_parentheses/outermost}, we avoid writing the outermost parentheses in terms like \( (\synx \syny) \) or \( ((\synx \syny) \synz) \).

    \thmitem{rem:lambda_term_parentheses/abstraction} We generally avoid writing parentheses around \( \synlambda \)-abstractions.

    Actually, it is not necessary to put parentheses around \( \synlambda \)-abstractions in order for the grammar to be unambiguous. Not requiring them, however, leads to the following unintuitive artifact.

    Consider the term \( \qabs x y z \). If parentheses are required only for \( \synlambda \)-abstractions but not for \( \synlambda \)-applications, it would unambiguously correspond to the following \hyperref[rem:lambda_term_ast]{abstract syntax tree}:
    \begin{equation*}
      \includegraphics[page=1]{output/rem__lambda_term_parentheses}
    \end{equation*}

    But it is reasonable to expect instead the following tree:
    \begin{equation*}
      \includegraphics[page=2]{output/rem__lambda_term_parentheses}
    \end{equation*}

    Since we will generally expect the latter, it is simpler to require parentheses around \( \synlambda \)-abstractions in the formal syntax and then, when convenient, avoid writing them within the metalogic.

    \thmitem{rem:lambda_term_parentheses/left_associative} We suppose that \( \synlambda \)-application is \hyperref[rem:binary_operation_syntax_trees/associativity]{left-associative}, which allows us to simplify notation in some cases like \eqref{eq:ex:def:lambda_term/combinator/s}, where we use \( \synx \synz (\syny \synz) \) rather than \( (\synx \synz)(\syny \synz) \).
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:lambda_subterm}\mcite[def. 1A3]{Hindley1997}
  We define the set of all \term[ru=подтерм (\cite[189]{Герасимов2011})]{subterms} of a term \( M \) as follows:
  \begin{equation*}
    \op*{Subterm}(M) \coloneqq \begin{cases}
      \set{ M },                                             &M \in \op*{Var}, \\
      \set{ M } \cup \op*{Subterm}(N) \cup \op*{Subterm}(K), &M = N K, \\
      \set{ M } \cup \op*{Subterm}(N),                       &M = \qabs x N.
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item Note that the analog of \fullref{thm:propositional_formula_characterization} no longer holds --- a variable that is a substring of a term is not necessarily a subterm --- see \fullref{ex:def:lambda_term/naive_subterm}.
\end{comments}

\begin{proposition}\label{thm:lambda_subterm_characterization}
  Suppose that the \hyperref[def:formal_language/occurrence]{substring} \( N \) of the \( \synlambda \)-term \( M \) is \hi{not a variable}. Then \( N \) is a \hyperref[def:lambda_subterm]{subterm} of \( M \) if and only if \( N \) is itself a \( \synlambda \)-term.
\end{proposition}
\begin{proof}
  We can give a proof similar to \fullref{thm:propositional_formula_characterization}.
\end{proof}

\begin{example}\label{ex:def:lambda_term}
  We list examples of \hyperref[def:lambda_term]{\( \synlambda \)-terms}:
  \begin{thmenum}
    \thmitem{ex:def:lambda_term/var} The simplest \( \synlambda \)-terms are the variables themselves, for example \( \synx \) or \( \syny \).

    \thmitem{ex:def:lambda_term/naive_subterm} Suppose that, as in \fullref{def:propositional_subformula} for propositional subformulas, we say that \( N \) is a subterm of \( M \) if it is itself a \hyperref[def:formal_language/occurrence]{substring} of \( M \).

    Then the term \( \qabs \synx \syny \) would have both \( \synx \) and \( \syny \) as subterms, while according to \fullref{def:lambda_term/subterm}, only \( \syny \) is a subterm.

    \thmitem{ex:def:lambda_term/combinator}\mcite[def. 1A10.1]{Hindley1997} The following terms have established names:
    \begin{subequations}
      \begin{align}
        &\qabs \synx \synx, \label{eq:ex:def:lambda_term/combinator/i}\tag{I} \\
        &\qabs \synx \qabs \syny \synx, \label{eq:ex:def:lambda_term/combinator/k}\tag{K} \\
        &\qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz), \label{eq:ex:def:lambda_term/combinator/s}\tag{S} \\
        &\qabs \synx (\qabs \syny \synx \syny \syny) (\qabs \syny \synx \syny \syny). \label{eq:ex:def:lambda_term/combinator/y}\tag{Y} \\
      \end{align}

      They are combinators in the sense that will be defined in \fullref{def:lambda_combinator}, and are referred to as such. We will further discuss them in \fullref{ex:def:beta_eta_reduction}.

      Another useful family of combinators is the following, taken from \cite[3.1.21; 6.2.1]{Barendregt1984}:
      \begin{align}
        &\qabs \synx \synx^n, \label{eq:ex:def:lambda_term/combinator/omega_n}\tag{\ensuremath{ \omega_n }} \\
        &\qabs \synx \synx \synx, \label{eq:ex:def:lambda_term/combinator/omega_small}\tag{\ensuremath{ \omega }} \\
        &\omega \omega. \label{eq:ex:def:lambda_term/combinator/omega}\tag{\ensuremath{ \Omega }}
      \end{align}
    \end{subequations}
  \end{thmenum}
\end{example}

\paragraph{Variable scope}

\begin{definition}\label{def:lambda_variable_occurrence}\mcite[1A5; 16A]{Hindley1997}
  If an \hyperref[def:formal_language/occurrence]{occurrence} of \( x \) in \( M \) is prefixed by \( \synlambda \), it is part of some abstraction \( N = (\qabs x K) \). We call \( \qabs* x \) the \term{abstractor} of \( N \) and \( K \) --- the \term{body} of \( N \) or the \term[ru=область действия (\cite[64]{Герасимов2011})]{scope} of \( \qabs* x \).

  We divide non-abstractor occurrences of \( x \) into \term[ru=связанное (вхождение) (\cite[64]{Герасимов2011})]{bound occurrences}, which are in the scope of some abstractor \( \qabs* x \), and \term[ru=свободное (вхождение) (\cite[64]{Герасимов2011})]{free occurrences}, which are not.

  If an occurrence of \( x \) is free in \( K \) but bound in \( N = (\qabs x K) \), we say that the abstractor of \( N \) \term{binds} it.
\end{definition}

\begin{definition}\label{def:lambda_variable_freeness}\mcite[16A]{Hindley1997}
  We say that a variable \( \synx \) is \term{free} in a \( \synlambda \)-term \( M \) if \( \synx \) has at least one \hyperref[def:lambda_variable_occurrence]{free occurrence} in \( M \) and \term{bound} if it has a \hyperref[def:lambda_variable_occurrence]{bound occurrence} in \( M \).
\end{definition}
\begin{comments}
  \item We may use the recursive definitions from \fullref{thm:lambda_variable_freeness_characterization} instead.
\end{comments}

\begin{example}\label{ex:def:lambda_variable_freeness}
  We list examples of free and bound variables and variables occurrences:
  \begin{thmenum}
    \thmitem{ex:def:lambda_variable_freeness/abstractor} The term \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) has exactly one occurrence of \( \synx \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__lambda_variable_freeness}
    \end{equation*}

     This occurrence is bound in the term \( I \) and free in the subterm \( \synx \). Then \( \synx \) is a bound variable in \( I \) and a free variable in \( I \).

    \thmitem{ex:def:lambda_variable_freeness/both} The term \( M = I \synx = (\qabs \synx \synx) \synx \) has two occurrences of the variable \( \synx \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__lambda_variable_freeness}
    \end{equation*}

    One of the occurrences is free, which makes \( \synx \) a free variable of \( M \), and one of the occurrences if bound, which makes \( \synx \) a bound variable of \( M \).

    \thmitem{ex:def:lambda_variable_freeness/binds} In the term \( \qabs \synx \qabs \synx \synx \), only the second abstractor is binding for \( \synx \).
  \end{thmenum}
\end{example}

\begin{remark}\label{rem:barendregt_convention}\mcite[148]{Mimram2020}
  Although a variable can be both free and bound, we will avoid such cases as much as possible. This is called the \term{Barendregt convention} because it is stated by \incite[2.1.12]{Barendregt1984}.
\end{remark}

\begin{proposition}\label{thm:lambda_variable_freeness_characterization}
  The set of all \hyperref[def:lambda_variable_freeness]{free variables} of a \( \synlambda \)-term can be characterized as follows:
  \begin{equation*}
    \op*{Free}(M) \coloneqq \begin{cases}
      \set{ M },                         &M \in \op*{Var}, \\
      \op*{Free}(N) \cup \op*{Free}(K),  &M = N K, \\
      \op*{Free}(N) \setminus \set{ x }, &M = \qabs x N. \\
    \end{cases}
  \end{equation*}

  Similarly, the bound variables can be characterized via
  \begin{equation*}
    \op*{Bound}(M) \coloneqq \begin{cases}
      \varnothing,                        &M \in \op*{Var}, \\
      \op*{Bound}(N) \cup \op*{Bound}(K), &M = N K, \\
      \op*{Bound}(N) \cup \set{ x },      &M = \qabs x N. \\
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{proof}
  Straightforward.
\end{proof}

\begin{definition}\label{def:lambda_combinator}\mcite[def. 1A10]{Hindley1997}
  If a \( \synlambda \)-term has no \hyperref[def:lambda_variable_freeness]{free variables}, we say that it is \term{closed}. Closed terms are also called \term[ru=комбинаторы (\cite[188]{Герасимов2011})]{combinators}.
\end{definition}

\paragraph{Simultaneous substitution}

\begin{definition}\label{def:lambda_substitution}\mimprovised
  A \term{simultaneous substitution} of \( \synlambda \)-terms is a pair \( (\sigma, \sharp) \), where
  \begin{thmenum}[series=def:lambda_substitution]
    \thmitem{def:lambda_substitution/sigma} \( \sigma: \op*{Var} \to \op*{Term} \) is a function specifying how variables need to be replaced with terms. We allow only finitely many variables to not be fixed by \( \sigma \).

    \thmitem{def:lambda_substitution/sharp} \( \sharp: F \to \op*{Var} \), where \( F \) is the family of all variable contexts (i.e. finite subsets of \( \op*{Var} \)), is a function providing us with a fresh variable identifier not present in some given context.

    As discussed in \fullref{def:variable_identifier}, unless otherwise noted, will suppose that this function simply provides the smallest variable identifier with respect to the \hyperref[def:lexicographic_order]{reverse lexicographic order}.
  \end{thmenum}

  We will now use substitutions to define operations on all \( \synlambda \)-terms, but we will first need several auxiliary definitions:
  \begin{thmenum}[resume=def:lambda_substitution]
    \thmitem{def:lambda_substitution/modified} We will find useful the concept of \term{modifying} \( \sigma \) at \( x \) with \( y \):
    \begin{equation}\label{eq:def:lambda_substitution/modified}
      \sigma_{x \mapsto y}(u) \coloneqq \begin{cases}
        y,         &u = x, \\
        \sigma(u), &u \neq x.
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_substitution/free} In order to be able to define substitutions for arbitrary terms, we will also need the following auxiliary definition:
    \begin{equation}\label{eq:def:lambda_substitution/free}
      \op*{Free}_\sigma(M) \coloneqq \bigcup_{\mathclap{v \in \op*{Free}(M)}} \op*{Free}(\sigma(v)).
    \end{equation}

    \thmitem{def:lambda_substitution/operation} Finally, for an arbitrary \( \synlambda \)-term \( M \), we define the following operation (for which will use the notational convention from \fullref{rem:substitution_notation}):
    \begin{subequations}
      \begin{empheq}[left={M[\sigma]} \coloneqq \empheqlbrace]{align}
        &\sigma(M),                       &&M \in \op*{Var},                                      \label{eq:def:lambda_substitution/var} \\
        &N[\sigma] \thinspace K[\sigma],  &&M = NK,                                               \label{eq:def:lambda_substitution/application} \\
        &\qabs x N[\sigma_{x \mapsto x}], &&M = \qabs x N \T{and} x \not\in \op*{Free}_\sigma(M), \label{eq:def:lambda_substitution/abstraction/direct} \\
        &\qabs n N[\sigma_{x \mapsto n}], &&M = \qabs x N \T{and} x \in \op*{Free}_\sigma(M),     \label{eq:def:lambda_substitution/abstraction/renaming}
      \end{empheq}
      where \( n = \sharp(\op*{Free}(N) \cup \op*{Free}_\sigma(N)) \).
    \end{subequations}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item In \eqref{eq:def:lambda_substitution/abstraction/direct} we modify \( \sigma \) to fix \( x \), while in \eqref{eq:def:lambda_substitution/abstraction/renaming} we modify it to send \( x \) to \( n \). We will refer to the latter rule as \enquote{substitution with renaming}. Whenever it will be sufficient, \fullref{thm:lambda_substitution_single_rule} will allow us to compress them into one rule with a looser condition.

  \item This definition is loosely based on \cite[def. 1A7]{Hindley1997}, but is modified to allow substituting multiple variables. This results in less rules since \eqref{eq:def:lambda_substitution/abstraction/direct} subsumes three of the four cases. Furthermore, our substitution rules also allow proving \fullref{thm:lambda_substitution_noop}.
\end{comments}

\begin{remark}\label{rem:renaming_substitution_rules}
  The substitution rules for abstractions from \fullref{def:lambda_substitution} are adjusted so that \fullref{thm:lambda_substitution_free_variables} and \fullref{thm:lambda_substitution_noop} hold.

  The bare minimum we need is to avoid \enquote{variable capturing} as discussed in \fullref{ex:def:lambda_substitution/capture}. As we can see in the proof of \fullref{thm:lambda_substitution_free_variables}, the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming} is by itself sufficient for this. Thus, we may choose to always rename the abstractor variable.

  In practice, however, we would prefer to not rename bound variables, especially in \hyperref[def:lambda_combinator]{combinators}; the rule \eqref{eq:def:lambda_substitution/abstraction/direct} allow us to prove \fullref{thm:lambda_substitution_noop}.

  See \fullref{ex:def:lambda_substitution/ignoring} for concrete examples of ignoring the latter rule.
\end{remark}

\begin{proposition}\label{thm:lambda_substitution_restriction}
  For any \( \synlambda \)-term \( M \), if the substitutions \( \sigma \) and \( \rho \) agree on the free variables on \( M \), then \( M[\sigma] = M[\rho] \).
\end{proposition}
\begin{proof}
  Straightforward.
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_noop}
  As long as the free variables of the \( \synlambda \)-term \( M \) are fixed by the substitution \( \sigma \), we have \( M[\sigma] = M \).
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_syntax_trees} on \( M \) simultaneously for all substitutions that fix the free variables of \( M \):
  \begin{itemize}
    \item If \( M \) is a variable, then \( M[\sigma] = \sigma(M) = M \) by assumption.
    \item If \( M = NK \) and the inductive hypothesis holds for \( N \) and \( K \), then
    \begin{equation*}
      M[\sigma]
      \reloset {\eqref{eq:def:lambda_substitution/application}} =
      N[\sigma] \thinspace K[\sigma]
      \reloset {\T{ind.}} =
      N K
      =
      M.
    \end{equation*}

    \item Suppose that \( M = \qabs x N \) and the inductive hypothesis holds for \( N \).

    Aiming at a contradiction, suppose that \( x \) is in \( \op*{Free}_\sigma(M) \), that is, there exists a free variable \( y \) of \( M \) such that \( x \) is free in \( \sigma(y) \). But \( \sigma(v) = y \) by assumption, hence \( x = y \), which cannot be free in \( M \).

    Therefore, \( x \) is not in \( \op*{Free}_\sigma(M) \), and we must use the rule \eqref{eq:def:lambda_substitution/abstraction/direct}. The free variables of \( N \) are those of \( N \) with the eventual addition of \( x \), all of which are fixed by \( \sigma_{x \mapsto x} \). Hence,
    \begin{equation*}
      M[\sigma]
      =
      \qabs x N[\sigma_{x \mapsto x}]
      \reloset {\T{ind.}} =
      \qabs x N
      =
      M.
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_combinators}
  For any \hyperref[def:lambda_combinator]{combinator} \( M \) and any substitution \( \sigma \), we have \( M[\sigma] = M \).
\end{corollary}
\begin{proof}
  Vacuously follows from \fullref{thm:lambda_substitution_noop} since combinators simply have no free variables.
\end{proof}

\begin{proposition}\label{thm:lambda_substitution_free_variables}
  For any \( \synlambda \)-term \( M \) and any substitution \( \sigma \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables}
    \op*{Free}( M[\sigma] ) = \overbrace{\bigcup_{\mathclap{v \in \op*{Free}(M)}} \op*{Free}(\sigma(v))}^{\op*{Free}_\sigma(M)}.
  \end{equation}

  This also holds if we always use the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming}.
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_syntax_trees} on \( M \) simultaneously for all possible substitutions:
  \begin{itemize}
    \item If \( M \) is a variable, say \( M = x \), then \( \op*{Free}(M) = \set{ x } \) and thus
    \begin{equation*}
      \op*{Free}(M[\sigma])
      \reloset {\eqref{eq:def:lambda_substitution/var}} =
      \op*{Free}(\sigma(x)).
    \end{equation*}

    Hence, \eqref{eq:thm:lambda_substitution_free_variables} is satisfied.

    \item Suppose that \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \).

    We have
    \begin{equation*}
      \op*{Free}(M[\sigma])
      \reloset {\eqref{eq:def:lambda_substitution/application}} =
      \op*{Free}(N[\sigma] \thinspace K[\sigma])
      =
      \op*{Free}(N[\sigma]) \cup \op*{Free}(K[\sigma]).
    \end{equation*}

    Since, by definition, \( \op*{Free}(M) = \op*{Free}(N) \cup \op*{Free}(K) \), from the inductive hypothesis it follows that \eqref{eq:thm:lambda_substitution_free_variables} holds.

    \item Suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \). We have the following possibilities:
    \begin{itemize}
      \item Suppose first that \( x \not\in \op*{Free}_\sigma(M) \). We must thus use \eqref{eq:def:lambda_substitution/abstraction/direct}. We have
      \begin{align*}
        \op*{Free}(M[\sigma])
        &\reloset{\eqref{eq:def:lambda_substitution/abstraction/direct}} =
        \op*{Free}(\qabs x N[\sigma_{x \mapsto x}])
        = \\ &=
        \op*{Free}(N[\sigma_{x \mapsto x}]) \setminus \set{ x }
        \reloset{\T{ind.}} = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{v \in \op*{Free}(N)}} \op*{Free}(\sigma_{x \mapsto x}(v)) } \setminus \set{ x }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N)}} \parens[\Big]{ \op*{Free}(\sigma_{x \mapsto x}(v)) \setminus \set{ x } }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\underbrace{\sigma_{x \mapsto x}(v)}_{\sigma(v)}) \setminus \set{ x } } \cup \underbrace{\parens[\Big]{ \op*{Free}(\sigma_{x \mapsto x}(x)) \setminus \set{ x } }}_\varnothing.
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\sigma(v)) },
      \end{align*}
      where at the last step we have used that, for \( v \in \op*{Free}(N) \), \( x \) is free in \( \sigma(v) \) only when \( v = x \).

      This demonstrates \eqref{eq:thm:lambda_substitution_free_variables}.

      \item Otherwise, \( x \in \op*{Free}_\sigma(M) \), and we must use \eqref{eq:def:lambda_substitution/abstraction/renaming}. As discussed in \fullref{rem:renaming_substitution_rules}, the assumption itself is irrelevant for proving \eqref{eq:thm:lambda_substitution_free_variables}.

      Let \( n \) be the renamed abstractor variable. Then
      \begin{align*}
        \op*{Free}(M[\sigma])
        &=
        \op*{Free}(\qabs n N[x \mapsto n][\sigma])
        = \\ &=
        \op*{Free}(\qabs n N[\sigma_{x \mapsto n}])
        = \\ &=
        \op*{Free}(N[\sigma_{x \mapsto n}]) \setminus \set{ n }
        \reloset {\T{ind.}} = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{v \in \op*{Free}(N)}} \op*{Free}(\sigma_{x \mapsto n}(v)) } \setminus \set{ n }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N)}} \parens[\Big]{ \op*{Free}(\sigma_{x \mapsto n}(v)) \setminus \set{ n } }
        = \\ &=
        \parens[\Big]{ \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\underbrace{\sigma_{x \mapsto n}(v)}_{\sigma(v)}) \setminus \set{ n } } } \cup \parens[\Big]{ \underbrace{\op*{Free}(\sigma_{x \mapsto n}(x)) \setminus \set{ n }}_\varnothing }
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(N) \setminus \set{ x }}} \parens[\Big]{ \op*{Free}(\sigma(v)) \setminus \set{ x } },
        = \\ &=
        \bigcup_{\mathclap{v \in \op*{Free}(M) \setminus \set{ x }}} \op*{Free}(\sigma(v)),
      \end{align*}
      where in the last step we have used that \( n \) is not free in \( \sigma(v) \) because it does not, by definition, belong to \( \op*{Free}_\sigma(N) \).

      This demonstrates \eqref{eq:thm:lambda_substitution_free_variables}.
    \end{itemize}
  \end{itemize}

  The induction is complete.
\end{proof}

\begin{corollary}\label{thm:lambda_substitution_free_variables_single}
  For any \( \synlambda \)-terms \( M \) and \( L \) and any variable \( u \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables_single}
    \op*{Free}( M[u \mapsto L] ) = \begin{cases}
      \parens[\Big]{ \op*{Free}(M) \setminus \set{ u } } \cup \op*{Free}(L), &u \T{is free in} M \\
      \op*{Free}(M),                                                         &\T{otherwise.}
    \end{cases}
  \end{equation}

  In both cases,
  \begin{equation}\label{eq:thm:lambda_substitution_free_variables_single/subset}
    \op*{Free}( M[u \mapsto L] ) \subseteq \parens[\Big]{ \op*{Free}(M) \setminus \set{ u } } \cup \op*{Free}(L).
  \end{equation}
\end{corollary}
\begin{proof}
  Denote by \( \sigma \) the substitution sending \( u \) to \( L \). If \( u \) is free in \( M \), then
  \begin{equation*}
    \op*{Free}(M[u \mapsto L])
    \reloset{\eqref{eq:thm:lambda_substitution_free_variables}} =
    \bigcup_{\mathclap{v \in \op*{Free}(M)}} \op*{Free}(\sigma(v))
    =
    \bigcup_{\mathclap{v \in \op*{Free}(M) \setminus \set{ v }}} \overbrace{\op*{Free}(\sigma(v))}^{\set{ v }} \cup \op*{Free}(\overbrace{\sigma(v)}^L).
  \end{equation*}

  Otherwise,
  \begin{equation*}
    \op*{Free}(M[v \mapsto L])
    \reloset{\eqref{eq:thm:lambda_substitution_free_variables}} =
    \bigcup_{\mathclap{v \in \op*{Free}(M)}} \overbrace{\op*{Free}(\sigma(v))}^{\set{ v }}
    =
    \op*{Free}(M).
  \end{equation*}
\end{proof}

\begin{example}\label{ex:def:lambda_substitution}
  We list examples of \hyperref[def:lambda_substitution]{substitution} of \( \synlambda \)-terms:
  \begin{thmenum}
    \thmitem{ex:def:lambda_substitution/simultaneous} We start with an example where we analyze the abstraction rules in detail. Consider
    \begin{equation*}
      \parens[\Big]{ \qabs \synx (xyz) }[\synx \mapsto \syna, \syny \mapsto \synb, \synz \mapsto \sync].
    \end{equation*}

    We have \( \op*{Free}_\sigma(M) = \set{ b, c } \). Since \( \synx \) does not belong to this set, we must apply \eqref{eq:def:lambda_substitution/abstraction/direct}:
    \begin{equation*}
      \parens[\Big]{ \qabs \synx (xyz) }[\synx \mapsto \syna, \syny \mapsto \synb, \synz \mapsto \sync]
      =
      \qabs \synx \parens[\Big]{ (xyz)[\syny \mapsto \synb, \synz \mapsto \sync] }
      =
      \qabs \synx \synx \synb \sync.
    \end{equation*}

    \thmitem{ex:def:lambda_substitution/nested_noop} Consider the substitution \( \ref{eq:ex:def:lambda_term/combinator/k}[\syny \mapsto \synx] \). Since \( K \) is a combinator, \fullref{thm:lambda_substitution_combinators} holds and \( K[\syny \mapsto \synx] = K \). We will show this explicitly:
    \begin{align*}
      K[\syny \mapsto \synx]
      &=
      (\qabs \synx \qabs \syny \synx)[\syny \mapsto \synx]
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/direct}} = \\ &=
      \qabs \synx \parens[\Big]{ (\qabs \syny \synx)[\syny \mapsto \synx] }
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/direct}} = \\ &=
      \underbrace{\qabs \synx (\qabs \syny \synx)}_{K}.
    \end{align*}

    \thmitem{ex:def:lambda_substitution/capture} The gist of \fullref{thm:lambda_substitution_free_variables} is that substitution avoids \enquote{capturing} free variables under the scope of some abstraction.

    Inappropriately using the rule \eqref{eq:def:lambda_substitution/abstraction/direct} in
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synx]
    \end{equation*}
    would give
    \begin{equation*}
      \qabs \synx (\synx \syny[\syny \mapsto \synx]) = \qabs \synx \synx \synx,
    \end{equation*}
    which \enquote{captures} the corresponding occurrence of \( \synx \) in the scope of the closest abstractor.

    The renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming} instead gives
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synx] = \qabs \syna (\synx \syny[\synx \mapsto \syna][\syny \mapsto \synx]) = \qabs \syna \syna \synx.
    \end{equation*}

    \thmitem{ex:def:lambda_substitution/ignoring} We discussed in \fullref{rem:renaming_substitution_rules} that we can ignore \eqref{eq:def:lambda_substitution/abstraction/direct} and always use the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming}.

    \Fullref{thm:lambda_substitution_combinators} would immediately fail:
    \begin{equation*}
      \ref{eq:ex:def:lambda_term/combinator/i}[\syny \mapsto \synz]
      =
      (\qabs \synx \synx)[\syny \mapsto \synz]
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/renaming}} =
      \qabs \syna (\synx[\synx \mapsto \syna][\syny \mapsto \synz])
      =
      \qabs \syna \syna.
    \end{equation*}

    In a slightly more complicated example where substitution is actually performed, we would obtain
    \begin{equation*}
      (\qabs \synx \synx \syny)[\syny \mapsto \synz]
      \reloset {\eqref{eq:def:lambda_substitution/abstraction/renaming}} =
      \qabs \syna (\synx \syny[\synx \mapsto a][\syny \mapsto \synz])
      =
      \qabs \syna \syna \synz
      =
      \qabs \syna \syna \synz.
    \end{equation*}
    rather than
    \begin{equation*}
      \qabs \synx \synx \synz.
    \end{equation*}
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:lambda_substitution_single_rule}
  For any abstraction \( M = \qabs x N \) and substitution \( \sigma \), we have
  \begin{equation}\label{eq:thm:lambda_substitution_single_rule}
    M[\sigma] = \qabs v N[\sigma_{x \mapsto v}],
  \end{equation}
  where \( v \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]) \).
\end{proposition}
\begin{proof}
  We have two cases to consider:
  \begin{itemize}
    \item If \( x \in \op*{Free}_\sigma(M) \), we must use the renaming rule \eqref{eq:def:lambda_substitution/abstraction/renaming}. Let \( n \) be the renamed abstractor variable. Then
    \begin{equation*}
      M[\sigma] = \qabs n N[\sigma_{x \mapsto n}].
    \end{equation*}

    Furthermore, \( n \) is not in \( \op*{Free}(N) \cup \op*{Free}_\sigma(N) \) --- the first is a superset of \( \op*{Free}(M) \), and the second --- of \( \op*{Free}_\sigma(M) \).

    \item Otherwise, we must use \eqref{eq:def:lambda_substitution/abstraction/direct}:
    \begin{equation*}
      M[\sigma] = \qabs x N[\sigma_{x \mapsto x}].
    \end{equation*}

    The variable \( x \) is clearly not free in \( M \). Furthermore, we have assumed that \( x \not\in \op*{Free}_\sigma(M) \).
  \end{itemize}

  Finally, \fullref{thm:lambda_substitution_free_variables} implies that \( \op*{Free}_\sigma(M) = \op*{Free}(M[\sigma]) \).
\end{proof}

\paragraph{\( \alpha \)-equivalence}

\begin{definition}\label{def:lambda_term_alpha_equivalence}\mimprovised
  We will define an equivalence relation between \( \synlambda \)-terms via metalingual \hyperref[def:inference_rule]{inference rules}:

  \begin{TwoColumns}
    \begin{equation*}\taglabel[\( \logic{Var}_\alpha \)]{inf:def:lambda_term_alpha_equivalence/var}
      \begin{prooftree}
        \infer0[\ref{inf:def:lambda_term_alpha_equivalence/var}]{ x \aequiv x }
      \end{prooftree}
    \end{equation*}
  \BeginSecondColumn
    \begin{equation*}\taglabel[\( \logic{App}_\alpha \)]{inf:def:lambda_term_alpha_equivalence/app}
      \begin{prooftree}
        \hypo{ A \aequiv C }
        \hypo{ B \aequiv D }
        \infer2[\ref{inf:def:lambda_term_alpha_equivalence/app}]{ AB \aequiv CD }
      \end{prooftree}
    \end{equation*}
  \end{TwoColumns}

  \begin{equation*}\taglabel[\( \logic{Abs}_\alpha \)]{inf:def:lambda_term_alpha_equivalence/abs}
    \begin{prooftree}
      \hypo{ A[a \mapsto n] \aequiv B[b \mapsto n] \T{for every} n \not\in \op*{Free}(\qabs a A) }
      \infer1[\ref{inf:def:lambda_term_alpha_equivalence/abs}]{ \qabs a A \aequiv \qabs b B }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item The gist of \ref{inf:def:lambda_term_alpha_equivalence/abs} is that we want \( A[a \mapsto n] \aequiv B[a \mapsto n] \) to hold for every variable \( n \) that is not free in either \( A \) or \( B \), but we still want to allow \( n \) to be \( a \) or \( b \). We do not need a separate condition for \( n \) not to be free in \( \qabs b B \) because, as we will show in \fullref{thm:def:lambda_term_alpha_equivalence/free}, if \( \qabs a A \) and \( \qabs b B \) are equivalence per our definition, they have the same free variables.

  The assumption in the premise will help us immensely in inductive proofs, but it is impossible to mechanize. We will be able to split it into two simplified rules in \fullref{thm:alpha_equivalence_simplified}.

  \item Our rules resemble those in \cite[5]{Pollack1994}, with two notable differences, both of which allow us to simplify inductive proofs:
  \begin{itemize}
    \item We have restricted \ref{inf:def:lambda_term_alpha_equivalence/var} to variables only, while Pollack states the rule for general terms.
    \item We have generalized the premise in \ref{inf:def:lambda_term_alpha_equivalence/abs} to hold for all suitable variables simultaneously, and have allowed this variable to be \( a \) or \( b \).
  \end{itemize}

  \item \incite[2.1.11]{Barendregt1984} and \incite[1A8]{Hindley1997} call the successive renaming of bound variables \enquote{\( \alpha \)-conversion} and consider \( \synlambda \)-terms \enquote{up to \( \alpha \)-conversion}. Barendregt calls \enquote{\( \alpha \)-congruence} for what we call \( \alpha \)-equivalence, while Hindley says that \enquote{\( M \) \( \alpha \)-converts to \( N \)}.

  Some authors like \incite[5]{Pollack1994} use \enquote{\( \alpha \)-conversion} and \enquote{\( \alpha \)-equivalence} interchangeably.

  We will avoid using the term \enquote{\( \alpha \)-conversion}.

  \item The equivalence relation can be obtained via \fullref{thm:least_fixed_point_recursion}, similarly to what is described in \fullref{ex:fixed_point_recursion_for_relations}

  \item The rules themselves can be formalized by introducing \( \synlambda \)-term schemas and substitutions akin to how we have formalized the rules in \fullref{subsec:natural_deduction}, but we will find it unnecessarily complicated to do so.
\end{comments}

\begin{definition}\label{def:lambda_term_length}
  We give equivalent definitions of the \term{length} of a \( \synlambda \)-term:
  \begin{thmenum}
    \thmitem{def:lambda_term_length/string}\mcite[2.1.3]{Barendregt1984} We define \( \len(M) \) to be the \hyperref[def:alphabet/length]{string length} of \( M \).
    \thmitem{def:lambda_term_length/recursive} We recursively define
    \begin{equation*}
      \len(M) \coloneqq \begin{cases}
        1,                     &M \in \op*{Var}, \\
        2 + \len(N) + \len(K), &M = (NK), \\
        5 + \len(N),           &M = (\qabs x N). \\
      \end{cases}
    \end{equation*}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The recursive definition resembles that by \incite[1A2]{Hindley1997}, but we also account for parentheses, dots and \( \synlambda \) itself.
  \item We have introduced this concept mostly for proofs like that of \fullref{thm:def:lambda_term_alpha_equivalence/equivalence} so that the inductive hypothesis holds simultaneously for all terms of the same length.
\end{comments}

\begin{definition}\label{def:lambda_renaming}
  We say that the \hyperref[def:lambda_substitution]{substitution} \( \sigma \) is a \term{renaming substitution} if \( \sigma(x) \) is a variable for every \( x \).
\end{definition}
\begin{comments}
  \item The definition is based on \cite[252]{Mimram2020}, but restated for \( \synlambda \)-terms.
\end{comments}

\begin{proposition}\label{thm:def:lambda_term_length}
  \( \synlambda \)-terms have the following basic properties regarding their \hyperref[def:lambda_term_length]{length}:
  \begin{thmenum}
    \thmitem{thm:def:lambda_term_length/subterm} Every strict subterm of a \( \synlambda \)-term is strictly shorter.

    \thmitem{thm:def:lambda_term_length/substitution} For any substitution \( \sigma \) and \( \synlambda \)-term \( M \), we have
    \begin{equation}\label{eq:thm:def:lambda_term_length/substitution}
      \len(M[\sigma]) = \len(M) + \sum_{\mathclap{u \in \op*{Free}(M)}} (\len(\sigma(u)) - 1).
    \end{equation}

    In particular, if \( \sigma \) is a \hyperref[def:lambda_renaming]{renaming substitution}, then \( \len(M[\sigma]) = \len(M) \).

    \thmitem{thm:def:lambda_term_length/equivalent} \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent}  \( \synlambda \)-terms have the same length.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:lambda_term_length/subterm} Trivial.

  \SubProofOf{thm:def:lambda_term_length/substitution} We proceed via \fullref{thm:induction_on_syntax_trees} on \( M \), simultaneously on all substitutions.
  \begin{itemize}
    \item If \( M \) is a variable, then
    \begin{equation*}
      \len(M[\sigma]) = \len(\sigma(M)) = \len(M) + (\len(\sigma(M)) - \underbrace{\len(M)}_1).
    \end{equation*}

    \item If \( M = NK \), where the inductive hypothesis holds for \( N \) and \( K \), we have
    \begin{balign*}
      \len(M[\sigma])
      &=
      \len(N[\sigma] K[\sigma])
      = \\ &=
      2 + \len(N[\sigma]) + \len(K[\sigma])
      \reloset {\T{ind.}} = \\ &=
      2 + \len(N) + \sum_{\mathclap{u \in \op*{Free}(N)}} (\len(\sigma(u)) - 1) + \len(K) + \sum_{\mathclap{u \in \op*{Free}(K)}} (\len(\sigma(u)) - 1)
      = \\ &=
      2 + \len(N) + \len(K) + \sum_{\mathclap{u \in \op*{Free}(NK)}} (\len(\sigma(u)) - 1)
      = \\ &=
      \len(NK) + \sum_{\mathclap{u \in \op*{Free}(NK)}} (\len(\sigma(u)) - 1).
    \end{balign*}

    \item Finally, if \( M = \qabs x N \), where the inductive hypothesis holds for \( N \), \fullref{thm:lambda_substitution_single} implies that
    \begin{equation*}
      M[\sigma] = \qabs v N[\sigma_{x \mapsto v}],
    \end{equation*}
    where \( v \not\in \op*{Free}(N) \cup \op*{Free}(N[\sigma]) \).

    Then
    \begin{balign*}
      \len(M[\sigma])
      &=
      5 + \len(N[\sigma_{x \mapsto u}])
      \reloset {\T{ind.}} = \\ &=
      5 + \len(N) + \sum_{\mathclap{u \in \op*{Free}(N)}} (\len(\sigma_{x \mapsto v}(u)) - 1)
      = \\ &=
      5 + \len(N) + \sum_{\mathclap{u \in \op*{Free}(N) \setminus \set{ x }}} (\len(\sigma(u)) - 1) + (\len(v) - 1)
      = \\ &=
      \len(M) + \sum_{\mathclap{u \in \op*{Free}(M)}} (\len(\sigma(u)) - 1).
    \end{balign*}
  \end{itemize}

  \SubProofOf{thm:def:lambda_term_length/equivalent} Straightforward considering \fullref{thm:def:lambda_term_length/substitution}.
\end{proof}

\begin{proposition}\label{thm:def:lambda_term_alpha_equivalence}
  \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence} of \( \synlambda \)-terms has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:lambda_term_alpha_equivalence/same_kind} If two \( \synlambda \)-terms are \( \alpha \)-equivalent, they are both either variables, applications or abstractions.

    \thmitem{thm:def:lambda_term_alpha_equivalence/free} The free variables of \( \alpha \)-equivalent \( \synlambda \)-terms coincide.

    \thmitem{thm:def:lambda_term_alpha_equivalence/equivalence} \( \alpha \)-equivalence is an \hyperref[def:equivalence_relation]{equivalence relation}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:lambda_term_alpha_equivalence/same_kind} Follows by inspecting the conclusions of the rules in \fullref{def:lambda_term_alpha_equivalence}.

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/free} We proceed via induction on the length of \( M \) to show that, if \( M \aequiv N \), then the free variables of \( M \) and \( N \) coincide.

  No term has length \( 0 \). If \( M \) has length \( 1 \), it is necessarily a variable, and, the only rule that allows us to conclude that \( M \aequiv N \) is \ref{inf:def:lambda_term_alpha_equivalence/var}, and it is satisfied only if \( M = N \). Then \( \op*{Free}(M) = \set{ M } = \set{ N } = \op*{Free}(N) \).

  If the length of \( M \) is strictly greater than \( 1 \), we have the following possibilities:
  \begin{itemize}
    \item If \( M = AB \), the rule \ref{inf:def:lambda_term_alpha_equivalence/app} is applicable if \( N \) is also an application, say \( N = CD \), and if both \( A \aequiv C \) and \( B \aequiv D \). Then
    \begin{equation*}
      \op*{Free}(M)
      =
      \op*{Free}(A) \cup \op*{Free}(B)
      \reloset{\T{ind.}} =
      \op*{Free}(C) \cup \op*{Free}(D)
      =
      \op*{Free}(N).
    \end{equation*}

    \item Otherwise, we have \( M = \qabs a A \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( N = \qabs b B \), where in particular \( A = A[a \mapsto a] \aequiv B[b \mapsto a] \). Then
    \begin{align*}
      \op*{Free}(\qabs a A)
      &=
      \op*{Free}(A) \setminus \set{ a }
      \reloset {\eqref{eq:thm:lambda_substitution_free_variables}} = \\ &=
      \op*{Free}(A[a \mapsto a]) \setminus \set{ a }
      \reloset{\T{ind.}} = \\ &=
      \op*{Free}(B[b \mapsto a]) \setminus \set{ a }
      \reloset {\eqref{eq:thm:lambda_substitution_free_variables}} = \\ &=
      \op*{Free}(B) \setminus \set{ b }
      = \\ &=
      \op*{Free}(\qabs b B).
    \end{align*}
  \end{itemize}

  \SubProofOf{thm:def:lambda_term_alpha_equivalence/equivalence}

  \SubProofOf*[def:binary_relation/reflexivity]{reflexivity} We proceed via \fullref{thm:induction_on_syntax_trees} on the \( \synlambda \)-term \( M \) to show that \( M \aequiv N \) whenever \( M = N \).
  \begin{itemize}
    \item If \( M \) is a variable, the rule \ref{inf:def:lambda_term_alpha_equivalence/var} directly implies that \( M \aequiv M \).
    \item If \( M = AB \) and the inductive hypothesis holds for \( A \) and \( B \), then \( A \aequiv A \) and \( B \aequiv B \), and the rule \ref{inf:def:lambda_term_alpha_equivalence/app} implies that \( M \aequiv M \).
    \item If \( M = \qabs x N \) and if the inductive hypothesis holds for \( N \), then \( N \aequiv N \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( M \aequiv M \).
  \end{itemize}

  \SubProofOf*[def:binary_relation/symmetric]{symmetry} We will use induction on the length of \( M \) to show that \( M \aequiv N \) implies \( N \aequiv M \).

  There are no terms of length \( 0 \), so symmetry holds vacuously. A term of length \( 1 \) is necessarily a variable, and the rule \ref{inf:def:lambda_term_alpha_equivalence/var} implies that \( \alpha \)-equivalent variables are equal. Hence, symmetry holds for terms of length \( 1 \).

  For terms strictly longer than \( 1 \) symbol, we have two possibilities:
  \begin{itemize}
    \item Suppose first that \( M = AB \). Then, if \( M \aequiv N \), \ref{inf:def:lambda_term_alpha_equivalence/app} implies that \( N = CD \), where \( A \aequiv C \) and \( B \aequiv D \).

    By the inductive hypothesis, \( C \aequiv A \) and \( D \aequiv B \). Applying \ref{inf:def:lambda_term_alpha_equivalence/app}, we conclude that \( N \aequiv M \).

    \item Otherwise, we have \( M = \qabs a A \). The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} implies that \( N = \qabs b B \) and, for every variable not in \( M \), \( A[a \mapsto n] \aequiv B[b \mapsto n] \).

    By \fullref{thm:def:lambda_term_length/substitution}, \( A[a \mapsto n] \) has the same length as \( A \), thus the inductive hypothesis holds for the former. Then \( B[b \mapsto n] \aequiv A[a \mapsto n] \).

    Furthermore, \fullref{thm:def:lambda_term_alpha_equivalence/free} implies that \( n \) is not free in \( N \), so we can apply \ref{inf:def:lambda_term_alpha_equivalence/abs} to obtain \( N \aequiv M \).
  \end{itemize}

  \SubProofOf*[def:binary_relation/transitive]{transitivity} We will use induction on the length of \( M \) that \( M \aequiv N \) and \( N \aequiv K \) imply \( M \aequiv K \).

  The base case and the case where \( M \) is an application are straightforward. For the remaining case, suppose that \( M = \qabs a A \), so that \( N = \qabs b B \) and \( K = \qabs c C \).

  Fix a variable \( n \) not free in \( M \). \Fullref{thm:def:lambda_term_alpha_equivalence/free} implies that \( n \) is also not free in \( N \). Then \( A[a \mapsto n] \aequiv B[b \mapsto n] \) and \( B[b \mapsto n] \aequiv C[c \mapsto n] \).

  The inductive hypothesis applies to \( A \), hence also to \( A[a \mapsto n] \), therefore
  \begin{equation*}
    A[a \mapsto n] \aequiv C[c \mapsto n].
  \end{equation*}

  We conclude via \ref{inf:def:lambda_term_alpha_equivalence/abs} that \( M \aequiv K \).
\end{proof}

\begin{example}\label{ex:def:lambda_term_alpha_equivalence}
  We list examples of \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}:
  \begin{thmenum}
    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/combinator} The combinator \( \ref{eq:ex:def:lambda_term/combinator/i} \) has the same essential structure regardless of how we name its variables:
    \begin{equation*}
      I = \qabs \synx \synx \aequiv \qabs \syny \syny \aequiv \qabs \syna \syna \aequiv \cdots
    \end{equation*}

    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/nested} Consider a more complicated case:
    \begin{equation*}
      \qabs \synx \qabs \syny \synx \syny
      \T{and}
      \qabs \syny \qabs \synx \syny \synx.
    \end{equation*}

    In the notation of \ref{inf:def:lambda_term_alpha_equivalence/abs}, we have
    \begin{equation*}
      \qabs {\underbrace{\synx}_a} \underbrace{\qabs \syny \synx \syny}_A
      \T{and}
      \qabs {\underbrace{\syny}_b} \underbrace{\qabs \synx \syny \synx}_B.
    \end{equation*}

    We reduce our \( \alpha \)-equivalence check to \( A[a \mapsto n] \) and \( B[b \mapsto n] \) (note that the bound variables were renamed to \( \syna \) in both):
    \begin{equation*}
      \qabs {\underbrace{\syna}_c} \underbrace{n \syna}_C
      \T{and}
      \qabs {\underbrace{\syna}_d} \underbrace{n \syna}_D.
    \end{equation*}

    We further reduce our check to \( C[\syna \mapsto m] = nm \) and \( D[\syna \mapsto m] = nm \). The rule \ref{inf:def:lambda_term_alpha_equivalence/app} allows us to reduce this problem to checking whether \( n \aequiv n \) and \( m \aequiv m \), while \ref{inf:def:lambda_term_alpha_equivalence/var} confirms that the latter equivalences hold. Therefore, our entire verification is correct and
    \begin{equation*}
      \qabs \synx \qabs \syny \synx \syny \aequiv \qabs \syny \qabs \synx \syny \synx.
    \end{equation*}

    \thmitem{ex:inf:def:lambda_term_alpha_equivalence/freeing} In \fullref{ex:def:lambda_variable_freeness/both} we discussed how \( \synx \) is both bound and free in \( M = I \synx = (\qabs \synx \synx) \synx \).

    We can use the term \( M' = (\qabs \syny \syny) \synx \) instead, where all occurrences of \( \synx \) are free and all occurrences of \( \syny \) are bound.

    This is generalized by \fullref{alg:separation_of_free_and_bound_variables}.
  \end{thmenum}
\end{example}

\paragraph{Invariance of \( \alpha \)-equivalence under substitution}

\begin{lemma}\label{thm:renaming_composition_is_alpha_equivalent}
  For the composite substitution \( \rho\sigma(u) \coloneqq \sigma(u)[\rho] \) of the \hyperref[def:lambda_renaming]{renaming substitutions} \( \sigma \) and \( \rho \), we have
  \begin{equation}\label{eq:thm:renaming_composition_is_alpha_equivalent}
    M[\rho\sigma] \aequiv M[\sigma][\rho].
  \end{equation}
\end{lemma}
\begin{comments}
  \item We will use this to prove \fullref{thm:renaming_on_alpha_equivalent_terms}, which will later be used to prove the generalization \fullref{thm:substitution_composition_is_alpha_equivalent} to non-renaming substitutions.
\end{comments}
\begin{proof}
  We will use induction on the length of \( M \) simultaneously on all substitutions.

  The base case and the case where \( M \) is an application are straightforward. For the remaining case, suppose that \( M = \qabs x N \). We will utilize \fullref{thm:lambda_substitution_single_rule} thrice:
  \begin{align*}
    M[\rho\sigma]   &= \qabs u N[\rho\sigma_{x \mapsto u}],                 &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\rho\sigma]), \\
    M[\sigma]       &= \qabs v N[\sigma_{x \mapsto v}],                     &&v \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
    M[\sigma][\rho] &= \qabs w N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}], &&w \not\in \op*{Free}(M[\sigma]) \cup \op*{Free}(M[\sigma][\rho]).
  \end{align*}

  Fix a variable \( n \) not free in \( M[\rho\sigma] \) and denote by \( \pi \) the composite of \( \rho\sigma_{x \mapsto u} \) and \( u \mapsto n \). The inductive hypothesis gives us
  \begin{equation*}
    N[\rho\sigma_{x \mapsto u}][u \mapsto n] \aequiv N[\pi].
  \end{equation*}

  Since \( u \) is not free in \( M \) nor in \( M[\rho\sigma] \), its only occurrences in \( N[\rho\sigma_{x \mapsto u}] \) are those where \( x \) has been substituted for it. \Fullref{thm:lambda_substitution_restriction} then implies that
  \begin{equation*}
    N[\pi] = N[\rho\sigma_{x \mapsto n}],
  \end{equation*}
  and the inductive hypothesis on \( N \) allows us to conclude that
  \begin{equation}\label{eq:thm:renaming_composition_is_alpha_equivalent/proof/composite}
    N[\rho\sigma_{x \mapsto u}][u \mapsto n] \aequiv N[\rho\sigma_{x \mapsto n}].
  \end{equation}

  Since \( \sigma \) is a renaming, \fullref{thm:def:lambda_term_length/substitution} implies that \( N[\sigma_{x \mapsto v}] \) has the same length as \( N \), thus the inductive hypothesis holds for the former. Then
  \begin{equation*}
    N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}][w \mapsto n] \aequiv N[\sigma_{x \mapsto v}][\rho_{v \mapsto n}].
  \end{equation*}

  Via the inductive hypothesis on \( N \), we can further simplify this and obtain
  \begin{equation}\label{eq:thm:renaming_composition_is_alpha_equivalent/proof/repeated}
    N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}][w \mapsto n] \aequiv N[\rho\sigma_{x \mapsto n}].
  \end{equation}

  Combining \eqref{eq:thm:renaming_composition_is_alpha_equivalent/proof/composite} and \eqref{eq:thm:renaming_composition_is_alpha_equivalent/proof/repeated} allows us to conclude that \( M[\rho\sigma] \aequiv M[\sigma][\rho] \).
\end{proof}

\begin{lemma}\label{thm:renaming_on_alpha_equivalent_terms}
  If \( M \aequiv N \), for any \hyperref[def:lambda_renaming]{renaming substitution} \( \sigma \), we have \( M[\sigma] \aequiv N[\sigma] \).
\end{lemma}
\begin{comments}
  \item We will use this to prove \fullref{thm:renaming_on_alpha_equivalent_terms}, which will later be used to prove the generalization \fullref{thm:substitution_on_alpha_equivalent_terms} to non-renaming substitutions.
\end{comments}
\begin{proof}
  We will use induction on the length of \( M \) simultaneously on all substitutions.

  Again, the base case and the case where \( M \) is an application are straightforward. For the remaining case, suppose that \( M = \qabs a A \), so that \( N = \qabs b B \). We will utilize \fullref{thm:lambda_substitution_single_rule} twice:
  \begin{align*}
    M[\sigma] &= \qabs u A[\sigma_{a \mapsto u}], &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
    N[\sigma] &= \qabs v B[\sigma_{b \mapsto v}], &&v \not\in \op*{Free}(N) \cup \op*{Free}(N[\sigma]).
  \end{align*}

  Since \( a \) is not free in \( M \), from \( M \aequiv N \) we conclude that \( A[a \mapsto a] \aequiv B[a \mapsto b] \), where \( A[a \mapsto a] = A \) as a consequence of \fullref{thm:lambda_substitution_noop}.

  Applying the inductive hypothesis to \( A \), we can conclude that
  \begin{equation*}
    A[\sigma_{a \mapsto u}] \aequiv B[b \mapsto a][\sigma_{a \mapsto u}].
  \end{equation*}

  Furthermore, from \fullref{thm:renaming_composition_is_alpha_equivalent} it follows that
  \begin{equation*}
    B[b \mapsto a][\sigma_{a \mapsto u}] \aequiv B[\sigma_{b \mapsto u}]
  \end{equation*}
  and
  \begin{equation*}
    B[\sigma_{b \mapsto u}] \aequiv B[\sigma_{b \mapsto v}][v \mapsto u].
  \end{equation*}

  Fix a variable \( n \) not free in \( M[\sigma] \). Since \( \sigma \) is a renaming, the inductive hypothesis holds for \( A[\sigma_{a \mapsto u}] \). Then
  \begin{equation*}
    A[\sigma_{a \mapsto u}][u \mapsto n]
    \reloset {\T{ind.}} \aequiv
    B[\sigma_{b \mapsto v}][v \mapsto u][u \mapsto n].
  \end{equation*}

  If \( u = v \), \fullref{thm:lambda_substitution_restriction} implies that
  \begin{equation*}
    B[\sigma_{b \mapsto v}][v \mapsto u] = B[\sigma_{b \mapsto u}],
  \end{equation*}
  thus \fullref{thm:renaming_composition_is_alpha_equivalent} implies that
  \begin{equation*}
    \underbrace{B[\sigma_{b \mapsto v}][v \mapsto u]}_{B[\sigma_{b \mapsto u}]}[u \mapsto n] = B[\sigma_{b \mapsto v}][v \mapsto n].
  \end{equation*}

  Otherwise, the same conclusion follows from \fullref{thm:renaming_composition_is_alpha_equivalent} directly:
  \begin{equation*}
    B[\sigma_{b \mapsto v}]\underbrace{[v \mapsto u][u \mapsto n]}_{[v \mapsto n]} = B[\sigma_{b \mapsto v}][v \mapsto n].
  \end{equation*}

  Therefore,
  \begin{equation*}
    A[\sigma_{a \mapsto u}][u \mapsto n]
    \aequiv
    B[\sigma_{a \mapsto v}][v \mapsto n]
  \end{equation*}
  and \ref{inf:def:lambda_term_alpha_equivalence/abs} allows us to conclude that \( M[\sigma] \aequiv N[\sigma] \).
\end{proof}

\begin{proposition}\label{thm:substitution_composition_is_alpha_equivalent}
  For the composite substitution \( \rho\sigma(u) \coloneqq \sigma(u)[\rho] \), we have
  \begin{equation}\label{eq:thm:substitution_composition_is_alpha_equivalent}
    M[\rho\sigma] \aequiv M[\sigma][\rho].
  \end{equation}
\end{proposition}
\begin{comments}
  \item This result generalizes \fullref{thm:renaming_composition_is_alpha_equivalent} to arbitrary substitutions.
\end{comments}
\begin{proof}
  We can follow the proof of \fullref{thm:renaming_composition_is_alpha_equivalent} until the point where we use that \( \sigma \) and \( \rho \) are renaming substitutions.

  In short, we are following induction on the length of \( M \), and in the case where \( M = \qabs x N \) we have
  \begin{align*}
    M[\rho\sigma]   &= \qabs u N[\rho\sigma_{x \mapsto u}],                 &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\rho\sigma]), \\
    M[\sigma]       &= \qabs v N[\sigma_{x \mapsto v}],                     &&v \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
    M[\sigma][\rho] &= \qabs w N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}], &&w \not\in \op*{Free}(M[\sigma]) \cup \op*{Free}(M[\sigma][\rho]).
  \end{align*}

  Fix again a variable \( n \) not free in \( M[\rho\sigma] \). In \fullref{thm:substitution_composition_is_alpha_equivalent} we have used the inductive hypothesis on \( N \) directly to conclude \eqref{eq:thm:renaming_composition_is_alpha_equivalent/proof/composite}, which we will restate here for convenience:
  \begin{equation}\label{eq:thm:substitution_composition_is_alpha_equivalent/proof/composite}
    N[\rho\sigma_{x \mapsto u}][u \mapsto n] \aequiv N[\rho\sigma_{x \mapsto n}].
  \end{equation}

  On the other hand, we can no longer apply the inductive hypothesis to \( N[\sigma_{x \mapsto v}] \) to conclude \eqref{eq:thm:renaming_composition_is_alpha_equivalent/proof/repeated}. Instead, we will start by applying the hypothesis to \( N \) to obtain
  \begin{equation*}
    N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}] \aequiv N[\rho\sigma_{x \mapsto w}]
  \end{equation*}
  and then \fullref{thm:renaming_on_alpha_equivalent_terms} to obtain
  \begin{equation*}
    N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}][w \mapsto n] \aequiv N[\rho\sigma_{x \mapsto w}][w \mapsto n].
  \end{equation*}

  We can now apply the inductive hypothesis to \( N \) for the third time to simplify the right-hand side and obtain
  \begin{equation}\label{eq:thm:substitution_composition_is_alpha_equivalent/proof/repeated}
    N[\sigma_{x \mapsto v}][\rho_{v \mapsto w}][w \mapsto n] \aequiv N[\rho\sigma_{x \mapsto n}].
  \end{equation}

  Finally, we can combine \eqref{eq:thm:substitution_composition_is_alpha_equivalent/proof/composite} and \eqref{eq:thm:substitution_composition_is_alpha_equivalent/proof/repeated} to conclude that \( M[\rho\sigma] \aequiv M[\sigma][\rho] \) via \ref{inf:def:lambda_term_alpha_equivalence/abs}.
\end{proof}

\begin{corollary}\label{thm:substitution_chain_contraction}
  If \( y \) is not free in \( M \), then, for any substitution \( \sigma \), we have
  \begin{equation}\label{eq:thm:substitution_chain_contraction/contraction}
    M[x \mapsto y][\sigma_{y \mapsto z}]
    \aequiv
    M[\sigma_{x \mapsto z}]
    \aequiv
    M[\sigma_{x \mapsto y}][y \mapsto z].
  \end{equation}
\end{corollary}
\begin{comments}
  \item We have already used a similar argument, but not we can state it in our desired generality.
\end{comments}
\begin{proof}
  Follows from \fullref{thm:substitution_composition_is_alpha_equivalent} by noting that \( y \) is not free in \( M \).
\end{proof}

\begin{proposition}\label{thm:substitution_on_alpha_equivalent_terms}
  If \( M \aequiv N \), for an \hyperref[def:lambda_substitution]{arbitrary substitution} \( \sigma \), we have \( M[\sigma] \aequiv N[\sigma] \).
\end{proposition}
\begin{comments}
  \item This result generalizes \fullref{thm:renaming_on_alpha_equivalent_terms} to arbitrary substitutions.
\end{comments}
\begin{proof}
  We can follow the proof of \fullref{thm:renaming_on_alpha_equivalent_terms} until the point where we use that \( \sigma \) and \( \rho \) are renaming substitutions.

  In short, we are following induction on the length of \( M \), and in the case where \( M = \qabs a A \) and \( N = \qabs b B \) and
  \begin{align*}
    M[\sigma] &= \qabs u A[\sigma_{a \mapsto u}], &&u \not\in \op*{Free}(M) \cup \op*{Free}(M[\sigma]), \\
    N[\sigma] &= \qabs v B[\sigma_{b \mapsto v}], &&v \not\in \op*{Free}(N) \cup \op*{Free}(N[\sigma]).
  \end{align*}

  Since \( M \aequiv N \), we can conclude, as in our proof of \fullref{thm:renaming_on_alpha_equivalent_terms}, that
  \begin{equation*}
    A \aequiv B[b \mapsto a].
  \end{equation*}

  Again, fix a variable \( n \) not free in \( M[\sigma] \). We can use the inductive hypothesis that
  \begin{equation*}
    A[\sigma_{a \mapsto n}] \aequiv B[b \mapsto a][\sigma_{a \mapsto n}].
  \end{equation*}

  This already differs from our proof of \fullref{thm:renaming_on_alpha_equivalent_terms} in that we modify \( \sigma \) via \( a \mapsto n \) rather than \( a \mapsto u \).

  We can use \fullref{thm:substitution_chain_contraction} to simplify the right-hand side and obtain
  \begin{equation*}
    A[\sigma_{a \mapsto n}] \aequiv B[\sigma_{b \mapsto n}]
  \end{equation*}
  and then again to expand both sides:
  \begin{equation*}
    A[\sigma_{a \mapsto u}][u \mapsto n] \aequiv B[\sigma_{b \mapsto v}][v \mapsto n].
  \end{equation*}

  Therefore, via \ref{inf:def:lambda_term_alpha_equivalence/abs} we can conclude that \( M[\sigma] \aequiv N[\sigma] \).
\end{proof}

\paragraph{Mechanizing \( \alpha \)-equivalence}

\begin{proposition}\label{thm:alpha_equivalence_simplified}
  The rule \ref{inf:def:lambda_term_alpha_equivalence/abs}, specifying when two abstractions are \( \alpha \)-equivalent, is equivalent to the following pair of rules:
  \begin{equation*}\taglabel[\( \logic{Lift}_\alpha \)]{inf:thm:alpha_equivalence_simplified/lift}
    \begin{prooftree}
      \hypo{ A \aequiv B }
      \infer1[\ref{inf:thm:alpha_equivalence_simplified/lift}]{ \qabs x A \aequiv \qabs x B }
    \end{prooftree}
  \end{equation*}

  \begin{equation*}\taglabel[\( \logic{Ren}_\alpha \)]{inf:thm:alpha_equivalence_simplified/ren}
    \begin{prooftree}
      \hypo{ a \neq b }
      \hypo{ a \not\in \op*{Free}(B) }
      \hypo{ A \aequiv B[b \mapsto a] }
      \infer3[\ref{inf:thm:alpha_equivalence_simplified/ren}]{ \qabs a A \aequiv \qabs b B }
    \end{prooftree}
  \end{equation*}
\end{proposition}
\begin{proof}
  \SufficiencySubProof We will show that \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren} are \hyperref[con:inference_rule_admissibility]{admissible} with respect to \ref{inf:def:lambda_term_alpha_equivalence/abs}.

  \SubProof*{Proof that \ref{inf:thm:alpha_equivalence_simplified/lift} is admissible} Fix a variable \( x \) and terms \( A \aequiv B \). Let \( n \) be any variable not free in \( \qabs x A \). \Fullref{thm:substitution_on_alpha_equivalent_terms} then implies that \( A[x \mapsto n] \aequiv B[x \mapsto n] \).

  The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} then implies that \( \qabs x A \aequiv \qabs x B \).

  Thus, \ref{inf:thm:alpha_equivalence_simplified/lift} is admissible.

  \SubProof*{Proof that \ref{inf:thm:alpha_equivalence_simplified/ren} is admissible} Fix variables \( a \equiv b \) and terms \( A \) and \( B \) such that \( a \) is not free in \( B \) and \( A \aequiv B[b \mapsto a] \).

  Let \( n \) be any variable not free in \( \qabs a A \). \Fullref{thm:substitution_on_alpha_equivalent_terms} implies that
  \begin{equation*}
    A[a \mapsto n] \aequiv B[b \mapsto a][a \mapsto n]
  \end{equation*}
  and \fullref{thm:substitution_chain_contraction} implies that
  \begin{equation*}
    A[a \mapsto n] \aequiv B[b \mapsto n].
  \end{equation*}

  The rule \ref{inf:def:lambda_term_alpha_equivalence/abs} then implies that \( \qabs a A \aequiv \qabs b B \).

  \NecessitySubProof We will show that \ref{inf:def:lambda_term_alpha_equivalence/abs} is admissible with respect to \ref{inf:thm:alpha_equivalence_simplified/lift} and \ref{inf:thm:alpha_equivalence_simplified/ren}.

  Fix \( \synlambda \)-terms \( A \) and \( B \) and variables \( a \) and \( b \) and suppose that \( A[a \mapsto n] \aequiv B[b \mapsto n] \) for every variable \( n \) not free in \( \qabs a A \). In particular, we are interested in \( n = a \).

  \begin{itemize}
    \item If \( a = b \), then \fullref{thm:lambda_substitution_noop} implies that \( A[a \mapsto a] = A \) and \( B[b \mapsto a] = B \), thus \ref{inf:thm:alpha_equivalence_simplified/lift} implies that \( \qabs a A \aequiv \qabs b B \).

    \item Otherwise, \( A \aequiv B[b \mapsto a] \), and to use \ref{inf:thm:alpha_equivalence_simplified/ren} we must only verify that \( a \) is not free in \( B \).

    If we suppose that \( a \) is free in \( B \), this will contradict \fullref{thm:def:lambda_term_alpha_equivalence/free} since \( A[a \mapsto b] \aequiv B \). Thus, \( a \) is indeed not free in \( B \), and we can use \ref{inf:thm:alpha_equivalence_simplified/ren} to conclude that \( \qabs A \aequiv \qabs b B \).
  \end{itemize}
\end{proof}

\begin{corollary}\label{thm:alpha_conversion}
  If \( y \) is not free in \( M \), then
  \begin{equation}\label{eq:thm:alpha_conversion}
    \qabs x M \aequiv \qabs y M[y \mapsto x]
  \end{equation}
\end{corollary}
\begin{proof}
  This is a restatement of \ref{inf:thm:alpha_equivalence_simplified/ren}.
\end{proof}

\begin{corollary}\label{thm:alpha_conversion_modified}
  If \( v \) is not free in \( M[\sigma_{x \mapsto u}] \), then
  \begin{equation}\label{eq:thm:alpha_conversion_modified}
    \qabs u M[\sigma_{x \mapsto u}] \aequiv \qabs v M[\sigma_{x \mapsto v}].
  \end{equation}
\end{corollary}
\begin{proof}
  \Fullref{thm:alpha_conversion} implies that
  \begin{equation*}
    \qabs v B[\rho_{x \mapsto v}]
    \aequiv
    \qabs u B[\rho_{x \mapsto v}][v \mapsto u].
  \end{equation*}

  Furthermore, \fullref{thm:substitution_chain_contraction/contraction} implies that
  \begin{equation*}
    B[\rho_{x \mapsto v}][v \mapsto u] \aequiv B[\rho_{x \mapsto u}]
  \end{equation*}
  and \ref{inf:thm:alpha_equivalence_simplified/ren} implies that
  \begin{equation*}
    \qabs u B[\rho_{x \mapsto v}][v \mapsto u] \aequiv \qabs u B[\rho_{x \mapsto u}].
  \end{equation*}
\end{proof}

\begin{algorithm}[Separation of free and bound variables]\label{alg:separation_of_free_and_bound_variables}
  Fix a \( \synlambda \)-term \( M \). We will build an \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent} term \( M' \) where the \hyperref[def:lambda_variable_freeness]{free and bound variables} are distinct.

  We will use the auxiliary operation, in which \( \Gamma \) is a context of variables that should be avoided:
  \begin{equation*}
    M'_\Gamma \coloneqq \begin{cases}
      M,                                 &M \in \op*{Var}, \\
      N'_\Gamma \thinspace K'_\Gamma,    &M = NK, \\
      \qabs x N'_{\Gamma,x}              &M = \qabs x N \T{and} x \not\in \Gamma, \\
      \qabs n N'_{\Gamma,n}[x \mapsto n] &M = \qabs x N \T{and} x \in \Gamma,
    \end{cases}
  \end{equation*}
  where \( n \) is the smallest variable not in \( \op*{Free}(N) \cup \Gamma \). We claim that \( M \aequiv M'_\Gamma \) and that the bound variables in \( M'_\Gamma \) are disjoint from \( \Gamma \).

  To obtain the desired \( \synlambda \)-term \( M' \), we simply take \( M'_\Gamma \) with \( \Gamma = \op*{Free}(M) \).
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda.alpha.separate_free_and_bound_variables} in \cite{code}.
\end{comments}
\begin{defproof}
  We proceed via \fullref{thm:induction_on_syntax_trees} on \( M \) to show that, for any context \( \Gamma \), \( M \aequiv M'_\Gamma \) and the bound variables in \( M'_\Gamma \) are not in \( \Gamma \).

  \begin{itemize}
    \item If \( M \) is a variable, then \( M = M'_\Gamma \), hence they are \( \alpha \)-equivalent by \fullref{thm:def:lambda_term_alpha_equivalence/reflexive}. Furthermore, \( M \) has no bound variables.

    \item If \( M = NK \) and if the inductive hypothesis holds for both \( N \) and \( K \), then the rule \ref{inf:def:lambda_term_alpha_equivalence/app} allows us to conclude that \( M \aequiv M'_\Gamma \) and the inductive hypothesis allows us to conclude that the bound variables of \( M'_\Gamma \) are disjoint from \( \Gamma \).

    \item Finally, suppose that \( M = \qabs x N \) and that the inductive hypothesis holds for \( N \). We have the following possibilities:
    \begin{itemize}
      \item If \( x \not\in \Gamma \), then \( M' = \qabs x N'_{\Gamma,x} \).

      By the inductive hypothesis, \( N \aequiv N'_{\Gamma,x} \) and the rule \ref{inf:thm:alpha_equivalence_simplified/lift} allows us to conclude that
      \begin{equation*}
        M = \qabs x N \aequiv \qabs x N'_{\Gamma,x} = M'_\Gamma.
      \end{equation*}

      Furthermore, by the inductive hypothesis,
      \begin{equation*}
        \op*{Bound}(N'_{\Gamma,x}) \cap \parens[\Big]{ \Gamma \cup \set{ x } } = \varnothing,
      \end{equation*}
      hence
      \begin{align*}
        \op*{Bound}(M'_\Gamma) \cap \Gamma
        &=
        \parens[\Big]{ \op*{Bound}(N'_{\Gamma,x}) \cup \set{ x } } \cap \Gamma
        \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} = \\ &=
        \parens[\Big]{ \underbrace{\op*{Bound}(N'_{\Gamma,x}) \cap \Gamma }_\varnothing } \cup \parens[\Big]{ \underbrace{\set{ x } \cap \Gamma}_\varnothing }
      \end{align*}

      \item If \( x \in \Gamma \), then \( M' = \qabs n N'_{\Gamma,n}[x \mapsto n] \), where \( n \) is the smallest variable not in \( \op*{Free}(N) \cup \Gamma \).

      By the inductive hypothesis, we have \( N \aequiv N'_{\Gamma,n} \). \Fullref{thm:substitution_on_alpha_equivalent_terms} implies that
      \begin{equation*}
        N[x \mapsto n] \aequiv N'_{\Gamma,n}[x \mapsto n].
      \end{equation*}

      Let
      \begin{align*}
        a &\coloneqq n && A \coloneqq N'_{\Gamma,n}[x \mapsto n], \\
        b &\coloneqq x && B \coloneqq N.
      \end{align*}
      so that, in the notation of \ref{inf:thm:alpha_equivalence_simplified/ren},
      \begin{equation*}
        A \aequiv B[b \mapsto a].
      \end{equation*}

      By definition, \( a = n \) is not free in \( B = N \). Thus, we can apply \ref{inf:thm:alpha_equivalence_simplified/ren} and obtain \( M \ M' \).

      Furthermore, by the inductive hypothesis,
      \begin{equation*}
        \op*{Bound}(N'_{\Gamma,n}) \cap \parens[\Big]{ \Gamma \cup \set{ n } } = \varnothing,
      \end{equation*}
      hence, again,
      \begin{align*}
        \op*{Bound}(M'_\Gamma) \cap \Gamma
        &=
        \parens[\Big]{ \op*{Bound}(N'_{\Gamma,n}) \cup \set{ n } } \cap \Gamma
        \reloset {\eqref{eq:thm:union_intersection_distributivity/intersection_over_union}} = \\ &=
        \parens[\Big]{ \underbrace{\op*{Bound}(N'_{\Gamma,n}) \cap \Gamma }_\varnothing } \cup \parens[\Big]{ \underbrace{\set{ n } \cap \Gamma}_\varnothing }.
      \end{align*}
    \end{itemize}
  \end{itemize}
\end{defproof}
