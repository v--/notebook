\section{Unisorted unification}\label{sec:unisorted_unification}

\paragraph{Equality}

\begin{concept}\label{con:equality}
  In addition to judgments, discussed in \cref{con:judgment}, another essentially undefinable fundamental notion is that of \term{equality}. It is a primordial \hyperref[def:equivalence_relation]{equivalence relation} that can, in some cases, be characterized formally.

  \tcite{In his essay #2, #1 writes}[222]{Mazur2008Equality}
  \begin{displayquote}
    One can't do mathematics for more than ten minutes without grappling, in some way or other, with the slippery notion of equality. Slippery, because the way in which objects are presented to us hardly ever, perhaps never, immediately tells us --- without further commentary --- when two of them are to be considered equal.
  \end{displayquote}

  On a \hyperref[con:syntax_semantics_duality]{syntactic level}, following \cite[19]{UnivalentFoundationsProgram2013HoTT}, for a given \hyperref[con:metalanguage]{object language} we can distinguish between \term{judgmental equality}, dictated by a judgment asserting that two expressions in the object language are equal, and \term{propositional equality}, an equality \hyperref[con:proposition]{proposition} within the object language itself. The latter is formalized for \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} in \cref{def:mltt_propositional_equality}.

  When introducing his type theory in \cite[85]{MartinLöf1984IntuitionisticTypeTheory}, Per Martin-L\"of calls \term{definitional equality} what is essentially judgmental equality. In his later work \cite[40]{MartinLöf1984IntuitionisticTypeTheory}, Martin-L\"of describes definitional equality as follows:
  \begin{displayquote}
    Definitional equality is the equivalence relation generated by abbreviatory definitions, changes of bound variables and the principle of substituting equals for equals.
  \end{displayquote}

  We use the following symbols:
  \begin{center}
    \begin{tabular}{lcc}
      \toprule
                      & Definitional equality & Propositional equality \\
      \midrule
      Metalanguage    & \( \coloneqq \)       & \( = \)      \\
      Object language & \( \judgeq \)         & \( \syneq \) \\
      \bottomrule
    \end{tabular}
  \end{center}

  On a \hyperref[con:syntax_semantics_duality]{semantic level}, we can utilize Leibniz' \enquote{identity of indiscernibles} principle discussed in \cref{rem:identity_of_indiscernibles} to justify equating objects that have identical properties. On a metatheoretic level two objects may be distinct, but as long as they satisfy the same collection of desired properties, we can construct an equivalence relation that will be used to interpret equality propositions in the object language. A more abstract approach to equality via generalized equivalence relations is discussed in \cref{rem:intuitionistic_equality}.
\end{concept}

\begin{remark}\label{rem:identity_of_indiscernibles}
  \incite[163]{Kleene2002Logic} calls the following principle \enquote{identity of indiscernibles}:
  \begin{displayquote}
    \textellipsis if we can discern no property \( P \) in which \( x \) and \( y \) differ, \( x \) and \( y \) are identical.
  \end{displayquote}

  Suppose we have a \hyperref[def:fol_signature]{first-order predicate} \( \op{Indiscernible} \) that validates this principle\fnote{It can be expressed in \hyperref[def:higher_order_logic]{higher-order logic} as
  \begin{equation*}
    \op{Indiscernible} \coloneqq \qabs {\synx^{\syn\iota}} \qabs {\syny^{\syn\iota}} \qforall {\synp^{\syn\iota \synimplies \syn\omicron}} \synp\synx \syniff \synp\syny
  \end{equation*}}.

  Kleene attributes it to Gottfried Leibniz. In \cite[54]{Russell1900LeibnizPhilosophy}, a book discussing Leibniz' philosophy, Bertrand Russell describes the principle using Leibniz' own words (translated into English):
  \begin{displayquote}
    \textellipsis there are not in nature two indiscernible real absolute beings
  \end{displayquote}
  and
  \begin{displayquote}
    \textellipsis no two substances are completely similar, or differ solely in number
  \end{displayquote}

  While the interpretation of the second sentence is ambiguous, we can confidently express the first as
  \begin{equation*}
    \neg \qexists \synx \qexists \syny (\op{Indiscernible}(\synx, \syny) \synwedge \neg (\synx \syneq \syny)),
  \end{equation*}
  which, due to the classical equivalences from \cref{thm:classical_equivalences} and \cref{thm:first_order_quantifiers_are_dual} (adapted to second-order logic), can be rewritten as
  \begin{equation}\label{eq:rem:identity_of_indiscernibles/forward}
    \qforall \synx \qforall \syny (\op{Indiscernible}(\synx, \syny) \synimplies \synx \syneq \syny).
  \end{equation}

  The \hyperref[def:conditional_formula/converse]{converse} is sometimes used. For example, \incite[278]{Farmer2008STTVirtues} states that
  \begin{displayquote}
    Leibniz' Law says that if two things are equal they satisfy exactly the same properties.
  \end{displayquote}
  and formalizes the law as
  \begin{equation}\label{eq:rem:identity_of_indiscernibles/backward}
    \qforall \synx \qforall \syny (\synx \syneq \syny \synimplies \op{Indiscernible}(\synx, \syny)).
  \end{equation}

  \incite[\S 9.1.4]{Mimram2020ProgramEqualsProof} refers to the former as the \enquote{identity of indiscernibles} and to the latter as the \enquote{indiscernibility of identicals}. He defines \enquote{Leibniz equality} in line with the above suggestion by Kleene:
  \begin{equation}\label{eq:rem:identity_of_indiscernibles/bi}
    \qforall \synx \qforall \syny (\op{Indiscernible}(\synx, \syny) \syniff \synx \syneq \syny).
  \end{equation}
\end{remark}

\begin{concept}\label{con:extensionality}
  When discussing \hyperref[def:inference_rule]{inference rules} akin to \ref{inf:def:first_order_natural_deduction_systems/eq/sub}, \incite[164]{Kleene2002Logic} describes \term{extensionality} as follows:
  \begin{displayquote}
    The same property is also sometimes described as \enquote{extensionality}, from the standpoint of the contexts in which \( x = y \) justifies the replacement of \( x \) by \( y \). A context in which such replacement is justified is called \textit{extensional}; one in which it is not, \textit{nonextensional} or sometimes \textit{intensional}.
  \end{displayquote}

  A related notion of \term{function extensionality}, defined by \incite[407]{Mimram2020ProgramEqualsProof} as follows:
  \begin{displayquote}
    \ldots we declare that two functions \( f \) and \( g \) of type \( A \to B \) are \textit{extensionally equal} when, for every element \( x \) of type \( A \), we have \( f(x) = g(x) \).
  \end{displayquote}

  Here \( f \) can be substituted for \( g \) as long as only their values are concerned. This may be inappropriate if \( f \) and \( g \) carry additional information like a syntactic representation (for example, via \hyperref[def:lambda_term]{\( \muplambda \)-terms}).
\end{concept}
\begin{comments}
  \item Leibniz' \hyperref[rem:identity_of_indiscernibles]{\enquote{identity of indiscernibles}} principle allows us to derive equality of \( x \) and \( y \), while extensionality allows us to use this equality to substitute \( x \) for \( y \).
\end{comments}

\paragraph{Equations}

\begin{definition}\label{def:equation}\mimprovised
  For expressing \hyperref[con:equality]{propositional equality}, we will find useful the following general definition.

  Consider the strings generated by the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{left side}  {\bnfpn{term}}, \\
    \bnfprod{right side} {\bnfpn{term}}, \\
    \bnfprod{equation}   {\bnfpn{left side} \bnfsp \bnftsq{\( \syneq \)} \bnfsp \bnfpn{right side}},
  \end{bnf*}
  where, as in \cref{def:logical_context}, we have purposefully not specified rules for the nonterminal \( \bnfpn{term} \) in order to encompass different kinds of terms.

  We require that the resulting grammar is \hyperref[def:grammar_ambiguity]{unambiguous} so that we can treat equations as pairs of terms.
\end{definition}
\begin{comments}
  \item Equations are \hyperref[con:assumed_knowledge]{assumed knowledge}, so definitions across the literature to base this one upon can hardly be found. We simply generalize to arbitrary terms the more established first-order equations from \cref{def:fol_equation}.
\end{comments}

\begin{concept}\label{con:equation_solution}
  \hyperref[def:equation]{Equations} are by fiat assumed to be \hyperref[con:hypothetical_judgment]{hypothetical} judgments or propositions, where the task of finding the hypotheses is implicit. We call this process \term{equation solving} and refer to a viable collection of hypotheses as a \term{solution}.

  If an equation has no hypotheses, solving it becomes meaningless. We will refer to such equations as \term[bg=тъждества (\cite[2]{Обрешков1962ВисшаАлгебра}), en=identities (\cite[50]{BaaderNipkow2012TermRewriting})]{identities}. All possible values are solutions to an identity.
\end{concept}
\begin{comments}
  \item Equations and identities are \hyperref[con:assumed_knowledge]{assumed knowledge}; a confirmation of our description above is the following excerpt from \cite[50]{BaaderNipkow2012TermRewriting}:
  \begin{displayquote}
    We use the name \enquote{identity} for a pair of terms \( s \approx t \) to express that this equation is assumed to \textit{hold} in an algebra, and distinguish this from the notion of an \enquote{equation}, which must be \enquote{solved} in an algebra.
  \end{displayquote}
\end{comments}

\begin{definition}\label{def:system_of_equations}\mimprovised
  We refer to nonempty \hyperref[def:ordered_tuple]{lists} of \hyperref[def:equation]{equations} as \term[en=equation system (\cite[\S 5.4.1]{Mimram2020ProgramEqualsProof})]{systems}.
\end{definition}

\begin{concept}\label{con:equivalent_systems_of_equations}
  We call two \hyperref[def:system_of_equations]{systems} of equations \term{equivalent} if they have the same solutions.
\end{concept}

\begin{example}\label{ex:def:equation}
  \hyperref[def:equation]{Equations} provide a simple way to specify rich semantic structure using simple syntactic objects. A remarkable portion of mathematics concerns the study of different kinds equations.

  \begin{thmenum}
    \thmitem{ex:def:equation/linear} Matrix theory can be regarded as the study of \hyperref[def:system_of_linear_equations]{systems of linear equations}. See \fullref{ch:linear_algebra}.

    \thmitem{ex:def:equation/dynamical} \hyperref[def:dynamical_system]{Dynamical systems} are often specified via equations, for example \hyperref[def:recurrence_relation]{recurrence relations}, \hyperref[def:difference_equation]{difference equations} or differential equations. See \fullref{ch:dynamical_systems}.

    \thmitem{ex:def:equation/nonsmooth} \hyperref[def:zero_of_function]{Zeros} of generalized derivatives are studied in optimization. See \fullref{sec:nonsmooth_derivatives}.

    \thmitem{ex:def:equation/fixed} \hyperref[def:function_fixed_point]{Fixed points} of functions are studied in different branches of mathematics. See \fullref{thm:fixed_point_existence}.

    \thmitem{ex:def:equation/algebraic} \hyperref[def:polynomial_equation]{Algebraic equations} are useful across different branches of mathematics.
  \end{thmenum}
\end{example}

\paragraph{Simultaneous substitution}

\begin{definition}\label{def:atomic_fol_substitution}\mimprovised
  We will define \hyperref[con:syntactic_substitution]{atomic substitution} for \hyperref[def:fol_term]{first-order terms} and \hyperref[def:fol_formula]{formulas} based on how we have defined it for \hyperref[def:lambda_term]{\( \muplambda \)-term} in \cref{def:atomic_lambda_term_substitution}.

  Namely, for a fixed \hyperref[def:fol_signature]{signature} \( \Sigma \), we will need a pair \( (\Bbbs, \sharp) \), where
  \begin{thmenum}[series=def:atomic_fol_substitution]
    \thmitem{def:atomic_fol_substitution/atomic} \( \Bbbs: \op*{Var} \to \op*{Term}_\Sigma \) is a function specifying how variables need to be replaced with terms. We allow only finitely many variables to not be fixed by \( \Bbbs \). We call \( \Bbbs \) an \term{atomic substitution}.

    \thmitem{def:atomic_fol_substitution/sharp} \( \sharp \) is, as in \cref{def:atomic_lambda_term_substitution/sharp}, a function providing us with fresh variables, i.e. \( \sharp(V) \) is a new variable not in \( V \).

    By default, we suppose that \( \sharp(V) \) is the smallest, with respect to the \hyperref[def:variable_identifier]{identifier order}, variable not in \( V \).
  \end{thmenum}

  The following two auxiliary notions are then adapted directly from \cref{def:atomic_fol_substitution}:
  \begin{thmenum}[resume=def:atomic_fol_substitution]
    \thmitem{def:atomic_fol_substitution/modified} We can \term{modify} \( \Bbbs \) at \( x \) with \( y \):
    \begin{equation}\label{eq:def:atomic_fol_substitution/modified}
      \Bbbs_{x \mapsto y}(u) \coloneqq \begin{cases}
        y,        &u = x, \\
        \Bbbs(u), &u \neq x.
      \end{cases}
    \end{equation}

    \thmitem{def:atomic_fol_substitution/free} For defining capture-avoiding substitution, we will need the function
    \begin{equation}\label{eq:def:atomic_fol_substitution/free/terms}
      \op*{Var}_\Bbbs(\tau) \coloneqq \bigcup_{\mathclap{v \in \op*{Var}(\tau)}} \op*{Var}(\Bbbs(v))
    \end{equation}
    for terms and
    \begin{equation}\label{eq:def:atomic_fol_substitution/free/formulas}
      \op*{Free}_\Bbbs(\varphi) \coloneqq \bigcup_{\mathclap{v \in \op*{Free}(\varphi)}} \op*{Free}(\Bbbs(v))
    \end{equation}
    for formulas.
  \end{thmenum}
\end{definition}

\begin{algorithm}[First-order term substitution]\label{alg:fol_term_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to arbitrary \hyperref[def:fol_term]{first-order terms} as follows:
  \begin{empheq}[left={\tau[\Bbbs]} \coloneqq \empheqlbrace]{align}
    &\Bbbs(x),                                                   &&\tau = x \in \op*{Var},               \label{eq:alg:fol_term_substitution/var} \\
    &f\parens[\big]{ \sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs] }, &&\tau = f(\sigma_1, \ldots, \sigma_n). \label{eq:alg:fol_term_substitution/application}
  \end{empheq}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.substitution.apply_substitution_to_term} in \cite{notebook:code}.
  \item This substitution has the properties listed in \cref{rem:variable_binding_properties}, but since we perform no renaming, these properties are trivial. Compare this to \fullref{alg:fol_formula_substitution}, for which the properties are made explicit in \cref{thm:alg:fol_formula_substitution}.
\end{comments}

\begin{proposition}\label{thm:alg:fol_term_substitution}
  \Fullref{alg:fol_term_substitution} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:alg:fol_term_substitution/subterm} If \( \sigma \) is a (strict) \hyperref[def:fol_subterm]{subterm} of \( \tau \), then \( \sigma[\Bbbs] \) is a (strict) subterm of \( \tau[\Bbbs] \) for any substitution \( \Bbbs \).
    \thmitem{thm:alg:fol_term_substitution/fixed} If \( \tau[\Bbbs] = \tau \), then every variable in \( \tau \) is fixed under \( \Bbbs \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:alg:fol_term_substitution/subterm} We will use \fullref{thm:induction_on_abstract_syntax} on \( \tau \) simultaneously on all \( \sigma \) and \( \Bbbs \):
  \begin{itemize}
    \item If \( \tau \) is a variable, its only subterm is \( \tau \) itself, so \( \tau = \sigma \). Then obviously \( \tau[\Bbbs] = \sigma[\Bbbs] \), i.e. \( \sigma[\Bbbs] \) is a (nonstrict) subterm of \( \tau[\Bbbs] \).
    \item Suppose that \( \tau = f(\sigma_1, \ldots, \sigma_n) \), where the inductive hypothesis holds for \( \sigma_1, \ldots, \sigma_n \).

    We have two cases:
    \begin{itemize}
      \item If \( \tau = \sigma \), again obviously \( \tau[\Bbbs] = \sigma[\Bbbs] \).
      \item If \( \sigma \) is a subterm of \( \sigma_k \), by the inductive hypothesis \( \sigma[\Bbbs] \) is a subterm of \( \sigma_k[\Bbbs] \), and hence also of \( \tau[\Bbbs] \).
    \end{itemize}
  \end{itemize}

  \SubProofOf{thm:alg:fol_term_substitution/fixed} We will use \fullref{thm:induction_on_abstract_syntax} on \( \tau \):
  \begin{itemize}
    \item If \( \tau \) is a variable, say \( x \), and \( \tau[\Bbbs] = \tau \), by definition \( \Bbbs(x) = x \).
    \item Suppose that \( \tau = f(\sigma_1, \ldots, \sigma_n) \) and that the inductive hypothesis holds for \( \sigma_1, \ldots, \sigma_n \).

    Since, for \( k = 1, \ldots, n \), \( \tau[\Bbbs] = \tau \) implies \( \sigma_k[\Bbbs] = \sigma_k \), the inductive hypothesis implies that every variable in \( \sigma_k \) is fixed by \( \Bbbs \).

    This holds for every index \( k \), so every variable in \( \tau \) is fixed by \( \Bbbs \).
  \end{itemize}
\end{proof}

\begin{algorithm}[First-order assignment substitution]\label{alg:fol_assignment_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to a arbitrary \hyperref[def:fol_variable_assignment]{first-order variable assignment} \( v \) in the \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \) as follows:
  \begin{equation}\label{eq:alg:fol_assignment_substitution}
    v[\Bbbs](x) \coloneqq \Bracks{\Bbbs(x)}_\mscrX^v.
  \end{equation}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.structure.apply_substitution_to_assignment} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:fol_assignment_substitution_compatibility}
  \Fullref{alg:fol_term_substitution} and \fullref{alg:fol_assignment_substitution} are compatible:
  \begin{equation}\label{eq:thm:fol_assignment_substitution_compatibility}
    \Bracks{\tau}_\mscrX^{v[\Bbbs]} = \Bracks{\tau[\Bbbs]}_\mscrX^v,
  \end{equation}
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_abstract_syntax} on \( \tau \) simultaneously on all assignments to show \eqref{eq:thm:fol_assignment_substitution_compatibility}.

  \begin{itemize}
    \item If \( \tau \) is a variable, say \( x \), then
    \begin{equation*}
      \Bracks{\tau}_\mscrX^{v[\Bbbs]}
      \reloset {\eqref{eq:alg:fol_term_substitution/var}} =
      v[\Bbbs](x)
      \reloset {\eqref{eq:alg:fol_assignment_substitution}} =
      \Bracks{\Bbbs(x)}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_term_substitution/var}} =
      \Bracks{\tau[\Bbbs]}_\mscrX^v.
    \end{equation*}

    \item If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), and if the inductive hypothesis holds for \( \sigma_1, \ldots, \sigma_n \), then
    \begin{multline*}
      \Bracks{\tau}_\mscrX^{v[\Bbbs]}
      \reloset {\eqref{eq:alg:fol_term_substitution/application}} =
      I(f) \parens[\big]{ \Bracks{\sigma_1}_\mscrX^{v[\Bbbs]}, \ldots, \Bracks{\sigma_n}_\mscrX^{v[\Bbbs]} }
      \reloset {\T{ind.}} = \\ =
      I(f) \parens[\big]{ \Bracks{\sigma_1[\Bbbs]}_\mscrX^v, \ldots, \Bracks{\sigma_n[\Bbbs]}_\mscrX^v }
      \reloset {\eqref{eq:alg:fol_term_denotation/fun}} =
      \Bracks[\big]{f(\sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs])}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_term_substitution/application}} =
      \Bracks{\tau[\Bbbs]}_\mscrX^v.
    \end{multline*}
  \end{itemize}
\end{proof}

\begin{definition}\label{def:fol_term_length}\mimprovised
  For some inductive proofs, we will find useful to recursively define the \term{length} of a \hyperref[def:fol_term]{first-order term} as
  \begin{equation*}
    \len(\tau) \coloneqq \begin{cases}
      1,                                                  &\tau \in \op*{Var}, \\
      1 + \len(\sigma_1) + \cdots + \len(\sigma_n),       &\tau = f(\sigma_1, \ldots, \sigma_n), \\
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item If all function symbols use prefix notation and if the variable names in \( \tau \) contain no numeric indices, then \( \len(\tau) \) is exactly the \hyperref[def:formal_language/string_length]{string length} of \( \tau \).
  \item We adapt this definition from the \( \muplambda \)-term counterpart presented in \cref{def:lambda_term_length}.
\end{comments}

\begin{proposition}\label{thm:def:fol_term_length}
  \hyperref[def:fol_term]{First-order terms} have the following basic properties regarding their \hyperref[def:fol_term_length]{length}:
  \begin{thmenum}
    \thmitem{thm:def:fol_term_length/subterm} Every strict subterm of a term is strictly shorter.

    \thmitem{thm:def:fol_term_length/substitution} For any atomic substitution \( \Bbbs \) and term \( \tau \), we have
    \begin{equation}\label{eq:thm:def:fol_term_length/substitution}
      \len(\tau[\Bbbs]) = \len(\tau) + \sum_{\mathclap{u \in \op*{Var}(\tau)}} (\len(\Bbbs(u)) - 1).
    \end{equation}

    In particular, if \( \Bbbs \) is a \hyperref[def:lambda_renaming_substitution]{renaming}, then \( \len(\tau[\Bbbs]) = \len(\tau) \).
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item See the corresponding statements for \( \muplambda \)-terms in \cref{thm:def:lambda_term_length}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:def:fol_term_length/subterm} Trivial.
  \SubProofOf{thm:def:fol_term_length/substitution} Similar to \cref{thm:def:lambda_term_length/substitution}.
\end{proof}

\begin{definition}\label{def:fol_substitution_composition}\mcite[39]{BaaderNipkow2012TermRewriting}
  We define the \term{composition} \( \Bbbt\Bbbs \) of the \hyperref[def:atomic_fol_substitution]{atomic first-order substitutions} \( \Bbbs \) and \( \Bbbt \) as
  \begin{equation}\label{eq:def:fol_substitution_composition}
    (\Bbbt\Bbbs)(x) \coloneqq x[\Bbbs][\Bbbt].
  \end{equation}

  This extends recursively to any number of substitutions, starting with the identity \( \id \) as a nullary composition.
\end{definition}

\begin{proposition}\label{thm:def:fol_substitution_composition}
  \hyperref[def:fol_substitution_composition]{Substitution composition} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_substitution_composition/iterated} For the composition \( \Bbbt\Bbbs \), we have
    \begin{equation}\label{eq:thm:def:fol_substitution_composition/iterated}
      \tau[\Bbbt\Bbbs] = \tau[\Bbbs][\Bbbt]
    \end{equation}
    for any term \( \tau \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_substitution_composition/iterated} We will use \fullref{thm:induction_on_abstract_syntax} on \( \tau \):
  \begin{itemize}
    \item If \( \tau \) is a variable, then \eqref{eq:thm:def:fol_substitution_composition/iterated} holds by definition.
    \item If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), where \( \sigma_1, \ldots, \sigma_n \) are substitutions, then
    \begin{equation*}
      \tau[\Bbbt\Bbbs]
      =
      f(\sigma_1[\Bbbt\Bbbs], \cdots, \sigma_n[\Bbbt\Bbbs])
      \reloset {\T{ind.}} =
      f(\sigma_1[\Bbbt][\Bbbs], \cdots, \sigma_n[\Bbbt][\Bbbs])
      =
      \tau[\Bbbt][\Bbbs].
    \end{equation*}
  \end{itemize}
\end{proof}

\begin{definition}\label{def:fol_substitution_instance}\mcite[def. 4.5.1]{BaaderNipkow2012TermRewriting}
  We say that the \hyperref[def:atomic_fol_substitution]{atomic first-order substitution} \( \Bbbt \) is an \term{instance} of \( \Bbbs \) if there exists a third substitution \( \Bbbr \) such that \( \Bbbt = \Bbbr\Bbbs \). We also say that \( \Bbbs \) is \term{more general} than \( \Bbbt \).
\end{definition}

\begin{proposition}\label{thm:def:fol_substitution_instance}
  The substitution instance relation from \cref{def:fol_substitution_instance} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_substitution_instance/preorder} It is a \hyperref[def:preordered_set]{preorder}.
  \end{thmenum}
\end{proposition}
\begin{comments}
  \SubProofOf{thm:def:fol_substitution_instance/preorder}
  \SubProofOf*[def:binary_relation/reflexive]{reflexivity} Every substitution \( \Bbbs \) is an instance of itself because \( \Bbbs = \id \bincirc \Bbbs \).
  \SubProofOf*[def:binary_relation/transitive]{transitivity} If \( \Bbbt = \Bbbr\Bbbs \) and \( \Bbbo = \Bbbp\Bbbt \), then, due to associativity of composition,
  \begin{equation*}
    \Bbbo
    =
    \Bbbp\Bbbt
    =
    \Bbbp(\Bbbr\Bbbs)
    =
    (\Bbbp\Bbbr)\Bbbs
  \end{equation*}
  hence \( \Bbbo \) is an instance of \( \Bbbs \).
\end{comments}

\begin{definition}\label{def:fol_unifier_equivalence}\mimprovised
  We say that the \hyperref[def:atomic_fol_substitution]{atomic first-order substitutions} \( \Bbbs \) and \( \Bbbt \) are \term{equally general} if both are instances of each other in the sense of \cref{def:fol_substitution_instance}.
\end{definition}

\begin{definition}\label{def:fol_renaming_substitution}\mcite[\S 5.4.2]{Mimram2020ProgramEqualsProof}
  We say that an \hyperref[def:atomic_fol_substitution]{atomic first-order substitution} is a \term{renaming} if it sends variables to variables.
\end{definition}
\begin{comments}
  \item \incite*[39]{BaaderNipkow2012TermRewriting} additionally require the substitution to be injective.
\end{comments}

\begin{proposition}\label{thm:def:fol_unifier_equivalence}
  \hyperref[def:fol_idempotent_substitution]{Equally general first-order substitutions} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_unifier_equivalence/renaming} \( \Bbbs \) and \( \Bbbt \) are equally general if and only if there exists a \hyperref[def:fol_renaming_substitution]{renaming} \( \Bbbr \) such that \( \Bbbt = \Bbbr\Bbbs \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_unifier_equivalence/renaming}
  \SufficiencySubProof* Suppose that there exist substitutions \( \Bbbr \) and \( \Bbbp \) such that \( \Bbbt = \Bbbr\Bbbs \) and \( \Bbbs = \Bbbp\Bbbt \). Since composition is associative, we have
  \begin{equation*}
    \Bbbs = \Bbbp\Bbbt = \Bbbp(\Bbbr\Bbbs) = (\Bbbp\Bbbr)\Bbbs.
  \end{equation*}

  Let us define
  \begin{equation*}
    \Bbbr'(x) \coloneqq \begin{cases}
      \Bbbr(x), &\qexists* y x \in \op*{Var}(\Bbbs(y)), \\
      x,        &\T{otherwise.}
    \end{cases}
  \end{equation*}

  This ensures that \( \Bbbt = \Bbbr' \Bbbs \). It remains to show that \( \Bbbr' \) is a renaming.

  Suppose that this is not so. Then there exists a variable \( x \) such that \( \Bbbr'(x) \) is not a variable. In turn, there exists a variable \( y \) such that \( x \in \op*{Var}(\Bbbs(y)) \). Then \( \Bbbr(x) = \Bbbr'(x) \).

  We have
  \begin{equation*}
    \Bbbs(y)[\Bbbp\Bbbr] = \Bbbs(y),
  \end{equation*}
  and, by \cref{thm:alg:fol_term_substitution/fixed},
  \begin{equation*}
    x[\Bbbp\Bbbr] = x.
  \end{equation*}

  But since \( \Bbbr(x) \) is not a variable, neither is \( x[\Bbbp\Bbbr] = \Bbbs(r)[\Bbbp] \). The obtained contradiction shows that \( \Bbbr' \) must be a renaming substitution.

  \NecessitySubProof* Suppose that \( \Bbbt = \Bbbr\Bbbs \), where \( \Bbbr \) is a renaming. Obviously \( \Bbbt \) is an instance of \( \Bbbs \).

  Consider the \hyperref[def:set_valued_map/inverse]{multi-valued inverse} \( \Bbbr^{-1} \). Let \( \Bbbp \) be a \hyperref[def:function/selection]{single-valued selection} of \( \Bbbr^{-1} \), with \( \Bbbp(x) \coloneqq x \) whenever \( x \) is not in the domain of \( \Bbbr^{-1} \). Clearly \( \Bbbp \) is also a renaming. Then \( \Bbbp \) is a left inverse of \( \Bbbr \), i.e. \( \Bbbp\Bbbr = \id \).

  We have
  \begin{equation*}
    \Bbbp\Bbbt
    =
    \Bbbp(\Bbbr\Bbbs)
    =
    (\Bbbp\Bbbr)\Bbbs
    =
    \id\Bbbs
    =
    \Bbbs.
  \end{equation*}

  Therefore, \( \Bbbs \) is an instance of \( \Bbbt \).
\end{proof}

\begin{definition}\label{def:fol_idempotent_substitution}\mcite[def. 4.5.6]{BaaderNipkow2012TermRewriting}
  We say that an \hyperref[def:atomic_fol_substitution]{atomic first-order substitution} \( \Bbbs \) is \term{idempotent} if \( \Bbbs\Bbbs = \Bbbs \).
\end{definition}

\begin{proposition}\label{thm:def:fol_idempotent_substitution}
  \hyperref[def:fol_idempotent_substitution]{Idempotent first-order substitutions} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_idempotent_substitution/fixed}\mcite[lemma 4.5.7]{BaaderNipkow2012TermRewriting} \( \Bbbs \) is idempotent if and only if, for any \( x \), every variable in \( \Bbbs(x) \) is fixed.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_idempotent_substitution/fixed}
  \SufficiencySubProof* Suppose that \( \Bbbs \) is idempotent. Fix a variable \( x \).

  By idempotence, we have \( \Bbbs(x)[\Bbbs] = \Bbbs(x) \). \Cref{thm:alg:fol_term_substitution/fixed} implies that every variable in \( \Bbbs(x) \) is fixed.

  \NecessitySubProof* Suppose that, for any \( x \), every variable in \( \Bbbs(x) \) is fixed. Then \( x[\Bbbs\Bbbs] = \Bbbs(x)[\Bbbs] = \Bbbs(x) \), hence \( \Bbbs \) is idempotent.
\end{proof}

\paragraph{Unifiers}

\begin{definition}\label{def:fol_equation}\mcite[39]{BaaderNipkow2012TermRewriting}
  In \hyperref[def:first_order_logic]{first-order logic}, an \hyperref[def:equation]{equation} is simply an equality formula \( \tau \syneq \sigma \). Equivalently, we can regard it is a pair of first-order terms.

  \begin{thmenum}
    \thmitem{def:fol_equation/system}\mimprovised A \hyperref[def:system_of_equations]{system} of first-order equations is then a list
    \begin{equation}\label{eq:def:fol_equation/system}
      \begin{aligned}
        \tau_1 &\syneq \sigma_1, \\
               &\vdots \\
        \tau_n &\syneq \sigma_n.
      \end{aligned}
    \end{equation}
    of equality formulas.

    We will single letters like \( E \) to encompass the entire list \eqref{eq:def:fol_equation/system}.

    \thmitem{def:fol_equation/syntactic_solution}\mcite[def. 4.5.4]{BaaderNipkow2012TermRewriting} A \term[ru=унификатор (\cite[def. 4.3.6]{Герасимов2014Вычислимость})]{unifier} or \term[en=solution (\cite[def. 4.5.4]{BaaderNipkow2012TermRewriting})]{syntactic solution} to the system \( E \) is an \hyperref[def:atomic_fol_substitution]{atomic substitution} \( \Bbbs \) such that \( \tau_i[\Bbbs] \) and \( \sigma_i[\Bbbs] \) coincide for \( i = 1, \ldots, n \).

    \thmitem{def:fol_equation/semantic_solution}\mimprovised A \term{semantic solution} to the system \( E \) in the \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \) is a \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) such that \( \Bracks{\tau_i}_\mscrX^v \) and \( \Bracks{\sigma_i}_\mscrX^v \) coincide for \( i = 1, \ldots, n \).

    We call the collection of all such assignments the \term{solution set} of \eqref{eq:def:fol_equation/system} in \( \mscrX \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item \Cref{thm:fol_unifier_semantic_solution} shows compatibility of syntactic and semantic solutions.
\end{comments}

\begin{proposition}\label{thm:fol_unifier_semantic_solution}
  Let \( \Bbbs \) be an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution}. Let \( v \) be any \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) in any \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \).

  If \( \Bbbs \) is a \hyperref[def:fol_equation/syntactic_solution]{unifier} of a \hyperref[def:fol_equation/system]{system} \( E \), then the assignment \( v[\Bbbs] \) obtained via \fullref{alg:fol_assignment_substitution} \hyperref[def:fol_equation/semantic_solution]{solves} \( E \).
\end{proposition}
\begin{proof}
  For every equation \( \tau \syneq \sigma \), we have
  \begin{equation*}
    \Bracks{\tau}^{v[\Bbbs]}
    \reloset {\eqref{eq:thm:fol_assignment_substitution_compatibility}} =
    \Bracks{\tau[\Bbbs]}^v
    =
    \Bracks{\sigma[\Bbbs]}^v
    \reloset {\eqref{eq:thm:fol_assignment_substitution_compatibility}} =
    \Bracks{\sigma}^{v[\Bbbs]}.
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:fol_unifier_instance}
  If the \hyperref[def:atomic_fol_substitution]{atomic substitution} \( \Bbbs \) is a \hyperref[def:fol_equation/syntactic_solution]{unifier} of the \hyperref[def:fol_equation/system]{system} \( E \), then every \hyperref[def:fol_substitution_instance]{instance} of \( \Bbbs \) is also a unifier of \( E \).
\end{proposition}
\begin{proof}
  Let \( \Bbbt = \Bbbr\Bbbs \). For every equation \( \tau \syneq \sigma \) in \( E \), we have \( \tau[\Bbbs] = \sigma[\Bbbs] \) by assumption, hence
  \begin{equation*}
    \tau[\Bbbt]
    =
    \tau[\Bbbr\Bbbs]
    \reloset {\eqref{eq:thm:def:fol_substitution_composition/iterated}} =
    \tau[\Bbbs][\Bbbr]
    =
    \sigma[\Bbbs][\Bbbr]
    \reloset {\eqref{eq:thm:def:fol_substitution_composition/iterated}} =
    \sigma[\Bbbt].
  \end{equation*}

  Generalizing on \( \tau \syneq \sigma \), we conclude that \( \Bbbt \) unifies \( E \).
\end{proof}

\begin{definition}\label{def:fol_most_general_unifier}
  If a \hyperref[def:fol_equation/syntactic_solution]{unifier} \( \Bbbs \) for a given \hyperref[def:fol_equation/system]{system of equations} \( E \) is \hyperref[def:extremal_points/maximal_and_minimal_element]{minimal}, i.e. if every unifier of \( E \) is an \hyperref[def:fol_substitution_instance]{instance} of \( \Bbbs \), we call \( \Bbbs \) a \term{most general unifier}.
\end{definition}

\begin{proposition}\label{thm:def:fol_most_general_unifier}
  \hyperref[def:fol_most_general_unifier]{Most general unifiers} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_most_general_unifier/equivalent} Any two most general unifiers are \hyperref[def:fol_unifier_equivalence]{equally general}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_most_general_unifier/equivalent} Trivial.
\end{proof}

\paragraph{Unification}

\begin{concept}\label{con:unification}
  \term[en=unification (\cite[71]{BaaderNipkow2012TermRewriting}), ru=унификация (\cite[\S 4.3]{Герасимов2014Вычислимость})]{Unification} is the process of solving \hyperref[def:equation]{equations} symbolically. In this monograph, it reduces to finding \hyperref[def:fol_equation/syntactic_solution]{unifiers} via \fullref{alg:first_order_unification}.
\end{concept}

\begin{definition}\label{def:fol_equation_system_solved_form}\mcite[def. 4.6.1]{BaaderNipkow2012TermRewriting}
  We say that the \hyperref[def:fol_equation/system]{system of first-order equations} is in \term{solved form} if the left sides are pairwise distinct variables that do not occur on any of the right sides.

  Such a system has the form
  \begin{equation}\label{eq:def:fol_equation_system_solved_form}
    \begin{aligned}
      x_1 &\syneq \sigma_1, \\
          &\vdots \\
      x_n &\syneq \sigma_n,
    \end{aligned}
  \end{equation}
  where \( x_i \not\in \op*{Var}(\sigma_j) \) for all indices \( i \) and \( j \), and \( x_i \neq x_j \) whenever \( i \neq j \).

  Denote the system above by \( E \). We define the \hyperref[def:atomic_fol_substitution]{atomic substitution}
  \begin{equation*}
    \Bbbe_E(x) \coloneqq \begin{cases}
      \sigma_i, &x = x_i, \\
      x,        &\T{otherwise.}
    \end{cases}
  \end{equation*}

  We refer to \( \Bbbe_E \) as \hi{the} canonical unifier of \( E \).
\end{definition}

\begin{proposition}\label{thm:fol_canonical_unifier_is_most_general}\mcite[lemma 4.6.2]{BaaderNipkow2012TermRewriting}
  The \hyperref[def:fol_equation_system_solved_form]{canonical unifier} of a \hyperref[def:fol_equation/system]{system of equations} in solved form is an \hyperref[def:fol_idempotent_substitution]{idempotent} \hyperref[def:fol_most_general_unifier]{most general unifier}.
\end{proposition}
\begin{proof}
  Consider the system \( E \) from \eqref{eq:def:fol_equation_system_solved_form}. Idempotence of \( \Bbbe_E \) follows from \cref{thm:def:fol_idempotent_substitution/fixed}.

  We will show that \( \Bbbe_E \) is a most general unifier of \( E \). Let \( \Bbbt \) be a unifier of \( E \). Define
  \begin{equation*}
    \Bbbr(x) \coloneqq \begin{cases}
      x,        &x \in \op*{Var}(\sigma_k) \T{for some} k = 1, \ldots, n, \\
      \Bbbt(x), &\T{otherwise}.
    \end{cases}
  \end{equation*}

  Then, for every variable \( x \), we have
  \begin{equation*}
    \Bbbt(x) = \Bbbe_E(x)[\Bbbr],
  \end{equation*}
  hence \( \Bbbt \) is an instance of \( \Bbbe_E \).
\end{proof}

\begin{lemma}\label{thm:fol_unifier_non_existence}
  The following equations have no \hyperref[def:fol_equation/syntactic_solution]{unifier}:
  \begin{thmenum}
    \thmitem{thm:fol_unifier_non_existence/var} \( x \syneq \tau \) if \( \tau \) is a function application that contains \( x \).
    \thmitem{thm:fol_unifier_non_existence/fun} \( f(\tau_1, \ldots, \tau_n) \syneq g(\sigma_1, \ldots, \sigma_m) \) if \( f \neq g \).
  \end{thmenum}
\end{lemma}
\begin{proof}
  \SubProofOf{thm:fol_unifier_non_existence/var} Suppose that \( \Bbbs \) unifies \( x \syneq \tau \), i.e. \( \Bbbs(x) = \tau[\Bbbs] \).

  Suppose that \( \tau = f(\sigma_1, \ldots, \sigma_n) \) and \( \tau[\Bbbs] \) contains \( x \). Then there exists some variable \( y \) in \( \tau \) such that \( \Bbbs(y) \) contains \( x \).

  \Cref{thm:alg:fol_term_substitution/subterm} implies that \( y \) is a strict subterm of \( \tau \). Since \( \Bbbs(x) \) is a subterm of \( \Bbbs(y) \), it follows that \( \Bbbs(x) \) is a strict subterm of \( \tau[\Bbbs] = \Bbbs(x) \), i.e. \( \Bbbs(x) \) is a strict subterm of itself.

  The obtained contradiction shows that \( \tau[\Bbbs] \) cannot contain \( x \).

  \SubProofOf{thm:fol_unifier_non_existence/fun} If \( f \neq g \), unification requires \fullref{alg:fol_term_signature_translation} rather than variable substitution.
\end{proof}

\begin{algorithm}[First-order unification]\label{alg:first_order_unification}\mcite[74]{BaaderNipkow2012TermRewriting}
  Consider some \hyperref[def:fol_equation/system]{system of first-order equations} \( E \). We will attempt to build a system \( U(E) \) in \hyperref[def:fol_equation_system_solved_form]{solved form}, which will have the same \hyperref[def:fol_equation/syntactic_solution]{unifiers} as \( E \). In particular, the canonical unifier of \( U(E) \) can be used for \( E \).

  Let \( E_0 \coloneqq E \). We will define a sequence \( E_1, E_2, \ldots \) that will eventually \hyperref[def:chain_condition/stabilization]{stabilize}. Suppose we have built \( E_k \). If it is in solved form, halt the algorithm with \( U(E) \coloneqq E_k \).

  Otherwise, try the following steps:
  \begin{thmenum}
    \thmitem{alg:first_order_unification/delete} We can \term{delete} identities: if \( E_k = E_k', (\tau \syneq \tau), E_k^\dprime \) for some term \( \tau \), where \( E_k' \) has no such equation, let \( E_{k+1} \) be
    \begin{equation*}
      E_k', E_k^\dprime.
    \end{equation*}

    \thmitem{alg:first_order_unification/decompose} We can \term{decompose} applications: if \( E_k = E_k', f(\tau_1, \ldots, \tau_n) \syneq f(\sigma_1, \ldots, \sigma_n), E_k^\dprime \), where \( E_k' \) has no such equation, let \( E_{k+1} \) be
    \begin{equation*}
      E_k', (\tau_1 \syneq \sigma_1), \ldots, (\tau_n \syneq \sigma_n), E_k^\dprime.
    \end{equation*}

    \thmitem{alg:first_order_unification/orient} We can \term{orient} equations: if \( E_k = E_k', (\tau \syneq x), E_k^\dprime \) for some variable \( x \) and some application \( \tau \), where \( E_k' \) has no such equation, let \( E_{k+1} \) be
    \begin{equation*}
      E_k', (x \syneq \tau), E_k^\dprime.
    \end{equation*}

    \thmitem{alg:first_order_unification/eliminate} We can \term{eliminate} known variables on right sides: if \( E_k = E_k', (x \syneq \tau), E_k^\dprime \), where \( \tau \) is a term that does not contain \( x \), if at least one term from \( E_k' \) or \( E_k^\dprime \) contains \( x \) and if \( E_k' \) has no such equation, let \( E_{k+1} \) be
    \begin{equation*}
      E_k'[x \mapsto \tau], (x \syneq \tau), E_k^\dprime[x \mapsto \tau],
    \end{equation*}
    where \( E_k'[x \mapsto \tau] \) applies \fullref{alg:fol_term_substitution} to both sides of every equation in \( E_k' \) (and similarly for \( E_k^\dprime \)).

    \thmitem{alg:first_order_unification/deduplicate} We can \term{deduplicate} equations: if \( E_k = E_k', (\tau \syneq \sigma), E_k^\dprime, (\tau \syneq \sigma), E_k^\trprime \), where \( E_k' \) and \( E_k^\dprime \) do not share an equation, let \( E_{k+1} \) be
    \begin{equation*}
      E_k', (\tau \syneq \sigma), E_k^\dprime, E_k^\trprime.
    \end{equation*}

    \thmitem{alg:first_order_unification/failure} If none of the cases above occur (and \( E_k \) is not in solved form), one of the cases in \cref{thm:fol_unifier_non_existence} occurs, and \( E \) has no unifier.

    In this case we can only abort the algorithm.
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item \incite[74]{BaaderNipkow2012TermRewriting} present this algorithm with \( E \) being a set rather than a list. We made some adjustments and added a deduplication rule.
\end{comments}
\begin{defproof}
  \SubProof{Proof that the algorithm halts} Let us call the variable \( x \) \term{solved} if it occurs exactly once in \( E \), as a standalone variable on the left side of some equation (i.e. \( x \syneq \tau \) and \( x \not\in \op*{Var} \)).

  At step \( k \), we can define a triple \( (n_{k,1}, n_{k,2}, n_{k,3}) \), where
  \begin{itemize}
    \item \( n_{k,1} \) is the number of unsolved variables present in \( E_k \).
    \item \( n_{k,2} \) is the summary \hyperref[def:fol_term_length]{length} of all terms in \( E_k \), i.e.
    \begin{equation*}
      n_{k,2} = \sum_{\mathclap{(\tau \syneq \sigma) \in E_k}} \parens[\big]{ \len(\tau) + \len(\sigma) }.
    \end{equation*}

    \item \( n_{k,3} \) is the number of equations in \( E_k \) with a standalone variable on the right.
  \end{itemize}

  \Cref{tab:alg:first_order_unification/proof/halting} describes how the operations affect these triples. We see that, at each step, we obtain a lower \hyperref[def:lexicographic_order]{lexicographic order}. Hence, the algorithm eventually halts.
  \begin{table}
    \begin{center}
      \begin{tabular}{lCCC}
        \toprule
                    & n_{k+1,1} - n_{k,1} & n_{k+1,2} - n_{k,2} & n_{k+1,3} - n_{k,3} \\
        \midrule
        Delete      & \geq 0              & > 0                 & \geq 0              \\
        Decompose   & \geq 0              & = 2                 & = 0                 \\
        Orient      & \geq 0              & = 0                 & = 1                 \\
        Eliminate   & = 1                 & \leq 0              &                     \\
        Deduplicate & = 0                 & > 0                 & \geq 0              \\
        \bottomrule
      \end{tabular}
    \end{center}
    \caption{The effect of the operations of \fullref{alg:first_order_unification} on the complexity of the system of equations.}\label{tab:alg:first_order_unification/proof/halting}
  \end{table}

  \SubProof{Proof that the algorithm preserves unifiers} First, let \( \Bbbs \) be a unifier of \( E \). We will show that it is a unifier of \( U(E) \).

  More specifically, we will use induction on \( k \) to show that, if \( \Bbbs \) unifies \( E_k \), it also unifies \( E_{k+1} \).

  Let \( \tau \syneq \sigma \) be an equation in \( E_{k+1} \) not in \( E_k \). We will show that \( \tau[\Bbbs] = \sigma[\Bbbs] \).
  \begin{itemize}
    \item If the equation was introduced by \cref{alg:first_order_unification/decompose}, there exists some equation \( f(\tau_1, \ldots, \tau_n) \syneq f(\sigma_1, \ldots, \sigma_n) \) in \( E_k \) such that \( \tau = \tau_k \) and \( \sigma = \sigma_k \) for some \( k \).

    Since \( \Bbbs \) unifies the application, it also unifies all terms. Thus, \( \tau[\Bbbs] = \sigma[\Bbbs] \).

    \item If the equation was introduced by \cref{alg:first_order_unification/orient}, the equation \( \sigma \syneq \tau \) in \( E_k \); hence \( \sigma[\Bbbs] = \tau[\Bbbs] \).

    \item Finally, if the equation was introduced by \cref{alg:first_order_unification/eliminate}, there exists some equations \( x \syneq \rho \) and \( \tau' \syneq \sigma' \) in \( E_k \) such that \( \tau = \tau'[x \mapsto \rho] \) and \( \sigma = \sigma'[x \mapsto \rho] \).

    Then
    \begin{equation*}
      \tau[\Bbbs] = \tau'[x \mapsto \rho][\Bbbs] = \tau'[\Bbbs_{x \mapsto \rho[\Bbbs]}]
    \end{equation*}

    But \( x[\Bbbs] = \rho[\Bbbs] \) since \( x \syneq \rho \) is an equation in \( E_k \), hence \( \Bbbs_{x \mapsto \rho[\Bbbs]} = \Bbbs \). Therefore,
    \begin{equation*}
      \tau[\Bbbs]
      =
      \tau'[\Bbbs]
      \reloset {\T{ind.}} =
      \sigma'[\Bbbs]
      =
      \sigma[\Bbbs].
    \end{equation*}
  \end{itemize}

  It follows that \( \Bbbs \) unifies \( E_k \) for any \( k \), and hence also \( U(E) \).

  \SubProof{Proof that the algorithm reflects unifiers} We can also show that if \( \Bbbs \) unifies \( E_{k+1} \), it unifies \( E_k \).

  Let \( \tau \syneq \sigma \) be an equation in \( E_k \) not in \( E_{k+1} \).
  \begin{itemize}
    \item If the equation was eliminated by \cref{alg:first_order_unification/delete}, then \( \tau = \sigma \), which trivially implies that \( \tau[\Bbbs] = \sigma[\Bbbs] \).
    \item If the equation was eliminated by \cref{alg:first_order_unification/decompose}, then \( \tau = f(\tau_1, \ldots, \tau_n) \) and \( \sigma = f(\sigma_1, \ldots, \sigma_n) \), where each of the equations \( \tau_k \syneq \sigma_k \) is in \( E_{k+1} \).

    By the inductive hypothesis, it follows that
    \begin{equation*}
      \tau[\Bbbs]
      =
      f(\tau_1[\Bbbs], \ldots, \tau_n[\Bbbs])
      =
      f(\sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs])
      =
      \sigma[\Bbbs].
    \end{equation*}
  \end{itemize}

  It follows that \( \Bbbs \) unifies \( E_k \) for any \( k \), and hence also \( E = E_0 \).

  \SubProof{Proof that aborting is correct} Suppose that \( E_k \) is not in solved form, but no rules are applicable. We will show that \( E_k \) has no unifiers. It will follow that \( E \) also has no unifiers, since we have just shown that the unifiers of \( E \) and \( E_k \) coincide.

  We have the following possibilities:
  \begin{itemize}
    \item \( E_k \) can contain multiple equations that solve some variable \( x \), i.e. \( x \syneq \tau \) and \( x \syneq \sigma \) for some terms \( \tau \) and \( \sigma \).

    If \( \tau = \sigma \), we could have used \cref{alg:first_order_unification/deduplicate}, so they must be different. In this case there cannot be a unifier.

    \item \( E_k \) can contain equations \( x \syneq \tau \) and \( y \syneq \sigma \), where \( x \) is a variable in \( \sigma \).

    If \( x \) and \( y \) were different, we could have used \cref{alg:first_order_unification/eliminate}, so they must coincide.

    Then we have an equation \( x \syneq \sigma \), there \( \sigma \) contains \( x \). \Cref{thm:fol_unifier_non_existence/var} shows that this equation has no unifier.

    \item \( E_k \) can contain an equation \( \tau \syneq \sigma \), where \( \tau \) is a function application, say \( \tau = f(\tau_1, \ldots, \tau_n) \).

    If \( \sigma \) is a variable, we could have used \cref{alg:first_order_unification/orient}, so it must also be an application, say \( \sigma = g(\sigma_1, \ldots, \sigma_m) \).

    If \( f = g \), we could have used \cref{alg:first_order_unification/decompose}, so they must be different.

    \Cref{thm:fol_unifier_non_existence/fun} shows that this equation has no unifier.
  \end{itemize}

  In all cases, we have shown that \( E_k \) has no unifier. Then neither does \( E \).
\end{defproof}

\begin{example}\label{ex:alg:first_order_unification}
  We list examples related to \fullref{alg:first_order_unification}:
  \begin{thmenum}
    \thmitem{ex:alg:first_order_unification/empty} Clearly every substitution unifies \( x \syneq x \). The algorithm suggests removing this equation and then unifying the empty system of equations.

    \thmitem{ex:alg:first_order_unification/loop} The equation \( x \syneq f(x) \) has no unifier since, for any substitution \( \Bbbs \), \( \Bbbs(x) \) is a strict subterm of \( f(x)[\Bbbs] = f(x[\Bbbs]) \).

    The algorithm aborts in this case, and \cref{thm:fol_unifier_non_existence/var} implies that no unifier exists.

    This may be harder to detect is systems with many equations. For example, given \( x \syneq f(y) \) and \( y \syneq g(x) \), \( x \) can be eliminated to form \( y \syneq g(f(y)) \).

    \thmitem{ex:alg:first_order_unification/glue} The system consisting of \( x \syneq f(y) \) and \( x \syneq f(z) \) allows eliminating \( x \) from the second equation to obtain \( f(y) \syneq f(z) \) and then using decomposition to obtain \( y \syneq z \). Finally, we eliminate \( y \) from the first equation and obtain the simpler system in solved form with \( x \syneq f(z) \) and \( y \syneq z \).

    \thmitem{ex:alg:first_order_unification/418a}\mcite[exerc. 4.18(a)]{BaaderNipkow2012TermRewriting} For the equation \( f(x, y) \syneq f(g(c), x) \), where \( c \) is a constant, the unification algorithm suggests into \( x \syneq g(c) \) and \( y \syneq x \) and then eliminating \( x \) from the second equation to obtain a substitution sending both \( x \) and \( y \) to \( g(c) \). \Cref{thm:fol_canonical_unifier_is_most_general} implies that this substitution it is both most general and idempotent.

    \thmitem{ex:alg:first_order_unification/418b}\mcite[exerc. 4.18(b)]{BaaderNipkow2012TermRewriting} We decompose the equation \( f(x, y) \syneq f(g(x), x) \) into \( x \syneq g(x) \) and \( y \syneq x \). We eliminate \( x \) from the second equation and obtain \( y \syneq g(x) \).

    Unfortunately, the final system is not in solved form; \cref{thm:fol_unifier_non_existence/var} implies that \( x \syneq g(x) \) has no unifier.

    \thmitem{ex:alg:first_order_unification/418c}\mcite[exerc. 4.18(c)]{BaaderNipkow2012TermRewriting} We decompose the equation \( f(x, c) \syneq f(g(y), z) \) into \( x \syneq g(y) \) and \( c \syneq z \). After orienting the second equation, we obtain a solved form, so we have a unifier sending \( x \) to \( g(y) \) and \( z \) to \( c \).

    \thmitem{ex:alg:first_order_unification/418d}\mcite[exerc. 4.18(d)]{BaaderNipkow2012TermRewriting} We decompose the equation \( f(x, x) \syneq f(g(y), y) \) into \( x \syneq g(y) \) and \( x \syneq y \). We eliminate \( x \) from the second equation and obtain \( g(y) \syneq y \), which we orient.

    \Cref{thm:fol_unifier_non_existence/var} implies that no unifier exists in this case.
  \end{thmenum}
\end{example}
\begin{comments}
  \item Many of these examples are verified programmatically in the module \identifier{math.logic.test_unification} in \cite{notebook:code}.
\end{comments}
