\section{Unisorted unification}\label{sec:unisorted_unification}

\paragraph{Equality}

\begin{concept}\label{con:equality}
  In addition to judgments, discussed in \cref{con:judgment}, another essentially undefinable fundamental notion is that of \term{equality}. It is a primordial \hyperref[def:equivalence_relation]{equivalence relation} that can, in some cases, be characterized formally.

  \tcite{In his essay #2, #1 writes}[222]{Mazur2008Equality}
  \begin{displayquote}
    One can't do mathematics for more than ten minutes without grappling, in some way or other, with the slippery notion of equality. Slippery, because the way in which objects are presented to us hardly ever, perhaps never, immediately tells us --- without further commentary --- when two of them are to be considered equal.
  \end{displayquote}

  On a \hyperref[con:syntax_semantics_duality]{syntactic level}, following \cite[19]{UnivalentFoundationsProgram2013HoTT}, for a given \hyperref[con:metalanguage]{object language} we can distinguish between \term{judgmental equality}, dictated by a judgment asserting that two expressions in the object language are equal, and \term{propositional equality}, an equality \hyperref[con:proposition]{proposition} within the object language itself. The latter is formalized for \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} in \cref{def:mltt_propositional_equality}.

  When introducing his type theory in \cite[85]{MartinLöf1984IntuitionisticTypeTheory}, Per Martin-L\"of calls \term{definitional equality} what is essentially judgmental equality. In his later work \cite[40]{MartinLöf1984IntuitionisticTypeTheory}, Martin-L\"of describes definitional equality as follows:
  \begin{displayquote}
    Definitional equality is the equivalence relation generated by abbreviatory definitions, changes of bound variables and the principle of substituting equals for equals.
  \end{displayquote}

  We use the following symbols:
  \begin{center}
    \begin{tabular}{lcc}
      \toprule
                      & Definitional equality & Propositional equality \\
      \midrule
      Metalanguage    & \( \coloneqq \)       & \( = \)      \\
      Object language & \( \judgeq \)         & \( \syneq \) \\
      \bottomrule
    \end{tabular}
  \end{center}

  On a \hyperref[con:syntax_semantics_duality]{semantic level}, we can utilize Leibniz' \enquote{identity of indiscernibles} principle discussed in \cref{rem:identity_of_indiscernibles} to justify equating objects that have identical properties. On a metatheoretic level two objects may be distinct, but as long as they satisfy the same collection of desired properties, we can construct an equivalence relation that will be used to interpret equality propositions in the object language.
\end{concept}

\begin{remark}\label{rem:identity_of_indiscernibles}
  \incite[163]{Kleene2002Logic} calls the following principle \enquote{identity of indiscernibles}:
  \begin{displayquote}
    \textellipsis if we can discern no property \( P \) in which \( x \) and \( y \) differ, \( x \) and \( y \) are identical.
  \end{displayquote}

  Suppose we have a \hyperref[def:fol_signature]{first-order predicate} \( \op{Indiscernible} \) that validates this principle\fnote{It can be expressed in \hyperref[def:higher_order_logic]{higher-order logic} as
  \begin{equation*}
    \op{Indiscernible} \coloneqq \qabs {\synx^{\syn\iota}} \qabs {\syny^{\syn\iota}} \qforall {\synp^{\syn\iota \synimplies \syn\omicron}} \synp\synx \syniff \synp\syny
  \end{equation*}}.

  Kleene attributes it to Gottfried Leibniz. In \cite[54]{Russell1900LeibnizPhilosophy}, a book discussing Leibniz' philosophy, Bertrand Russell describes the principle using Leibniz' own words (translated into English):
  \begin{displayquote}
    \textellipsis there are not in nature two indiscernible real absolute beings
  \end{displayquote}
  and
  \begin{displayquote}
    \textellipsis no two substances are completely similar, or differ solely in number
  \end{displayquote}

  While the interpretation of the second sentence is ambiguous, we can confidently express the first as
  \begin{equation*}
    \neg \qexists \synx \qexists \syny (\op{Indiscernible}(\synx, \syny) \synwedge \neg (\synx \syneq \syny)),
  \end{equation*}
  which, due to the classical equivalences from \cref{thm:classical_equivalences} and \cref{thm:first_order_quantifiers_are_dual} (adapted to second-order logic), can be rewritten as
  \begin{equation}\label{eq:rem:identity_of_indiscernibles/forward}
    \qforall \synx \qforall \syny (\op{Indiscernible}(\synx, \syny) \synimplies \synx \syneq \syny).
  \end{equation}

  The \hyperref[def:conditional_formula/converse]{converse} is sometimes used. For example, \incite[278]{Farmer2008STTVirtues} states that
  \begin{displayquote}
    Leibniz' Law says that if two things are equal they satisfy exactly the same properties.
  \end{displayquote}
  and formalizes the law as
  \begin{equation}\label{eq:rem:identity_of_indiscernibles/backward}
    \qforall \synx \qforall \syny (\synx \syneq \syny \synimplies \op{Indiscernible}(\synx, \syny)).
  \end{equation}

  \incite[\S 9.1.4]{Mimram2020ProgramEqualsProof} refers to the former as the \enquote{identity of indiscernibles} and to the latter as the \enquote{indiscernibility of identicals}. He defines \enquote{Leibniz equality} in line with the above suggestion by Kleene:
  \begin{equation}\label{eq:rem:identity_of_indiscernibles/bi}
    \qforall \synx \qforall \syny (\op{Indiscernible}(\synx, \syny) \syniff \synx \syneq \syny).
  \end{equation}
\end{remark}

\begin{concept}\label{con:extensionality}
  When discussing \hyperref[def:inference_rule]{inference rules} akin to \ref{inf:def:first_order_natural_deduction_systems/eq/sub}, \incite[164]{Kleene2002Logic} describes \term{extensionality} as follows:
  \begin{displayquote}
    The same property is also sometimes described as \enquote{extensionality}, from the standpoint of the contexts in which \( x = y \) justifies the replacement of \( x \) by \( y \). A context in which such replacement is justified is called \textit{extensional}; one in which it is not, \textit{nonextensional} or sometimes \textit{intensional}.
  \end{displayquote}

  A related notion of \term{function extensionality}, defined by \incite[407]{Mimram2020ProgramEqualsProof} as follows:
  \begin{displayquote}
    \ldots we declare that two functions \( f \) and \( g \) of type \( A \to B \) are \textit{extensionally equal} when, for every element \( x \) of type \( A \), we have \( f(x) = g(x) \).
  \end{displayquote}

  Here \( f \) can be substituted for \( g \) as long as only their values are concerned. This may be inappropriate if \( f \) and \( g \) carry additional information like a syntactic representation (for example, via \hyperref[def:lambda_term]{\( \muplambda \)-terms}).
\end{concept}
\begin{comments}
  \item Leibniz' \hyperref[rem:identity_of_indiscernibles]{\enquote{identity of indiscernibles}} principle allows us to derive equality of \( x \) and \( y \), while extensionality allows us to use this equality to substitute \( x \) for \( y \).
\end{comments}

\paragraph{Equations}

\begin{definition}\label{def:equation}\mimprovised
  For expressing \hyperref[con:equality]{propositional equality}, we will find useful the following general definition.

  Consider the strings generated by the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{left side}  {\bnfpn{term}}, \\
    \bnfprod{right side} {\bnfpn{term}}, \\
    \bnfprod{equation}   {\bnfpn{left side} \bnfsp \bnftsq{\( \syneq \)} \bnfsp \bnfpn{right side}},
  \end{bnf*}
  where, as in \cref{def:logical_context}, we have purposefully not specified rules for the nonterminal \( \bnfpn{term} \) in order to encompass different kinds of terms.

  We require that the resulting grammar is \hyperref[def:grammar_ambiguity]{unambiguous} so that we can treat equations as pairs of terms.
\end{definition}
\begin{comments}
  \item Equations are \hyperref[con:assumed_knowledge]{assumed knowledge}, so definitions across the literature to base this one upon can hardly be found. We simply generalize to arbitrary terms the more established first-order equations from \cref{def:fol_equation}.
\end{comments}

\begin{concept}\label{con:equation_solution}
  \hyperref[def:equation]{Equations} are by fiat assumed to be \hyperref[con:hypothetical_judgment]{hypothetical} judgments or propositions, where the task of finding the hypotheses is implicit. We call this process \term{equation solving} and refer to a viable collection of hypotheses as a \term{solution}.

  If an equation has no hypotheses, solving it becomes meaningless. We will refer to such equations as \term[bg=тъждества (\cite[2]{Обрешков1962ВисшаАлгебра}), en=identities (\cite[50]{BaaderNipkow2012TermRewriting})]{identities}. All possible values are solutions to an identity.
\end{concept}
\begin{comments}
  \item Equations and identities are \hyperref[con:assumed_knowledge]{assumed knowledge}; a confirmation of our description above is the following excerpt from \cite[50]{BaaderNipkow2012TermRewriting}:
  \begin{displayquote}
    We use the name \enquote{identity} for a pair of terms \( s \approx t \) to express that this equation is assumed to \textit{hold} in an algebra, and distinguish this from the notion of an \enquote{equation}, which must be \enquote{solved} in an algebra.
  \end{displayquote}
\end{comments}

\begin{definition}\label{def:system_of_equations}\mimprovised
  We refer to nonempty \hyperref[def:ordered_tuple]{lists} of \hyperref[def:equation]{equations} as \term[en=equation system (\cite[\S 5.4.1]{Mimram2020ProgramEqualsProof})]{systems}.
\end{definition}

\begin{concept}\label{con:equivalent_systems_of_equations}
  We call two \hyperref[def:system_of_equations]{systems} of equations \term{equivalent} if they have the same solutions.
\end{concept}

\begin{example}\label{ex:def:equation}
  \hyperref[def:equation]{Equations} provide a simple way to specify rich semantic structure using simple syntactic objects. A remarkable portion of mathematics concerns the study of different kinds equations.

  \begin{thmenum}
    \thmitem{ex:def:equation/linear} Matrix theory can be regarded as the study of \hyperref[def:system_of_linear_equations]{systems of linear equations}. See \fullref{ch:linear_algebra}.

    \thmitem{ex:def:equation/dynamical} \hyperref[def:dynamical_system]{Dynamical systems} are often specified via equations, for example \hyperref[def:recurrence_relation]{recurrence relations}, \hyperref[def:difference_equation]{difference equations} or differential equations. See \fullref{ch:dynamical_systems}.

    \thmitem{ex:def:equation/nonsmooth} \hyperref[def:zero_of_function]{Zeros} of generalized derivatives are studied in optimization. See \fullref{sec:nonsmooth_derivatives}.

    \thmitem{ex:def:equation/fixed} \hyperref[def:function_fixed_point]{Fixed points} of functions are studied in different branches of mathematics. See \fullref{thm:fixed_point_existence}.

    \thmitem{ex:def:equation/algebraic} \hyperref[def:polynomial_equation]{Algebraic equations} are useful across different branches of mathematics.
  \end{thmenum}
\end{example}

\paragraph{Simultaneous substitution}

\begin{definition}\label{def:atomic_fol_substitution}\mimprovised
  We will define \hyperref[con:syntactic_substitution]{atomic substitution} for \hyperref[def:fol_term]{first-order terms} and \hyperref[def:fol_formula]{formulas} based on how we have defined it for \hyperref[def:lambda_term]{\( \muplambda \)-term} in \cref{def:atomic_lambda_term_substitution}.

  Namely, for a fixed \hyperref[def:fol_signature]{signature} \( \Sigma \), we will need a pair \( (\Bbbs, \sharp) \), where
  \begin{thmenum}[series=def:atomic_fol_substitution]
    \thmitem{def:atomic_fol_substitution/atomic} \( \Bbbs: \op*{Var} \to \op*{Term}_\Sigma \) is a function specifying how variables need to be replaced with terms. We allow only finitely many variables to not be fixed by \( \Bbbs \). We call \( \Bbbs \) an \term{atomic substitution}.

    \thmitem{def:atomic_fol_substitution/sharp} \( \sharp \) is, as in \cref{def:atomic_lambda_term_substitution/sharp}, a function providing us with fresh variables, i.e. \( \sharp(V) \) is a new variable not in \( V \).

    By default, we suppose that \( \sharp(V) \) is the smallest, with respect to the \hyperref[def:variable_identifier]{identifier order}, variable not in \( V \).
  \end{thmenum}

  The following two auxiliary notions are then adapted directly from \cref{def:atomic_fol_substitution}:
  \begin{thmenum}[resume=def:atomic_fol_substitution]
    \thmitem{def:atomic_fol_substitution/modified} We can \term{modify} \( \Bbbs \) at \( x \) with \( y \):
    \begin{equation}\label{eq:def:atomic_fol_substitution/modified}
      \Bbbs_{x \mapsto y}(u) \coloneqq \begin{cases}
        y,        &u = x, \\
        \Bbbs(u), &u \neq x.
      \end{cases}
    \end{equation}

    \thmitem{def:atomic_fol_substitution/free} For defining capture-avoiding substitution, we will need the function
    \begin{equation}\label{eq:def:atomic_fol_substitution/free/terms}
      \op*{Var}_\Bbbs(\tau) \coloneqq \bigcup_{\mathclap{v \in \op*{Var}(\tau)}} \op*{Var}(\Bbbs(v))
    \end{equation}
    for terms and
    \begin{equation}\label{eq:def:atomic_fol_substitution/free/formulas}
      \op*{Free}_\Bbbs(\varphi) \coloneqq \bigcup_{\mathclap{v \in \op*{Free}(\varphi)}} \op*{Free}(\Bbbs(v))
    \end{equation}
    for formulas.
  \end{thmenum}
\end{definition}

\begin{algorithm}[First-order term substitution]\label{alg:fol_term_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to arbitrary \hyperref[def:fol_term]{first-order terms} as follows:
  \begin{empheq}[left={\tau[\Bbbs]} \coloneqq \empheqlbrace]{align}
    &\Bbbs(x),                                                   &&\tau = x \in \op*{Var},               \label{eq:alg:fol_term_substitution/var}         \\
    &f\parens[\big]{ \sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs] }, &&\tau = f(\sigma_1, \ldots, \sigma_n). \label{eq:alg:fol_term_substitution/application}
  \end{empheq}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.substitution.apply_substitution_to_term} in \cite{notebook:code}.
  \item This substitution has the properties listed in \cref{rem:variable_binding_properties}, but since we perform no renaming, these properties are trivial. Compare this to \fullref{alg:fol_formula_substitution}, for which the properties are made explicit in \cref{thm:alg:fol_formula_substitution}.
\end{comments}

\begin{algorithm}[First-order assignment substitution]\label{alg:fol_assignment_substitution}\mimprovised
  We can extend an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution} \( (\Bbbs, \sharp) \) to a arbitrary \hyperref[def:fol_variable_assignment]{first-order variable assignment} \( v \) in the \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \) as follows:
  \begin{equation}\label{eq:alg:fol_assignment_substitution}
    v[\Bbbs](x) \coloneqq \Bracks{\Bbbs(x)}_\mscrX^v.
  \end{equation}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.structure.apply_substitution_to_assignment} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:fol_assignment_substitution_compatibility}
  \Fullref{alg:fol_term_substitution} and \fullref{alg:fol_assignment_substitution} are compatible:
  \begin{equation}\label{eq:thm:fol_assignment_substitution_compatibility}
    \Bracks{\tau}_\mscrX^{v[\Bbbs]} = \Bracks{\tau[\Bbbs]}_\mscrX^v,
  \end{equation}
\end{proposition}
\begin{proof}
  We will use \fullref{thm:induction_on_abstract_syntax} on \( \tau \) simultaneously on all assignments to show \eqref{eq:thm:fol_assignment_substitution_compatibility}.

  \begin{itemize}
    \item If \( \tau \) is a variable, say \( x \), then
    \begin{equation*}
      \Bracks{\tau}_\mscrX^{v[\Bbbs]}
      \reloset {\eqref{eq:alg:fol_term_substitution/var}} =
      v[\Bbbs](x)
      \reloset {\eqref{eq:alg:fol_assignment_substitution}} =
      \Bracks{\Bbbs(x)}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_term_substitution/var}} =
      \Bracks{\tau[\Bbbs]}_\mscrX^v.
    \end{equation*}

    \item If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), and if the inductive hypothesis holds for \( \sigma_1, \ldots, \sigma_n \), then
    \begin{multline*}
      \Bracks{\tau}_\mscrX^{v[\Bbbs]}
      \reloset {\eqref{eq:alg:fol_term_substitution/application}} =
      I(f) \parens[\big]{ \Bracks{\sigma_1}_\mscrX^{v[\Bbbs]}, \ldots, \Bracks{\sigma_n}_\mscrX^{v[\Bbbs]} }
      \reloset {\T{ind.}} = \\ =
      I(f) \parens[\big]{ \Bracks{\sigma_1[\Bbbs]}_\mscrX^v, \ldots, \Bracks{\sigma_n[\Bbbs]}_\mscrX^v }
      \reloset {\eqref{eq:alg:fol_term_denotation/fun}} =
      \Bracks[\big]{f(\sigma_1[\Bbbs], \ldots, \sigma_n[\Bbbs])}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_term_substitution/application}} =
      \Bracks{\tau[\Bbbs]}_\mscrX^v.
    \end{multline*}
  \end{itemize}
\end{proof}

\paragraph{Unification}

\begin{definition}\label{def:fol_equation}\mcite[39]{BaaderNipkow2012TermRewriting}
  In \hyperref[def:first_order_logic]{first-order logic}, an \hyperref[def:equation]{equation} is simply an equality formula \( \tau \syneq \sigma \). Equivalently, we can regard it is a pair of first-order terms.

  \begin{thmenum}
    \thmitem{def:fol_equation/system}\mimprovised A \hyperref[def:system_of_equations]{system} of first-order equations is then a list
    \begin{equation}\label{eq:def:fol_equation/system}
      \begin{aligned}
        \tau_1 &\syneq \sigma_1, \\
               &\vdots \\
        \tau_n &\syneq \sigma_n.
      \end{aligned}
    \end{equation}
    of equality formulas.

    \thmitem{def:fol_equation/syntactic_solution}\mcite[def. 4.5.4]{BaaderNipkow2012TermRewriting} A \term[ru=унификатор (\cite[def. 4.3.6]{Герасимов2014Вычислимость})]{unifier} or \term[en=solution (\cite[def. 4.5.4]{BaaderNipkow2012TermRewriting})]{syntactic solution} to the system \eqref{eq:def:fol_equation/system} is an \hyperref[def:atomic_fol_substitution]{atomic substitution} \( \Bbbs \) such that \( \tau_i[\Bbbs] \) and \( \sigma_i[\Bbbs] \) coincide for \( i = 1, \ldots, n \).

    \thmitem{def:fol_equation/semantic_solution}\mimprovised A \term{semantic solution} to the system \eqref{eq:def:fol_equation/system} in the \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \) is a \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) such that \( \Bracks{\tau_i}_\mscrX^v \) and \( \Bracks{\sigma_i}_\mscrX^v \) coincide for \( i = 1, \ldots, n \).

    We call the collection of all such assignments the \term{solution set} of \eqref{eq:def:fol_equation/system} in \( \mscrX \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item \Cref{thm:fol_unifier_semantic_solution} shows compatibility of syntactic and semantic solutions.
\end{comments}

\begin{proposition}\label{thm:fol_unifier_semantic_solution}
  Let \( \Bbbs \) be an \hyperref[def:atomic_lambda_term_substitution]{atomic simultaneous substitution}. Let \( v \) be any \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) in any \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \).

  Then the assignment \( v[\Bbbs] \) obtained via \fullref{alg:fol_assignment_substitution} \hyperref[def:fol_equation/semantic_solution]{solves} the system.
\end{proposition}
\begin{proof}
  For every equation \( \tau \syneq \sigma \), we have
  \begin{equation*}
    \Bracks{\tau}^{v[\Bbbs]}
    \reloset {\eqref{eq:thm:fol_assignment_substitution_compatibility}} =
    \Bracks{\tau[\Bbbs]}^v
    =
    \Bracks{\sigma[\Bbbs]}^v
    \reloset {\eqref{eq:thm:fol_assignment_substitution_compatibility}} =
    \Bracks{\sigma}^{v[\Bbbs]}.
  \end{equation*}
\end{proof}

\begin{concept}\label{con:unification}
  \term[en=unification, ru=унификация (\cite[\S 4.3]{Герасимов2014Вычислимость})]{unification}
  \todo{}
\end{concept}
