\section{First-order theories}\label{sec:first_order_theories}

\paragraph{Theories}

\begin{definition}\label{def:fol_theory}\mimprovised
  We restate here some definitions related to \hyperref[def:logical_theory]{logical theories}, adapted to \hyperref[def:first_order_logic]{first-order logic}.

  First and foremost, a (syntactic or semantic) \term[ru=теория (\cite[def. 3.1.1]{Герасимов2014Вычислимость}), en=theory (\cite[def. 2.4.1]{Hinman2005Logic})]{theory} is, as in \cref{def:general_logic_theory}, a set of sentences closed under logical consequence. For any set of sentences \( \Gamma \), we denote its consequence closure by \( \cat{Th}(\Gamma) \), and say that \( \Gamma \) \term{axiomatizes} \( \cat{Th}(\Gamma) \).

  \begin{thmenum}
    \thmitem{def:fol_theory/morphism} As in \cref{def:entailment_system_theory/morphism}, we call the \hyperref[def:fol_signature_category/morphisms]{first-order signature morphism} \( t: \Sigma \to \Sigma' \) a \term{theory morphisms} from \( (\Sigma, T) \) to \( (\Sigma', T') \) if the translation via \fullref{alg:fol_formula_signature_translation} of the formulas in \( T \) belong to \( T' \).

    \thmitem{def:fol_theory/extension} Of special interest is the case where \( t: \Sigma \to \Sigma^+ \) is the inclusion map of a \hyperref[def:fol_signature_extension]{signature extension}. In this case translation is does nothing, and \( t \) is a theory morphism from \( (\Sigma, T) \) to \( (\Sigma^+, T^+) \) if and only if \( T \) is a subset of \( T^+ \).

    We call \( T^+ \) an \term{extension} of \( T \).

    \thmitem{def:fol_theory/category} Based on theories and their morphisms, as per \cref{def:category_of_theories}, we have a category of (syntactic or semantic) theories \( \ucat{Th} \) for every \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \).

    \thmitem{def:fol_theory/conservative} Based on \cref{def:entailment_system_theory/conservative}, we say that a theory morphism \( t: (\Sigma, T) \to (\Sigma', T') \) is \term[en=conservative extension (\cite[180]{Hinman2005Logic})]{conservative} when \( \varphi \) belongs to \( T \) if and only if \( \op*{Sen}(t)(\varphi) \) belongs to \( T' \).

    Sufficiency is obvious for both semantic entailment and natural deduction, so it usually suffices to check that \( \op*{Sen}(t)(\varphi) \in T' \) implies \( \varphi \in T \).

    \thmitem{def:fol_theory/model}\mcite[def. 2.4.4]{Hinman2005Logic} As in \cref{def:theory_of_institutional_model}, we define the \term{theory} \( \cat{Th}(\mscrX) \) \hi{of} a structure \( \mscrX \) as the set of all sentences valid in \( \mscrX \).

    \thmitem{def:fol_theory/consistent}\mcite[def. 2.6.19]{Герасимов2014Вычислимость} We call a first-order theory \term[ru=непротиворечивое (множество формул)]{consistent} if \( T \) contains no \hyperref[def:fol_semantics/tautology]{contradictions}, i.e. if \( T \) does not contain \( \synbot \).

    More generally, a set of sentences \( T \) is consistent if \( \synbot \) cannot be derived from it.

    We discuss consistent theories in a general setting in \cref{def:consistent_set_of_sentences}, and give equivalent conditions for syntactic theories in \cref{thm:propositional_semantic_inconsistency} and for semantic theories in \cref{thm:propositional_semantic_inconsistency}. The latter also shows that semantic consistency is equivalent to \hyperref[def:propositional_semantics/satisfaction]{satisfiability}.

    \thmitem{def:fol_theory/complete}\mcite[def. 2.4.i]{Hinman2005Logic} We call a first-order theory \( T \) \term[ru=полное (множество формул) (\cite[def. 2.6.20]{Герасимов2014Вычислимость})]{complete} if, for every sentence \( \varphi \), \( T \) contains either \( \varphi \) or \( \synneg \varphi \) (or possibly both, if the theory is inconsistent).

    More generally, a set of sentences \( T \) is complete if, for every sentence \( \varphi \), we can derive either \( \varphi \) or \( \synneg \varphi \) (or possibly both) from \( T \).

    We will discuss complete theories in a general setting in \cref{def:complete_set_of_sentences}, and prove in \cref{thm:propositional_syntactically_complete_set} that it coincides with our notion when restricted to classical logic.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:def:fol_theory}
  \hyperref[def:fol_theory]{First-order theories} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_theory/model_theory_consistent_complete} For every structure \( \mscrX \), the theory \( \cat{Th}(\mscrX) \) is consistent and complete.

    \thmitem{thm:def:fol_theory/theory_morphism_reduct} For every \hyperref[def:fol_theory/morphism]{theory morphism} \( t: (\Sigma, T) \to (\Sigma', T') \), if \( \mscrY \) is a model of \( T' \), its \hyperref[def:fol_reduct_along_morphism]{reduct} \( \red_t(\mscrY) \) is a model of \( T \).

    The reduct is taken with respect to the underlying signature morphism of \( t \). We show that the theory morphism is also compatible with this reduct.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_theory/model_theory_consistent_complete} Analogous to \cref{thm:def:propositional_theory/model_theory_consistent_complete}.

  \SubProofOf{thm:def:fol_theory/theory_morphism_reduct} Suppose that \( \mscrY \) is a model of \( T' \).

  Consider the theory morphism \( t: (\Sigma, T) \to (\Sigma', T') \). By definition, it is a signature morphism that translates formulas from \( T \) to formulas from \( T' \).

  The reduct \( \red_t(\mscrY) \) along the \hi{signature morphism} \( t \). Suppose that \( \mscrY \) is a model of \( T' \), i.e. \( \Bracks{\psi}_\mscrY = \semtop \) for every formula \( \psi \) in \( T' \). In particular, \( \Bracks{\varphi[t]}_\mscrY = \semtop \) for every \( \varphi \) in \( T \).

  \Cref{thm:fol_structure_reduct_denotation/formulas} implies that \( \Bracks{\varphi}_{\red_t(\mscrY)}^v = \semtop \) for every \( \varphi \) in \( T \); hence, \( \red_t(\mscrY) \) is a model of \( T \).
\end{proof}

\begin{definition}\label{def:fol_theory_model_functor}\mimprovised
  Consider the \hyperref[def:fol_institution]{first-order institution} over the \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \).

  This institution has a \hyperref[def:fol_institution/models]{model functor} \( \cat{Mod}: \cat{Sign} \to \cat{Cat}^{\oppos} \) which sends each \hyperref[def:fol_signature]{signature} \( \Sigma \) to the category \( \cat{Mod}(\Sigma) \) of all \hyperref[def:fol_structure]{structures} and \hyperref[def:fol_homomorphism]{homomorphisms} over \( \Sigma \), and each \hyperref[def:fol_signature_category/morphisms]{signature morphism} \( t: \Sigma \to \Sigma' \) to the corresponding \hyperref[def:fol_institution/models/hom]{reduct functor} \( \cat{Mod}(t): \cat{Mod}(\Sigma') \to \cat{Mod}(\Sigma) \).

  We can extend \( \cat{Mod} \) to a functor \( \cat{Mod}: \cat{Th} \to \cat{Cat}^{\oppos} \) on the corresponding \hyperref[def:fol_theory/category]{category of theories}:
  \begin{thmenum}
    \thmitem{def:fol_theory_model_functor/obj} We send a theory \( T \) to the \hyperref[def:subcategory/full]{\hi{full} subcategory} of \( \cat{Mod}(\Sigma) \) of all structures in which \( T \) is \hyperref[def:fol_semantics/model]{valid}.

    We denote it by \( \cat{Mod}(T) \) and refer to it as the \term{category of \( \mscrU \)-small models of \( T \)}.

    It is important that we have required the subcategory \( \cat{Mod}(T) \) to be full. Thus, what counts as a model in \( \cat{Mod}(T) \) depend on the axioms of \( T \), but what counts as a homomorphism depend solely on \( \Sigma \). In particular, if \( T \) is the empty theory, then \( \cat{Mod}(T) \) coincides with \( \cat{Mod}(\Sigma) \).

    \thmitem{def:fol_theory_model_functor/hom} We send the \hyperref[def:fol_theory/morphism]{theory morphism} \( t: (\Sigma, T) \to (\Sigma', T') \) to the aforementioned reduct functor \( \cat{Mod}(t): \cat{Mod}(\Sigma') \to \cat{Mod}(\Sigma) \). To highlight that the functor acts on theories, we denote it by \( \cat{Mod}(t): \cat{Mod}(T') \to \cat{Mod}(T) \).

    The reduct functor only depends on the underlying signature morphism, but, as shown in \cref{thm:def:fol_theory/theory_morphism_reduct}, whether the reduct is a model of \( T \) generally depends on \( T' \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item For established theories, instead of \( \cat{Mod}(T) \), we introduce specific names. For example, we use \( \cat{Grp} \) for the \hyperref[def:group/category]{category of groups} or \( \cat{Lat} \) for \hyperref[def:lattice/theory]{category of lattices}.

  \item We have skipped the \( \mscrU \) prefix here for brevity, but all the aforementioned categories depend on \( \mscrU \).

  \item This definition is based on the discussion in \bycite[105]{GoguenBurstall1992Institutions}.
\end{comments}

\begin{proposition}\label{thm:def:fol_theory_model_functor}
  The \hyperref[def:fol_theory_model_functor]{theory model functor} \( \cat{Mod}: \cat{Th} \to \cat{Cat}^{\oppos} \) has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_theory_model_functor/reduct_faithful} For every theory morphism \( t: (\Sigma, T) \to (\Sigma', T') \), the corresponding reduct functor \( \cat{Mod}(t): \cat{Mod}(T') \to \cat{Mod}(T) \) is \hyperref[def:functor_invertibility/faithful]{faithful}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_theory_model_functor/reduct_faithful} Fix two models \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) of \( T' \), and consider their reducts \( \red_t(\mscrX) = (X, I_t) \) and \( \red_t(\mscrY) = (Y, J_t) \). \Cref{thm:def:fol_theory/theory_morphism_reduct} implies that they are models of \( T \).

  If \( \red_t(h) \) and \( \red_t(g) \) coincide for homomorphisms \( h \) and \( g \) in \( \cat{Mod}(\Sigma) \), they agree as functions on \( X \), thus \( h \) and \( g \) also coincide as homomorphisms in \( \cat{Mod}(\Sigma) \). Hence, \( \cat{Mod}(t) \) is faithful.
\end{proof}

\begin{definition}\label{def:fol_theory_forgetful_functor}\mimprovised
  The \hyperref[def:fol_theory_model_functor/obj]{theory model functor} \( \cat{Mod}: \cat{Th} \to \cat{Cat}^{\oppos} \) induces many \hyperref[def:concrete_category]{forgetful functors}.

  \begin{thmenum}
    \thmitem{def:fol_theory_forgetful_functor/reduct} For every theory morphism \( t: (\Sigma, T) \to (\Sigma', T') \), the corresponding reduct functor \( \cat{Mod}(t): \cat{Mod}(T') \to \cat{Mod}(T) \) can be regarded as forgetful.

    \thmitem{def:fol_theory_forgetful_functor/set} For any category of models \( \cat{Mod}(T) \), there is a natural functor \( U: \cat{Mod}(T) \to \cat{Set} \) sending each structure to its universe and each homomorphism to its underlying function.
  \end{thmenum}
\end{definition}
\begin{defproof}
  \Cref{thm:def:fol_theory_model_functor/reduct_faithful} implies that the reduct functors are faithful, and the proof for \( U \) is even simpler, so the implicit requirement of faithfulness from \cref{def:concrete_category} is satisfied.
\end{defproof}

\begin{example}\label{ex:def:fol_theory_model_functor}
  We list examples related to \hyperref[def:fol_theory_model_functor]{theory model functor} \( \cat{Mod}: \cat{Th} \to \cat{Cat}^{\oppos} \):
  \begin{thmenum}
    \thmitem{ex:def:fol_theory_model_functor/order} The \hyperref[def:preordered_set/theory]{partially ordered sets} extend the \hyperref[def:preordered_set/theory]{theory of preordered sets} with the antisymmetry condition \eqref{eq:def:binary_relation/antisymmetric}.

    The homomorphisms of partially ordered sets are \hyperref[def:order_function/preserving]{order-preserving maps}, as in the case of the more general preordered sets. This is to be expected since we have not modified the signature.

    On the other hand, the \hyperref[def:lattice/theory]{theory of lattices} introduces new function symbols and only introduces the familiar inequalities via \hyperref[def:fol_definitional_extension]{definitional extensions}.

    \thmitem{ex:def:fol_theory_model_functor/groups} The \hyperref[def:group/theory]{theory of groups} extends \hyperref[def:monoid/theory]{that of monoids} with the unary symbol \( {\syninv} \), which forces it to also adapt the notion of homomorphisms.

    On the other hand, the \hyperref[def:abelian_group]{abelian groups} extend only the theory, so the homomorphisms of abelian groups are precisely those of groups.
  \end{thmenum}
\end{example}

\paragraph{Topological structures}

\begin{definition}\label{def:topological_fol_structures}\mcite[159]{Robinson1974TopologicalModelTheory}
  A \term{topological structure} over the \hyperref[def:fol_signature]{signature} \( \Sigma \) is a triple \( \mscrX = (X, I, \mscrT) \), where \( (X, I) \) is a structure in the sense of \cref{def:fol_structure} and \( \mscrT \) is a \hyperref[def:topological_space]{topology} on \( X \).

  We require the following compatibility conditions:
  \begin{thmenum}
    \thmitem{def:topological_fol_structures/functions} For every function symbol \( f \) or arity \( n \), the function \( I(f): X^n \to X \) is \hyperref[def:global_continuity]{continuous}.

    \thmitem{def:topological_fol_structures/predicates} For every predicate symbol \( p \) of arity \( n \), the \hyperref[def:function_support]{support} of \( I(p) \) is either open or closed in \( X^n \).

    We call \( I(p) \) \term{open} or \term{closed} depending on whether its support is.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item For every algebraic structure defined in \fullref{ch:group_theory} and \fullref{ch:ring_theory}, there exists a topological equivalent. We discuss \hyperref[def:topological_group]{topological groups} and \hyperref[def:topological_vector_space]{topological vector spaces} through the monograph, especially in \fullref{ch:functional_analysis}.
\end{comments}

\begin{definition}\label{def:fol_theory_topological_model_functor}\mimprovised
  Based on the \hyperref[def:fol_theory_model_functor]{model functor} \( \cat{Mod}: \cat{Th} \to \cat{Cat}^{\oppos} \), we define a \term{topological model functor} \( \cat{TopMod}: \cat{Th} \to \cat{Top}^{\oppos} \) by considering \hyperref[def:topological_fol_structures]{topological structures} and \hyperref[def:global_continuity]{continuous} \hyperref[def:fol_homomorphism]{homomorphisms}.
\end{definition}

\paragraph{Subobjects}

\begin{definition}\label{def:fol_monomorphism}\mimprovised
  Consider some \hyperref[def:fol_theory_model_functor/obj]{category of models} \( \cat{Mod}(T) \). Based on the categorical terminology from \cref{def:morphism_invertibility/left_cancellative}, we say that the homomorphism \( h: \mscrX \to \mscrY \) is a \term{monomorphism} if it is left-cancellative, i.e. if \( h \bincirc g_1 = h \bincirc g_2 \) implies that \( g_1 = g_2 \).

  We say that \( h \) \term{splits} if it has a \hyperref[def:morphism_invertibility/left_invertible]{left inverse}, i.e. a homomorphism \( g: \mscrY \to \mscrX \) such that \( g \bincirc h = \id_\mscrX \).
\end{definition}
\begin{comments}
  \item If \( h \) has a left inverse, \cref{thm:def:morphism_invertibility/split_monomorphism} implies that it automatically follows that it is a monomorphism.

  \item This definition is a direct restatement of the general categorical one, but the context allows some simplifications. For many useful theories, monomorphisms between first-order models are precisely injective homomorphisms. See \cref{rem:def:fol_monomorphism}.

  Split monomorphisms, on the other hand, are more restrictive than even \hyperref[def:fol_embedding]{embeddings} --- see \cref{ex:def:fol_monomorphism/no_left_inverse}.

  \item Since \( \cat{Mod}(T) \) generally has more objects than \( \cat{Mod}(T') \) when \( T \subseteq T' \), it is possible for \( h \) to be a monomorphism in \( \cat{Mod}(T') \) but not in \( \cat{Mod}(T) \) (and conversely for split monomorphisms).
\end{comments}

\begin{remark}\label{rem:def:fol_monomorphism}
  \hyperref[def:fol_monomorphism]{Monomorphisms} of first-order models are better behaved than those in general categories. This mainly stems from the connection to set-theoretic invertibility.

  Indeed, consider the \hyperref[def:fol_theory_forgetful_functor/set]{forgetful functor} \( U: \cat{Mod}(T) \to M \) and structures \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \). The universes \( X \) and \( Y \) are by definition nonempty, so \cref{thm:concrete_category_function_invertibility/injective} implies that, for any homomorphism \( h: \mscrX \to \mscrY \), the following are equivalent:
  \begin{itemize}
    \item \( U(h) \) is left-cancellative (i.e. a categorical monomorphism) in \( \cat{Set} \).

    \item \( U(h) \) is left-invertible (i.e. a categorical split monomorphism) in \( \cat{Set} \).

    \item \( U(h) \) is injective.
  \end{itemize}

  Thus, if \( U(h) \) is injective, it is left-cancellative, i.e. \( U(h) \bincirc \alpha_1 = U(h) \bincirc \alpha_2 \) must imply \( \alpha_1 = \alpha_2 \) for all \hi{functions} \( \alpha_1 \) and \( \alpha_2 \). This is a stronger conditions than left cancellation of \( h \), where \( \alpha_1 \) and \( \alpha_2 \) must be homomorphisms. So injective homomorphisms are monomorphisms. The converse may fail, but counterexamples are sparse; see \cite{MathSE:categories_where_monomorphisms_differ_from_injective_morphisms}.

  Nevertheless, as shown in \cref{thm:concrete_category_function_invertibility/injective}, monomorphisms are precisely injective homomorphisms when \( U: \cat{Mod}(T) \to M \) has a \hyperref[def:category_adjunction]{left adjoint}. This is the case, for example, for \hyperref[def:fol_equational_theory]{equational theories}, which have \hyperref[def:fol_free_term_model]{free term models}.

  We can say less about the left invertibility of \( h \). Indeed, if \( U(h) \) is injective, it is left-invertible, but \( h \) may fail to be. If \( \alpha \bincirc U(h) = \id_X \) for \hi{some} function \( \alpha \), the mere existence of \( \alpha \) does not entail the existence of a homomorphism \( g \) such that \( U(g) = \alpha \). In fact, we show in \cref{ex:def:fol_monomorphism/no_left_inverse} that left invertible homomorphisms are even more general than \hyperref[def:fol_monomorphism]{first-order embeddings}.
\end{remark}

\begin{proposition}\label{thm:def:fol_monomorphisms}
  \hyperref[def:fol_monomorphism]{First-order monomorphisms} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_monomorphisms/monomorphism} Every \hyperref[def:fol_monomorphism]{embedding} is a monomorphism (left-cancellative homomorphism).

    \thmitem{thm:def:fol_monomorphisms/split_monomorphism} Every split monomorphism (left-invertible homomorphism) is an embedding.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_monomorphisms/monomorphism} Follows from \cref{thm:concrete_category_function_invertibility/injective} since an embedding is by definition injective.

  \SubProofOf{thm:def:fol_monomorphisms/split_monomorphism} Let \( g: \mscrY \to \mscrX \) be a left inverse of \( h: \mscrX \to \mscrY \).

  \Cref{thm:concrete_category_function_invertibility/injective} implies that \( h \) is injective. Furthermore, we have
  \begin{equation*}
    I(p)(a_1, \ldots, a_n)
    \leq
    J(p)\parens[\big]{ h(a_1), \ldots, h(a_n) }
    \leq
    I(p)\parens[\big]{ g(h(a_1)), \ldots, g(h(a_n)) }
    =
    I(p)(a_1, \ldots, a_n),
  \end{equation*}
  so the homomorphism is strong. Thus, it is an embedding because it satisfies \cref{def:fol_monomorphism/direct}.
\end{proof}

\begin{example}\label{ex:def:fol_monomorphism}
  We list examples of \hyperref[def:fol_monomorphism]{first-order monomorphisms}:
  \begin{thmenum}
    \thmitem{ex:def:fol_monomorphism/no_left_inverse} Consider the \hyperref[def:fol_embedding]{embedding} \( h(n) \coloneqq 2n \) of the additive group \( (\BbbZ, +) \) into itself.

    It is indeed an embedding because it is obviously injective, and there are no predicate symbols in the theory of abelian groups.

    Suppose it has a left inverse \( g \). Then
    \begin{equation*}
      n = [g \bincirc h](n) = g(2n) = 2 g(n),
    \end{equation*}
    so \( g(n) = n / 2 \). But \( n / 2 \) must be an integer, which is not possible if \( n \) is odd.

    The obtained contradiction shows that \( h \) has no left inverse, and that having a left inverse is stronger than being an embedding.
  \end{thmenum}
\end{example}

\begin{definition}\label{def:categorical_subobject}\mcite[18]{Jacobson1989BasicAlgebraII}
  In some \hyperref[def:category]{category}, define an equivalence relation on \hyperref[def:morphism_invertibility/left_cancellative]{monomorphisms} \( f: B \to A \) and \( g: C \to A \) with a common codomain \( A \) to hold if there exists an \hyperref[def:morphism_invertibility/isomorphism]{isomorphism} \( h: B \to C \) such that \( f = g \bincirc h \).

  We call the equivalence classes of this relation \term{subobjects} of \( A \).
\end{definition}
\begin{comments}
  \item The definition is also discussed in \cite{MathSE:categorical_subobject_definition}.

  \item Due to \cref{thm:fol_categorical_subobjects} and analogous results, we will mostly regard subobjects as concrete canonical objects with an obvious inclusion map.

  \item This definition is dual to \hyperref[def:categorical_quotient_object]{quotient objects}.
\end{comments}
\begin{defproof}
  We must show that the above equivalence is indeed an equivalence relation.

  \SubProofOf[def:binary_relation/reflexive]{reflexivity} For every morphism, we have \( f = f \bincirc \id \) by definition.

  \SubProofOf[def:binary_relation/symmetric]{symmetry} If \( f = g \bincirc h \) for some isomorphism \( h \), then \( g = f \bincirc h^{-1} \).

  \SubProofOf[def:binary_relation/transitive]{transitivity} If \( f = g \bincirc h \) and \( k = g \bincirc l \), then
  \begin{equation*}
    f = g \bincirc h = (k \bincirc l^{-1}) \bincirc h = k \bincirc (l^{-1} \bincirc h).
  \end{equation*}
\end{defproof}

\begin{example}\label{ex:def:categorical_subobject}
  We list examples of \hyperref[def:categorical_subobject]{categorical subobjects}:
  \begin{thmenum}
    \thmitem{ex:def:categorical_subobject/sets} Consider the \hyperref[def:category_of_small_sets]{category of small sets} \( \cat{Set} \).

    By definition, \( \set{ 1 } \) is a subset of \( \set{ 1, 2 } \). Categorically, this is manifested by the inclusion \( \iota_1: \set{ 1 } \to \set{ 1, 2 } \). It is clearly injective and, by \cref{thm:function_invertibility_categorical/nonempty_left_invertible}, a categorical monomorphism. Thus, \( \iota_1 \) induces a subobject.

    Similarly, \( \set{ 2 } \) is a subset of \( \set{ 1, 2 } \), and the inclusion map \( \iota_2: \set{ 2 } \to \set{ 1, 2 } \) induces a subobject.

    There is a unique isomorphism \( h: \set{ 1 } \to \set{ 2 } \), however,
    \begin{equation*}
      1 = \iota_1(1) \neq \iota_2(h(1)) = 2,
    \end{equation*}
    so the two subsets correspond to different categorical subobjects.

    On the other hand, the map \( 2 \mapsto 1 \) is equivalent to \( \iota_1 \). To avoid confusion, we will focus on inclusion maps.
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:fol_categorical_subobjects}
  Consider some \hyperref[def:fol_theory_model_functor/obj]{category of models} \( \cat{Mod}(T) \).

  If \( \mscrY = (Y, J) \) and \( \mscrZ = (Z, K) \) are \hyperref[def:fol_substructure/model]{submodels} of \( \mscrX = (X, I) \), the inclusions \( \iota_Y: Y \to X \) and \( \iota_Z: Z \to X \) induce the same \hyperref[def:categorical_subobject]{categorical subobject} of \( \mscrX \) in \( \cat{Mod}(T) \) if and only if \( Y = Z \).
\end{proposition}
\begin{comments}
  \item An analogous statement holds for \hyperref[def:categorical_quotient_object]{quotient objects} --- see \cref{thm:fol_categorical_quotient_objects}.
\end{comments}
\begin{proof}
  \SufficiencySubProof Suppose that \( \iota_Y: Y \to X \) and \( \iota_Z: Z \to X \) are equivalent, i.e. there exists some isomorphism \( h: Y \to Z \) such that \( \iota_Y = \iota_Z \bincirc h \).

  Both \( \iota_Y \) and \( \iota_Z \) are embeddings by \cref{thm:fol_inclusion_is_embedding}, and hence monomorphisms by \cref{thm:def:fol_monomorphisms/monomorphism}, so they induce subobjects.

  For every \( b \) in \( Y \), we have \( b = \iota_Y(b) = \iota_Z(h(b)) = h(b) \), which in particular implies that all elements of \( Y \) belong to \( Z \).

  Similarly, for every \( c \) in \( Z \), we have \( c = \iota_Z(c) = \iota_Y(h^{-1}(c)) = h(c) \), which implies that \( Z \) is a subset of \( Y \). We have used here that the categorical isomorphism \( h \) is bijective, which follows from the equivalences in \cref{def:fol_isomorphism}.

  \NecessitySubProof Conversely, suppose that \( Y = Z \). Then \( \iota_Y = \iota_Z \), so obviously they correspond to the same subobject.
\end{proof}

\paragraph{Quotient objects}

\begin{definition}\label{def:fol_epimorphism}\mimprovised
  Consider some \hyperref[def:fol_theory_model_functor/obj]{category of models} \( \cat{Mod}(T) \). Based on the categorical terminology from \cref{def:morphism_invertibility/right_cancellative}, we say that the homomorphism \( h: \mscrX \to \mscrY \) is an \term{epimorphism} if it is right-cancellative, i.e. if \( g_1 \bincirc h = g_2 \bincirc h \) implies that \( g_1 = g_2 \).

  We say that \( h \) \term{splits} if it has a \hyperref[def:morphism_invertibility/right_invertible]{right inverse}, i.e. a homomorphism \( g: \mscrY \to \mscrX \) such that \( h \bincirc g = \id_\mscrY \).
\end{definition}
\begin{comments}
  \item If \( h \) has a right inverse, \cref{thm:def:morphism_invertibility/split_epimorphism} implies that it automatically follows that it is an epimorphism.

  \item This definition is a direct restatement of the general categorical one, but the context allows some simplifications. For some useful theories like \hyperref[def:group]{groups} or \hyperref[def:module]{modules}, epimorphisms are precisely surjective homomorphisms.

  \item Since \( \cat{Mod}(T) \) generally has more objects than \( \cat{Mod}(T') \) if \( T \subseteq T' \), it is possible for \( h \) to be an epimorphism in \( \cat{Mod}(T') \) but not in \( \cat{Mod}(T) \) (and conversely for split epimorphisms).
\end{comments}

\begin{proposition}\label{thm:fol_quotient_map_is_epimorphism}
  The projection map of a \hyperref[def:fol_quotient_structure/model]{quotient model} is a \hyperref[def:function_invertibility/surjective]{surjective} \hyperref[def:fol_epimorphism]{epimorphism}.
\end{proposition}
\begin{proof}
  Follows from \cref{thm:concrete_category_function_invertibility/surjective}.
\end{proof}

\begin{definition}\label{def:categorical_quotient_object}\mcite[18]{Jacobson1989BasicAlgebraII}
  In some \hyperref[def:category]{category}, define an equivalence relation on \hyperref[def:morphism_invertibility/right_cancellative]{epimorphisms} \( f: A \to B \) and \( g: A \to C \) with a common domain \( A \) to hold if there exists an \hyperref[def:morphism_invertibility/isomorphism]{isomorphism} \( h: B \to C \) such that \( f = h \bincirc g \).

  We call the equivalence classes of this relation \term{quotient objects} of \( A \).
\end{definition}
\begin{comments}
  \item Due to \cref{thm:fol_categorical_subobjects} and analogous results, we will mostly regard quotient objects as concrete \hyperref[def:set_partition]{partitions} with an obvious projection map.

  \item This definition is dual to \hyperref[def:categorical_subobject]{subobjects}.
\end{comments}

\begin{proposition}\label{thm:fol_categorical_quotient_objects}
  Consider some \hyperref[def:fol_theory_model_functor/obj]{category of models} \( \cat{Mod}(T) \).

  If \( \mscrY = (Y, J) \) and \( \mscrZ = (Z, K) \) are \hyperref[def:fol_quotient_structure/model]{quotient models} of \( \mscrX = (X, I) \), the projections \( \pi_Y: X \to Y \) and \( \pi_Z: X \to Z \) induce the same \hyperref[def:categorical_quotient_object]{categorical quotient object} of \( \mscrX \) in \( \cat{Mod}(T) \) if and only if \( Y = Z \).
\end{proposition}
\begin{comments}
  \item An analogous statement holds for \hyperref[def:categorical_subobject]{subobjects} --- see \cref{thm:fol_categorical_subobjects}.
\end{comments}
\begin{proof}
  \SufficiencySubProof Suppose that \( \pi_Y: X \to Y \) and \( \pi_Z: X \to Z \) are equivalent, i.e. there exists some isomorphism \( h: Y \to Z \) such that \( \pi_Y = \pi_Z \bincirc h \).

  Both \( \pi_Y \) and \( \pi_Z \) are epimorphisms by \cref{thm:fol_quotient_map_is_epimorphism}, so they induce quotient objects.

  If \( \pi_Y(a) = \pi_Y(a') \), then
  \begin{equation*}
    \pi_Z(a) = h^{-1}(\pi_Y(a)) = h^{-1}(\pi_Y(a')) = \pi_Z(a').
  \end{equation*}

  The converse is analogously. Therefore, \( \pi_Y(a) = \pi_Y(a') \) if and only if \( \pi_Z(a) = \pi_Z(a') \).

  Since both \( Y \) and \( Z \) are partitions of \( X \), it follows that they are equal.

  \NecessitySubProof Conversely, suppose that \( Y = Z \). Then \( \pi_Y = \pi_Z \), so obviously they correspond to the same quotient object.
\end{proof}

\begin{definition}\label{def:simple_object}\mimprovised
  In a \hyperref[def:category]{category} with a \hyperref[def:universal_objects/zero]{zero object} \( Z \), we say that an object \( A \) is \term{simple} if its every \hyperref[def:categorical_quotient_object]{quotient object} of \( A \) is equivalent to \( 0_{Z,A}: Z \to A \) or \( \id: A \to A \).
\end{definition}

\paragraph{Elementary embeddings}

\begin{remark}\label{rem:fol_homomorphism_refinements}
  We discuss here several flavors of \hyperref[def:fol_homomorphism]{first-order homomorphisms}. Their relationship is visualized in \cref{fig:rem:fol_homomorphism_refinements} and made precise in \cref{thm:def:fol_function_respect} and \cref{thm:def:elementary_embedding}.

  We list some counterexample to this hierarchy in \cref{ex:rem:fol_homomorphism_refinements}.

  \begin{figure}[!ht]
    \hfill
    \begin{forest}
      [
        {\hyperref[def:fol_homomorphism]{homomorphism}}, name=basic
          [
            {\hyperref[def:fol_homomorphism]{strong} \\ \hyperref[def:fol_homomorphism]{homomorphism}}, align=center, name=strong
              [
                {\hyperref[def:fol_monomorphism]{embedding}}, name=embedding
                  [
                    {\hyperref[def:elementary_embedding]{elementary} \\ \hyperref[def:elementary_embedding]{embedding}}, align=center, name=elementary
                      [{\hyperref[def:fol_isomorphism]{isomorphism}}, name=isomorphism]
                  ]
              ]
          ]
      ]
      \draw[-, dashed] (embedding) to[in=east, out=east] node[right] {\hyperref[def:function_invertibility/injective]{injective}} (strong);
      \draw[-, dashed] (isomorphism) to[in=west, out=west] node[left] {\hyperref[def:function_invertibility/surjective]{surjective}} (embedding);
    \end{forest}
    \hfill\hfill
    \caption{First-order homomorphisms and related notions.}\label{fig:rem:fol_homomorphism_refinements}
  \end{figure}
\end{remark}

\begin{definition}\label{def:fol_function_respect}\mcite[def. 2.3.4]{Hinman2005Logic}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature}.

  \begin{thmenum}
    \thmitem{def:fol_function_respect/term} We say that the function \( h: X \to Y \) \term{respects} the term \( \tau \) if, for every \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) into \( \mscrX \), we have \( \Bracks{\tau}_\mscrY^{h \bincirc v} = h(\Bracks{\tau}_\mscrX^v) \).

    This can also be expressed via \hyperref[def:fol_parameterized_term_denotation]{parametrized term denotations}:
    \begin{equation}\label{eq:def:fol_function_respect/term}
      \Bracks{\tau}_\mscrY\parens[\big]{ h(a_1), \ldots, h(a_n) } = h\parens[\big]{ \Bracks{\tau}_\mscrX(a_1, \ldots, a_n) }.
    \end{equation}

    \thmitem{def:fol_function_respect/formula} Similarly, we say that \( h: X \to Y \) \term{respects} the formula \( \varphi \) if, for every variable assignment \( v \) into \( \mscrX \), we have \( \Bracks{\varphi}_\mscrY^{h \bincirc v} = \Bracks{\varphi}_\mscrX^v \).

    This can also be expressed via \hyperref[def:fol_parameterized_term_denotation]{parametrized formula denotations}:
    \begin{equation}\label{eq:def:fol_function_respect/formula}
      \Bracks{\varphi}_\mscrY\parens[\big]{ h(a_1), \ldots, h(a_n) } = \Bracks{\varphi}_\mscrX(a_1, \ldots, a_n).
    \end{equation}

    This is a strengthening of what we require for \hi{strong} homomorphisms.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:def:fol_function_respect}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \).

  The term and formula compatibility notions from \cref{def:fol_function_respect} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_function_respect/atomic} A function \( h: X \to Y \) is a \hyperref[def:fol_homomorphism]{strong homomorphism} if and only if it respects \hi{atomic} formulas.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_function_respect/atomic}
  \SufficiencySubProof* Suppose that \( h: X \to Y \) is a strong homomorphism. Fix an atomic formula \( \varphi \) and a variable assignment \( v \).

  We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( h \) respects \( \varphi \).
  \begin{itemize}
    \item If \( \varphi \) is a constant, by definition \( \Bracks{\varphi}_\mscrX^v = \semtop = \Bracks{\varphi}_\mscrY^{h \bincirc v} \) if \( \varphi = \syntop \) and similarly if \( \varphi = \synbot \).

    \item If \( \varphi = (\tau \syneq \sigma) \), where the inductive hypothesis holds for \( \tau \) and \( \sigma \), then
    \begin{equation*}
      \Bracks{\tau \syneq \sigma}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/eq}} =
      \delta\parens[\big]{ \Bracks{\tau}_\mscrX^v, \Bracks{\sigma}_\mscrX^v }
      \reloset {\T{ind.}} =
      \delta\parens[\big]{ \Bracks{\tau}_\mscrY^{h \bincirc v}, \Bracks{\sigma}_\mscrY^{h \bincirc v} }
      \reloset {\eqref{eq:alg:fol_formula_denotation/eq}} =
      \Bracks{\tau \syneq \sigma}_\mscrY^{h \bincirc v}
    \end{equation*}

    \item If \( \varphi = p(\tau_1, \ldots, \tau_n) \), we proceed similarly.
  \end{itemize}

  \NecessitySubProof* Suppose that \( h: X \to Y \) respects atomic formulas. We will show that it is a homomorphism.

  \begin{itemize}
    \item For a predicate symbol \( p \) in \( \Sigma \) of arity \( n \), since \( h \) respects atomic formulas, we have
    \begin{equation*}
      \Bracks{p(\synx_1, \ldots, \synx_n)}_\mscrX^v = \Bracks{p(\synx_1, \ldots, \synx_n)}_\mscrY^{h \bincirc v}.
    \end{equation*}

    Given elements \( a_1, \ldots, a_n \) in \( X \), we can take any assignment \( v \) satisfying \( v(\synx_k) = a_k \) for \( k = 1, \ldots, n \) to conclude that
    \begin{equation*}
      J(p)\parens[\big]{ h(a_1), \ldots, h(a_n) } = h\parens[\big]{ I(p)(a_1, \ldots, a_n) },
    \end{equation*}
    as desired.

    \item For a functional symbol \( f \) in \( \Sigma \) of arity \( n \), we consider the following equality formulas:
    \begin{equation}\label{thm:def:fol_function_respect/atomic/proof/functions}
      \Bracks{f(\synx_1, \ldots, \synx_n) \syneq \syny}_\mscrX^v = \Bracks{f(\synx_1, \ldots, \synx_n) \syneq \syny}_\mscrY^{h \bincirc v}
    \end{equation}
    for every variable assignment \( v \).

    Fix elements \( a_1, \ldots, a_n \) in \( X \) and consider any assignment \( v \) that satisfies \( v(\synx_k) = a_k \) for \( k = 1, \ldots, n \), and also
    \begin{equation*}
      v(\syny) = I(f)(a_1, \ldots, a_n).
    \end{equation*}

    From \eqref{thm:def:fol_function_respect/atomic/proof/functions} it follows that
    \begin{equation*}
      \delta\parens[\big]{ I(f)(a_1, \ldots, a_n), v(\syny) } = \delta\parens[\big]{ J(f)\parens[\big]{ h(a_1), \ldots, h(a_n) }, h(v(\syny)) }.
    \end{equation*}

    Since the interpretation of formal equality is standard, this amounts to
    \begin{equation*}
      I(f)(a_1, \ldots, a_n) = v(\syny) \T{if and only if} J(f)\parens[\big]{ h(a_1), \ldots, h(a_n) } = h(v(\syny)),
    \end{equation*}
    hence
    \begin{equation*}
      h(v(\syny)) = J(f)\parens[\big]{ h(a_1), \ldots, h(a_n) } = h\parens[\big]{ I(f)(a_1, \ldots, a_n) }.
    \end{equation*}

    Therefore, \( h \) is compatible with function application.
  \end{itemize}
\end{proof}

\begin{definition}\label{def:elementary_embedding}\mcite[def. 2.3.30; def. 2.3.43]{Hinman2005Logic}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \).

  We say that the function \( h: X \to Y \) is an \term[ru=элементарное вложение (\cite[237]{Мальцев1970АлгебраическиеСистемы})]{elementary embedding} if it \hyperref[def:fol_function_respect]{respects} every formula over \( \Sigma \).

  If \( \mscrX \) is a \hyperref[def:fol_substructure]{substructure} of \( \mscrY \) and the inclusion \( \iota: X \to Y \) is an elementary embedding, we call \( \mscrX \) an \term[ru=элементарная подмодель (\cite[237]{Мальцев1970АлгебраическиеСистемы})]{elementary substructure} of \( \mscrY \) and \( \mscrY \) --- an \term{elementary extension} of \( \mscrX \).
\end{definition}
\begin{comments}
  \item In this definition, we only require \( h \) to be a function. As shown in \cref{thm:def:elementary_embedding/embedding}, if \( h \) is an elementary embedding, it is an embedding in the sense of \cref{def:fol_monomorphism}. The converse is not generally true --- see \cref{ex:rem:fol_homomorphism_refinements/not_elementary}. Thus, it makes sense to say \enquote{non-elementary embedding}.
\end{comments}

\begin{proposition}\label{thm:def:elementary_embedding}
  \hyperref[def:elementary_embedding]{Elementary embeddings} for \hyperref[def:fol_structure]{structures} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:elementary_embedding/embedding} Every elementary embedding is a first-order embedding in the sense of \cref{def:fol_monomorphism}.

    \thmitem{thm:def:elementary_embedding/isomorphism} Every \hyperref[def:fol_isomorphism]{isomorphism} is an elementary embedding.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:elementary_embedding/embedding} An elementary embedding necessarily respects atomic formulas, so \cref{thm:def:fol_function_respect/atomic} implies that it is a strong homomorphism. We must only show injectivity.

  Let \( h: X \to Y \) be an elementary embedding from \( \mscrX = (X, I) \) to \( \mscrY = (Y, J) \). Suppose that \( h(a) = h(b) \). Let \( v \) be an assignment such that \( v(\synx) = a \) and \( v(\syny) = b \). Then
  \begin{equation*}
    \Bracks{\synx \syneq \syny}_\mscrX^v = \underbrace{\Bracks{\synx \syneq \syny}_\mscrY^{h \bincirc v}}_{\delta(h(a), h(b)) = \semtop},
  \end{equation*}
  hence \( a = b \).

  \SubProofOf{thm:def:elementary_embedding/isomorphism} Let \( h: X \to Y \) be an isomorphism between the structures \( \mscrX = (X, I) \) to \( \mscrY = (Y, J) \) over \( \Sigma \).

  Let \( \varphi \) be an arbitrary formula over \( \Sigma \) and let \( v \) be a variable assignment into \( \mscrX \).

  We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) simultaneously on all assignments \( v \) to show that \( h \) respects \( \varphi \).
  \begin{itemize}
    \item Since \( h \) is an isomorphism, it is a strong homomorphism, and hence by \cref{thm:def:fol_function_respect/atomic} it respects atomic formulas. So, it remains to verify only non-atomic formulas.

    \item If \( \varphi = (\psi \syncirc \theta) \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), we have
    \begin{equation*}
      \Bracks{\psi \bincirc \theta}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/conn}} =
      \Bracks{\psi}_\mscrX^v \bincirc \Bracks{\theta}_\mscrX^v
      \reloset {\T{ind.}} =
      \Bracks{\psi}_\mscrY^{h \bincirc v} \bincirc \Bracks{\theta}_\mscrY^{h \bincirc v}
      \reloset {\eqref{eq:alg:fol_formula_denotation/conn}} =
      \Bracks{\psi \bincirc \theta}_\mscrY^{h \bincirc v}
    \end{equation*}

    \item If \( \varphi = \qforall x \psi \), where the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Bracks{\qforall x \psi}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/forall}} =
      \bigwedge\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }
      \reloset {\T{ind.}} =
      \bigwedge\set[\big]{ \Bracks{\psi}_\mscrY^{h \bincirc v_{x \mapsto a}} \given* a \in X }
      =
      \bigwedge\set[\big]{ \Bracks{\psi}_\mscrY^{(h \bincirc v)_{x \mapsto b}} \given* b \in Y },
    \end{equation*}
    where we have used that \( (h \bincirc v)_{x \mapsto b} = h \bincirc v_{x \mapsto h^{-1}(b)} \).

    \item If \( \varphi = \qexists x \psi \), we proceed similarly.
  \end{itemize}
\end{proof}

\begin{example}\label{ex:rem:fol_homomorphism_refinements}
  We list counterexamples of the hierarchy of homomorphism-related notions from \cref{fig:rem:fol_homomorphism_refinements}:
  \begin{thmenum}
    \thmitem{ex:rem:fol_homomorphism_refinements/not_strong} Not every homomorphism is strong.

    Consider the constant function \( f(x) = 0 \) in \( \BbbR \). It is trivially an \hyperref[def:order_function/preserving]{order-preserving map} and hence an \hyperref[def:preordered_set/homomorphism]{order homomorphism}, i.e. a first-order homomorphism in the \hyperref[def:preordered_set/theory]{theory of preordered sets}. Yet, it is not a strong homomorphism because \( f(1) \leq f(0) \).

    \thmitem{ex:rem:fol_homomorphism_refinements/not_embedding} \Cref{fig:ex:rem:fol_homomorphism_refinements/not_embedding} demonstrates a nontrivial (but very simple) strong homomorphism between \hyperref[def:directed_graph]{simple directed graphs} that is injective.

    \begin{figure}[!ht]
      \centering
      \includegraphics[page=1]{output/ex__rem__fol_homomorphism_refinements__non_embedding}
      \caption{A non-injective \hyperref[def:directed_graph/homomorphism]{strong graph homomorphism}.}\label{fig:ex:rem:fol_homomorphism_refinements/not_embedding}
    \end{figure}

    \thmitem{ex:rem:fol_homomorphism_refinements/not_elementary}\mcite{MathSE:fol_homomorphism_isomorphism_and_related_notions} The inclusion of \( \BbbN \) into \( \BbbZ \) is an order homomorphism.

    It is not an elementary embedding because it does not respect the formula \( \qexists \synx \qforall \syny {\synx \synleq \syny} \).

    \thmitem{ex:rem:fol_homomorphism_refinements/not_isomorphism} Any two unbounded \hyperref[def:dense_total_order]{dense total orders} are elementarily equivalent. This is proven in \cite[ch. 2.4]{Hinman2005Logic}.

    Hence, as ordered sets, \( \BbbQ \) and \( \BbbR \) are elementarily equivalent. But they are not isomorphic because they have different cardinalities.
  \end{thmenum}
\end{example}

\begin{definition}\label{def:elementary_equivalence}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \).

  We say that \( \mscrX \) and \( \mscrY \) are \term[ru=элементарно эквивалентные (алгебраические системы) (\cite[235]{Мальцев1970АлгебраическиеСистемы}), en=elementarily equivalent (\cite[def. 2.3.3]{Hinman2005Logic})]{elementarily equivalent} and write \( \mscrX \equiv \mscrY \) if any of the following hold:
  \begin{thmenum}
    \thmitem{def:elementary_equivalence/direct}\mcite[def. 2.3.3]{Hinman2005Logic} \( \mscrX \vDash \varphi \) if and only if \( \mscrY \vDash \varphi \) for every \hi{closed} formula \( \varphi \) over \( \Sigma \).

    \smallskip

    \thmitem{def:elementary_equivalence/theory}\mcite[prop. 2.4.10(ii)]{Hinman2005Logic} The \hyperref[def:fol_theory/model]{theories} \( \cat{Th}(\mscrX) \) and \( \cat{Th}(\mscrY) \) coincide.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:cardinality_control_formulas}
  We can control the cardinality of \hyperref[def:fol_semantics/model]{first-order models} using the family of formulas \( \chi^{\geq n} \), defined as the \hyperref[def:fol_quantifier_closure]{existential closures} of
  \begin{equation*}
    \chi^{\geq n} \coloneqq \begin{cases}
      \syntop,                                                                                                                                                      &n = 1, \\
      \qforall {\synx_1} \ldots \qforall {\synx_{n-1}} \qexists \syny \synneg (\synx_1 \syneq \syny) \synwedge \cdots \synwedge \synneg (\synx_{n-1} \syneq \syny), &n > 1.
    \end{cases}
  \end{equation*}

  For \( n > 1 \), we define \( \chi^{< n} \) as the opposite of \( \chi^{\geq n} \) obtained via \fullref{alg:fol_formula_dualization}:
  \begin{equation*}
    \chi^{< n} \coloneqq \qexists {\synx_1} \ldots \qexists {\synx_{n-1}} \qforall \syny (\synx_1 \syneq \syny) \synvee \cdots \synvee (\synx_{n-1} \syneq \syny).
  \end{equation*}

  Then a structure satisfies \( \chi^{\geq n} \) if and only if it has at least \( n \) elements, and it satisfies \( \chi^{< n} \) if and only if it has less than \( n \) elements. It is thus natural to also define
  \begin{equation*}
    \chi^{=n} \coloneqq \begin{cases}
      \chi^{<2},                           &n = 1, \\
      \chi^{\geq n} \synwedge \chi^{<n+1}, &n > 1.
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item We handle the special case \( n = 1 \) separately because
  \begin{equation*}
    \chi^{\geq 1} \synwedge \chi^{<2} = \syntop \synwedge \qexists {\synx_1} \qforall {\syny} (\synx_1 \syneq \syny) = \syntop \synwedge \chi^{=1},
  \end{equation*}
  which can be simplified (as justified in \fullref{alg:propositional_constant_collapse}).

  An adaptation of the obtained formula \( \chi^{=1} \) is used for defining contractible types in \cref{def:contractible_type}.

  \item In classical logic, we can define \( \chi^{< n} \) as \( \synneg \chi^{\geq n} \). Using the specifically constructed complemented dual extends this more generally.

  \item These formulas are implemented in the module \identifier{math.logic.theories.equality} in \cite{notebook:code}.
\end{comments}
\begin{proof}
  Trivial.
\end{proof}

\begin{lemma}\label{thm:fol_finite_structure_characterizing_formula}\mcite[thm. 2.3.11(ii)]{Hinman2005Logic}
  Fix a finite structure \( \mscrX = (X, I) \) of finite cardinality \( n \) over \( \Sigma \).

  Then there exists a closed formula \( \varphi_\mscrX \) that characterizes \( \mscrX \) in the sense that every structure over \( \Sigma \) satisfying \( \varphi_\mscrX \) is \hyperref[def:fol_isomorphism]{isomorphic} to \( \mscrX \).

  For this to hold, we need \( \Sigma \) to contain no predicate symbols.
\end{lemma}
\begin{proof}
  Let \( a_1, \ldots a_n \) be an enumeration of the elements of \( X \). First, we will define set \( T_\mscrX \) of atomic formulas that capture the structure of \( \mscrX \):
  \begin{itemize}
    \item Fix a function symbol \( f \) in \( \Sigma \) of arity \( m \). For every \( m \)-tuple \( a_{i_1}, \ldots, a_{i_m} \) from \( X \), if \( f(a_{i_1}, \ldots, a_{i_m}) = a_j \), add to \( T_\mscrX \) the formula
    \begin{equation*}
      f(\synx_{i_1}, \ldots, \synx_{i_m}) \syneq \synx_j.
    \end{equation*}

    \item Fix a predicate symbol \( p \) in \( \Sigma \) of arity \( m \). For every \( m \)-tuple \( a_{i_1}, \ldots, a_{i_m} \) from \( X \) add to \( T_\mscrX \) the formula
    \begin{equation*}
      p(\synx_{i_1}, \ldots, \synx_{i_m})
    \end{equation*}
    if \( I(p)(a_{i_1}, \ldots, a_{i_m}) = \semtop \) and
    \begin{equation*}
      \synneg p(\synx_{i_1}, \ldots, \synx_{i_m})
    \end{equation*}
    otherwise.
  \end{itemize}

  For \( \varphi_\mscrX \) itself, we can take any \hyperref[def:fol_quantifier_closure]{existential closure} of any conjunction of all formulas in \( T_\mscrX \).

  Clearly \( \mscrX \) satisfies \( \varphi_\mscrX \) by sending \( \synx_i \) to \( a_i \). By elementary equivalence, \( \mscrY \) also satisfies \( \varphi_\mscrY \). Then there exists a variable assignment \( v \) into \( Y \) such that
  \begin{equation*}
    J(f)\parens[\big]{ v(\synx_{i_1}), \ldots, v(\synx_{i_m}) } = v(\synx_j)
  \end{equation*}
  for every function application formula in \( T_\mscrX \), i.e. if and only if
  \begin{equation*}
    I(f)(a_{i_1}, \ldots, a_{i_m}) = a_j.
  \end{equation*}

  Similarly,
  \begin{equation*}
    J(p)\parens[\big]{ v(\synx_{i_1}), \ldots, v(\synx_{i_m}) } = I(p)\parens[\big]{ a_{i_1}, \ldots, a_{i_m} }
  \end{equation*}

  Then \( v \) defines an embedding \( h: X \to Y \) by sending \( a_i \) to \( v(\synx_i) \).

  To show that \( h \) is an isomorphism, we will use the cardinality control formulas from \cref{thm:cardinality_control_formulas}. Let \( n \) be the cardinality of \( X \). Then \( \mscrX \vDash \chi^{=n} \). By elementary equivalence, we have \( \mscrY \vDash \chi^{=n} \), which implies that \( Y \) also has cardinality \( n \).
\end{proof}

\begin{proposition}\label{thm:def:elementary_equivalence}
  \hyperref[def:elementary_equivalence]{Elementary equivalence} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:elementary_equivalence/isomorphic} If two structures are \hyperref[def:fol_isomorphism]{isomorphic}, they are elementarily equivalent.

    \thmitem{thm:def:elementary_equivalence/embedding} If a structure \hyperref[def:fol_monomorphism]{embeds} into another, it is elementarily equivalent to its image.

    \thmitem{thm:def:elementary_equivalence/elementary_embedding} Assuming \hyperref[def:truth_value_algebra/classical]{classical semantics}, if a structure \hyperref[def:elementary_embedding]{elementarily embeds} into another, they are elementarily equivalent.

    \thmitem{thm:def:elementary_equivalence/finite}\mcite[thm. 2.3.11(i)]{Hinman2005Logic} Assuming classical semantics, if two structures are elementarily equivalent and one of them is finite, they are isomorphic.

    The assumption of classical semantics can be lifted if the signature has no predicate symbols.

    \thmitem{thm:def:elementary_equivalence/infinite} If two structures are elementarily equivalent and one of them is infinite, so is the other.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:elementary_equivalence/isomorphic} \Cref{thm:def:elementary_embedding/isomorphism} implies that every isomorphism, as well as its inverse, are elementary embeddings.

  \SubProofOf{thm:def:elementary_equivalence/embedding} Follows from \cref{thm:def:elementary_equivalence/isomorphic}.

  \SubProofOf{thm:def:elementary_equivalence/elementary_embedding} Assume we are working with classical semantics. Let \( \mscrX = (Y, J) \) and \( \mscrY = (X, I) \) be structures over \( \Sigma \). Let \( h: X \to Y \) be an elementary embedding.

  Since \( h \) preserves all formulas, it preserves closed ones in particular, so every closed formula valid in \( \mscrX \) is also valid in \( \mscrY \).

  Conversely, let \( \varphi \) be a closed formula valid in \( \mscrY \).

  Aiming at a contradiction, suppose that it is not valid in \( \mscrX \). \Fullref{thm:propositional_semantic_lem} implies that \( \synneg \varphi \) is valid in \( \mscrX \). Since \( \synneg \varphi \) is closed, it does not depend on a variable assignment; thus, because \( h \) is an elementary embedding, we conclude that \( \synneg \varphi \) is also valid in \( \mscrY \).

  But then both \( \varphi \) and \( \synneg \varphi \) are valid in \( \mscrY \), which contradicts \cref{thm:def:fol_theory/model_theory_consistent_complete}.

  The obtained contradiction shows that \( \varphi \) must be valid in \( \mscrX \). Generalizing on \( \varphi \), we conclude that \( \mscrX \) and \( \mscrY \) are elementarily equivalent.

  \SubProofOf{thm:def:elementary_equivalence/finite} Assume we are working with classical semantics. Let \( \mscrX \) and \( \mscrY \) be elementarily equivalent structures over \( \Sigma \). Suppose that \( \mscrX \) is finite.

  \Cref{thm:fol_finite_structure_characterizing_formula} gives us a closed formula \( \varphi_\mscrX \) that characterizes \( \mscrX \). By elementary equivalence, \( \mscrY \) satisfies \( \varphi_\mscrX \), hence it is isomorphic to \( \mscrX \).

  \SubProofOf{thm:def:elementary_equivalence/infinite} Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be structures over \( \Sigma \). Suppose that \( X \) is infinite.

  Again, we can use the cardinality control formulas from \cref{thm:cardinality_control_formulas}. We have \( \mscrX \vDash \chi^{\geq n} \) for every \( n \geq 1 \). By elementary equivalence, \( \mscrY \vDash \chi^{\geq n} \) for every \( n \geq 1 \), which implies that \( Y \) is also infinite.
\end{proof}

\paragraph{Definitional extensions}

\begin{concept}\label{con:primitive_notion}
  In a sufficiently complex \hyperref[con:metalogic]{object theory}, different notions can be defined via each other. If we want to use \hyperref[def:well_founded_relation]{well-founded} notions that are not defined circularly via each other, we must choose a subset of them that should to be characterized via axioms, and then use them to define the rest. Following \incite[28]{Kleene1971Metamathematics}, we will refer call these notions as \term{primitive}.

  For instance, when formalizing \hyperref[def:lattice]{lattices}, we may use an object theory based on one \hyperref[def:partially_ordered_set]{partial order relation} \( {\synleq} \), as we have done in \cref{def:lattice/theory}, or we may use a theory based on two operations \( {\latwedge} \) and \( {\latvee} \).

  The object language will feature all three symbols anyway. If we use the formalization from \cref{def:lattice/theory}, however, we will specify the behavior of \( {\synleq} \) via axioms, while the behavior of \( {\latwedge} \) and \( {\latvee} \) will be defined via that of \( {\synleq} \). Conversely, \cref{thm:lattice_from_binary_operations} shows how we can take \( {\latwedge} \) and \( {\latvee} \) as primitive and use them to specify how \( {\synleq} \) behaves.

  Usually the essential object of study is taken as primitive --- for example, sets and set membership are primitive in \fullref{ch:set_theory}, groups and group operations are primitive in \fullref{ch:group_theory}, vectors and vector space operations are primitive in \fullref{ch:linear_algebra} and so forth. This is mildly ironic because, for example, linear algebra cannot answer what a vector is beyond characterizing it as \enquote{an element of an abstract vector space}.

  Since it is impractical to make a definitive list of all required symbols beforehand, we will rely on \hyperref[def:fol_definitional_extension]{definitional extensions} and \hyperref[con:syntactic_abbreviation]{metalingual abbreviations}.
\end{concept}
\begin{comments}
  \item In addition to the adjective \enquote{primitive}, \incite[28]{Kleene1971Metamathematics} suggests \enquote{technical} and \enquote{undefined}. We will avoid the latter term because it would conflict with undefinedness as described in \cref{con:undefinedness}. See \cref{rem:undefined_and_primitive_terms} for disambiguation of the different notions of undefinedness.

  \item We avoid introducing a distinct term for symbols whose behavior is defined via others. \incite[28]{Kleene1971Metamathematics} suggests \enquote{ordinary}, \enquote{logical} and \enquote{defined}.
\end{comments}

\begin{concept}\label{con:syntactic_abbreviation}\mimprovised
  It is sometimes convenient to introduce a simplified notation for a more intricate \hyperref[con:expression]{expression}. We call this process \term{abbreviation}.

  Inside the \hyperref[con:metalogic]{object languages}, we can use \hyperref[def:fol_signature_category/morphisms]{signature translation} and \hyperref[def:fol_definition]{definitional extensions}. In case they are either insufficient or inconvenient, we may rely on notational shorthands entirely within the \hyperref[con:metalogic]{metalanguage}. For example, we use the \hyperref[con:description_operator/unique_existence]{unique existence quantifier} \( \qExists* x \varphi \) as an abbreviation of the more complicated expression \eqref{eq:rem:fol_formula_conventions/unique_existence}.
\end{concept}

\begin{definition}\label{def:fol_definition}\mcite[def. 2.6.11]{Hinman2005Logic}
  Fix a \hyperref[def:fol_theory]{first-order theory} \( T \) over the signature \( \Sigma \).

  \begin{thmenum}
    \thmitem{def:fol_definition/predicate} Consider some symbol \( p \) not in \( \Sigma \) and some formula \( \varphi_p \) whose free variables are among \( x_1, \ldots, x_n \).

    We can \hyperref[def:fol_signature_extension]{extend} \( \Sigma \) with \( p \) as an \( n \)-ary predicate and then form an \hyperref[def:fol_theory/extension]{extended theory} as the closure of \( T \) and the formula
    \begin{equation}\label{eq:def:fol_definition/predicate}
      \qforall {x_1} \cdots \qforall {x_n} (p(x_1, \ldots, x_n) \syniff \varphi_p).
    \end{equation}

    We call \eqref{eq:def:fol_definition/predicate} a \term{definition} of \( p \) in \( T \).

    \thmitem{def:fol_definition/function} Consider some symbol \( f \) not in \( \Sigma \) and some formula \( \varphi_f \) whose free variables are among \( x_1, \ldots, x_n \), and such that \( T \) contains
    \begin{equation}\label{eq:def:fol_definition/function/condition}
      \qforall {x_1} \cdots \qforall {x_n} \qexists y \varphi_f.
    \end{equation}

    We can extend \( \Sigma \) with \( f \) as an \( n \)-ary predicate and then form an extended theory as the closure of \( T \) and the formula
    \begin{equation}\label{eq:def:fol_definition/function}
      \qforall {x_1} \cdots \qforall {x_n} \qforall y (f(x_1, \ldots, x_n) \syneq y \syniff \varphi_f).
    \end{equation}

    We call \eqref{eq:def:fol_definition/function} a \term{definition} of \( f \) in \( T \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Of course, the new symbols are allowed to have any \hyperref[def:fol_signature/notation]{notation}.
\end{comments}

\begin{definition}\label{def:fol_definitional_extension}\mcite[def. 2.6.12]{Hinman2005Logic}
  We say that the \hyperref[def:fol_theory/extension]{theory extension} \( (\Sigma^+, T^+) \) of \( (\Sigma, T) \) is a \term{definitional extension} if there exist finitely many function and predicate symbols in \( \Sigma^+ \) but not \( \Sigma \) such that \( (\Sigma^+, T^+) \) can be obtained from \( (\Sigma, T) \) by adding definitions for these symbols in accordance with \cref{def:fol_definition}.
\end{definition}
\begin{comments}
  \item We do not disallow trivial definitional extensions, but will not find them useful.
  \item See \cref{thm:fol_definability_and_definitions} for how \hyperref[def:fol_definability]{definability} relates to definitional extensions.
\end{comments}

\begin{definition}\label{def:fol_definitional_structure_expansion}\mimprovised
  In the setting of \cref{def:fol_definitional_extension}, for every structure \( \mscrX = (X, I) \), we can define an \hyperref[def:fol_structure_expansion]{expansion} \( \mscrX^+ = (X, I^+) \), where \( I^+ \) extends \( I \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_definitional_structure_expansion/predicate} For each new \( n \)-ary predicate symbol \( p \), we use the \hyperref[def:fol_parameterized_formula_denotation]{parametrized formula denotation}:
    \begin{equation*}
      I^+(p)(a_1, \ldots, a_n) \coloneqq \Bracks{\varphi_p}_\mscrX(a_1, \ldots, a_n).
    \end{equation*}

    \thmitem{def:fol_definitional_structure_expansion/function} For each new \( n \)-ary function symbol \( f \), we define \( I^+(p)(a_1, \ldots, a_n) \) as the unique value \( y \) for which \( \Bracks{\varphi_p}_\mscrX(a_1, \ldots, a_n, y) = \semtop \).

    Uniqueness of \( y \) is guaranteed by \eqref{eq:def:fol_definition/function/condition}.
  \end{thmenum}

  We call it the \term{definitional expansion} of \( \mscrX \).
\end{definition}

\begin{lemma}\label{thm:fol_definitional_extension_model_uniqueness}
  In the setting of \cref{def:fol_definitional_structure_expansion}, if \( \mscrX \) is a model of \( T \), then \( \mscrX^+ \) is the unique expansion of \( \mscrX \) that is a model of \( T^+ \).
\end{lemma}
\begin{proof}
  It suffices to consider the case where \( (\Sigma^+, T^+) \) extends \( (\Sigma, T) \) with one definition. Suppose that \( \mscrX = (X, I) \) is a model of \( T \).

  \begin{itemize}
    \item Suppose that \( \Sigma^+ \) extends \( \Sigma \) with the \( n \)-ary predicate symbol \( p \).

    Every formula \( \varphi \) in \( \mscrX^+ \) is by definition a semantic consequence of \( T \) and \eqref{eq:def:fol_definition/predicate}, both of which \( \mscrX^+ \) satisfies. Then \( \mscrX^+ \) also satisfies \( \varphi \).

    Furthermore, any other interpretation of \( p \) would not satisfy \eqref{eq:def:fol_definition/predicate}, which demonstrates the uniqueness of \( \mscrX^+ \).

    \item The case for function symbols is similar.
  \end{itemize}
\end{proof}

\begin{proposition}\label{thm:fol_definitional_extension_conservative}
  \hyperref[def:fol_definitional_extension]{First-order definitional extensions} are \hyperref[def:fol_theory/conservative]{conservative}.
\end{proposition}
\begin{proof}
  It suffices to consider the case where \( (\Sigma^+, T^+) \) extends \( (\Sigma, T) \) with the definition of one symbol. Let \( \mscrX = (X, I) \) be a model of \( T \) and let \( \mscrX^+ = (X, I^+) \) be the corresponding expansion from \cref{def:fol_definitional_structure_expansion}.
  \begin{itemize}
    \item Suppose that \( \Sigma^+ \) extends \( \Sigma \) with the \( n \)-ary predicate symbol \( p \).

    Let \( \varphi \) be a formula from \( T^+ \) that does not contain \( f \).

    By \cref{thm:fol_definitional_extension_model_uniqueness}, the expansion \( \mscrX^+ \) is a model of \( T^+ \), and of \( \varphi \) in particular. Since \( \varphi \) does not contain \( f \), the denotation of \( \varphi \) in \( \mscrX^+ \) only uses the interpretation \( I \). Thus, \( \mscrX \) is also a model of \( \varphi \).

    Therefore, \( T^+ \) is conservative.

    \item The case for function symbols is similar.
  \end{itemize}
\end{proof}

\begin{example}\label{ex:def:fol_definitional_extension}
  We list examples of \hyperref[def:fol_definitional_extension]{definitional extensions}:
  \begin{thmenum}
    \thmitem{ex:def:fol_definitional_extension/sets} In \fullref{sec:naive_set_theory}, we define many operators on sets, and in \cref{thm:zfc_existence_theorems} we prove that they satisfy the condition \eqref{eq:def:fol_definition/function} for function definitions.

    \thmitem{ex:def:fol_definitional_extension/lattices} The \hyperref[def:lattice/theory]{theory of lattices} is only formulated using function symbols, and is adapted to the \hyperref[def:preordered_set/theory]{theory of preordered sets} via definitional extensions.
  \end{thmenum}
\end{example}

\paragraph{Definability}

\begin{definition}\label{def:fol_definability}\mcite[def. 2.3.37]{Hinman2005Logic}
  In a \hyperref[def:fol_structure]{first-order structure} \( \mscrX = (X, I) \), we say that the subset \( A \) of \( X^n \) is \term{definable} with \term{parameters} \( b_1, \ldots, b_m \) if there exists a formula \( \varphi_A \) with at most \( n + m \) free variables such that
  \begin{equation*}
    A = \set[\big]{ (a_1, \ldots, a_n) \in X^n \given* \Bracks{\varphi_A}_\mscrX^v(a_1, \ldots, a_n, b_1, \ldots, b_m) = \semtop }.
  \end{equation*}

  If \( A \) is definable without parameters, we simply say that it is \term{definable}.

  \begin{thmenum}
    \thmitem{def:fol_definability/predicate} As per \cref{rem:boolean_valued_functions_and_relations}, we may regard the \hyperref[def:subset_characteristic_function]{characteristic function} of \( A \) as the interpretation of a predicate symbol.

    \thmitem{def:fol_definability/function} If \( n > 1 \), we may also regard \( A \) as the interpretation of a \hyperref[def:set_valued_map]{set-valued map} from \( X^{n-1} \) to \( X \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item See \cref{thm:fol_definability_and_definitions} for how definability relates to \hyperref[def:fol_definitional_extension]{definitional extensions}.
  \item See \cref{def:set_builder_notation} and \fullref{thm:cumulative_hierarchy_model_of_zfc} for how this concept deeply relates to set theory.
\end{comments}

\begin{proposition}\label{thm:fol_definability_and_definitions}
  \hyperref[def:fol_definitional_extension]{Definitional extensions} and \hyperref[def:fol_definability]{definability} are related as follows:
  \begin{thmenum}
    \thmitem{thm:fol_definability_and_definitions/function} If the formula \( \varphi_f \) is used for a \hyperref[def:fol_definition/function]{function definition} of the symbol \( f \) in a \hyperref[def:fol_definitional_extension]{definitional extension} \( T^+ \) of \( T \), and if \( \mscrX \) is a model of \( T \), then the interpretation \( I^+(f) \) in the \hyperref[def:fol_definitional_structure_expansion]{definitional expansion} \( \mscrX^+ \) is \hyperref[def:fol_definability/function]{definable} by \( \varphi_f \) in \( \mscrX \).

    \thmitem{thm:fol_definability_and_definitions/predicates_extension} Similarly, if \( \varphi_p \) is used for a \hyperref[def:fol_definition/predicate]{predicate definition} of the symbol \( p \) in a \hyperref[def:fol_definitional_extension]{definitional extension} \( T^+ \) of \( T \), and if \( \mscrX \) is a model of \( T \), then the interpretation \( I^+(p) \) in the definitional expansion of \( \mscrX^+ \) is the \hyperref[def:subset_characteristic_function]{\hi{characteristic function}} of the set \hyperref[def:fol_definability/function]{definable} by \( \varphi_p \) in \( \mscrX \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  Straightforward.
\end{proof}

\begin{proposition}\label{thm:fol_definable_set_automorphism}\mcite[corr. 2.3.40]{Hinman2005Logic}
  \hyperref[def:fol_definability]{Definable sets} are \hyperref[def:invariant_subset]{invariant} under \hyperref[def:morphism_invertibility/automorphism]{automorphisms}.
\end{proposition}
\begin{proof}
  In the structure \( \mscrX = (X, I) \), suppose that the set \( A \) is definable by \( \varphi_A \).

  Fix an automorphism \( h: \mscrX \to \mscrX \). \Cref{thm:def:elementary_embedding/isomorphism} implies that \( h \) is an elementary embedding, so \( h \) \hyperref[def:fol_function_respect/formula]{respects} \( \varphi_A \).

  Therefore, \( h[A] \) is definable by \( \varphi_A \).
\end{proof}

\paragraph{Skolemization}

\begin{definition}\label{def:fol_prenex_normal_form}\mcite[def. 2.2.33]{Hinman2005Logic}
  We say that the \hyperref[def:fol_formula]{first-order formula} \( \varphi \) is in \term[ru=предварённая / пренексная нормальная форма (\cite[def. 2.5.1]{Герасимов2014Вычислимость})]{prenex normal form} if there exist quantifiers \( Q_1, \ldots, Q_n \) and variables \( x_1, \ldots, x_n \) such that
  \begin{equation*}
    \varphi = \quantifier {Q_1} {x_1} \ldots \quantifier {Q_n} {x_n} \psi,
  \end{equation*}
  where \( \psi \) contains no quantifiers.

  We call the \hi{formula} \( \psi \) the \term[ru=матрица (\cite[def. 2.5.1]{Герасимов2014Вычислимость})]{matrix} of \( \varphi \), and the \hi{string} \( \quantifier {Q_1} {x_1} \ldots {Q_n} {x_n} \) --- the \term[en=prefix (\cite[def. 2.2.33]{Hinman2005Logic})]{quantifier prefix} of \( \varphi \).
\end{definition}

\begin{algorithm}[First-order formula to prenex normal form]\label{alg:fol_formula_to_prenex_normal_form}
  We introduce an operator \( T_{\logic{PNF}} \) on \hyperref[def:fol_formula]{first-order formulas} that \enquote{pulls out} quantifiers in order to produce a \hyperref[def:fol_semantics/equivalence]{semantically equivalent} formula in \hyperref[def:fol_prenex_normal_form]{prenex normal form}.

  We proceed by recursion on \( \varphi \):
  \begin{thmenum}
    \thmitem{alg:fol_formula_to_prenex_normal_form/atomic} If \( \varphi \) is an atomic formula, let \( T_{\logic{pr}}(\varphi) \coloneqq \varphi \).

    \thmitem{alg:fol_formula_to_prenex_normal_form/negation} If \( \varphi = \synneg \psi \), let \( \psi' \coloneqq T_{\logic{PNF}}(\psi) \) and let
    \begin{equation*}
      T_{\logic{PNF}}(\varphi) \coloneqq \begin{cases}
        \quantifier {Q^{\oppos}} x T_{\logic{DNE}}(T_{\logic{PNF}}(\synneg \theta)), &\psi' = \quantifier Q x \theta, Q \in \op*{Quant}, \\
        \synneg \psi',                                                               &\T{otherwise.}
      \end{cases}
    \end{equation*}

    \thmitem{alg:fol_formula_to_prenex_normal_form/connectives} If \( \varphi = \psi \bincirc \theta \), let \( \psi' \coloneqq T_{\logic{PNF}}(\psi) \) and \( \theta' \coloneqq T_{\logic{PNF}}(\theta) \), and let
    \small
    \begin{equation*}
      T_{\logic{PNF}}(\varphi) \coloneqq \begin{cases}
        T_{\logic{PNF}}\parens[\big]{ (\psi' \synimplies \theta') \wedge (\theta' \synimplies \psi') }, &{\syncirc} \T{is} {\syniff} \T{and} \psi' \T{or} \theta' \T{have quantifiers}, \\
        \quantifier {Q^{\oppos}} n T_{\logic{PNF}}(\omega[x \mapsto n] \synimplies \theta'),            &{\syncirc} \T{is} {\synimplies} \T{and} \psi' = \quantifier Q x \omega \T{and} n = \op*{FVar}(\theta', x), \\
        \quantifier Q n T_{\logic{PNF}}(\omega[x \mapsto n] \synimplies \theta'),                       &\T{otherwise if} \psi' = \quantifier Q x \omega \T{and} n = \op*{FVar}(\theta', x), \\
        \quantifier Q n T_{\logic{PNF}}(\psi' \synimplies \omega[x \mapsto n]),                         &\T{otherwise if} \theta' = \quantifier Q x \omega \T{and} n = \op*{FVar}(\psi', x), \\
        \psi' \syncirc \theta',                                                                         &\T{otherwise,}
      \end{cases}
    \end{equation*}
    \normalsize
    where the auxiliary operator
    \small
    \begin{equation*}
      \op*{FVar}(\omega, x) \coloneqq \begin{cases}
        \sharp(\op*{Free}(\omega)), &x \in \op*{Free}(\omega), \\
        x,                          &\T{otherwise.}
      \end{cases}
    \end{equation*}
    \normalsize
    aids us in combining analogues of the renaming \eqref{eq:alg:fol_formula_substitution/quant/renaming} and non-renaming \eqref{eq:alg:fol_formula_substitution/quant/direct} cases for substitution.

    \thmitem{alg:fol_formula_to_prenex_normal_form/quantifiers} Finally, if \( \varphi = \quantifier Q x \psi \), let
    \begin{equation*}
      T_{\logic{PNF}}(\varphi) \coloneqq \quantifier Q x T_{\logic{PNF}}(\psi).
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.pnf.formula_to_pnf} in \cite{notebook:code}. The bulk of the implementation is in the module \identifier{math.logic.transformation.pull_quantifiers}.
\end{comments}
\begin{defproof}
  We can use induction on the \hyperref[def:graph_cardinality/order]{graph order} of the \hyperref[def:fol_formula_ast]{abstract syntax tree} of \( \varphi \) to show that \( T_{\logic{PNF}}(\varphi) \) is in prenex normal form. This is straightforward because, in every operation, we recursively \enquote{pull} quantifiers outwards.

  Semantic equivalence of \( \varphi \) and \( T_{\logic{PNF}}(\varphi) \) is also simple to show by induction.
  \begin{itemize}
    \item The case \ref{alg:fol_formula_to_prenex_normal_form/atomic} of atomic formulas is trivial.

    \item If \( \varphi \) is a negation formula, the construction in \ref{alg:fol_formula_to_prenex_normal_form/negation} uses \fullref{alg:propositional_repeated_negation_collapse} to remove repeated negation, and overall semantic equivalence of \( \varphi \) and \( T_{\logic{PNF}}(\varphi) \) follows from the correctness of \fullref{alg:fol_formula_dualization}.

    \item If \( \varphi \) is a connective formula, come additional commentary is needed.

    Semantic equivalence of \( \varphi \) and \( T_{\logic{PNF}}(\varphi) \) follows \cref{thm:intuitionistic_equivalences/biconditional_via_conditionals} in the first case. In the other cases, we take care to rename the variables that may cause collisions; otherwise, equivalence follows from distributivity of joins and meets in the classical truth value algebra. In the second case, we must additionally note that \( \psi' \synimplies \theta' \) is equivalent to \( \synneg \psi' \synvee \theta' \), as shown in \cref{thm:classical_equivalences/conditional_as_disjunction}.

    \item The case \ref{alg:fol_formula_to_prenex_normal_form/quantifiers} of quantifier formulas is also trivial.
  \end{itemize}
\end{defproof}
