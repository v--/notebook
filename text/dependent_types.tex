\section{Dependent types}\label{sec:dependent_types}

This section is a detour; our purpose is to present some ideas without diving into them, and specifically without lengthy consistency proofs as in \fullref{sec:lambda_term_alpha_equivalence}.

\begin{remark}\label{rem:dependent_type_rule_formalization}
  In this section, we will not attempt to fully formalize the type derivation trees of the object theory like we did in \fullref{sec:curry_howard_correspondence}. In particular, due to the increased importance of \hyperref[rem:type_theory_rule_classification/equality]{equality rules}, we will identify not only \( \alpha \)-equivalent terms, but also results of \( \beta \)- and \( \eta \)-reduction.

  Since we will not fully formalize derivation trees, we will also not bother with a dedicated language that would allow encoding the rules. Instead, we will thus specify our rules entirely within the \hyperref[con:metalanguage]{metalanguage}. Otherwise, if we continue our formalization effort, we will encounter some complications which, if handled properly, would result a much more intricate formal language than we currently have. See \cref{rem:inference_rule_formalization} for some additional commentary.

  We list here some of the complications:
  \begin{thmenum}
    \thmitem{rem:dependent_type_rule_formalization/context} \hyperref[def:type_context]{Type contexts} must be well-formed as per \cref{rem:well_formed_context}. This requires us to implement a mechanism for finding, for any type used, a derivation tree demonstrating that it is well-formed.

    \thmitem{rem:dependent_type_rule_formalization/relations} We need to allow defining binary relations as per \fullref{thm:recursively_defined_relations}. This complicates \hyperref[con:unification]{unification} for the two sides of a transitive binary relation, which should be allowed to match arbitrarily complicated expressions.

    \thmitem{rem:dependent_type_rule_formalization/equality} The main binary relation we will use is \hyperref[con:equality]{judgmental equality}, which subsumes \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}, \hyperref[def:typed_term_reduction]{\( \beta \)-reduction} and \hyperref[def:typed_term_reduction]{\( \eta \)-reduction}. This makes unification subtle even without other binary relations involved, because, rather than considering a concrete term or type, we must now work with equivalence classes and conceive a way for picking a particular member when needed.

    \thmitem{rem:dependent_type_rule_formalization/side_conditions} Rules like \cref{rem:type_theory_rule_classification/equality/uniq} require stating side conditions via dedicated syntactic constructs, in this case ones for relating free variables. This requires a more sophisticated approach than what we currently have, perhaps an adaptation of the eigenvariable extensions in \cref{def:first_order_proof_tree}.

    In fact, every possible kind of side conditions requires a specific syntax.
  \end{thmenum}
\end{remark}

\paragraph{Pseudoterms}

\begin{concept}\label{con:pseudoterm_expression}\mimprovised
  We have defined simply typed \( \muplambda \)-terms in \cref{def:typed_lambda_term} so that terms and types are syntactically distinguishable. In particular, we have defined \( \muplambda \)-term variables to be Latin identifiers and type variables to be Greek identifiers. For simple types, it is unambiguous whether a variable ranges over terms or types. Furthermore, the concept of \hyperref[con:variable_binding]{free variable} applies only to term variables.

  As the complexity of type systems grow, so does duplication between the syntax of terms and types. This is why it is convenient to work with a grammar common to terms and types. We will call the strings generated by this grammar \term{pseudoterm expressions}, and later further distinguish ones that are \hyperref[rem:well_formed_context]{well-formed} according to some inference rules.
\end{concept}
\begin{comments}
  \item Pseudoterms come with the additional burden of contexts possibly being ill-formed. Among those that are well-formed, however, we nonetheless have precise notions terms and types; see \cref{rem:well_formed_context} and \cref{def:mltt_well_formed_context}.

  \item Our terminology is a combination of \tcite{#2, where #1}[\S 5.2]{Barendregt1992LambdaCalculiWithTypes} uses \enquote{pseudoterm} and \tcite{#2, where #1}[\S 8.1.1]{Mimram2020ProgramEqualsProof} uses \enquote{expression}.
\end{comments}

\begin{remark}\label{rem:well_formed_context}
  Most \hyperref[def:abstract_type_system]{type systems} we consider are based on \hyperref[def:simple_type]{simple types}, where terms and types have distinct grammars, both of which only generate strings that are well-formed in the sense of \cref{con:expression}. The role of the type system and its rules is then only to clarify the relationship between terms and types.

  In contrast, more complicated systems like \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} are based on \hyperref[con:pseudoterm_expression]{pseudoterm expressions} that combine the syntax of terms and types. We consider an expression a well-formed type if it inhabits a \hyperref[con:type_universe]{type universe} with respect to some well-formed context. For simplicity, we consider type universes themselves to be well-formed types. It is reasonable to shorten \enquote{well-formed type} to \enquote{type} since there is no other notion of type available.

  We will call a \enquote{well-formed term} or simply \enquote{term} an expression which inhabit a type but not a type universe.

  There is some logical circularity because a well-formed type is defined with respect to a well-formed context and vice versa. This can be resolved by stating the necessary definitions using mutual recursion. In \cref{def:mltt_well_formed_context} we will give precise definitions for well-formed types, \hyperref[def:type_context]{type contexts} and \hyperref[def:type_derivation_tree]{type derivation trees}.
\end{remark}

\begin{definition}\label{def:mltt_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} for Martin-L\"of type theory extends the \hyperref[def:lambda_term_alphabet]{\( \muplambda \)-calculus alphabet} with two additional \hyperref[con:variable_binding]{variable binders}:
  \begin{thmenum}
    \thmitem{def:mltt_alphabet/product} The \term{dependent product} binder \enquote{\( \synprod \)}.
    \thmitem{def:mltt_alphabet/sum}\mcite[374]{Mimram2020ProgramEqualsProof} The \term{dependent sum} binder \enquote{\( \synsum \)}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:mltt_pseudoterm}\mimprovised
  We will present a \hyperref[def:formal_grammar/schema]{grammar schema} suitable for all \hyperref[def:abstract_type_system]{type systems} considered in this section. It is based on Martin-L\"of's \cite{MartinLöf1984IntuitionisticTypeTheory}, for which reason we refer to it as the \enquote{the \hyperref[con:syntax_semantics_duality]{syntax} of Martin-L\"of type theory}.

  Similarly to the case of untyped \( \muplambda \)-terms, fix an \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Const} \) of constant pseudoterms. It will be used as a generalization of both constant \( \muplambda \)-terms and base types. Consider the following rules:

  \begin{bnf*}
    \bnfprod{variable}           {\bnfpn{Small Latin identifier}} \\
    \bnfprod{atom}               {\bnfpn{variable} \bnfor \bnfpn{constant}} \\
    \bnfprod{annotated variable} {\bnfpn{variable} \bnfsp \bnftsq{:} \bnfsp \bnfpn{pseudoterm}} \\
    \bnfprod{application}        {\bnftsq{\( ( \)} \bnfsp \bnfpn{pseudoterm} \bnfsp \bnfpn{pseudoterm} \bnfsp \bnftsq{\( ) \)}} \\
    \bnfprod{binder}             {\bnftsq{\( \synlambda \)} \bnfor \bnftsq{\( \synprod \)} \bnfor \bnftsq{\( \synsum \)}} \\
    \bnfprod{binder pseudoterm}  {\bnftsq{\( ( \)} \bnfsp \bnfpn{binder} \bnfsp \bnfpn{annotated variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{pseudoterm} \bnfsp \bnftsq{\( ) \)}} \\
    \bnfprod{identity}           {\bnftsq{\( ( \)} \bnfsp \bnfpn{pseudoterm} \bnfsp \bnftsq{\( \syneq \)} \bnfsp \bnftsq{\( : \)} \bnfsp \bnfpn{pseudoterm} \bnfsp \bnfpn{pseudoterm} \bnfsp \bnftsq{\( ) \)}} \\
    \bnfprod{pseudoterm}         {\bnfpn{atom} \bnfor \bnfpn{application}\bnfor \bnfpn{abstraction} \bnfor \bnfpn{identity} \bnfor} \\
    \bnfmore                     {\bnfpn{dependent product} \bnfor \bnfpn{dependent sum}}
  \end{bnf*}

  The \( \bnfpn{binder} \) rule lists the binder symbols from \cref{def:mltt_alphabet}. We assume capture-avoiding substitution and \( \alpha \)-equivalence are defined for them as per \cref{rem:variable_binding_properties}.

  In the \( \bnfpn{identity} \) rule, the second pseudoterm is intended to serve as a \hyperref[con:type_annotation]{type annotation} for the other two. This will be explained in \cref{def:identity_type}. We will find it more convenient to write \enquote{\( M \syneq_\tau N \)} instead of \enquote{\( M \mathrel{{\syneq:} \tau} N \)}.
\end{definition}
\begin{comments}
  \item Because of the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, we focus on types rather than terms, and we have added dedicated grammar rules for the new \hyperref[con:type_constructor]{type constructors}. On the other hand, in accordance with \cref{rem:binders_in_type_theory_terms}, we will not bother introducing distinct grammar rules for every kind of term, but instead rely on the familiar syntax of \( \muplambda \)-calculus to express all needed terms.

  \item Because of the symbols used, dependent products and sums are also called \enquote{\( \Pi \)-types} and \enquote{\( \Sigma \)-types} in \cite{UnivalentFoundationsProgram2013HoTT}.
\end{comments}

\begin{remark}\label{rem:pseudoterm_schemas}
  We may introduce \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:mltt_pseudoterm]{Martin-L\"of type theory pseudoterms}, similarly to how we have introduced in \cref{def:simple_type_schema} schemas for \hyperref[def:simple_type]{simple types}.

  Since there is no distinct grammar rule for types, we can use the placeholder rules
  \begin{bnf*}
    \bnfprod{variable placeholder}   {\bnfpn{Small Latin identifier}} \\
    \bnfprod{pseudoterm placeholder} {\bnfpn{Capital Latin identifier} \bnfor \bnfpn{Small Greek identifier}}
  \end{bnf*}
  and define the rest in the obvious way.

  The choice of identifiers is such that pseudoterm placeholders may reuse our established notation for term placeholders (e.g. \( M \) and \( N \)) and type placeholders (e.g. \( \tau \) and \( \sigma \)), depending on whether the intended pseudoterm is to be treated as a term or a type.

  Unfortunately, such schemas only cover a portion of what is needed for formalizing the rules in this section. See \cref{rem:dependent_type_rule_formalization}.
\end{remark}

\begin{remark}\label{rem:mltt_pseudoterm_dependency}
  As discussed in \cref{rem:simply_typed_lambda_term_dependency}, we can regard the \hyperref[def:typed_lambda_term]{typed \( \muplambda \)-term}
  \begin{equation*}
    M = \qabs {x_1^{\tau_1}}\ldots \qabs {x_n^{\tau_n}} N
  \end{equation*}
  as an \( n \)-ary function whose arguments are inhabitants of \( \tau_1, \ldots, \tau_n \), correspondingly. In accordance with the terminology for functions from \cref{con:variable_dependence}, we may state that \( M \) depends on variables of types \( \tau_1, \ldots, \tau_n \).

  We can extend this to \hyperref[def:mltt_pseudoterm]{Martin-L\"of type theory pseudoterms} by regarding \( \synprod \) and \( \synsum \) as \hyperref[con:variable_binding]{variable binders} in addition to \( \synlambda \).

  Because of the unified syntax of terms and types, this opens different possibilities. Suppose that, in a fixed \hyperref[def:abstract_type_system]{type system}, \( M \) inhabits \( \tau \). Then, in accordance with \cref{rem:well_formed_context}, based on \( \tau \) and \( \tau_k \), we can state that the term/type \( M \) depends on the term/type variable \( x_k \).

  Furthermore, we must avoid referencing the names of the variables because the judgmental equality rules are adjusted so that abstractor prefixes are preserved, but still the variables can possibly be renamed. So, we will be able to say that a term depends on a variable of a given type, but not give a concrete name for the variable.

  We will classify such dependencies when describing Barendregt's \( \muplambda \)-cube in \cref{def:lambda_cube}.
\end{remark}

\paragraph{Type constructors}

\begin{concept}\label{con:type_constructor}\mimprovised
  If, in some \hyperref[def:abstract_type_system]{type system}, a type depends on other types (in the sense of \cref{rem:mltt_pseudoterm_dependency}), we call it a \term[en=type constructor (\cite[198]{Barendregt1992LambdaCalculiWithTypes})]{type constructor} or a \term[en=type forming operation (\cite[83]{MartinLöf1975IntuitionisticTypeTheory})]{type forming operation}.

  If all dependent variables of a type constructor have the same type annotation, it is convenient to assign an arity to the constructor, similarly to how it is done for algebraic operations in \cref{def:operation_on_set}. In such case, we will use the prefixes from \cref{def:operation_arity_terminology} like \enquote{unary}, \enquote{binary}, etc.
\end{concept}
\begin{comments}
  \item This is based on Barendregt's definition of a type constructor as an inhabitant of a \hyperref[con:type_universe]{kind}, which we will describe in \cref{def:lambda_cube/type_on_type}.
\end{comments}

\begin{example}\label{ex:con:type_constructor}
  We list examples of \hyperref[con:type_constructor]{type constructors}:
  \begin{thmenum}
    \thmitem{con:type_constructor/nullary} The (simple) \hyperref[def:simple_unit_type]{unit type} \( \syn\Bbbone \) is a self-contained constant, that is, the \hyperref[rem:type_theory_rule_classification/intro]{introduction rule} \ref{inf:def:simple_unit_type/intro} allows inferring that \( \syn\Bbbone \) itself is inhabited. This makes it a nullary type constructor.

    On the other hand, for the (simple) \hyperref[def:simple_empty_type]{empty type} \( \syn\Bbbzero \) we have no introduction rule, so it technically not a type constructor.

    The same holds for the dependent empty and unit types that we will define in \cref{def:dependent_empty_type} and \cref{def:dependent_unit_type}, correspondingly.

    \thmitem{con:type_constructor/binary} With the syntax of \hyperref[def:simple_type]{simple types}, the \hyperref[def:arrow_type]{arrow type} \( \syn\tau \synimplies \syn\sigma \) contains two type variables.

    We can encode the arrow type as a \hyperref[rem:pseudoterm_schemas]{Martin-L\"of type theory pseudoterm} by introducing a constant \( \synA_+ \), and adding a type formation rule that allows concluding that \( \synA_+ \tau \sigma \) is a type (i.e. belongs to some \hyperref[con:type_universe]{type universe} \( \BbbT \)) given types \( \tau \) and \( \sigma \).

    To obtain a binary type constructor in the sense of \cref{con:type_constructor}, we must then bind these types in \( \BbbT \):
    \begin{equation*}
      \qprod {\synx^{\BbbT}} \qprod {\syny^{\BbbT}} \synA_+ \synx \syny.
    \end{equation*}

    In practice, the phrase \enquote{\( {\synimplies} \) is a binary type constructor} is unambiguous enough to use freely.

    Similarly, the symbols \( {\syntimes} \) used for \hyperref[def:simple_product_type]{product types} and \( {\synplus} \) used for \hyperref[def:simple_sum_type]{sum types} can also be regarded as binary constructors.

    \thmitem{con:type_constructor/identity} The \hyperref[def:identity_type]{identity type} \( M \syneq_\tau N \) (when properly bound) depends on two term variables and one type variable.

    That technically makes it both a type constructor and a \hyperref[con:dependent_type]{dependent type}.
  \end{thmenum}
\end{example}

\paragraph{Dependent types}

\begin{concept}\label{con:dependent_type}\mcite[200]{Barendregt1992LambdaCalculiWithTypes}
  If, in some \hyperref[def:abstract_type_system]{type system}, a type depends on a term (in the sense of \cref{rem:mltt_pseudoterm_dependency}), we call it a \term{dependent type}.
\end{concept}
\begin{comments}
  \item In practice, the phrase \enquote{dependent type} is associated with \hyperref[def:identity_type]{identity types}, \hyperref[def:dependent_product]{dependent products} or \hyperref[def:dependent_product]{dependent sums}, however there are other examples like the dependent empty type defined in \cref{def:dependent_empty_type}, the dependent unit type defined in \cref{def:dependent_unit_type} and the type of Booleans defined in \cref{def:type_of_booleans}.
\end{comments}

\begin{definition}\label{def:dependent_empty_type}\mcite[\S A.2.8]{UnivalentFoundationsProgram2013HoTT}
  We define an \term{empty type} \( \syn\Bbbzero \) based on \cref{def:simple_empty_type}, but with rules utilizing \hyperref[con:dependent_type]{dependent types}.

  First, for a fixed the type universe \( \BbbT \), we will define \hyperref[rem:type_theory_rule_classification/form]{formation rule}
  \begin{equation*}\taglabel[\ensuremath{ \Bbbzero_{\logic{form}} }]{inf:def:dependent_empty_type/form}
    \begin{prooftree}
      \infer0[\ref{inf:def:dependent_empty_type/form}]{ \syn\Bbbzero: \BbbT }
    \end{prooftree}
  \end{equation*}

  We then add an \hyperref[rem:type_theory_rule_classification/elim]{elimination rule} resembling the simple elimination rule \ref{inf:def:simple_empty_type/elim}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbzero_- }]{inf:def:dependent_empty_type/elim}
    \begin{prooftree}
      \hypo{ x: \syn\Bbbzero }
      \infer[dashed]1{ \tau: \BbbT }

      \hypo{ A: \syn\Bbbzero }

      \infer2[\ref{inf:def:simple_empty_type/elim}]{ \synE_- (\qabs {x^{\syn\Bbbzero}} \tau) A: \tau[x \mapsto A] }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item For disambiguation, we will refer to this definition as the \enquote{dependent empty type}.
\end{comments}

\begin{remark}\label{rem:dependent_type_rule_sequents}
  The \hyperref[con:typing_rule]{typing rules} used in \hyperref[def:abstract_type_system]{type systems} based on \hyperref[con:pseudoterm_expression]{pseudoterm expressions} are often presented in \hyperref[rem:natural_deduction_explicit_sequents]{explicit sequent style}.

  For example, in \cite[\S A.2.7]{UnivalentFoundationsProgram2013HoTT} the \hyperref[def:dependent_empty_type]{empty type} elimination rule \ref{inf:def:dependent_empty_type/elim} is presented as
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \Gamma, x: \syn\Bbbzero \vdash \tau: \BbbT }
      \hypo{ \Gamma \vdash A: \syn\Bbbzero }
      \infer2[\ref{inf:def:simple_empty_type/elim}]{ \Gamma \vdash \synE_- (\qabs {x^{\syn\Bbbzero}} \tau) A: \tau[x \mapsto A] }
    \end{prooftree}
  \end{equation*}

  We are given not only the type assertions for the premises, but also the type contexts from which they should be derived. In particular, it is assumed that \( \Gamma \) is a \hyperref[rem:well_formed_context]{well-formed context}.

  We have tried to make derivations as precise as possible:
  \begin{itemize}
    \item Our definition of type derivation trees in \cref{def:type_derivation_tree} makes the assumptions explicit. Furthermore, \cref{def:mltt_well_formed_context/derivation} states precise conditions for type derivations to be well-formed.

    \item Our definition of entailment in \cref{def:mltt_derivation} define precisely what is means for a type assertion to be derivable from a (well-formed) type context.
  \end{itemize}

  This allows us to use rules with implicit sequents while still being fully precise about derivations. We actually prefer implicit sequents because it makes derivation trees less clunky.
\end{remark}
\begin{comments}
  \item Implicit sequent rules for dependent types are also used \bycite{MartinLöf1984IntuitionisticTypeTheory}, who however does not concern himself with the intricacies of type contexts.

  \item Even for simple types, \incite{Mimram2020ProgramEqualsProof} and \incite{Hindley1997BasicSTT} prefer explicit sequents. \incite*[ch. 3]{Barendregt1992LambdaCalculiWithTypes} initially presents his rules in two sets --- via implicit sequents and via explicit sequents --- but later, when presenting more complicated type systems where ill-formed types are possible, he switches to only using explicit sequents.
\end{comments}

\begin{definition}\label{def:dependent_unit_type}\mcite[\S A.2.8]{UnivalentFoundationsProgram2013HoTT}
  Similarly to the dependent empty type that we have defined in \cref{def:dependent_empty_type}, we also define a \term{unit type} \( \syn\Bbbone \) based on \cref{def:simple_unit_type}, but with rules utilizing \hyperref[con:dependent_type]{dependent types}.

  Again, for a fixed type universe \( \BbbT \), we define \hyperref[rem:type_theory_rule_classification/form]{formation rule}
  \begin{equation*}\taglabel[\ensuremath{ \Bbbone_{\logic{form}} }]{inf:def:dependent_unit_type/form}
    \begin{prooftree}
      \infer0[\ref{inf:def:dependent_unit_type/form}]{ \syn\Bbbone: \BbbT }
    \end{prooftree}
  \end{equation*}

  The \hyperref[rem:type_theory_rule_classification/intro]{introduction rule} is simply a restatement of \ref{inf:def:simple_unit_type/intro}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbone_+ }]{inf:def:dependent_unit_type/intro}
    \begin{prooftree}
      \infer0[\ref{inf:def:dependent_unit_type/intro}]{ \synU_+: \syn\Bbbone }
    \end{prooftree}
  \end{equation*}

  Unlike with the simply typed analogue, we can now state an \hyperref[rem:type_theory_rule_classification/elim]{elimination rule}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbone_- }]{inf:def:dependent_unit_type/elim}
    \begin{prooftree}
      \hypo{ x: \syn\Bbbone }
      \infer[dashed]1{ \tau: \BbbT }

      \hypo{ M: \tau[x \mapsto \synU_+] }

      \hypo{ A: \syn\Bbbone }

      \infer3[\ref{inf:def:dependent_unit_type/elim}]{ \synU_- (\qabs {x^{\syn\Bbbone}} \tau) M A: \tau[x \mapsto A] }
    \end{prooftree}
  \end{equation*}

  Roughly, this elimination rule allows us to exchange any two terms inhabiting \( \Bbbone \). We will see in \cref{thm:unit_type_term_uniqueness} how this rule can be used in combination with \hyperref[def:identity_type]{identity types}.

  There is also the following \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rule}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbone_\beta }]{inf:def:dependent_unit_type/comp}
    \begin{prooftree}
      \hypo{ x: \syn\Bbbone }
      \infer[dashed]1{ \tau: \BbbT }

      \hypo{ M: \tau[x \mapsto \synU_+] }

      \infer2[\ref{inf:def:dependent_unit_type/comp}]{ \synU_- (\qabs {x^{\syn\Bbbone}} \tau) M \synU_+ \coloneqq M: \tau[x \mapsto \synU_+] }
    \end{prooftree}
  \end{equation*}

  It allows simplifying some eliminator terms featuring \( \synU_+ \).
\end{definition}
\begin{comments}
  \item For disambiguation, we will refer to this definition as the \enquote{dependent unit type}.
\end{comments}

\begin{definition}\label{def:type_of_booleans}\mcite[\S 8.3.6]{Mimram2020ProgramEqualsProof}
  Similarly to the dependent empty type \( \syn\Bbbzero \) defined in \cref{def:dependent_empty_type} and the dependent unit type \( \syn\Bbbone \) defined in \cref{def:dependent_unit_type}, we will introduce a type, denoted by \( \syn\Bbbtwo \), with two inhabitants. Such a type can be used to express Boolean values in the sense of \cref{con:boolean_value}, and we will call it the \term{type of Booleans}\fnote{Not to be confused with the type of propositions from \cref{def:quantifiable_type}}.

  The rules are a degenerate case of \hyperref[def:simple_sum_type]{binary sum types}, but they are based on dependent types rather than simple types.

  For a fixed type universe \( \BbbT \) we will need the \hyperref[rem:type_theory_rule_classification/form]{formation rule}
  \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_{\logic{form}} }]{inf:def:type_of_booleans/form}
    \begin{prooftree}
      \infer0[\ref{inf:def:type_of_booleans/form}]{ \syn\Bbbtwo: \BbbT }
    \end{prooftree}
  \end{equation*}

  For formalizing the two terms inhabiting \( \syn\Bbbtwo \), we will need the constants \( \synB_{+L} \) and \( \synB_{+R} \) and the \hyperref[rem:type_theory_rule_classification/intro]{introduction rules}
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_{+L} }]{inf:def:type_of_booleans/intro_left}
        \begin{prooftree}
          \infer0[\ref{inf:def:type_of_booleans/intro_left}]{ \synB_{+L}: \syn\Bbbtwo }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_{+R} }]{inf:def:type_of_booleans/intro_right}
        \begin{prooftree}
          \infer0[\ref{inf:def:type_of_booleans/intro_right}]{ \synB_{+R}: \syn\Bbbtwo }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  For the \hyperref[rem:type_theory_rule_classification/elim]{elimination rule}, we will need a new constant, \( \synB_- \):
  \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_- }]{inf:def:type_of_booleans/elim}
    \begin{prooftree}
      \hypo{ x: \syn\Bbbtwo }
      \infer[dashed]1{ \tau: \BbbT }

      \hypo{ M: \tau[x \mapsto \synB_{+L}] }
      \hypo{ N: \tau[x \mapsto \synB_{+R}] }

      \hypo{ A: \syn\Bbbtwo }

      \infer4[\ref{inf:def:type_of_booleans/elim}]{ \synB_- (\qabs {x^{\syn\Bbbtwo}} \tau) M N A: \tau[x \mapsto A] }
    \end{prooftree}
  \end{equation*}

  We have two \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rules}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_\beta^L }]{inf:def:type_of_booleans/comp_left}
    \begin{prooftree}
      \hypo{ x: \syn\Bbbtwo }
      \infer[dashed]1{ \tau: \BbbT }

      \hypo{ M: \tau[x \mapsto \synB_{+L}] }
      \hypo{ N: \tau[x \mapsto \synB_{+R}] }

      \infer3[\ref{inf:def:type_of_booleans/comp_left}]{ \synB_- (\qabs {x^{\syn\Bbbtwo}} \tau) M N \synB_{+L} \syndefeq M: \tau[x \mapsto \synB_{+L}] }
    \end{prooftree}
  \end{equation*}
  and
  \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_\beta^R }]{inf:def:type_of_booleans/comp_right}
    \begin{prooftree}
      \hypo{ x: \syn\Bbbtwo }
      \infer[dashed]1{ \tau: \BbbT }

      \hypo{ M: \tau[x \mapsto \synB_{+L}] }
      \hypo{ N: \tau[x \mapsto \synB_{+R}] }

      \infer3[\ref{inf:def:type_of_booleans/comp_right}]{ \synB_- (\qabs {x^{\syn\Bbbtwo}} \tau) M N \synB_{+R} \syndefeq N: \tau[x \mapsto \synB_{+R}] }
    \end{prooftree}
  \end{equation*}

  Finally, we have the following \hyperref[rem:type_theory_rule_classification/equality/comp]{uniqueness rule}:
  \begin{equation*}\taglabel[\ensuremath{ \Bbbtwo_\eta }]{inf:def:type_of_booleans/uniq}
    \begin{prooftree}
      \hypo{ A: \syn\Bbbtwo }
      \infer1[\ref{inf:def:type_of_booleans/uniq}]{ \synB_- (\qabs {x^{\syn\Bbbtwo}} \syn\Bbbtwo) \synB_{+L} \synB_{+R} A \syndefeq A: \syn\Bbbtwo }
    \end{prooftree}
  \end{equation*}
\end{definition}

\paragraph{Identity types}

\begin{definition}\label{def:identity_type}\mcite[60; 61]{MartinLöf1984IntuitionisticTypeTheory}
  When defining the syntax of Martin-L\"of type theory in \cref{def:mltt_pseudoterm}, we have stated the \( \bnfpn{identity} \) grammar rule. Its intent is to express \hyperref[con:equality]{propositional equality} --- in Martin-L\"of's own words from \cite[81]{MartinLöf1975IntuitionisticTypeTheory}, \enquote{the proposition that \( x \) and \( y \) are identical} given that they \enquote{are objects of one and the same type}.

  More formally, for a fixed \hyperref[con:type_universe]{type universe} \( \BbbT \), we have the \hyperref[rem:type_theory_rule_classification/form]{formation rule}:
  \begin{equation*}\taglabel[\ensuremath{ =_{\logic{form}} }]{inf:def:identity_type/form}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ M: \tau }
      \hypo{ N: \tau }
      \infer3[\ref{inf:def:identity_type/form}]{ M \syneq_{\tau} N: \BbbT }
    \end{prooftree}
  \end{equation*}

  We also have the following \hyperref[rem:type_theory_rule_classification/intro]{introduction rule} based on the constant pseudoterm \( \synI_+ \):
  \begin{equation*}\taglabel[\ensuremath{ =_+ }]{inf:def:identity_type/intro}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ M: \tau }
      \infer2[\ref{inf:def:identity_type/intro}]{ \synI_+ M: M \syneq_\tau M }
    \end{prooftree}
  \end{equation*}

  The term \( \synI_+ M \) provides an identification of \( M \) with itself. Since it essentially proves reflexivity of propositional equality, a more conventional notation for \enquote{\( \synI_+ \)} is \enquote{\( \op{refl} \)} --- it is used, for example, in \cite[\S A.2.10]{UnivalentFoundationsProgram2013HoTT} and \cite[\S 9.1.3]{Mimram2020ProgramEqualsProof}.

  There are different elimination rules, with different consequences. Unless specifically noted otherwise, we will use that the \( J \) eliminator from \cref{def:identity_type/j}.

  \begin{thmenum}
    \thmitem{def:identity_type/i} It is natural to expect that, if \( M \) and \( N \) are judgmentally equal, they are also propositionally equal.

    Indeed, if we make explicit the \hyperref[rem:type_theory_rule_classification/equality/cong]{congruence rule}
    \begin{equation*}\taglabel[\ensuremath{ \coloneqq_=^{\logic{form}} }]{inf:def:identity_type/i/cong}
      \begin{prooftree}
        \hypo{ M \syndefeq M': \tau }
        \hypo{ N \syndefeq N': \tau }
        \infer2[\ref{inf:def:identity_type/i/cong}]{ M \syneq_\tau N \syndefeq M' \syneq_\tau N': \BbbT },
      \end{prooftree}
    \end{equation*}
    we can easily prove the above principle:
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {} { \tau: \BbbT }

        \hypo{}
        \ellipsis {} { M: \tau }

        \infer2[\ref{inf:def:identity_type/intro}]{ \synI_+ M: M \syneq_\tau M }

        \hypo{}
        \ellipsis {} { M: \tau }
        \infer1[\ref{rem:type_theory_rule_classification/equality/refl}]{ M \syndefeq M: \tau }

        \hypo{}
        \ellipsis {} { M \syndefeq N: \tau }
        \infer2[\ref{inf:def:identity_type/i/cong}]{ M \syneq_\tau M \syndefeq M \syneq_\tau N: \BbbT }

        \infer2[\ref{rem:type_theory_rule_classification/equality/type}]{ \synI_+ M: M \syneq_\tau N }
      \end{prooftree}
    \end{equation*}

    \incite*[61]{MartinLöf1984IntuitionisticTypeTheory} expresses the converse as a rule:
    \begin{equation*}\taglabel[\ensuremath{ =_-^\Iota }]{inf:def:identity_type/i/elim}
      \begin{prooftree}
        \ParacolAlignmentHack
        \hypo{ p: M \syneq_\tau N }
        \infer1[\ref{inf:def:identity_type/i/elim}]{ M \syndefeq N }
      \end{prooftree}
    \end{equation*}

    It allows us to conclude that, if the identity type \( M \syneq_\tau N \) is inhabited, the terms \( M \) and \( N \) are judgmentally equal.

    \incite*[13]{Streicher1993IntensionalTypeTheory} calls \ref{inf:def:identity_type/i/elim} the \enquote{reflection rule}, and divides types systems into \term{extensional} and \term{intensional} depending on whether the rule is \hyperref[con:inference_rule_admissibility]{admissible}. Indeed, \ref{inf:def:identity_type/i/elim} can be regarded as a form of extensionality in the sense of \cref{con:extensionality}.

    Streicher proves that the reflection rule is incompatible with \fullref{thm:church_rosser_theorem}.

    \thmitem{def:identity_type/j}\mcite[50]{UnivalentFoundationsProgram2013HoTT} The following \hyperref[rem:type_theory_rule_classification/elim]{elimination rule}, based on the constant \( \synJ \), is much more complicated:
    \footnotesize
    \begin{equation*}\taglabel[\ensuremath{ =_-^J }]{inf:def:identity_type/j/elim}
      \begin{prooftree}[separation=1.5em]
        \hypo{ x: \tau }
        \hypo{ y: \tau }
        \hypo{ p: x \syneq_{\tau} y }
        \infer[dashed]3{ \sigma: \BbbT }

        \hypo{ z: \tau }
        \infer[dashed]1{M: \sigma[x \mapsto z, y \mapsto z, p \mapsto \Iota_+ z]}

        \hypo{ A: \tau }
        \hypo{ B: \tau }
        \hypo{ E: A \syneq_{\tau} B }

        \infer5[\ref{inf:def:identity_type/j/elim}]{ \synJ (\qabs {x^{\tau}} \qabs {y^{\tau}} \qabs {p^{x \syneq_{\tau} y}} \sigma) (\qabs {z^{\tau}} M) A B E: \sigma[x \mapsto A, y \mapsto B, p \mapsto E] }
      \end{prooftree}
    \end{equation*}
    \normalsize

    We use the letter \( J \) rather than, for example, \( I_- \), for clarity, since there are other eliminators like the \( K \) eliminator discussed next. Both constants are used in \cite[6]{Streicher1993IntensionalTypeTheory}.

    One thing to note here is that the first premise has three dischargeable assumptions, while we only formally allow one such assumption in \cref{def:natural_deduction_rule}. This requires a straightforward adaptation. We do not want to complicate the formal syntax and programmatic implementation of natural deduction rules because of one case that is mostly used for demonstration.

    We also have the following \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rule} based on \cite[\S A.2.10]{UnivalentFoundationsProgram2013HoTT}:
    \small
    \begin{equation*}\taglabel[\ensuremath{ =_\beta^J }]{inf:def:identity_type/j/comp}
      \begin{prooftree}[separation=1.2em]
        \hypo{ x: \tau }
        \hypo{ y: \tau }
        \hypo{ p: x \syneq_{\tau} y }
        \infer[dashed]3{\sigma: \BbbT}

        \hypo{ z: \tau }
        \infer[dashed]1{M: \sigma[x \mapsto z, y \mapsto z, p \mapsto \Iota_+ z]}

        \hypo{ A: \tau }

        \infer3[\ref{inf:def:identity_type/j/comp}]{ \synJ (\qabs {x^{\tau}} \qabs {y^{\tau}} \qabs {p^{x \syneq_{\tau} y}} \sigma) (\qabs {z^{\tau}} M) A A (\Iota_+ \tau A) \coloneqq M[z \mapsto A]: \sigma[x \mapsto A, y \mapsto A, p \mapsto \Iota_+ \tau A] }
      \end{prooftree}
    \end{equation*}
    \normalsize

    \incite*[\S 9.1.3]{Mimram2020ProgramEqualsProof} additionally provides a straightforward uniqueness rule, however he claims it is \enquote{debatable} because, as shown in \cite[thm. 1]{Streicher1993IntensionalTypeTheory}, uniqueness entails the reflection rule. In particular, the uniqueness rule is not present in \cite[\S A.2.10]{UnivalentFoundationsProgram2013HoTT}.

    \thmitem{def:identity_type/k}\mcite[13]{Streicher1993IntensionalTypeTheory} Streicher suggests the following alternative to \ref{inf:def:identity_type/j/elim}:
    \small
    \begin{equation*}\taglabel[\ensuremath{ =_-^K }]{inf:def:identity_type/k/elim}
      \begin{prooftree}
        \hypo{ x: \tau }
        \hypo{ p: x \syneq_{\tau} x }
        \infer[dashed]2{ \sigma: \BbbT }

        \hypo{ z: \tau }
        \infer[dashed]1{ M: \sigma[x \mapsto z, p \mapsto \Iota_+ z] }

        \hypo{ A: \tau }
        \hypo{ E: A \syneq_{\tau} A }

        \infer4[\ref{inf:def:identity_type/k/elim}]{ \syn\Kappa (\qabs {x^{\tau}} \qabs {p^{x \syneq_{\tau} x}} \sigma) (\qabs {z^{\tau}} M) A E: \sigma[x \mapsto A, p \mapsto E] }
      \end{prooftree}
    \end{equation*}
    \normalsize

    Correspondingly, we have the following computation rule:
    \begin{equation*}\taglabel[\ensuremath{ =_\beta^K }]{inf:def:identity_type/k/comp}
      \begin{prooftree}
        \hypo{ x: \tau }
        \hypo{ p: x \syneq_{\tau} x }
        \infer[dashed]2{\sigma: \BbbT}

        \hypo{ z: \tau }
        \infer[dashed]1{M: \sigma[x \mapsto z, p \mapsto \Iota_+ z]}

        \hypo{ A: \tau }

        \infer3[\ref{inf:def:identity_type/k/comp}]{ \synK (\qabs {x^{\tau}} \qabs {p^{x \syneq_{\tau} x}} \sigma) (\qabs {z^{\tau}} M) a (\Iota_+ \tau A) \coloneqq M[z \mapsto A]: \sigma[x \mapsto A, p \mapsto \Iota_+ \tau A] }
      \end{prooftree}
    \end{equation*}

    \tcite{#1 have shown in #2}[\S 5.1]{HofmannStreicher1998GroupoidInterpretation} that, surprisingly, \ref{inf:def:identity_type/j/elim} does not entail \ref{inf:def:identity_type/k/elim}. The reason for this is that every type \( \sigma \) usable in \ref{inf:def:identity_type/j/elim} can also be used in \ref{inf:def:identity_type/k/elim}, but not vice versa. Thus, in addition to those types usable in \ref{inf:def:identity_type/j/elim}, there are possibly other ones usable in \ref{inf:def:identity_type/j/elim}. Our proof of \fullref{thm:uniqueness_of_identity_proofs} provides an example.
  \end{thmenum}
  \normalsize
\end{definition}

\begin{definition}\label{def:mltt_propositional_equality}\mcite[47]{UnivalentFoundationsProgram2013HoTT}
  In a \hyperref[def:abstract_type_system]{type system} with \hyperref[def:identity_type]{identity types}, if the type \( M \syneq_\tau N \) is \hyperref[def:type_habitation]{inhabited}, we say that the terms \( M \) and \( N \) are \term{propositionally equal}.

  If, as per \cref{def:propositionally_uninhabited}, \( (M \syneq_\tau N) \synimplies \syn\Bbbzero \) is inhabited, we say that \( M \) and \( N \) are \term{propositionally unequal}.
\end{definition}
\begin{comments}
  \item This is an instance of propositional equality as described in \cref{con:equality}.
\end{comments}

\begin{proposition}\label{thm:unit_type_term_uniqueness}
  Every term inhabiting the \hyperref[def:simple_unit_type]{unit type} is \hyperref[def:mltt_propositional_equality]{propositionally equal} to \( \synU_+ \).
\end{proposition}
\begin{comments}
  \item This result is used to prove \cref{thm:unit_type_is_contractible}.
\end{comments}
\begin{proof}
  The elimination rule from \cref{def:dependent_unit_type} provides us an inhabitant of \( A \syneq_{\syn\Bbbone} \synU_+ \) given \( A: \syn\Bbbone \):
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:dependent_unit_type/form}]{ \syn\Bbbone: \BbbT }
      \hypo{ x: \syn\Bbbone }
      \infer0[\ref{inf:def:dependent_unit_type/intro}]{ \synU_+: \syn\Bbbone }
      \infer3[\ref{inf:def:identity_type/form}]{x \syneq_{\syn\Bbbone} \synU_+: \BbbT}

      \infer0[\ref{inf:def:dependent_unit_type/form}]{ \syn\Bbbone: \BbbT }
      \infer0[\ref{inf:def:dependent_unit_type/intro}]{ \synU_+: \syn\Bbbone }
      \infer2[\ref{inf:def:identity_type/intro}]{ \synI_+ \synU_+: \synU_+ \syneq_{\syn\Bbbone} \synU_+ }

      \hypo{}
      \ellipsis {} { A: \syn\Bbbone }

      \infer[left label={\( x \)}]3[\ref{inf:def:dependent_unit_type/elim}]{ \synU_- (\qabs {x^{\syn\Bbbone}} x \syneq_{\syn\Bbbone} \synU_+) (\synI_+ \synU_+) A: A \syneq_{\syn\Bbbone} \synU_+ }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{theorem}[Uniqueness of identity proofs]\label{thm:uniqueness_of_identity_proofs}
  The elimination rule \ref{inf:def:identity_type/k/elim} entails the following principle:
  \begin{displayquote}
    Every habitant of \( M \syneq_\tau M \) is \hyperref[def:mltt_propositional_equality]{propositionally equal} to the reflection term \( \synI_+ M \).
  \end{displayquote}
\end{theorem}
\begin{comments}
  \item This is based on Streicher's \enquote{uniqueness of proof objects of identity type} principle from \cite[37; 38]{Streicher1993IntensionalTypeTheory}. The name is shortened to \enquote{uniqueness of identity proofs} in \cite[55]{UnivalentFoundationsProgram2013HoTT} and \cite[\S 9.1.6]{Mimram2020ProgramEqualsProof}.
\end{comments}
\begin{proof}
  To prove the principle, we can apply \ref{inf:def:identity_type/k/elim}, taking \( \sigma \) to be \( p \syneq_{x \syneq_\tau x} \synI_+ x \).

  The application itself is straightforward, while \( \sigma \) can be constructed as follows:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ x: \tau }
      \hypo{ x: \tau }
      \infer3[\ref{inf:def:identity_type/form}]{x \syneq_\tau x: \BbbT}

      \hypo{ p: x \syneq_\tau x }

      \hypo{ \tau: \BbbT }
      \hypo{ x: \tau }
      \infer2[\ref{inf:def:identity_type/intro}]{ \synI_+ x: x \syneq_\tau x }

      \infer3[\ref{inf:def:identity_type/form}]{p \syneq_{x \syneq_\tau x} \synI_+ x: \BbbT}
    \end{prooftree}
  \end{equation*}
\end{proof}

\paragraph{Dependent products}

\begin{definition}\label{def:dependent_product}\mcite[35]{MartinLöf1984IntuitionisticTypeTheory}
  When defining the syntax of Martin-L\"of type theory in \cref{def:mltt_pseudoterm}, we have described the syntax of dependent products. They generalize both \hyperref[def:arrow_type]{arrow types} and \hyperref[def:simple_product_type]{binary product types}.

  The rules largely mirror those for arrow types described in \cref{rem:type_theory_rule_classification}. For a fixed \hyperref[con:type_universe]{type universe} \( \BbbT \), we have the following \hyperref[rem:type_theory_rule_classification/form]{formation}, \hyperref[rem:type_theory_rule_classification/intro]{introduction} and \hyperref[rem:type_theory_rule_classification/elim]{elimination} rules:
  \begin{paracol}{3}
    \begin{nthcolumn}{0}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Pi_{\logic{form}} }]{inf:def:dependent_product/form}
        \begin{prooftree}
          \hypo{ \tau: \BbbT }

          \hypo{ x: \tau }
          \infer[dashed]1{ \sigma: \BbbT }

          \infer2[\ref{inf:def:dependent_product/form}]{ \qprod {x^\tau} \sigma: \BbbT }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{1}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Pi_+ }]{inf:def:dependent_product/intro}
        \begin{prooftree}
          \hypo{ x: \tau }
          \infer[dashed]1{ M: \sigma }
          \infer1[\ref{inf:def:dependent_product/intro}]{ \qabs {x^\tau} M: \qprod {x^\tau} \sigma }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}

    \begin{nthcolumn}{2}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Pi_- }]{inf:def:dependent_product/elim}
        \begin{prooftree}
          \hypo{ M: \qprod {x^\tau} \sigma }
          \hypo{ A: \tau }
          \infer2[\ref{inf:def:dependent_product/elim}]{ M A: \sigma[x \mapsto A] }
        \end{prooftree}
      \end{equation*}
    \end{nthcolumn}
  \end{paracol}

  We also have the following \hyperref[rem:type_theory_rule_classification/equality/comp]{computation} and \hyperref[rem:type_theory_rule_classification/equality/uniq]{uniqueness} rules:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Pi_\beta }]{inf:def:dependent_product/comp}
        \begin{prooftree}
          \hypo{ x: \tau }
          \infer[dashed]1{ M: \sigma }

          \hypo{ A: \tau }
          \infer2[\ref{inf:def:dependent_product/comp}]{ (\qabs {x^\tau} M) A \syndefeq M[x \mapsto A]: \sigma[x \mapsto A] }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \Pi_\eta }]{inf:def:dependent_product/uniq}
        \begin{prooftree}
          \hypo{ M: \qprod {x^\tau} \sigma }
          \infer1[\ref{inf:def:dependent_product/uniq}]{ M \syndefeq \qabs {x^\tau} M x: \qprod {x^\tau} \sigma },
        \end{prooftree}
      \end{equation*}
      where, as per \cref{rem:type_theory_rule_classification/equality/uniq}, we require \( x \) not to be the variable of an open assumption.
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item The rules are generally based on Martin-L\"of's rules from \cite[35]{MartinLöf1984IntuitionisticTypeTheory}, with computation and equality rules adapted from \cite[\S A.2.4]{UnivalentFoundationsProgram2013HoTT}. Due to \cref{rem:product_type_via_dependent_product}, the latter prefer calling dependent products \enquote{dependent function types}.
\end{comments}

\begin{remark}\label{rem:arrow_type_via_dependent_product}
  The \hyperref[def:arrow_type]{arrow type} \( \tau \synimplies \sigma \) is a special case of the \hyperref[def:dependent_product]{dependent product} \( \qprod {x^\tau} \sigma \), in which \( \sigma \) does not depend on \( x \) (in the sense of \cref{rem:mltt_pseudoterm_dependency}).
\end{remark}

\begin{remark}\label{rem:product_type_via_dependent_product}
  The \hyperref[def:type_of_booleans]{type of Booleans} \( \syn\Bbbtwo \) allows us to define \hyperref[def:simple_product_type]{binary product types} via \hyperref[def:dependent_product]{dependent products}:
  \begin{equation*}\taglabel[\ensuremath{ \times_{\logic{form}}^{\logic{bin}} }]{inf:rem:product_type_via_dependent_product/form}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \sigma: \BbbT }
      \infer2[\ref{inf:rem:product_type_via_dependent_product/form}]{ \tau \syntimes \sigma \syndefeq \qprod {x^{\syn\Bbbtwo}} \synB_- (\qabs {y^{\syn\Bbbtwo}} \BbbT) \tau \sigma x: \BbbT }
    \end{prooftree}
  \end{equation*}

  We can imitate the introduction rule \ref{inf:def:simple_product_type/intro} by adding a constant \( \synP_+ \) with the following equality rule:
  \begin{equation*}\taglabel[\ensuremath{ \times_+^{\logic{bin}} }]{inf:rem:product_type_via_dependent_product/intro}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \sigma: \BbbT }
      \hypo{ M: \tau }
      \hypo{ N: \tau }
      \infer4[\ref{inf:rem:product_type_via_dependent_product/intro}]{ \synP_+ \tau \sigma M N \syndefeq \qabs {a^{\syn\Bbbtwo}} \synB_- (\qabs {b^{\syn\Bbbtwo}} (\tau \syntimes \sigma) b) M N a: \tau \syntimes \sigma }
    \end{prooftree}
  \end{equation*}

  Similarly, we can imitate the elimination rule \ref{inf:def:simple_product_type/elim_left} as follows:
  \begin{equation*}\taglabel[\ensuremath{ \times_{-L}^{\logic{bin}} }]{inf:rem:product_type_via_dependent_product/elim_left}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \sigma: \BbbT }
      \hypo{ K: \tau \syntimes \sigma }
      \infer3[\ref{inf:rem:product_type_via_dependent_product/elim_left}]{ \synP_{-L} \tau \sigma K \syndefeq K \synB_-: \tau }
    \end{prooftree}
  \end{equation*}

  The typing in this rule is sound due to \ref{inf:def:type_of_booleans/elim}.

  The above rules allow the following chain of definitional equality rewriting:
  \begin{align*}
    \synP_{-L} \tau \sigma (\synP_+ \tau \sigma M N)
    &\overset {\ref{inf:rem:product_type_via_dependent_product/elim_left}} \syndefeq
    (\synP_+ \tau \sigma M N) \synB_{+L}
    \syndefeq \\ &\overset {\ref{inf:rem:product_type_via_dependent_product/intro}} \syndefeq
    (\qabs {a^{\syn\Bbbtwo}} \synB_- (\qabs {b^{\syn\Bbbtwo}} (\tau \syntimes \sigma) b) M N a) \synB_{+L}
    \syndefeq \\ &\overset {\ref{inf:def:dependent_product/comp}} \syndefeq
    \synB_- (\qabs {b^{\syn\Bbbtwo}} (\tau \syntimes \sigma) b) M N \synB_{+L}
    \syndefeq \\ &\overset {\ref{inf:def:type_of_booleans/comp_left}} \syndefeq
    M.
  \end{align*}
\end{remark}

\paragraph{Dependent sums}

\begin{definition}\label{def:dependent_sum}\mcite[\S A.2.5]{UnivalentFoundationsProgram2013HoTT}
  When defining the syntax of Martin-L\"of type theory in \cref{def:mltt_pseudoterm}, we have stated the syntax of dependent sums. They generalize \hyperref[def:simple_sum_type]{binary sum types} and also, coincidentally, \hyperref[def:simple_product_type]{binary product types}.

  For a fixed \hyperref[con:type_universe]{type universe} \( \BbbT \), we have the following \hyperref[rem:type_theory_rule_classification/form]{formation rule}:
  \begin{equation*}\taglabel[\ensuremath{ \Sigma_{\logic{form}} }]{inf:def:dependent_sum/form}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }

      \hypo{ x: \tau }
      \infer[dashed]1{ \sigma: \BbbT }

      \infer2[\ref{inf:def:dependent_sum/form}]{ \qsum {x^\tau} \sigma: \BbbT }
    \end{prooftree}
  \end{equation*}

  We will need constants \( \synS_+ \) and \( \synS_- \), whose role differs from the same constants used for \hyperref[def:simple_product_type]{binary product types}.

  The \hyperref[rem:type_theory_rule_classification/intro]{introduction rule} creates an ordered pair:
  \begin{equation*}\taglabel[\ensuremath{ \Sigma_+ }]{inf:def:dependent_sum/intro}
    \begin{prooftree}
      \hypo{ x: \tau }
      \infer[dashed]1{ \sigma: \BbbT }

      \hypo{ M: \tau }
      \hypo{ N: \sigma[x \mapsto M] }

      \infer3[\ref{inf:def:dependent_sum/intro}]{ \synS_+ M N: \qsum {x^\tau} \sigma }
    \end{prooftree}
  \end{equation*}

  The \hyperref[rem:type_theory_rule_classification/elim]{elimination rule} allows substituting such a pair as long as the types are appropriate:
  \begin{equation*}\taglabel[\ensuremath{ \Sigma_- }]{inf:def:dependent_sum/elim}
    \begin{prooftree}
      \hypo{ z: \qsum {x^\tau} \sigma }
      \infer[dashed]1{ \rho: \BbbT }

      \hypo{ a: \tau }
      \hypo{ b: \sigma }
      \infer[dashed]2{ M: \rho[z \mapsto \synS_+ a b] }

      \hypo{ A: \qsum {x^\tau} \sigma }

      \infer3[\ref{inf:def:dependent_sum/elim}]{ \synS_- (\qabs {z^{\qsum {x^\tau} \sigma}} \rho) (\qabs {x^\tau} \qabs {y^\sigma} M) A: \rho[z \mapsto A] }
    \end{prooftree}
  \end{equation*}

  Finally, we have the following \hyperref[rem:type_theory_rule_classification/equality/comp]{computation rule}:
  \begin{equation*}\taglabel[\ensuremath{ \Sigma_\beta }]{inf:def:dependent_sum/comp}
    \begin{prooftree}
      \hypo{ z: \qsum {x^\tau} \sigma }
      \infer[dashed]1{ \rho: \BbbT }

      \hypo{ a: \tau }
      \hypo{ b: \sigma }
      \infer[dashed]2{ M: \rho[z \mapsto \synS_+ a b] }

      \hypo{ A: \tau }
      \hypo{ B: \sigma[x \mapsto A] }

      \infer4[\ref{inf:def:dependent_sum/comp}]{ \synS_- (\qabs {z^{\qsum {x^\tau} \sigma}} \rho) (\qabs {a^\tau} {b^\sigma} M) (\synS_+ A B) \syndefeq M[a \mapsto A, b \mapsto B]: \rho[z \mapsto \synS_+ A B] }
    \end{prooftree}
  \end{equation*}
\end{definition}
\begin{comments}
  \item We associate with each product sum the projection terms \( \pi_L \) and \( \pi_R \) from \cref{def:dependent_sum_projections}.
\end{comments}

\begin{remark}\label{rem:sum_type_via_dependent_sum}
  Similarly to how we used the \hyperref[def:type_of_booleans]{type of Booleans} \( \syn\Bbbtwo \) in \cref{rem:product_type_via_dependent_product} to define \hyperref[def:simple_product_type]{binary product types} via \hyperref[def:dependent_product]{dependent products}, we can also define \hyperref[def:simple_sum_type]{binary sum types} via \hyperref[def:dependent_sum]{dependent sums}:
  \begin{equation*}\taglabel[\ensuremath{ +_{\logic{form}} }]{inf:rem:sum_type_via_dependent_sum/form}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \sigma: \BbbT }
      \infer2[\ref{inf:rem:sum_type_via_dependent_sum/form}]{ \tau \synplus \sigma \syndefeq \qsum {x^{\syn\Bbbtwo}} \synB_- (\qabs {y^{\syn\Bbbtwo}} \BbbT) \tau \sigma x: \BbbT }
    \end{prooftree}
  \end{equation*}

  To distinguish the constants \( \synS_{+L} \), \( \synS_{+R} \) and \( \synS_- \) for binary sums from \cref{def:simple_sum_type} from the constants \( \synS_+ \) and \( \synS_- \) for dependent sums from \cref{def:dependent_sum}, we will add superscripts (e.g. \( \synS_+^{\logic{bin}} \)) to the former.

  We can imitate the introduction rule \ref{inf:def:simple_sum_type/intro_left} as follows:
  \begin{equation*}\taglabel[\ensuremath{ +_{-L} }]{inf:rem:sum_type_via_dependent_sum/intro_left}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \sigma: \BbbT }
      \hypo{ M: \tau }
      \infer3[\ref{inf:rem:sum_type_via_dependent_sum/intro_left}]{ \synS_{+L}^{\logic{bin}} \tau \sigma M \syndefeq \synS_+ \synB_{+L} M: \tau \synplus \sigma }
    \end{prooftree}
  \end{equation*}

  Again, the types here are sound due to \ref{inf:def:type_of_booleans/elim}.

  To imitate the elimination rule \ref{inf:def:simple_sum_type/elim}, we can define
  \begin{equation*}\taglabel[\ensuremath{ +_- }]{inf:rem:sum_type_via_dependent_sum/elim}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \sigma: \BbbT }
      \hypo{ \rho: \BbbT }

      \hypo{ M: \tau \syntimes \sigma }

      \hypo{ a: \tau }
      \infer[dashed]1{ N: \rho }

      \hypo{ b: \sigma }
      \infer[dashed]1{ K: \rho }

      \infer6[\ref{inf:rem:sum_type_via_dependent_sum/elim}]{ \synS_-^{\logic{bin}} \tau \sigma (\qabs {a^\tau} N) (\qabs {b^\tau} K) M \syndefeq \ref{eq:rem:sum_type_via_dependent_sum/elim_dagger}: \rho },
    \end{prooftree}
  \end{equation*}
  where
  \begin{equation*}\taglabel[\ensuremath{ \dagger }]{eq:rem:sum_type_via_dependent_sum/elim_dagger}
    \ref{eq:rem:sum_type_via_dependent_sum/elim_dagger} = \synS_- (\qabs {z^{\tau \syntimes \sigma}} \rho) (\qabs {x^{\syn\Bbbtwo}} \qabs {y^{\synB_- (\qabs {y^{\syn\Bbbtwo}} \BbbT) \tau \sigma x}} \synB_- (\qabs {t^{\syn\Bbbtwo}} \rho) \thinspace N[a \mapsto y] \thinspace K[b \mapsto y] \thinspace x) M.
  \end{equation*}

  Note that we have assumed that, as in \cref{def:simple_sum_type}, \( \rho \) does not depend on \( a \) nor \( b \).

  The above rules allow the following chain of definitional equality rewriting:
  \begin{align*}
    &\phantom{{}\syndefeq{}}
    \synS_-^{\logic{bin}} \tau \sigma (\qabs {x^\tau} N) (\qabs {y^\tau} K) (\synS_+^{\logic{bin} M})
    \syndefeq \\ &\overset {\ref{inf:rem:sum_type_via_dependent_sum/intro_left}} \syndefeq
    \synS_-^{\logic{bin}} \tau \sigma (\qabs {x^\tau} N) (\qabs {y^\tau} K) (\synS_{+L} \synB_{+L} M)
    \syndefeq \\ &\overset {\ref{inf:rem:sum_type_via_dependent_sum/elim}} \syndefeq
    \synS_- (\qabs {z^{\tau \syntimes \sigma}} \rho) (\qabs {x^{\syn\Bbbtwo}} \qabs {y^{\synB_- (\qabs {y^{\syn\Bbbtwo}} \BbbT) \tau \sigma x}} \hi {\synB_- (\qabs {t^{\syn\Bbbtwo}} \rho) \thinspace N[a \mapsto y] \thinspace K[b \mapsto y] \thinspace x}) (\synS_+ \synB_{+L} M)
    \syndefeq \\ &\overset {\ref{inf:def:dependent_sum/comp}} \syndefeq
    (\synB_- (\qabs {t^{\syn\Bbbtwo}} \rho) \thinspace N[a \mapsto y] \thinspace K[b \mapsto y] \thinspace x)[x \mapsto \synB_{+L}, y \mapsto M]
    \syndefeq \\ &\overset {\ref{inf:def:type_of_booleans/comp_left}} \syndefeq
    N[a \mapsto M].
  \end{align*}

  This is the desired result, as discussed in \cref{rem:sum_type_equality_rules}.
\end{remark}

\begin{remark}\label{rem:dependent_sum_as_binary_product}
  The \hyperref[def:simple_product_type]{binary product type} \( \tau \syntimes \sigma \) is a special case of the \hyperref[def:dependent_product]{dependent sum} \( \qsum {x^\tau} \sigma \), in which \( \sigma \) does not depend on \( x \) (in the sense of \cref{rem:mltt_pseudoterm_dependency}).

  This is analogous to how the integer product \( mn \) is a special case of the sum \( \sum_{k=1}^n m \).
\end{remark}

\begin{definition}\label{def:dependent_sum_projections}\mimprovised
  For a fixed \hyperref[def:dependent_sum]{dependent sum type} \( \qsum {x^\tau} \sigma \), we can define two terms acting as projections:
  \begin{align*}
    \pi_L &\coloneqq \qabs {\syna^{\qsum {x^\tau} \sigma}} \synS_- (\qabs {\synz^{\qsum {x^\tau} \sigma}} \tau) (\qabs {\synx^\tau} {\syny^\sigma} \synx) \syna, \\
    \pi_R &\coloneqq \qabs {\syna^{\qsum {x^\tau} \sigma}} \synS_- (\qabs {\synz^{\qsum {x^\tau} \sigma}} \sigma[x \mapsto \pi_L \synz]) (\qabs {\synx^\tau} {\syny^\sigma} \syny) \syna.
  \end{align*}

  The outermost abstractors in \( \pi_L \) and \( \pi_R \) have no other purpose except making the terms \hyperref[def:mltt_well_formed_context/type]{well-formed} in the same type context as \( \qsum {x^\tau} \sigma \) (by a straightforward application of \ref{inf:def:dependent_sum/elim}):
  \begin{align*}
    &\pi_L: \qprod {\syna^{\qsum {x^\tau} \sigma}} \tau, \\
    &\pi_R: \qprod {\syna^{\qsum {x^\tau} \sigma}} \sigma[x \mapsto \pi_L \syna].
  \end{align*}

  By \ref{inf:def:dependent_product/comp} and \ref{inf:def:dependent_sum/comp}, for any terms \( A: \tau \) and \( B: \sigma[x \mapsto A] \), the following are judgmentally equal:
  \begin{align*}
    &\pi_L (\synS_+ A B) \syndefeq A: \tau, \\
    &\pi_R (\synS_+ A B) \syndefeq B: \sigma[x \mapsto A].
  \end{align*}
\end{definition}
\begin{comments}
  \item We do not denote this explicitly to avoid overcrowding, but the projection terms depend on \( \qsum {x^\tau} \sigma \).
\end{comments}

\paragraph{Martin-L\"of type theory}

\begin{definition}\label{def:mltt_signature}\mimprovised
  A \hyperref[con:logical_system_signature]{signature} \( \Sigma \) for Martin-L\"of type theory is a specification of two \hyperref[def:formal_language/alphabet]{alphabets} (nonempty hereditarily finite sets):
  \begin{thmenum}
    \thmitem{def:mltt_signature/universe} A nonempty set \( \op*{Univ}_\Sigma \) of symbols acting as \hyperref[con:type_universe]{type universe}. Unless noted otherwise, we assume that there is only one universe --- \( \syn\BbbT \).

    \thmitem{def:mltt_signature/const} A (possibly empty) set \( \op*{Const}_\Sigma \) of symbols acting as \hyperref[def:mltt_pseudoterm]{(pseudoterm) constants}.
  \end{thmenum}

  As per \cref{rem:improper_symbols_and_parsing}, we disallow the \hyperref[con:improper_symbol]{improper symbols} from the \hyperref[def:mltt_alphabet]{Martin-L\"of type theory alphabet} as universes and constants.
\end{definition}
\begin{comments}
  \item The requirement for \( \op*{Univ}_\Sigma \) and \( \op*{Const}_\Sigma \) to be hereditarily finite is discussed in \cref{rem:signatures_are_small}.
\end{comments}

\begin{definition}\label{def:martin_lof_type_theory}\mimprovised
  We call \term{Martin-L\"of type theory} the \hyperref[def:abstract_type_system]{type system} based on the \hyperref[def:mltt_pseudoterm]{eponymous pseudoterm expressions}, depending on an \hyperref[def:mltt_signature]{eponymous signature} and featuring the \hyperref[con:dependent_type]{dependent types} presented in this section --- \hyperref[def:identity_type]{identity types}, \hyperref[def:dependent_product]{dependent products} and \hyperref[def:dependent_sum]{dependent sums} --- as well as the \hyperref[def:dependent_empty_type]{dependent empty type}, \hyperref[def:dependent_unit_type]{dependent unit type} and the \hyperref[def:type_of_booleans]{type of Booleans}.

  We assume all generic equality rules from \cref{rem:type_theory_rule_classification/equality}.

  Furthermore, we label as well-formed the types, type contexts and derivation trees as per the procedure described in \cref{def:mltt_well_formed_context}. We consider the others ill-formed and implicitly disregard them.
\end{definition}
\begin{comments}
  \item The system is named after Per Martin-L\"of, who presented a variant of it in \cite{MartinLöf1975IntuitionisticTypeTheory}, with a refined version in \cite{MartinLöf1984IntuitionisticTypeTheory}. The same name is used in \cite{UnivalentFoundationsProgram2013HoTT} and \cite[ch. 8]{Mimram2020ProgramEqualsProof}. Martin-L\"of himself called his system \enquote{intuitionistic type theory}. \cite[ch. 8]{Mimram2020ProgramEqualsProof} calls it \enquote{dependent type theory}.

  \item If needed, we can also encode the other \hyperref[def:simple_algebraic_types]{simple algebraic types} as abbreviations:
  \begin{itemize}
    \item \hyperref[def:arrow_type]{Arrow types} are special cases of dependent products, as shown in \cref{rem:arrow_type_via_dependent_product}.
    \item \hyperref[def:simple_product_type]{Binary product types} can be represented via dependent products and the type of Booleans, as shown in \cref{rem:product_type_via_dependent_product}.
    \item \hyperref[def:simple_sum_type]{Binary sum types} can be represented via dependent sums and the type of Booleans, as shown in \cref{rem:sum_type_via_dependent_sum}.
  \end{itemize}
\end{comments}

\begin{definition}\label{def:mltt_well_formed_context}\mimprovised
  We have briefly described in \cref{rem:well_formed_context} how types, \hyperref[def:type_context]{type contexts} and \hyperref[def:type_derivation_tree]{type derivation trees} can be well- and ill-formed in \hyperref[def:abstract_type_system]{type systems} with \hyperref[con:pseudoterm_expression]{pseudoterm expressions}.

  Here we will give precise mutually recursive definitions for these concepts for \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}. The definitions will be just as valid for \hyperref[def:pure_type_system]{pure type systems} and \hyperref[def:higher_order_logic]{higher-order logic}, and possibly other related type systems.

  \begin{thmenum}
    \thmitem{def:mltt_well_formed_context/base} We consider any \hyperref[def:mltt_signature/universe]{type universe} itself to be a well-formed type (with respect to the empty type context). Correspondingly, if the type context \( \Gamma \) has type universes as its only types, we consider it well-formed.

    This is the base case. The other well-formed types and contexts depend recursively on derivation trees, which we will discuss next.

    \thmitem{def:mltt_well_formed_context/derivation} We consider a type derivation tree \( T \) to be well-formed with respect to a well-formed context \( \Gamma \) if all open assumptions of \( T \) are in \( \Gamma \) and if all discharged (closed and implicit) assumptions are \hi{not} in \( \Gamma \) but have well-formed types with respect to \( \Gamma \).

    We give several examples in \cref{ex:def:mltt_well_formed_context} of why allowing discharged assumptions in \( \Gamma \) can lead to pathologies.

    \thmitem{def:mltt_well_formed_context/type} We consider the pseudoterm expression \( \tau \) a well-formed type with respect to a well-formed context \( \Gamma \) if it either satisfies \cref{def:mltt_well_formed_context/base} (i.e. if it is a type universe) or if there exists a well-formed (with respect to \( \Gamma \)) derivation tree with conclusion \( \tau: \BbbT \), where \( \BbbT \) is a type universe.

    \thmitem{def:mltt_well_formed_context/context} Finally, we consider the type context \( \Delta \) to be a well-formed if it either satisfies \cref{def:mltt_well_formed_context/base} (i.e. if it features only type universes; the base case also covers the case where \( \Delta \) is empty) or if \( \Delta = \Gamma, (x: \tau) \), where \( \Gamma \) has already been shown to be a well-formed context, and \( \tau \) has already been shown to be a well-formed type with respect to \( \Gamma \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item As discussed in \cref{rem:well_formed_context}, we have not defined what it means for a pseudoterm expression to be a \enquote{type}, only a \enquote{well-formed type}, so we take \enquote{type} to be synonymous with \enquote{well-formed type}.
\end{comments}

\begin{definition}\label{def:mltt_derivation}\mimprovised
  We define a \hyperref[def:type_derivation_relation]{type derivation relation} for \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} by asserting that \( \Gamma \vdash M: \tau \) holds if there exists a \hyperref[def:type_derivation_tree]{type derivation tree} with conclusion \( M: \tau \) that is \hyperref[def:mltt_well_formed_context/derivation]{well-formed} with respect to \( \Gamma \).
\end{definition}
\begin{comments}
  \item The proof that this is indeed a type derivation relation is analogous to the proof of consistency in \cref{def:propositional_natural_deduction_consequence}.
\end{comments}

\begin{example}\label{ex:def:mltt_well_formed_context}
  We list examples of \hyperref[def:mltt_well_formed_context]{well- and ill-formed contexts} in \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}:

  \begin{thmenum}
    \thmitem{ex:def:mltt_well_formed_context/negation} Consider first the following derivation tree:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \syn\tau: \BbbT }
        \infer0[\ref{inf:def:dependent_empty_type/form}]{ \syn\Bbbzero: \BbbT }
        \infer2[\ref{inf:def:dependent_product/form}]{ \syn\tau \synimplies \syn\Bbbzero: \BbbT }
      \end{prooftree}
    \end{equation*}

    The context \( \syn\tau: \BbbT \) is well-formed as per \cref{def:mltt_well_formed_context/base}, and there are no other assumptions, so, by \cref{def:mltt_well_formed_context/derivation}, the derivation is well-formed.

    By \cref{def:mltt_well_formed_context/type}, \( \syn\tau \synimplies \syn\Bbbzero \) is a well-formed type with respect to \( \syn\tau: \BbbT \), so, by \cref{def:mltt_well_formed_context/context}, the following context is well-formed:
    \begin{equation*}
      \syn\tau: \BbbT, \synf: \syn\tau \synimplies \syn\Bbbzero
    \end{equation*}

    The order of type assertions here is important because \( \synf: \syn\tau \synimplies \syn\Bbbzero \) is not by itself meaningful unless we know that \( \syn\tau \) is a type.

    To extend this example, consider the derivation
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \syn\tau \synimplies \syn\Bbbzero }
        \hypo{ \synx: \syn\tau }
        \infer2[\ref{inf:def:dependent_product/elim}]{ \synf \synx: \syn\Bbbzero }
      \end{prooftree}
    \end{equation*}

    It shows that
    \begin{equation*}
      \syn\tau: \BbbT, \synf: \syn\tau \synimplies \syn\Bbbzero, \synx: \syn\tau \vdash \synf \synx: \syn\Bbbzero.
    \end{equation*}

    We can exchange the assertions for \( \synf \) and \( \synx \) in the context, but both can only come after the assertion for \( \syn\tau \).

    \thmitem{ex:def:mltt_well_formed_context/invalid_derivation}\mcite[198]{Barendregt1992LambdaCalculiWithTypes} In the context \( \syn\tau: \BbbT \), the derivation
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \syn\tau }
        \infer1[\ref{inf:def:dependent_product/intro}]{ \qabs {\synx^{\syn\tau}} \synx: \syn\tau \synimplies \syn\tau }
      \end{prooftree}
    \end{equation*}
    is well-formed.

    The order of assumptions in the type context is important. In the context \( \Gamma \coloneqq \syn\tau: \BbbT, \synx: \syn\tau \), we can attempt to abstract away \( \tau: \BbbT \) rather than \( \synx: \syn\tau \). The derivation
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \syn\tau }
        \infer1[\ref{inf:def:dependent_product/intro}]{ \qabs {\syn\tau^{\BbbT}} \synx: \BbbT \synimplies \syn\tau }
      \end{prooftree}
    \end{equation*}
    is not well-formed, however.

    Indeed, \( \synx: \syn\tau \) is an open assumption and thus must be contained in \( \Gamma \). On the other hand, the assumption \( \syn\tau: \BbbT \) is implicit and must by definition not be contained in \( \Gamma \). But \( \synx: \syn\tau \) is not by itself a well-formed context without \( \syn\tau: \BbbT \).

    If we instead bind another variable, say \( \syn\sigma \), we obtain the derivation
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \syn\tau }
        \infer1[\ref{inf:def:dependent_product/intro}]{ \qabs {\syn\sigma^{\BbbT}} \synx: \BbbT \synimplies \syn\tau }
      \end{prooftree}
    \end{equation*}
    that is well-formed with respect to \( \Gamma \).

    \thmitem{ex:def:mltt_well_formed_context/discharging} The type \( \synx \syneq_{\syn\tau} \syny \) is well-formed in the context \( \syn\tau: \BbbT, \synx: \syn\tau, \syny: \syn\tau \) due to \ref{inf:def:identity_type/form}.

    Let \( M \) be some term inhabiting this type and consider the following derivation tree:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ M: \synx \syneq_{\syn\tau} \syny }
        \infer[left label=\( \synx \)]1[\ref{inf:def:dependent_product/intro}]{ \qabs {\synx^{\syn\tau}} M: \qprod {\synx^{\syn\tau}} (\synx \syneq_{\syn\tau} \syny) }
      \end{prooftree}
    \end{equation*}

    According to \cref{def:mltt_well_formed_context/derivation}, the tree is well-formed in a (well-formed) context \( \Gamma \) if \( \Gamma \) contains the open assumptions \( \syn\tau: \BbbT \) and \( \syny: \syn\tau \), but \hi{not} the discharged assumption \( \synx: \syn\tau \). Without \( \synx: \syn\tau \), the assumption \( M: \synx \syneq_{\syn\tau} \syny \) cannot even be assigned a type. So this derivation tree is ill-formed.

    See \cref{con:eigenvariable} for how this well-formedness condition justifies the eigenvariable conditions in \hyperref[def:higher_order_logic]{higher-order logic}.
  \end{thmenum}
\end{example}

\begin{remark}\label{rem:mltt_curry_howard}
  With the \hyperref[def:type_derivation_relation]{type derivation relation} defined in \cref{def:mltt_derivation}, \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} can be seen as a form of \hyperref[rem:predicate_logic]{predicate logic} if we extend the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} by matching \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantifiers} with \hyperref[def:dependent_product]{dependent products} and \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantifiers} with \hyperref[def:dependent_sum]{dependent sums}.

  \begin{thmenum}
    \thmitem{rem:mltt_curry_howard/no_restriction} Without constraints on which types are allowed to act as formulas, we obtain a very general \hyperref[con:logical_system]{logical system} that is hard to analyze.

    \thmitem{rem:mltt_curry_howard/mere_propositions} One possibility is to only use allow those types that are \hyperref[def:mere_proposition]{mere propositions}.

    A benefit of this is that all terms inhabiting a mere proposition are \hyperref[def:mltt_propositional_equality]{propositionally equal}. This is important in some cases such as our definition of subtypes in \cref{def:dependent_subtype}.

    \thmitem{rem:mltt_curry_howard/arrow_types} Another possibility is to restrict type annotations of quantifiers to only \hyperref[def:quantifiable_type]{quantifiable types}.

    The resulting types then resemble those allowed by Church in his simply typed higher-order logic. Since Church encoded propositions via terms (and not types), we must discard the terms since they are not relevant. We discuss this approach in \fullref{rem:mltt_hol}.
  \end{thmenum}
\end{remark}

\begin{proposition}\label{thm:propositional_equality_equivalence_relation}
  \hyperref[def:mltt_propositional_equality]{Propositional equality} in \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} (with the \hyperref[def:identity_type/j]{\( J \) eliminator}) acts like an \hyperref[def:equivalence_relation]{equivalence relation}. More precisely:
  \begin{thmenum}
    \thmitem{thm:propositional_equality_equivalence_relation/reflexivity} \hyperref[def:relation_closures/reflexive]{Reflexivity}: the type \( A \syneq_\tau A \) is inhabited (if the term \( A \) inhabits \( \tau \)).

    \thmitem{thm:propositional_equality_equivalence_relation/symmetry} \hyperref[def:relation_closures/symmetric]{Symmetry}: the type \( A \syneq_\tau B \) entails \( B \syneq_\tau A \) (if one is inhabited, so is the other).

    \thmitem{thm:propositional_equality_equivalence_relation/transitivity}\mcite[lemma 2.1.2]{UnivalentFoundationsProgram2013HoTT} \hyperref[def:relation_closures/transitive]{Transitivity}: \( A \syneq_\tau B \) and \( B \syneq_\tau C \) entail \( A \syneq_\tau C \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:propositional_equality_equivalence_relation/reflexivity} This is simply a restatement of \ref{inf:def:identity_type/intro}.

  \SubProofOf{thm:propositional_equality_equivalence_relation/symmetry} Given \( E: A \syneq_\tau B \) (and \( \tau: \BbbT \)), we can construct a term inhabiting \( B \syneq_\tau A \):
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \synx: \tau }
      \hypo{ \syny: \tau }
      \infer3[\ref{inf:def:identity_type/form}]{ \syny \syneq_\tau \synx: \BbbT }

      \hypo{ \tau: \BbbT }
      \hypo{ \synz: \tau }
      \infer2[\ref{inf:def:identity_type/intro}]{ \synI_+ \synz: \synz \syneq_\tau \synz }

      \hypo{}
      \ellipsis {} { A: \tau }
      \hypo{}
      \ellipsis {} { B: \tau }
      \hypo{}
      \ellipsis {} { E: A \syneq_\tau B }

      \infer[left label={\( \synx, \syny, \synz \)}]5[\ref{inf:def:identity_type/j/elim}]{ \synJ (\qabs {\synx^{\tau}} \qabs {\syny^{\tau}} \qabs {\synp^{\synx \syneq_{\tau} \syny}} \syny \syneq_\tau \synx) (\qabs {\synz^{\tau}} \synI_+ \synz) A B E: B \syneq_\tau A: \BbbT }
    \end{prooftree}
  \end{equation*}

  \SubProofOf{thm:propositional_equality_equivalence_relation/transitivity} Similarly, fix terms \( E: A \syneq_\tau B \) and \( F: B \syneq_\tau C \).

  First, we will use the \( J \) elimination rule on \( \sigma = (\syny \syneq_\tau C) \synimplies (\synx \syneq_\tau C) \), with the dischargeable assumptions \( \synx: \tau \) and \( \syny: \tau \) in the type forming premise:
  \begin{equation*}
    \begin{prooftree}
      \hypo{}
      \ellipsis {} { \sigma: \BbbT }

      \hypo{ \synp: \synz \syneq_\tau C }
      \infer[left label=\( \synp \)]1[\ref{inf:def:dependent_product/intro}]{ \qabs {\synp^{\synz \syneq_\tau C}} \synp: \sigma[\synx \mapsto \synz, \syny \mapsto \synz] }

      \hypo{}
      \ellipsis {} { A: \tau }
      \hypo{}
      \ellipsis {} { B: \tau }
      \hypo{}
      \ellipsis {} { E: A \syneq_\tau B }

      \infer[left label={\( \synx, \syny \)}]5[\ref{inf:def:identity_type/j/elim}]{ \synJ \ldots A B E: (B \syneq_\tau C) \synimplies (A \syneq_\tau C): \BbbT }
    \end{prooftree}
  \end{equation*}

  We can now apply this term to \( F \) (via \ref{inf:def:dependent_product/elim}) and obtain a term of type \( A \syneq_\tau C \), as desired.
\end{proof}

\begin{definition}\label{def:propositionally_uninhabited}\mimprovised
  In \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}, we say that the type \( \tau \) is \term{propositionally uninhabited} if \( \vdash \tau \synimplies \syn\Bbbzero \), where \( \syn\Bbbzero \) is the (dependent) \hyperref[def:dependent_empty_type]{empty type}.
\end{definition}
\begin{comments}
  \item Via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, we can view \( \tau \synimplies \syn\Bbbzero \) as a logical negation of \( \tau \). From this perspective \( \tau \) is propositionally uninhabited if and only if its negation is inhabited. Propositionally uninhabited types thus correspond to \hyperref[def:propositional_contradiction]{contradictions}.

  The definition itself is based on a comment in \cite[47]{UnivalentFoundationsProgram2013HoTT}.
\end{comments}

\begin{proposition}\label{thm:empty_type_is_uninhabited}
  The (dependent) \hyperref[def:dependent_empty_type]{empty type} is \hyperref[def:propositionally_uninhabited]{propositionally uninhabited}.
\end{proposition}
\begin{proof}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \synx: \syn\Bbbzero }
      \infer1[\ref{inf:def:dependent_product/intro}]{ \qabs {\synx^{\syn\Bbbzero}} \synx: \syn\Bbbzero \synimplies \syn\Bbbzero }.
    \end{prooftree}
  \end{equation*}
\end{proof}

\paragraph{Mere propositions}

\begin{remark}\label{rem:mere_propositions}
  Due to the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, every type in \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} can be regarded as a logical formula in the sense of \cref{con:proposition}.

  As noted in \cite[111]{UnivalentFoundationsProgram2013HoTT}, this definition only takes into account whether the type is inhabited, and not in which terms inhabit it. The authors suggest restricting the Curry-Howard correspondence to only those types that are inhabited by at most one term. We define such types, called \enquote{mere propositions}, in \cref{def:mere_proposition}.

  Unfortunately, without the additional machinery of homotopy type theory, we will not be able to prove that some types that are intended to be propositions satisfy the definition of a mere propositions.
\end{remark}

\begin{definition}\label{def:mere_proposition}\mcite[def. 3.3.1]{UnivalentFoundationsProgram2013HoTT}
  Within \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}, we call the type \( \tau \) a \term{mere proposition} if all its inhabitants are \hyperref[def:mltt_propositional_equality]{propositionally equal} or, more formally, if the following type is inhabited:
  \begin{equation*}\taglabel[\op{IsProp}]{abbr:def:mere_proposition}
    \ref{abbr:def:mere_proposition}[\tau] \coloneqq \qprod {\synx^\tau} \qprod {\syny^\tau} (\synx \syneq_\tau \syny).
  \end{equation*}
\end{definition}
\begin{comments}
  \item Since the condition resembles that for \hyperref[def:subsingleton_set]{subsingleton sets}, mere propositions are also called \enquote{subsingletons}.

  \item The \hyperref[con:type_constructor]{type constructor} \( \op{IsProp} \) here is an abbreviation in the sense of \cref{con:syntactic_abbreviation}.
\end{comments}

\begin{proposition}\label{thm:uninhabited_type_is_proposition}
  Any \hyperref[def:propositionally_uninhabited]{propositionally uninhabited} term is a \hyperref[def:mere_proposition]{mere proposition}.
\end{proposition}
\begin{proof}
  If \( \tau \) is propositionally uninhabited, there exists a term \( M \) inhabiting \( \tau \synimplies \syn\Bbbzero \). Then
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \tau: \BbbT }
      \hypo{ \synx: \tau }
      \hypo{ \syny: \tau }
      \infer3[\ref{inf:def:identity_type/form}]{ \synx \syneq_\tau \syny: \BbbT }

      \hypo {}
      \ellipsis {} { M: \tau \synimplies \syn\Bbbzero }

      \hypo{ \syny: \tau }
      \infer2[\ref{inf:def:dependent_product/elim}]{ M \syny: \syn\Bbbzero }

      \infer2[\ref{inf:def:dependent_empty_type/elim}]{ \synE_- (\qabs {\synz^{\syn\Bbbzero}} \synx \syneq_\tau \syny) (M \syny): \synx \syneq_\tau \syny }
      \infer[left label=\( y \)]1[\ref{inf:def:dependent_product/intro}]{ \qabs {\syny^\tau} \ldots: \qprod {\syny^\tau} \synx \syneq_\tau \syny }
      \infer[left label=\( x \)]1[\ref{inf:def:dependent_product/intro}]{ \qabs {\synx^\tau} \qabs {\syny^\tau} \ldots: \ref{abbr:def:mere_proposition}[\tau] }
    \end{prooftree}
  \end{equation*}
\end{proof}

\begin{corollary}\label{thm:empty_type_is_proposition}
  The (dependent) \hyperref[def:dependent_empty_type]{empty type} is a \hyperref[def:mere_proposition]{mere proposition}.
\end{corollary}
\begin{proof}
  By \cref{thm:empty_type_is_uninhabited}, the empty type is (propositionally) uninhabited. By \cref{thm:uninhabited_type_is_proposition}, it is a mere proposition.
\end{proof}

\begin{definition}\label{def:contractible_type}\mcite[def. 3.11.1]{UnivalentFoundationsProgram2013HoTT}
  Within \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory}, we call the type \( \tau \) \term{contractible} if it has a distinguished inhabitant, called the \term{center of contraction}, that is \hyperref[def:mltt_propositional_equality]{propositionally equal} to any other inhabitant, i.e. if the following type is inhabited:
  \begin{equation*}\taglabel[\op{IsContr}]{abbr:def:contractible_type}
    \ref{abbr:def:contractible_type}[\tau] \coloneqq \qsum {\syna^\tau} \qprod {\synx^\tau} (\syna \syneq_\tau \synx).
  \end{equation*}
\end{definition}
\begin{comments}
  \item There is generally no canonical choice of center of contraction.

  \item The \hyperref[con:type_constructor]{type constructor} \( \op{IsProp} \) here is an abbreviation in the sense of \cref{con:syntactic_abbreviation}.
\end{comments}

\begin{proposition}\label{thm:contractible_type_is_proposition}
  Any \hyperref[def:contractible_type]{contractible type} is a \hyperref[def:mere_proposition]{mere proposition}.
\end{proposition}
\begin{proof}
  Suppose that \( M: \qsum {\syna^\tau} \qprod {\synx^\tau} (\syna \syneq_\tau \synx) \). Such a term can only be obtained via \ref{inf:def:dependent_sum/intro}, hence \( M = \synS_+ N K \) for some terms \( N \) and \( K \) such that \( N: \tau \) and \( K: \qprod {\synx^\tau} (N \syneq_\tau \synx) \).

  For any term \( L: \tau \), \ref{inf:def:dependent_product/elim} allows us to derive \( KL: N \syneq_\tau L \). In particular, for two variables \( a: \tau \) and \( b: \tau \), we have \( Ka: N \syneq_\tau a \) and \( Kb: N \syneq_\tau b \). \Cref{thm:propositional_equality_equivalence_relation/symmetry} gives us a term of type \( a \syneq_\tau N \), and we combine it with \( Kb \) to obtain, via \cref{thm:propositional_equality_equivalence_relation/transitivity}, a term of type \( a \syneq_\tau b \).

  Since \( a \) and \( b \) are arbitrary, we can use \ref{inf:def:dependent_product/intro} twice to obtain \( \ref{abbr:def:mere_proposition}[\tau] \).
\end{proof}

\begin{proposition}\label{thm:unit_type_is_contractible}
  The (dependent) \hyperref[def:dependent_unit_type]{unit type} is \hyperref[def:contractible_type]{contractible}.
\end{proposition}
\begin{proof}
  \Cref{thm:unit_type_term_uniqueness} shows how to derive a term of type \( \synx \syneq_{\syn\Bbbone} \synU_+ \). We will find it more convenient to swap the two sides (which is justified by \cref{thm:propositional_equality_equivalence_relation/symmetry}).

  Let \( M: \synU_+ \syneq_{\syn\Bbbone} \synx \). We can then construct the following derivation:
  \footnotesize
  \begin{equation*}
    \begin{prooftree}
      \infer0[\ref{inf:def:dependent_unit_type/form}]{ \syn\Bbbone: \BbbT }

      \infer0[\ref{inf:def:dependent_unit_type/form}]{ \syn\Bbbone: \BbbT }
      \hypo{ \syna: \syn\Bbbone }
      \hypo{ \synx: \syn\Bbbone }
      \infer3[\ref{inf:def:identity_type/form}]{ \syna \syneq_{\syn\Bbbone} \synx: \BbbT }

      \infer[left label=\( \synx \)]2[\ref{inf:def:dependent_product/form}]{ \qprod {\synx^{\syn\Bbbone}} \syna \syneq_{\syn\Bbbone} \synx: \BbbT }

      \infer0[\ref{inf:def:dependent_unit_type/intro}]{ \synU_+: \syn\Bbbone }

      \hypo{ \synx: \syn\Bbbone }
      \ellipsis {} { M: \synU_+ \syneq_{\syn\Bbbone} \synx }

      \infer[left label=\( \synx \)]1[\ref{inf:def:dependent_product/intro}]{ \qabs {\synx^{\syn\Bbbone}} M: \qprod {\synx^{\syn\Bbbone}} \synU_+ \syneq_{\syn\Bbbone} \synx }

      \infer[left label=\( \syna \)]3[\ref{inf:def:dependent_sum/intro}]{ \synS_+ \synU_+ (\qabs {\synx^{\syn\Bbbone}} M): \ref{abbr:def:contractible_type}[\syn\Bbbone] }
    \end{prooftree}
  \end{equation*}
  \normalsize
\end{proof}

\begin{corollary}\label{thm:unit_type_is_proposition}
  The (dependent) \hyperref[def:dependent_unit_type]{unit type} is a \hyperref[def:mere_proposition]{mere proposition}.
\end{corollary}
\begin{proof}
  \Cref{thm:unit_type_is_contractible} implies that the unit type is contractible, and \cref{thm:contractible_type_is_proposition} implies that contractible types are mere propositions.
\end{proof}

\paragraph{Subtypes}

\begin{definition}\label{def:dependent_subtype}\mcite[46; 115]{UnivalentFoundationsProgram2013HoTT}
  Consider the \hyperref[def:dependent_sum]{dependent sum} \( \qsum {x^\tau} \sigma \), assumed to satisfy
  \begin{equation}\label{eq:def:dependent_subtype}
    \qprod {x^\tau} \ref{abbr:def:mere_proposition}[\sigma].
  \end{equation}

  This sum corresponds, via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, to an \hyperref[def:first_order_language/quantifiers]{existential quantifier}, hinting that we can regard it as an abstract collection of inhabitants \( M \) of \( \tau \) satisfying the condition \( \sigma[x \mapsto M] \).

  Because of this interpretation, where appropriate, we will call \( \qsum {x^\tau} \sigma \) a \term{subtype} of \( \tau \) determined by the proposition \( \sigma \) parameterized by \( x \).

  We can use the projection functions from \cref{def:dependent_sum_projections} to clarify the relation between a type and its subtype. Given a term \( S: \qsum {x^\tau} \sigma \), the left projection \( \pi_L S \) is an inhabitant of \( \tau \), while the right projection \( \pi_R S \) is a witness that \( \pi_L S \) satisfies the subtype criterion. In accordance with \cref{con:inclusion_and_projection}, we will call \( \pi_L \) the \enquote{inclusion into \( \tau \)} and denote it by \( \iota \). Since, \( \sigma[x \mapsto M] \) is a mere proposition whenever \( M: \tau \), the inclusion term \( \iota \) is injective as a function.
\end{definition}
\begin{comments}
  \item It is important to note that \( \qsum {x^\tau} \sigma \) is a purely syntactic object used only as a type annotation. As such, it merely expresses the intention of taking a subcollection of \( \tau \) satisfying some condition.

  \item Subtypes are ubiquitous in programming, where they are advised, if not enforced, to obey Liskov's substitution principle. We discuss this principle in \cref{con:liskov_substitution_principle}.
\end{comments}

\begin{example}\label{ex:def:dependent_subtype}
  We list examples of \hyperref[def:dependent_subtype]{subtypes}:
  \begin{thmenum}
    \thmitem{ex:def:dependent_subtype/trivial} For any type \( \tau \), the (dependent) \hyperref[def:dependent_empty_type]{empty type} induces the \hyperref[def:propositionally_uninhabited]{propositionally uninhabited} subtype \( \qsum {\synx^\tau} \syn\Bbbzero \).

    Indeed, by \cref{thm:empty_type_is_proposition}, \( \syn\Bbbzero \) is a mere proposition, so the condition \eqref{eq:def:dependent_subtype} for the definition of subtype is satisfied.

    Furthermore, the right projection \( \pi_R: \qprod {\syna^{\qsum {x^\tau} \syn\Bbbzero}} \syn\Bbbzero \) itself acts as a witness that the subtype \( \qsum {x^\tau} \syn\Bbbzero \) is (propositionally) uninhabited.

    \thmitem{ex:def:dependent_subtype/improper} Dually, for any type \( \tau \), the (dependent) \hyperref[def:dependent_unit_type]{unit type} induces the subtype \( \qsum {\synx^\tau} \syn\Bbbone \).

    The definition of subtype is satisfied because, due to \cref{thm:unit_type_is_proposition}, \( \syn\Bbbone \) is a mere proposition.

    Furthermore, \( \syn\Bbbone \) does not depend on \( \synx \) and it is always inhabited. Thus, the inclusion \( \iota \) is a surjective function --- for any term \( M \) of \( \tau \), \( \synS_+ M \synU_+ \) is a term of the subtype \( \qsum {\synx^\tau} \syn\Bbbone \).

    \thmitem{ex:def:dependent_subtype/unit} Consider the subtype \( \qsum {\synx^{\syn\Bbbone}} (\synx \syneq_{\syn\Bbbone} \synU_+) \) of the unit type \( \syn\Bbbone \).

    For simplicity, we can assume the \( K \) elimination rule \ref{inf:def:identity_type/k/elim}. By \cref{thm:uniqueness_of_identity_proofs}, that would imply that the identity type \( \synU_+ \syneq_{\syn\Bbbone} \synU_+ \) is \hyperref[def:contractible_type]{contractible} and, by \cref{thm:contractible_type_is_proposition}, a mere proposition.

    Then \ref{inf:def:dependent_unit_type/elim} can be used to conclude that \( \synx \syneq_{\syn\Bbbone} \synU_+ \) is a mere proposition for any \( \synx \), hence the condition \eqref{eq:def:dependent_subtype} for subtype is satisfied.
  \end{thmenum}
\end{example}

\begin{concept}\label{con:liskov_substitution_principle}
  In \cite[25]{Liskov1987DataAbstractionAndHierarchy}, in the context of object-oriented programming, Barbara Liskov formulates the following informal definition for \hyperref[def:dependent_subtype]{subtypes}:
  \begin{displayquote}
    A type hierarchy is composed of subtypes and supertypes. The intuitive idea of a \textit{subtype} is one whose objects provide all the behavior of objects of another type (the \textit{supertype}) plus something extra. What is wanted here is something like the following substitution property [6]: If for each object \( o_1 \) of type \( S \) there is an object \( o_2 \) of type \( T \) such that for all programs \( P \) defined in the terms of \( T \), the behavior of \( P \) is unchanged when \( o_1 \) is substituted for \( o_2 \), then \( S \) is a subtype of \( T \).
  \end{displayquote}

  The bibliography entry \( 6 \) refers to a PhD thesis that is not available to the general public.

  Anyhow, the first two sentences of the quote highlight how Liskov's notion of type is distinct from ours. Nevertheless, we can adapt the above as a property that is possibly satisfied by a subtype \( \qsum {x^\tau} \sigma \) of \( \tau \):
  \begin{displayquote}
    For every term \( M \) of \( \qsum {x^\tau} \sigma \) and for every type \( \qprod {y^{\tau + \qsum {x^\tau} \sigma}} \rho \) depending on either \( \tau \) or \( \qsum {x^\tau} \sigma \), if \( \rho M \) is inhabited, so is \( \rho (\iota M) \).
  \end{displayquote}

  We will refer to the view that this property must be satisfied as \term[en=(the) Liskov substitution principle (\cite*[1]{Martin1996LiskovSubstitutionPrinciple})]{Liskov's substitution principle}. This particular name was introduced by Robert Martin in \cite[1]{Martin1996LiskovSubstitutionPrinciple}, who rephrases Liskov's definition as a software engineering principle:
  \begin{displayquote}
    Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.
  \end{displayquote}

  We discuss the relationship between types and object-oriented classes in \cref{rem:types_and_classes}.
\end{concept}

\begin{remark}\label{rem:types_and_classes}
  In connection to \hyperref[con:liskov_substitution_principle]{Liskov's substitution principle}, it should be noted that the concept of class and subclass in object-oriented programming languages is quite different from our notion of type and subtype:
  \begin{itemize}
    \item A class is a self-contained specification of the internal state of an entity and its methods for interaction. It can be instantiated to create an object, which encapsulates its state data and can act via the methods of its class.

    A subclass extends its base class with additional state and methods, possibly overriding methods of the class. Every subclass instance can be used where an instance of its parent class is expected.

    A subclass is thus a refinement of its base class.

    \item A type (within the scope of this monograph) is simply a label. The rules for type inference are part of the ambient type system. A term of a given type is simply an immutable string of symbols that can be used for type derivation.

    A subtype is a specification for filtering the terms of a type. Via the inclusion, a term inhabiting a subtype is an unmodified term of its base type.

    A subtype is thus a restriction of its base type.
  \end{itemize}

  In \cite[25]{Liskov1987DataAbstractionAndHierarchy}, Liskov emphasizes that (her notion of) types and subtypes are distinct from classes and subclasses:
  \begin{displayquote}
    We are using the words \enquote{subtype} and \enquote{supertype} here to emphasize that now we are talking about a semantic distinction. By contrast, \enquote{subclass} and \enquote{superclass} are simply linguistic concepts in programming languages that allow programs to be built in a particular way. They can be used to implement subtypes, but also, as mentioned above, in other ways.
  \end{displayquote}

  She attempts to characterize subtypes by how they behave, irrespective of how they are defined in the language. Our notion of subtype is purely syntactic and, as discussed in \cref{con:liskov_substitution_principle}, is distinct from Liskov's. Nevertheless is it similar in that it is determined only by its properties.
\end{remark}

\paragraph{Polymorphic types}

\begin{definition}\label{def:polymorphic_typed_lambda_calculus}\mcite[def. 5.1.3]{Barendregt1992LambdaCalculiWithTypes}
  We will now extend \hyperref[con:simple_type_theory/arrow]{simply typed \( \muplambda \)-calculus} into a new \hyperref[def:abstract_type_system]{type system} called \term[en=polymorphic typed lambda calculus (\cite[164]{Barendregt1992LambdaCalculiWithTypes})]{polymorphic typed \( \muplambda \)-calculus}.

  The type syntax is based on the following \hyperref[con:variable_binding]{variable binder} extending the grammar of simple types from \cref{def:simple_type}:
  \begin{bnf*}
    \bnfprod{polymorphic type} {\bnftsq{\( \synforall \)} \bnfsp \bnfpn{type variable} \bnfsp \bnftsq{\( . \)} \bnfsp \bnfpn{type}}
  \end{bnf*}

  We also extend the grammar of typed \( \muplambda \)-terms from \cref{def:typed_lambda_term} with a corresponding binder:
  \begin{bnf*}
    \bnfprod{type abstraction} {\bnftsq{\( \syn\Lambda \)} \bnfsp \bnfpn{type variable} \bnfsp \bnftsq{\( . \)} \bnfsp \bnfpn{typed term}}
  \end{bnf*}

  We assume capture-avoiding substitution is extended to polymorphic types and type abstractions as per \cref{rem:variable_binding_properties}.

  We reuse the \hyperref[con:typing_rule]{typing rules} \ref{inf:def:arrow_type/elim} and \ref{inf:def:arrow_type/intro/explicit} for arrow types, and also introduce the following new rules:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \forall_+ }]{inf:def:polymorphic_lambda_calculus/polymorphic/intro}
        \begin{prooftree}
          \hypo{ M: \tau }
          \infer1[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/intro}]{ \qAbs \alpha M: \qpolytype \alpha \tau },
        \end{prooftree}
      \end{equation*}
      where \( \alpha \) is a type variable not free (in the type of) any open assumption.
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \forall_- }]{inf:def:polymorphic_lambda_calculus/polymorphic/elim}
        \begin{prooftree}
          \hypo{ M: \qpolytype \alpha \tau }
          \infer1[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/elim}]{ M\sigma: \tau[\alpha \mapsto \sigma] }.
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  Here \( \alpha \) is a type variable, while \( \tau \) and \( \sigma \) can be arbitrarily complex types. We simply use different section of the Greek alphabet for the two. We do not bother with more general disambiguation in the grammar of inference rules since we only present polymorphic types for demonstrating several examples. Furthermore, since we will not introduce schemas here, so it is safe to assume that dotted small Greek letter denote type variables (and not type placeholder schemas).

  Finally, we extend \hyperref[def:typed_term_reduction]{\( \beta \)-reduction} as follows:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\Lambda^\beta }]{inf:def:polymorphic_lambda_calculus/beta}
        \begin{prooftree}
          \infer0[\ref{inf:def:polymorphic_lambda_calculus/beta}]{ (\qAbs \alpha M) \sigma \bred M[\alpha \mapsto \sigma] }.
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \logic{Red}_\Lambda }]{inf:def:polymorphic_lambda_calculus/beta_compat}
        \begin{prooftree}
          \hypo{ M \pred N }
          \infer1[\ref{inf:def:polymorphic_lambda_calculus/beta_compat}]{ \qAbs \alpha M \pred \qAbs \alpha N }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}

  Here \( M[\alpha \mapsto \sigma] \) is the result of substituting \( \alpha \) for \( \sigma \) in all annotated variables in \( M \). Of course, the \hyperref[con:subject_reduction]{subject reduction} property holds on types via an adaptation of \fullref{alg:simply_typed_reduction}, so the \( \beta \)-redex provably inhabits \( \tau[\alpha \mapsto \sigma] \).
\end{definition}
\begin{comments}
  \item An obvious alternative would be to use \hyperref[def:mltt_pseudoterm]{Martin-L\"of type theory pseudoterms} for presenting this system. We will in fact do so in \cref{def:lambda_cube/term_on_type} when discussing Barendregt's \( \muplambda \)-cube.

  We wanted to demonstrate polymorphic types using their dedicated syntax, and in a standalone system that is not burdened by the complexity of dependent types. The rules are based on \tcite{#1's #2}[def. 5.1.3]{Barendregt1992LambdaCalculiWithTypes}, adapted to \hyperref[rem:natural_deduction_explicit_sequents]{implicit sequent style} as per \cref{rem:dependent_type_rule_sequents}.

  See also \cref{rem:polymorphic_type_origin} regarding earlier formalization of polymorphic types.

  \item We do not bother with type variable assumptions, and in particular provide no notion of discharging them. This is one difference compared to the dependent type theory adaptation, where every variable assumption is tracked, irrespective whether it applies to types or terms.

  This leaves the possibility of unbound type variables, which may or may not be desired behavior.
\end{comments}

\begin{remark}\label{rem:polymorphic_type_origin}
  When introducing \hyperref[def:polymorphic_typed_lambda_calculus]{second-order polymorphic \( \muplambda \)-calculus} \tcite{in #2, #1}[def. 5.1.3]{Barendregt1992LambdaCalculiWithTypes} attributes the idea to two independent formulations --- Jean-Yves Girard's \enquote{System F} from \cite{Girard1971SystèmeF} and John Reynolds' unnamed system from \cite{Reynolds1974TheoryOfTypeStructure}, published three years later.

  We use Barendregt's rules, as well as his notation --- \( \qAbs \alpha M \) for the term-level binder and \( \qpolytype \alpha \tau \) for the type-level binder (as per \cref{rem:object_language_dots}, we place dots over the binder's symbols to distinguish them from metalingual variables).

  Reynolds used the same term-level binder, but with \( \syn\Delta \) rather than \( \synforall \) as a type-level binder. His intention was to study semantics of polymorphic types.

  Girard introduced a much more complicated syntax, with two type-level binders --- \( \syn\delta \) and \( \syn\sigma \), mapping via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} to \hyperref[def:predicate_logic_alphabet/quantifiers/universal]{universal quantification} and \hyperref[def:predicate_logic_alphabet/quantifiers/existential]{existential quantification}, with rules resembling those we give for first-order logic in \cref{def:first_order_natural_deduction_system}. He called \enquote{system \( F \)} the restriction of the more general \enquote{system \( Y \)} to terms and types without \hyperref[con:variable_binding]{free variables}. His intention was to formulate an \hyperref[def:propositional_axiomatic_derivation_system]{axiomatic derivation system} based on system \( F \).

  \cite[ch. 11]{GirardEtAl1989ProofsAndTypes} features Girard's description of system \( F \) from \( 15 \) years later, with a much simplified syntax --- \( \qAbs \alpha M \) is used as the only term-level binder and \( \qprod \alpha \tau \) --- as the type-level binder.
\end{remark}

\begin{example}\label{ex:def:polymorphic_typed_lambda_calculus}
  We list some examples of derivations in \hyperref[def:polymorphic_typed_lambda_calculus]{polymorphic typed \( \muplambda \)-calculus}:
  \begin{thmenum}
    \thmitem{ex:def:polymorphic_typed_lambda_calculus/var} The simplest example is
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \syn\alpha }
        \infer1[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/intro}]{ \qAbs {\syn\alpha} \synx: \qpolytype {\syn\alpha} \syn\alpha }
      \end{prooftree}
    \end{equation*}

    Then, for any type \( \tau \),
    \begin{equation*}
      \begin{prooftree}
        \hypo{}
        \ellipsis {} { \qAbs {\syn\alpha} \synx: \qpolytype {\syn\alpha} \syn\alpha }

        \hypo{ \tau: \BbbT }

        \infer2[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/elim}]{ (\qAbs {\syn\alpha} \synx) \tau: \tau }.
      \end{prooftree}
    \end{equation*}

    This latter term \( \beta \)-reduces to \( \synx \) via \ref{inf:def:polymorphic_lambda_calculus/beta}.

    \thmitem{ex:def:polymorphic_typed_lambda_calculus/i} Consider the (untyped) \( \muplambda \)-term \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \).

    We showed in \cref{ex:def:type_derivation_tree/i} that, for any type \( \tau \), we have the derivation
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {\synx^\tau} \synx: \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    In particular, using the type variable \( \syn\alpha \), we can utilize polymorphic types:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \syn\alpha }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {\synx^{\syn\alpha}} \synx: \syn\alpha \synimplies \syn\alpha }
        \infer1[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/intro}]{ \qAbs {\syn\alpha} \qabs {\synx^{\syn\alpha}} \synx: \qpolytype {\syn\alpha} \syn\alpha \synimplies \syn\alpha }
      \end{prooftree}
    \end{equation*}

    We can use the eliminator \ref{inf:def:polymorphic_lambda_calculus/polymorphic/elim} to instantiate \( \syn\alpha \) with some term \( \tau \), and via \( \beta \)-reduction obtain \( \qabs {\synx^\tau} \synx \).

    \thmitem{ex:def:polymorphic_typed_lambda_calculus/k} Similarly, we can adapt \cref{ex:def:type_derivation_tree/k}, where we attempt to type the untyped combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \synx \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \syn\alpha }
        \infer1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {\syny^{\syn\beta}} \synx: \syn\beta \synimplies \syn\alpha }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {\synx^{\syn\alpha}} \qabs {\syny^{\syn\alpha}} \synx: \syn\alpha \synimplies \syn\beta \synimplies \syn\alpha }
        \infer1[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/intro}]{ \qAbs {\syn\beta} \qabs {\synx^{\syn\alpha}} \qabs {\syny^{\syn\alpha}} \synx: \qpolytype {\syn\beta} \syn\alpha \synimplies \syn\beta \synimplies \syn\alpha }
        \infer1[\ref{inf:def:polymorphic_lambda_calculus/polymorphic/intro}]{ \qAbs {\syn\alpha} \qAbs {\syn\beta} \qabs {\synx^{\syn\alpha}} \qabs {\syny^{\syn\alpha}} \synx: \qpolytype {\syn\alpha} \qpolytype {\syn\beta} \syn\alpha \synimplies \syn\beta \synimplies \syn\alpha }
      \end{prooftree}
    \end{equation*}
  \end{thmenum}
\end{example}

\paragraph{Pure type systems}

\begin{definition}\label{def:pure_type_system}\mcite[\S 5.2]{Barendregt1992LambdaCalculiWithTypes}
  A \term{pure type system} is a modular \hyperref[def:abstract_type_system]{type system} based on a restricted version of \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} featuring only \hyperref[def:dependent_product]{dependent products}, without even the judgmental equality rules from \cref{rem:type_theory_rule_classification/equality}.

  A particular pure type system is determined by a \hyperref[con:logical_system_signature]{signature} consisting of the following\fnote{We usually require \hyperref[con:logical_system_signature]{signatures} to only have finitely many symbols. Here, we have not required the sets of sorts or axioms to be finite since we simply follow Barendregt's definition.}:
  \begin{thmenum}
    \thmitem{def:pure_type_system/signature/const} A nonempty set of symbols, which we will call \term{sorts}. These will act as \hyperref[con:type_universe]{type universes}.

    \thmitem{def:pure_type_system/signature/axioms} A possibly empty set of \hyperref[def:type_assertion]{type assertions} of the form \( c: S \), where \( c \) is a constant and \( S \) is a sort. We will call these assertions \term{axioms}.

    These induce the typing rule:
    \begin{equation*}\taglabel[\logic{Ax}]{inf:def:pure_type_system/axiom}
      \begin{prooftree}
        \infer0[\ref{inf:def:pure_type_system/axiom}]{ c: S }
      \end{prooftree}
    \end{equation*}

    Here \( c: S \) ranges over axioms. Unlike in \cref{def:hol_signature/nl_type}, where we want to use \hyperref[def:simple_typing_rule]{simple typing rules} and thus have a distinct rule for each assertion, here we gather all assertions into a single rule.

    \thmitem{def:pure_type_system/signature/rules} A possibly empty set of triples of sorts, which we will call \term{rule specifications} because they determine the product formation rule.

    Namely, we have the rule
    \begin{equation*}\taglabel[\ensuremath{ \Pi_{\logic{form}}^{\logic{PTS}} }]{inf:def:pure_type_system/product_form}
      \begin{prooftree}
        \hypo{ \tau: S_1 }

        \hypo{ x: \tau }
        \infer[dashed]1{ \sigma: S_2 }

        \infer2[\ref{inf:def:pure_type_system/product_form}]{ \qprod {x^\tau} \sigma: S_3 }
      \end{prooftree}
    \end{equation*}
    where \( (S_1, S_2, S_3) \) ranges over rule specification. This rule is a restriction of \ref{inf:def:dependent_product/form}.

    For brevity, we will allow pairs in rule specification, where \( (S_1, S_2) \) corresponds to \( (S_1, S_2, S_2) \).
  \end{thmenum}

  We will reuse the dependent product rules \ref{inf:def:dependent_product/intro} and \ref{inf:def:dependent_product/elim}.

  Pure type systems lack equality rules, and in particular computation rules, however they feature the following \hyperref[def:beta_eta_reduction]{\( \beta \)-equivalence} compatibility rule for typing:
  \begin{equation*}\taglabel[\ensuremath{ \logic{Conv} }]{inf:def:pure_type_system/beta}
    \begin{prooftree}
      \hypo{ M: \tau }
      \hypo{ \sigma: S }
      \hypo{ \tau \equivrel{\beta} \sigma }
      \infer3[\ref{inf:def:pure_type_system/beta}]{ M: \sigma },
    \end{prooftree}
  \end{equation*}
  where \( S \) ranges over sorts. We show how this rule can be useful in \cref{ex:def:lambda_cube/conversion}.

  As in Martin-L\"of type theory, we label as well-formed the types, type contexts and derivation trees as per the procedure described in \cref{def:mltt_well_formed_context}.
\end{definition}
\begin{comments}
  \item We have adapted the rules from \cite[\S 5.2]{Barendregt1992LambdaCalculiWithTypes} to \hyperref[rem:natural_deduction_explicit_sequents]{implicit sequent style} as per \cref{rem:dependent_type_rule_sequents}.

  \item We implicitly assume that, via a rule analogous to \ref{inf:def:lambda_term_reduction/abs} and \ref{inf:def:polymorphic_lambda_calculus/beta_compat}, \( \beta \)-reduction is compatible with the variable binder \( \synprod \). We do not postulate a rule for reducing \( (\qprod {x^\tau} \sigma) \rho \) to \( \sigma[x \mapsto \rho] \) because that is handled implicitly in \ref{inf:def:dependent_product/elim}.

  \item As defined here, sorts are unrelated to sorts in \hyperref[def:higher_order_logic]{higher order logic}, which instead act analogously to base types in \hyperref[def:simple_type_system]{simple type theories}.
\end{comments}

\begin{definition}\label{def:lambda_cube}\mcite[sec. 5.2]{Barendregt1992LambdaCalculiWithTypes}
   As discussed in \cref{rem:well_formed_context}, well-formed \hyperref[con:pseudoterm_expression]{pseudoterms} can be divided into terms and types, which can nevertheless depend on each other as per \cref{rem:mltt_pseudoterm_dependency}. These dependencies allow for a range of possibilities. \incite[ch. 5]{Barendregt1992LambdaCalculiWithTypes} arranges eight of them into a schematic cube, which he calls the \term{\( \muplambda \)-cube}.

  He presents them in a unified way as \hyperref[def:pure_type_system]{pure type systems} over two sorts --- the sort \( \ast \) of types, and the sort \( \Box \) of \hyperref[con:type_universe]{kinds}, with the axiom \( \ast: \Box \).

  \begin{figure}[!ht]
    \centering
    \includegraphics[page=1]{output/def__lambda_cube}
    \caption{Barendregt's \hyperref[def:lambda_cube]{\( \muplambda \)-cube}.}\label{fig:def:lambda_cube}
  \end{figure}

  \begin{thmenum}
    \thmitem{def:lambda_cube/term_on_term} A term can depend on another term. Such a system must include the rule specified by \( (\ast, \ast) \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \tau: \ast }

        \hypo{ x: \tau }
        \infer[dashed]1{ \sigma: \ast }

        \infer2[\ensuremath{ \Pi_{\logic{form}} }]{ \qprod {x^\tau} \sigma: \ast }
      \end{prooftree}
    \end{equation*}

    General pure type systems allow \( \sigma \) to depend on \( x \), but in the absence of other rule specifications there is simply no way to construct such a dependency. Since, as discussed in \cref{rem:arrow_type_via_dependent_product}, arrow types as special cases of dependent products, this reduces type formation to the familiar rule \ref{inf:def:arrow_type/intro/explicit}, and, modulo technicalities, reduces the entire system to \hyperref[con:simple_type_theory/arrow]{simply typed \( \muplambda \)-calculus}.

    \incite[def. 5.1.1]{Barendregt1992LambdaCalculiWithTypes} denotes this system by \( \muplambda_{\rightarrow} \). This is the weakest system of the \( \muplambda \)-cube, upon which all others are built.

    \thmitem{def:lambda_cube/term_on_type} A term can depend on a type. Such a system must, in addition to \( (\ast, \ast) \), also include the rule specified by \( (\Box, \ast) \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ k: \Box }

        \hypo{ \alpha: k }
        \infer[dashed]1{ \sigma: \ast }

        \infer2[\ensuremath{ \Pi_{\logic{form}} }]{ \qprod {\alpha^k} \sigma: \ast }.
      \end{prooftree}
    \end{equation*}

    Only the axiom \( \ast: \Box \) allows producing a kind, hence we can simplify this rule. Using the alternative notation \( \syn\Lambda \alpha \) for \( \synlambda {\alpha^\ast} \) and \( \synforall \alpha \) for \( \synprod {\alpha^\ast} \), the rule reduces to
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \alpha: \ast }
        \infer[dashed]1{ \sigma: \ast }

        \infer1[\ensuremath{ \Pi_{\logic{form}} }]{ \qpolytype \alpha \sigma: \ast },
      \end{prooftree}
    \end{equation*}
    while \ref{inf:def:dependent_product/intro} and \ref{inf:def:dependent_product/elim} become \ref{inf:def:polymorphic_lambda_calculus/polymorphic/intro} (with discharging) and \ref{inf:def:polymorphic_lambda_calculus/polymorphic/elim}.

    Therefore, modulo technicalities, the obtained system reduces to \hyperref[def:polymorphic_typed_lambda_calculus]{polymorphic typed \( \muplambda \)-calculus}. We thus refer to adding \( (\Box, \ast) \) to an existing system as \enquote{adding polymorphic types}.

    \incite[def. 5.1.3]{Barendregt1992LambdaCalculiWithTypes} denotes this system by \( \muplambda 2 \) and places it next to \( \muplambda_{\rightarrow} \) in the \( \muplambda \)-cube. All three (oriented) edges of the cube parallel to this one also endow the corresponding pure type systems with \( (\Box, \ast) \).

    \thmitem{def:lambda_cube/type_on_term} A type can depend on a term. This requires the rule specification \( (\ast, \Box) \) in addition to \( (\ast, \ast) \).

    The new type formation rule enables dependent types in the sense of \cref{con:dependent_type}, and we refer to adding \( (\Box, \ast) \) to an existing system as \enquote{adding dependent types}.

    It should be noted that this rule is incompatible with the familiar dependent product formation rule \ref{inf:def:dependent_product/form} from \hyperref[def:martin_lof_type_theory]{Martin-L\"of type theory} because the type universe is instead stratified into types and kinds.

    \incite*[def. 5.1.8]{Barendregt1992LambdaCalculiWithTypes} denotes this system by \( \muplambda P \) and places it next to \( \muplambda_{\rightarrow} \) in the \( \muplambda \)-cube.

    \thmitem{def:lambda_cube/type_on_type} Finally, a type can depend on another type. This requires the rule specification \( (\Box, \Box) \) in addition to \( (\ast, \ast) \), which enables type constructors in the sense of \cref{con:type_constructor}.

    \incite*[def. 5.1.4]{Barendregt1992LambdaCalculiWithTypes} denotes this system by \( \muplambda \underline \omega \) and places it in the final corner next to \( \muplambda_{\rightarrow} \) in the \( \muplambda \)-cube.

    \thmitem{def:lambda_cube/combinations} When combining the above dependencies in various forms, we obtain the other corners of the \( \muplambda \)-cube. For example, there are two ways to obtain \( \muplambda \omega \) from \( \muplambda_{\rightarrow} \):
    \begin{itemize}
      \item By adding type constructors to \( \muplambda_{\rightarrow} \) to obtain \( \muplambda \underline \omega \) and, after that, adding polymorphic types.

      \item By adding polymorphic types to \( \muplambda_{\rightarrow} \) to obtain \( \muplambda 2 \) and, after that, adding type constructors.
    \end{itemize}

    On the opposing corner of simply typed \( \muplambda \)-calculus, Barendregt puts the system \( \muplambda P \omega \) featuring all four aforementioned rules. There are six ways to obtain it from \( \muplambda_{\rightarrow} \).

    Barendregt also denotes this system by \( \muplambda C \) because it roughly corresponds to the \term[en=calculus of constructions (\cite{CoquandHuet1986CoC})]{calculus of constructions} presented originally by \incite{CoquandHuet1986CoC}.
  \end{thmenum}
\end{definition}

\begin{example}\label{ex:def:lambda_cube}
  We list some examples related to the \hyperref[def:pure_type_system]{pure type systems} of the \hyperref[def:lambda_cube]{\( \muplambda \)-cube}:
  \begin{thmenum}
    \thmitem{ex:def:lambda_cube/conversion} In the calculus of constructions, consider the type assumptions \( \syn\tau: {\ast} \) and \( \synf: \syn\tau \synimplies {\ast} \). Roughly, \( \syn\tau \) denotes a type, while \( \synf \) denotes a function from \( \syn\tau \) to types.

    First, note that the type \( \syn\tau \synimplies {\ast} \) is well-formed in the context \( \syn\tau: \ast \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \syn\tau: \ast }
        \infer0[\ref{inf:def:pure_type_system/axiom}]{ \ast: \Box }
        \infer2[\ref{inf:def:pure_type_system/product_form}]{ \syn\tau \synimplies {\ast}: \Box }
      \end{prooftree}
    \end{equation*}

    In the extended context
    \begin{equation*}
      \syn\tau: \ast, \syn\tau \synimplies {\ast}: \Box, \synf: \syn\tau \synimplies {\ast}, \synt: \syn\tau
    \end{equation*}
    we can thus perform the type derivation
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \syn\tau \synimplies {\ast} }
        \hypo{ \synt: \syn\tau }
        \infer2[\ref{inf:def:dependent_product/elim}]{ \synf \synt: {\ast} }.
      \end{prooftree}
    \end{equation*}

    This shows that \( \synf \synt \) is a well-formed type, and thus can be used to introduce new variables to the context.

    In the same context, we can perform \( \eta \)-expansion:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \syn\tau \synimplies {\ast} }
        \hypo{ \synx: \syn\tau }
        \infer2[\ref{inf:def:dependent_product/elim}]{ \synf \synx: {\ast} }
        \infer[left label=\( x \)]1[\ref{inf:def:dependent_product/intro}]{ (\qabs {\synx^{\syn\tau}} \synf \synx): \syn\tau \synimplies {\ast} }

        \hypo{ \synt: \syn\tau }

        \infer2[\ref{inf:def:dependent_product/elim}]{ (\qabs {\synx^{\syn\tau}} \synf \synx) \synt: {\ast} }
      \end{prooftree}
    \end{equation*}

    Then, finally, given any term \( M \) inhabiting \( \synf \synt \), we can use \ref{inf:def:pure_type_system/beta} to conclude that it also inhabits \( (\qabs {\synx^{\syn\tau}} \synf \synx) \synt \).
  \end{thmenum}
\end{example}
