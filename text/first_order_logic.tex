\section{First-order logic}\label{sec:first_order_logic}

First-order logic is a particularly convenient form of \hyperref[con:predicate_logic]{predicate logic}.

We give here the following definition, and then dedicate several sections to explaining it:
\begin{definition}\label{def:first_order_logic}\mimprovised
\end{definition}
\begin{comments}
  \item First-order logic can be regarded as a special case of \hyperref[def:higher_order_logic]{higher-order logic}. See \cref{ex:def:bounded_hol/first}.
\end{comments}

\paragraph{First-order signatures}

\begin{definition}\label{def:predicate_logic_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} of \hyperref[con:predicate_logic]{predicate logic} extends the \hyperref[def:propositional_alphabet]{alphabet of propositional logic} with the following new symbols:
  \begin{thmenum}
    \thmitem{def:predicate_logic_alphabet/quantifiers}\mcite[80]{Kleene2002Logic} The set \( \op*{Quant} \) of \term[ru=кванторы (\cite[72]{ШеньВерещагин2017ЯзыкиИИсчисления})]{quantifiers}, namely
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/quantifiers/universal} The \term[ru=квантор общости (\cite[61]{Эдельман1975Логика})]{universal quantifier} \enquote{\( \synforall \)}.
      \thmitem{def:predicate_logic_alphabet/quantifiers/existential}\mcite[80]{Kleene2002Logic} The \term[ru=квантор существования (\cite[61]{Эдельман1975Логика})]{existential quantifier} \enquote{\( \synexists \)}.
    \end{thmenum}

    \thmitem{def:predicate_logic_alphabet/equality}\mcite[def. 2.1.2(vi)]{Hinman2005Logic} The \hyperref[def:function_application_syntax]{infix} \term{equality symbol} \enquote{\( \syneq \)}

    \thmitem{def:predicate_logic_alphabet/comma} In addition to the parentheses, two more auxiliary symbols:
    \begin{thmenum}
      \thmitem{def:lambda_term_alphabet/aux/comma} The comma \enquote{\( , \)} for delimiting \hyperref[con:function_arguments]{function arguments}.

      \thmitem{def:lambda_term_alphabet/aux/dot} The dot \enquote{\( . \)} for separating quantifiers from their bodies.
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This alphabet is intended for first-order logic, but will also be reused for higher-order logic in \fullref{sec:higher_order_logic}.

  \item As discussed in \cref{rem:quantifier_notation}, the dot has no functional role and is only used as visual aid for complicated formulas.
\end{comments}

\begin{definition}\label{def:fol_signature}\mcite[282]{Meseguer1989GeneralLogics}
  A \hyperref[con:logical_system_signature]{signature} \( \Sigma \) for first-order logic consists of the following:
  \begin{thmenum}
    \thmitem{def:fol_signature/fun} A possibly empty \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Fun}_\Sigma \), whose elements we call \term{function symbols}.

    \thmitem{def:fol_signature/pred} A possibly empty alphabet \( \op*{Pred}_\Sigma \), whose elements we call \term{relation symbols}.

    \thmitem{def:fol_signature/arity}\mcite[38]{CitkinMuravitsky2022ConsequenceRelations} A function \( {\#}: \op*{Fun} \cup \op*{Pred} \to \BbbZ_{\geq 0} \) determining the corresponding symbol's \term{arity}.

    Based on this arity, we will use the prefixes from \cref{def:operation_arity_terminology} like \enquote{unary}, \enquote{binary}, etc.
  \end{thmenum}

  As per \cref{rem:improper_symbols_and_parsing}, we disallow the \hyperref[con:improper_symbol]{improper symbols} from the \hyperref[def:predicate_logic_alphabet]{alphabet of predicate logic} as function or predicate symbols.
\end{definition}
\begin{comments}
  \item We discuss in \cref{rem:language_alphabet_cardinality} some cardinality considerations; we mention here only that both alphabets are by default assumed to be finite. In general, we use adjectives like \enquote{finite} and \enquote{countably infinite} for the signature itself as per \cref{rem:cardinality_auxiliary_terminology}.

  \item When specifying a signature, we will be explicit about whether we want to use \hyperref[def:function_application_syntax]{infix notation} for binary function or predicate symbols. We do not include this choice as part of the signature since it only affects the \hyperref[con:metalogic]{metalanguage} --- see \cref{rem:first_order_formula_conventions/infix}.
\end{comments}

\begin{definition}\label{def:fol_signature_category}\mcite[282]{Meseguer1989GeneralLogics}
  For a fixed \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \), assumed by default to be the universe \hyperref[def:universe_of_hereditary_finite_sets]{\( V_\omega \)} of hereditarily finite sets, we define the \hyperref[def:category]{category} \( \ucat{Sign} \) of \( \mscrU \)-small \hyperref[def:fol_signature]{first-order signatures} as follows:
  \begin{thmenum}
    \thmitem{def:fol_signature_category/objects} The objects are, unsurprisingly, the \( \mscrU \)-small signatures.

    \thmitem{def:fol_signature_category/morphism} A morphism \( s: \Sigma \to \Theta \) between signatures is a set-theoretic function mapping the function symbols of \( \Sigma \) to function symbols of \( \Theta \) with the same arity, and analogously for predicate symbols.

    \thmitem{def:fol_signature_category/morphism} The composition of morphisms is their set-theoretic composition.

    \thmitem{def:fol_signature_category/identity} The identity on \( \Sigma \) is simply the set-theoretic identity.
  \end{thmenum}
\end{definition}

\paragraph{First-order terms}

\begin{definition}\label{def:fol_term}\mimprovised
  For a fixed \hyperref[def:fol_signature]{signature} \( \Sigma \) of \hyperref[def:first_order_logic]{first-order logic}, we reuse the function application grammar from \cref{def:function_application_syntax} to formally introduce \hyperref[con:predicate_logic/predicate]{terms}:
  \begin{bnf*}
    \bnfprod{function application} {\underbrace{f \bnfsp \bnftsq{(} \bnfsp \overbrace{\bnfpn{term} \bnfsp \bnftsq{,} \bnfsp \bnfsk \bnfsp \bnftsq{,} \bnfsp \bnfpn{term}}^{\# f \T*{terms separated by commas}} \bnfsp \bnftsq{)}}_{\T*{Standalone rule for each} f \in \op*{Fun}_\Sigma}} \\
    \bnfprod{individual variable}  {\bnfpn{Small Latin identifier}} \\
    \bnfprod{term}                 {\bnfpn{individual variable} \bnfor \bnfpn{function application}}
  \end{bnf*}

  \begin{itemize}
    \item As in \cref{def:function_application_syntax}, when \( \# f = 0 \), we avoid writing parentheses in function application rules.
    \item We have used the variable identifier rules from \cref{def:variable_identifier}.
  \end{itemize}

  Similarly to the case of \( \muplambda \)-terms in \cref{def:propositional_subformula}, we will denote the set of all \term[ru=индивидные переменные / предметные переменные (\cite[49]{КолмогоровДрагалин2006Логика}), en=individual variables (\cite[57]{VanDalen2004LogicAndStructure})]{individuals variables} by \( \op*{Var} \) and the set of all \term{first-order terms} over \( \Sigma \) by \( \op*{Term}_\Sigma \).
\end{definition}
\begin{comments}
  \item A general discussion of terms and variables in predicate logic can be found in \cref{con:predicate_logic}.

  \item Within the metalanguage, we will denote abstract terms via \( \tau \), \( \sigma \), \( \rho \) and other letters in accordance with \cref{rem:mathematical_logic_conventions/greek_alphabet}. This convention will later lead us to a formal definition of formula schemas in \cref{def:fol_formula_schema}.

  \item We implicitly associate with each propositional formula an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} --- see \cref{def:fol_term_ast}. The grammar of first-order terms is unambiguous as shown via \cref{thm:fol_term_grammar/unambiguous}, which makes it possible to perform proofs via \fullref{thm:induction_on_rooted_trees}.

  \item First-order terms are implemented in \identifier{math.logic.terms}, with a parser in \identifier{math.logic.parsing}.
\end{comments}

\begin{proposition}\label{thm:fol_term_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:fol_term]{first-order terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:fol_term_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:fol_term_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:fol_term_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  The proof is similar to \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{definition}\label{def:fol_subterm}\mimprovised
  We define the set of all \term{subterms} of a \hyperref[def:fol_term]{first-order term} \( \tau \) as follows:
  \begin{equation*}
    \op*{Subterm}(\tau) \coloneqq \begin{cases}
      \set{ \tau },                                            &\tau \in \op*{Var}, \\
      \set{ \tau } \cup \bigcup_{k=1}^n \op*{Subterm}(\rho_k), &\tau = f(\rho_1, \ldots, \rho_n).
    \end{cases}
  \end{equation*}

  We denote by \( \op*{Var}(\tau) \) those subterms of \( \tau \) that are variables.
\end{definition}

\begin{proposition}\label{thm:propositional_formula_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \rho \) of the first-order term \( \tau \) is a \hyperref[def:fol_subterm]{subterm} of \( \tau \) if and only if \( \rho \) is itself a formula.
\end{proposition}
\begin{proof}
  We can adapt the proof of \cref{thm:propositional_formula_characterization}. There are no variable binders, so we are safe from the \( \muplambda \)-term nuances in \cref{thm:lambda_subterm_characterization}.
\end{proof}

\begin{definition}\label{def:fol_term_ast}\mimprovised
  We implicitly associate with each first-order term \( \tau \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\tau) \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_term_ast/variable} If \( \tau \) is a variable, we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:fol_term_ast/application} If \( \tau = f(\rho_1, \ldots, \rho_n) \), assuming we have built \( T(\rho_k) \) for \( k = 1, \ldots, n \), we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( f \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__fol_term_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:closed_fol_term}\mcite[def. 2.3.8]{VanDalen2004LogicAndStructure}
  We say that a \hyperref[def:fol_term]{first-order term} is \term[ru=замкнутый терм (\cite[62]{КолмогоровДрагалин2006Логика})]{closed} if it has no variables.
\end{definition}
\begin{comments}
  \item Closed terms are also called \enquote{ground terms}, for example by \incite[def. 3.1.5]{BaaderNipkow2012TermRewriting}.
\end{comments}

\begin{algorithm}[Signature translation of first-order terms]\label{alg:fol_term_signature_translation}
  Given a \hyperref[def:fol_signature_category/morphism]{signature morphism} \( s: \Sigma \to \Theta \), we can easily translate any \hyperref[def:fol_term]{first-order term} from \( \op*{Term}_\Sigma \) to \( \op*{Term}_\Theta \):
  \begin{equation*}
    \tau[s] \coloneqq \begin{cases}
      \tau,                                              &\tau \in \op*{Var}, \\
      s(f)\parens[\big]{ \rho_1[s], \ldots, \rho_n[s] }, &\tau = f(\rho_1, \ldots, \rho_n).
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.signature_translation.translate_term} in \cite{notebook:code}.
\end{comments}

\paragraph{First-order formulas}

\begin{definition}\label{def:fol_formula}\mimprovised
  For a fixed \hyperref[def:fol_signature]{signature} \( \Sigma \) of \hyperref[def:first_order_logic]{first-order logic}, we introduce a \hyperref[def:formal_grammar]{formal grammar} for \hyperref[con:proposition]{formulas}:
  \begin{bnf*}
    \bnfprod{predicate application} {\underbrace{p \bnfsp \bnftsq{(} \bnfsp \overbrace{\bnfpn{term} \bnfsp \bnftsq{,} \bnfsp \bnfsk \bnfsp \bnftsq{,} \bnfsp \bnfpn{term}}^{\# p \T*{terms separated by commas}} \bnfsp \bnftsq{)}}_{\T*{Standalone rule for each} p \in \op*{Pred}_\Sigma}} \\
    \bnfprod{equality formula}       {\bnftsq{(} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( \syneq \)} \bnfsp \bnfpn{term} \bnfsp \bnftsq{)}} \\
    \bnfprod{quantifier formula}     {\bnfpn{quantifier} \bnfsp \bnfpn{individual variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{formula}} \\
    \bnfprod{atomic formula}         {\bnfpn{constant formula} \bnfor} \\
    \bnfmore                         {\bnfpn{equality formula} \bnfor} \\
    \bnfmore                         {\bnfpn{predicate application} \bnfor} \\
    \bnfprod{formula}                {\bnfpn{atomic formula} \bnfor} \\
    \bnfmore                         {\bnfpn{negation formula} \bnfor} \\
    \bnfmore                         {\bnfpn{connective formula} \bnfor} \\
    \bnfmore                         {\bnfpn{quantifier formula}}
  \end{bnf*}

  \begin{itemize}
    \item The \( \bnfpn{individual variable} \) and \( \bnfpn{term} \) rules are taken from \cref{def:fol_term}.

    \item The \( \bnfpn{negation formula} \) and \( \bnfpn{connective formula} \) rules are exactly as in for propositional formulas in \cref{def:propositional_formula}, so we have avoided stating them explicitly.

    \item The \( \bnfpn{predicate application} \) rules are based on the function application syntax from \cref{def:function_application_syntax} (without parentheses when \( \# p = 0 \)).

    \item The \( \bnfpn{quantifier} \) rule lists the corresponding symbols from the alphabet.
  \end{itemize}

  Similarly to the case of propositional formulas in \cref{def:propositional_subformula}, we denote by \( \op*{Form}_\Sigma \) the set of all \term[en=first-order formulas (\cite[23]{CitkinMuravitsky2022ConsequenceRelations})]{first-order formulas} over \( \Sigma \), and by \( \op*{Atom}_\Sigma \) those that are \term[ru=атомарные (формулы) (\cite[56]{КолмогоровДрагалин2006Логика}), en=atomic (formulas) (\cite[def. 2.1.8]{Hinman2005Logic})]{atomic}.
\end{definition}
\begin{comments}
  \item Within the metalanguage, we will denote abstract formulas via \( \varphi \), \( \psi \), \( \theta \) and other letters in accordance with \cref{rem:mathematical_logic_conventions/greek_alphabet}. This convention will later lead us to a formal definition of formula schemas in \cref{def:fol_formula_schema}.

  \item First-order formulas are implemented in \identifier{math.logic.formulas}, with a parser in \identifier{math.logic.parsing}.
\end{comments}

\begin{proposition}\label{thm:fol_formula_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:fol_formula]{first-order terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:fol_formula_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:fol_formula_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:fol_formula_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  The proof is more complicated, but similar to \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{definition}\label{def:fol_subformula}\mimprovised
  Analogously to how we handled propositional subformulas in \cref{def:propositional_subformula}, we define the set of all \term{subformulas} of a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as follows:
  \begin{equation*}
    \op*{Subform}(\varphi) \coloneqq \begin{cases}
      \set{ \varphi },                                                        &\varphi \in \op*{Atom}, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \synneg \psi, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi) \cup \op*{Subform}(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}

  The only difference is the presence of the quantifier case.
\end{definition}

\begin{proposition}\label{thm:fol_formula_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \psi \) of the first-order term \( \varphi \) is a \hyperref[def:fol_subformula]{subformula} of \( \varphi \) if and only if \( \psi \) is itself a formula.
\end{proposition}
\begin{proof}
  Like in the case of \( \muplambda \)-terms in \cref{thm:lambda_subterm_characterization}, there are variable binders, but unlike in that case, the variables themselves are not considered formulas. So, there are no nuances to handle, and we can proceed as in the propositional case in \cref{thm:propositional_formula_characterization}.
\end{proof}

\begin{definition}\label{def:fol_formula_ast}\mimprovised
  We implicitly associate with each first-order formula \( \varphi \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\varphi) \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_formula_ast/const} If \( \varphi \) is a logical constant, i.e. \( \syntop \) or \( \synbot \), we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:fol_formula_ast/equality} If \( \varphi = \tau \syneq \sigma \), assuming we have built \( T(\tau) \) and \( T(\sigma) \) in accordance with \cref{def:fol_formula_ast}, we define \( T(\varphi) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( \syneq \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/application} If \( \varphi = p(\tau_1, \ldots, \tau_n) \), assuming we have built \( T(\tau_k) \) for \( k = 1, \ldots, n \) in accordance with \cref{def:fol_formula_ast}, we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( p \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/negation} Analogously to the propositional negation trees from \cref{def:propositional_formula_ast/negation}, if \( \varphi = \synneg \psi \), assuming we have already built \( T(\psi) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) to a new root labeled with \( \synneg \):
    \begin{equation*}
      \includegraphics[page=3]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/connective} Analogously to the propositional connective formula trees from \cref{def:propositional_formula_ast/connective}, if \( \varphi = \psi \syncirc \theta \), assuming we have built \( T(\psi) \) and \( T(\theta) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) and \( T(\theta) \) to a new root labeled with \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=4]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/quantifier} Analogously to the untyped \( \muplambda \)-abstraction trees from \cref{def:lambda_term_ast/abstraction}, if \( \varphi = \quantifier Q x \psi \), where \( Q \) is a quantifier, assuming we have built \( T(\psi) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) to a new root labeled with \( Q x \):
    \begin{equation*}
      \includegraphics[page=5]{output/def__fol_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{algorithm}[Signature translation of first-order formulas]\label{alg:fol_formula_signature_translation}
  Given a \hyperref[def:fol_signature_category/morphism]{signature morphism} \( s: \Sigma \to \Theta \), we can translate any \hyperref[def:fol_formula]{first-order formula} from \( \op*{Form}_\Sigma \) to \( \op*{Form}_\Theta \) with the aid of \fullref{alg:fol_term_signature_translation}:
  \begin{equation*}
    \varphi[s] \coloneqq \begin{cases}
      \varphi,                                                                 &\varphi = \syntop \T{or} \varphi = \synbot, \\
      \tau[s] \syneq \sigma[s],                                                &\varphi = \tau \syneq \sigma, \\
      s(p)\parens[\big]{ \tau_1[s], \ldots, \tau_n[s]) },                      &\varphi = p(\tau_1, \ldots, \tau_n), \\
      \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.signature_translation.translate_formula} in \cite{notebook:code}.
\end{comments}

\paragraph{Variable binding}

\begin{definition}\label{def:fol_variable_occurrence}\mimprovised
  Similarly to variable occurrences of \( \muplambda \)-terms defined in \cref{def:lambda_variable_occurrence}, we define an \term[ru=вхождение (\cite[64]{Герасимов2011Вычислимость}), en=occurrence (\cite[63]{VanDalen2004LogicAndStructure})]{occurrence} of an individual variable \( x \) in a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as a variable node with label \( x \) in the \hyperref[def:fol_formula_ast]{abstract syntax tree} of \( \varphi \).

  We analogously call a variable occurrence of \( x \) \term[ru=свободное (вхождение) (\cite[64]{Герасимов2011Вычислимость}), en=free occurrence (\cite[def. 9.1.2]{CitkinMuravitsky2022ConsequenceRelations})]{free} in \( \varphi \) if the root of the AST can be reached without passing through a quantifier. If an occurrence is not free, we say that it is \term[ru=связоное (вхождение) (\cite[64]{Герасимов2011Вычислимость}), en=bound occurrence (\cite[def. 9.1.2]{CitkinMuravitsky2022ConsequenceRelations})]{bound}.
\end{definition}

\begin{definition}\label{def:fol_variable_freeness}\mcite[64]{Герасимов2011Вычислимость}
  In analogy with how we handled variable freeness in \( \muplambda \)-terms defined in \cref{def:lambda_variable_freeness}, we say that a variable \( x \) is \term[ru=свободная (переменная), en=free (variable) (\cite[63]{VanDalen2004LogicAndStructure})]{free} in a first-order formula \( \varphi \) if \( x \) has at least one \hyperref[def:fol_variable_occurrence]{free occurrence} in \( \varphi \) and \term[ru=связанная (переменная), en=bound (variable) (\cite[63]{VanDalen2004LogicAndStructure})]{bound} if it has a \hyperref[def:lambda_variable_occurrence]{bound occurrence} in \( M \).
\end{definition}
\begin{comments}
  \item We may use the recursive definitions from \cref{thm:fol_variable_freeness_characterization} instead.
\end{comments}

\begin{proposition}\label{thm:fol_variable_freeness_characterization}
  The set of all \hyperref[def:fol_variable_freeness]{free variables} of a first-order formula can be characterized as follows:
  \begin{equation*}
    \op*{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                &\varphi = \syntop \T{or} \varphi = \synbot, \\
      \op*{Var}(\tau) \cup \op*{Var}(\sigma),     &\varphi = \tau \syneq \sigma, \\
      \bigcup_{k=1}^n \op*{Var}(\tau_k),          &\varphi = p(\tau_1, \ldots, \tau_n), \\
      \op*{Free}(\psi),                           &\varphi = \synneg \psi, \\
      \op*{Free}(\psi) \cup \op*{Free}(\theta),   &\varphi = \synneg \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \op*{Free}(\psi) \setminus \set{ x },       &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}

  Similarly, the bound variables can be characterized via
  \begin{equation*}
    \op*{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                &\varphi \in \op*{Atom}, \\
      \op*{Bound}(\psi),                          &\varphi = \synneg \psi, \\
      \op*{Bound}(\psi) \cup \op*{Bound}(\theta), &\varphi = \synneg \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \op*{Bound}(\psi) \cup \set{ x },           &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item We show an analogous result for \( \muplambda \)-terms in \cref{thm:lambda_variable_freeness_characterization}.
\end{comments}
\begin{proof}
  Straightforward.
\end{proof}

\begin{definition}\label{def:closed_fol_formula}\mcite[def. 2.3.8]{VanDalen2004LogicAndStructure}
  We say that a \hyperref[def:fol_formula]{first-order formula} is \term[ru=замкнутая формула (\cite[61]{КолмогоровДрагалин2006Логика})]{closed} if it has no \hyperref[def:fol_variable_freeness]{free variables}. Closed formulas are also called \term[ru=предложения (\cite[61]{КолмогоровДрагалин2006Логика})]{sentences}.
\end{definition}
\begin{comments}
  \item In fact, \enquote{sentence} is a more general word used in many definitions in \cref{sec:abstract_logics}. We explicitly disallow non-closed formulas as sentences for the reasons outlined in \cref{ex:universal_validity_and_lem}.
\end{comments}
