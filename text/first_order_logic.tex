\section{First-order logic}\label{sec:first_order_logic}

First-order logic is a particularly convenient form of \hyperref[con:predicate_logic]{predicate logic}.

We give here the following definition, and then dedicate several sections to explaining it:
\begin{definition}\label{def:first_order_logic}\mimprovised
  We call \term[ru=логика первого порядка (\cite[83]{Герасимов2014Вычислимость}), en=first-order logic (\cite[58]{VanDalen2004LogicAndStructure})]{first-order logic} the \hyperref[def:general_logic]{general logic} specified by the \hyperref[def:fol_institution]{first-order institutions} and the corresponding \hyperref[def:fol_natural_deduction_systems]{\hyperref[def:truth_value_algebra/classical]{classical} natural deduction system}.
  \end{definition}
\begin{comments}
  \item First-order logic can be regarded as a special case of \hyperref[def:higher_order_logic]{higher-order logic}. See \cref{ex:def:bounded_hol/first}.
\end{comments}

\paragraph{First-order signatures}

\begin{definition}\label{def:predicate_logic_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} of \hyperref[con:predicate_logic]{predicate logic} extends the \hyperref[def:propositional_alphabet]{alphabet of propositional logic} and the \hyperref[def:substitution_schema_alphabet]{alphabet of substitution schemas} with the following new symbols:
  \begin{thmenum}
    \thmitem{def:predicate_logic_alphabet/quantifiers}\mcite[80]{Kleene2002Logic} The set \( \op*{Quant} \) of \term[ru=кванторы (\cite[82]{Герасимов2014Вычислимость})]{quantifiers}, namely
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/quantifiers/universal} The \term[ru=квантор всеобщости (\cite[86]{Герасимов2014Вычислимость})]{universal quantifier} \enquote{\( \synforall \)}.
      \thmitem{def:predicate_logic_alphabet/quantifiers/existential}\mcite[80]{Kleene2002Logic} The \term[ru=квантор существования (\cite[86]{Герасимов2014Вычислимость})]{existential quantifier} \enquote{\( \synexists \)}.
    \end{thmenum}

    \thmitem{def:predicate_logic_alphabet/equality}\mcite[def. 2.1.2(vi)]{Hinman2005Logic} The \hyperref[def:fol_signature/notation]{infix} \term{equality symbol} \enquote{\( \syneq \)}

    \thmitem{def:predicate_logic_alphabet/aux} In addition to the parentheses, two more auxiliary symbols:
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/aux/comma} The comma \enquote{\( , \)} for delimiting \hyperref[con:function_arguments]{function arguments}.

      \thmitem{def:predicate_logic_alphabet/aux/dot} The dot \enquote{\( . \)} for separating quantifiers from their bodies.

      \thmitem{def:predicate_logic_alphabet/aux/asterisk} The asterisk \enquote{\( * \)} for denoting \hyperref[con:eigenvariable]{eigenvariables}.
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This alphabet is intended for first-order logic, but will also be reused for higher-order logic in \fullref{sec:higher_order_logic}.

  \item As discussed in \cref{rem:quantifier_notation}, the dot has no functional role and is only used as visual aid for complicated formulas.
\end{comments}

\begin{definition}\label{def:fol_signature}\mcite[282]{Meseguer1989GeneralLogics}
  A \hyperref[con:logical_system_signature]{signature} \( \Sigma \) for first-order logic consists of the following:
  \begin{thmenum}
    \thmitem{def:fol_signature/fun} A possibly empty \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Fun}_\Sigma \), whose elements we call \term[ru=функциональные символы (\cite[84]{Герасимов2014Вычислимость})]{function symbols}.

    \thmitem{def:fol_signature/pred} A possibly empty alphabet \( \op*{Pred}_\Sigma \), whose elements we call \term[ru=реляционные символы (\cite[84]{Герасимов2014Вычислимость})]{relation symbols}.

    \thmitem{def:fol_signature/arity}\mcite[38]{CitkinMuravitsky2022ConsequenceRelations} A function \( {\#}: \op*{Fun}_\Sigma \cup \op*{Pred}_\Sigma \to \BbbZ_{\geq 0} \) determining the corresponding symbol's \term[ru=арность (\cite[84]{Герасимов2014Вычислимость}); валентность (\cite[73]{ШеньВерещагин2017ЯзыкиИИсчисления})]{arity}.

    Based on this arity, we will use the prefixes from \cref{def:operation_arity_terminology} like \enquote{unary}, \enquote{binary}, etc.

    \thmitem{def:fol_signature/notation}\mimprovised In accordance with \cref{rem:fol_application_notation}, we allow \hyperref[def:set_partition]{partitioning} the set \( \op*{Fun}_\Sigma \cup \op*{Pred}_\Sigma \) of all signature symbols into three subsets called \( \op*{Prefix}_\Sigma \), \( \op*{Cond}_\Sigma \) (condensed notation) and \( \op*{Infix}_\Sigma \), based on the \hyperref[def:function_application_notation]{application notation} for we want to use.

    \begin{itemize}
      \item We force all nullary symbols into \( \op*{Cond}_\Sigma \).
      \item We only allow binary symbols in \( \op*{Infix}_\Sigma \).
      \item All non-nullary symbols by default go to \( \op*{Prefix}_\Sigma \).
    \end{itemize}
  \end{thmenum}

  As per \cref{rem:improper_symbols_and_parsing}, we disallow the \hyperref[con:improper_symbol]{improper symbols} from the \hyperref[def:predicate_logic_alphabet]{alphabet of predicate logic} and the \hyperref[def:inference_rule_alphabet]{alphabet of inference rules} as function or predicate symbols.
\end{definition}
\begin{comments}
  \item We discuss in \cref{rem:language_alphabet_cardinality} some cardinality considerations; we mention here only that both alphabets are by default assumed to be finite. In accordance with \cref{rem:cardinality_auxiliary_terminology}, we use cardinality-related terminology like \enquote{finite} and \enquote{countably infinite} for the signature itself when we mean the larger of the cardinalities of the alphabets.
\end{comments}

\begin{definition}\label{def:fol_signature_category}\mcite[282]{Meseguer1989GeneralLogics}
  For a fixed \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \), assumed by default to be the universe \hyperref[def:universe_of_hereditary_finite_sets]{\( V_\omega \)} of hereditarily finite sets, we define the \hyperref[def:category]{category} \( \ucat{Sign} \) of \( \mscrU \)-small \hyperref[def:fol_signature]{first-order signatures} as follows:
  \begin{thmenum}
    \thmitem{def:fol_signature_category/objects} The objects are, unsurprisingly, the \( \mscrU \)-small signatures.

    \thmitem{def:fol_signature_category/morphisms} A morphism \( s: \Sigma \to \Theta \) between signatures is a set-theoretic function mapping the function symbols of \( \Sigma \) to function symbols of \( \Theta \) with the same arity, and analogously for predicate symbols.

    We allow changing the notation of a symbol, e.g. sending a prefix symbol to an infix symbol and vice versa.

    \thmitem{def:fol_signature_category/composition} The composition of morphisms is their set-theoretic composition.

    \thmitem{def:fol_signature_category/identity} The identity on \( \Sigma \) is simply the set-theoretic identity.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Signature morphisms enable \fullref{alg:fol_formula_signature_translation}. This becomes powerful when combined with \hyperref[def:fol_definitional_extension]{definitional extensions}; see \cref{rem:signature_translation_and_definitional_extensions}.
\end{comments}

\paragraph{First-order terms}

\begin{definition}\label{def:fol_term}\mimprovised
  For a fixed \hyperref[def:fol_signature]{first-order signature} \( \Sigma \), we introduce a \hyperref[def:formal_grammar]{formal grammar} for \hyperref[con:predicate_logic/predicate]{terms}:
  \begin{bnf*}
    \bnfprod{individual variable}  {\bnfpn{Small Latin identifier}}                                  \\
    \bnfprod{term}                 {\bnfpn{individual variable} \bnfor \bnfpn{function application}}
  \end{bnf*}
  where, for every function symbol \( f \), we introduce a dedicated rule based on the function application grammar rules from \cref{def:function_application_notation}:
  \begin{bnfextra}
    \bnfprod{function application} {f \bnfsp \bnftsq{(} \bnfsp \overbrace{\bnfpn{term} \bnfsp \bnftsq{,} \bnfsp \bnfsk \bnfsp \bnftsq{,} \bnfsp \bnfpn{term}}^{\# f \T*{terms separated by commas}} \bnfsp \bnftsq{)}} \bnfe{if \( f \in \op*{Prefix}_\Sigma \)} \\
    \bnfprod{function application} {\bnftsq{(} \bnfsp \bnfpn{term} \anon \bnfpn{term} \bnfsp \bnftsq{)}}                                                                                                               \bnfe{if \( f \in \op*{Infix}_\Sigma \)}  \\
    \bnfprod{function application} {f \bnfsp \underbrace{\bnfpn{term} \bnfsp \bnfsk \bnfsp \bnfpn{term}}_{\# f \T*{terms}}}                                                                                            \bnfe{if \( f \in \op*{Cond}_\Sigma \)}
  \end{bnfextra}

  \begin{itemize}
    \item For the variables we have used the variable identifier rules from \cref{def:variable_identifier}.
    \item The function application rules are discussed in \cref{rem:fol_application_notation}.
  \end{itemize}

  We will denote the set of all \term[ru=индивидные переменные / предметные переменные (\cite[84]{Герасимов2014Вычислимость}), en=individual variables (\cite[57]{VanDalen2004LogicAndStructure})]{individuals variables} by \( \op*{Var} \) and the set of all \term{first-order terms} over \( \Sigma \) by \( \op*{Term}_\Sigma \).
\end{definition}
\begin{comments}
  \item A general discussion of terms and variables in predicate logic can be found in \cref{con:predicate_logic}.

  \item Within the metalanguage, we will denote abstract terms via \( \tau \), \( \sigma \), \( \rho \) and other letters in accordance with \cref{rem:mathematical_logic_conventions/greek_alphabet}. This convention will later lead us to a formal definition of formula schemas in \cref{def:fol_formula_schema}.

  \item We implicitly associate with each propositional formula an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} --- see \cref{def:fol_term_ast}. The grammar of first-order terms is unambiguous as shown via \cref{thm:fol_term_grammar/unambiguous}, which makes it possible to perform proofs via \fullref{thm:induction_on_rooted_trees}.

  \item First-order terms are implemented in the module \identifier{math.logic.terms} in \cite{notebook:code}, with a parser in \identifier{math.logic.parsing}.
\end{comments}

\begin{remark}\label{rem:fol_application_notation}
  We have defined first-order terms in \cref{def:fol_term} so that function application differs syntactically between symbols using prefix, condensed prefix and infix notation. We will do the same in \cref{def:fol_formula} for predicate application. Supporting different notations greatly increases the readability of some symbolic expressions in \cite{notebook:code}.

  Examples of function and predicate symbols that use infix notation abound --- all binary operations from \fullref{ch:group_theory}, \fullref{ch:ring_theory} and \fullref{ch:order_theory}, as well as the order relations from the latter. Other examples include the binary Peano arithmetic operations in \fullref{sec:natural_numbers} and the set membership predicate and most defined operations in \fullref{ch:set_theory}.

  Examples of condensed notation are mostly restricted to unary operators, where writing parentheses adds little benefit. This includes nearly all unary operators from \fullref{ch:set_theory}, as well as various kinds of \hyperref[def:morphism_invertibility/involution]{involutions}, \hyperref[def:moore_closure_operator]{closure operators}, and the \hyperref[sec:trigonometric_functions]{trigonometric functions}.

  Unlike metalingual \enquote{abuse-of-notation} conventions like those in \cref{rem:fol_formula_conventions}, supporting more than prefix notation does not require sacrificing syntactic unambiguity or useful properties like the subterm characterization in \cref{thm:lambda_subterm_characterization}. Furthermore, we already support infix notation for connective and equality formulas, and condensed prefix notation for logical negation.

  One thing should be noted, however. Since we mostly deal with \hyperref[con:abstract_syntax_tree]{abstract syntax trees}, the actual notation is not relevant outside the object language. We want \fullref{alg:fol_term_signature_translation} to produce an isomorphic syntax tree, but we have allowed signature morphisms to exchange symbols with different notation.

  Correspondingly, when only the abstract structure of a term (or formula) is concerned, we assume that a metalingual schema for function application like \( f(x, y) \) encompasses prefix, infix and condensed prefix symbols. Otherwise, we would have to add meaningless cases when using \hyperref[con:evaluation]{pattern matching}. For instance, when defining term denotations in \cref{def:fol_denotation/terms}, we prefer writing
  \begin{equation*}
    \Bracks{\tau}_\mscrX^v \coloneqq \begin{cases}
      v(\tau),                                                                             &\tau \in \op*{Var}, \\
      I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &\tau = f(\sigma_1, \ldots, \sigma_n)
    \end{cases}
  \end{equation*}
  instead of
  \begin{equation*}
    \Bracks{\tau}_\mscrX^v \coloneqq \begin{cases}
      v(\tau),                                                                             &\tau \in \op*{Var}, \\
      I(\anon)\parens[\big]{ \Bracks{\sigma}_\mscrX^v, \Bracks{\rho}_\mscrX^v },           &\tau = \sigma \anon \rho, \\
      I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &\tau = f \sigma_1 \ldots \sigma_n, \\
      I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &\tau = f(\sigma_1, \ldots, \sigma_n)
    \end{cases}
  \end{equation*}

  Furthermore, we have defined signature morphisms in \cref{def:fol_signature_category/morphisms} so that symbols using different notation can be exchanged.
\end{remark}

\begin{proposition}\label{thm:fol_term_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:fol_term]{first-order terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:fol_term_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:fol_term_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:fol_term_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  The proof is similar to \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{definition}\label{def:fol_subterm}\mimprovised
  We define the set of all \term{subterms} of a \hyperref[def:fol_term]{first-order term} \( \tau \) as follows:
  \begin{equation*}
    \op*{Subterm}(\tau) \coloneqq \begin{cases}
      \set{ \tau },                                              &\tau \in \op*{Var}, \\
      \set{ \tau } \cup \bigcup_{k=1}^n \op*{Subterm}(\sigma_k), &\tau = f(\sigma_1, \ldots, \sigma_n).
    \end{cases}
  \end{equation*}

  We denote by \( \op*{Var}(\tau) \) those subterms of \( \tau \) that are variables.
\end{definition}

\begin{proposition}\label{thm:fol_term_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \rho \) of the first-order term \( \tau \) is a \hyperref[def:fol_subterm]{subterm} of \( \tau \) if and only if \( \rho \) is itself a formula.
\end{proposition}
\begin{proof}
  We can adapt the proof of \cref{thm:propositional_formula_characterization}. There are no variable binders, so we are safe from the \( \muplambda \)-term nuances in \cref{thm:lambda_subterm_characterization}.
\end{proof}

\begin{definition}\label{def:fol_term_ast}\mimprovised
  We implicitly associate with each first-order term \( \tau \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\tau) \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_term_ast/variable} If \( \tau \) is a variable, we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:fol_term_ast/application} If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), assuming we have built \( T(\sigma_k) \) for \( k = 1, \ldots, n \), we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( f \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__fol_term_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:closed_fol_term}\mcite[def. 2.3.8]{VanDalen2004LogicAndStructure}
  We say that a \hyperref[def:fol_term]{first-order term} is \term[ru=замкнутый терм (\cite[62]{КолмогоровДрагалин2006Логика})]{closed} if it has no variables.
\end{definition}
\begin{comments}
  \item Closed terms are also called \enquote{ground terms}, for example by \incite[def. 3.1.5]{BaaderNipkow2012TermRewriting}.
\end{comments}

\begin{algorithm}[Signature translation of first-order terms]\label{alg:fol_term_signature_translation}
  Given a \hyperref[def:fol_signature_category/morphism]{signature morphism} \( s: \Sigma \to \Theta \), we can easily translate any \hyperref[def:fol_term]{first-order term} from \( \op*{Term}_\Sigma \) to \( \op*{Term}_\Theta \):
  \begin{equation*}
    \tau[s] \coloneqq \begin{cases}
      \tau,                                                  &\tau \in \op*{Var}, \\
      s(f)\parens[\big]{ \sigma_1[s], \ldots, \sigma_n[s] }, &\tau = f(\sigma_1, \ldots, \sigma_n).
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item As discussed in \cref{rem:fol_application_notation}, we allow exchanging prefix and infix symbols.
  \item This algorithm can be found as \identifier{math.logic.signature_translation.translate_term} in \cite{notebook:code}.
\end{comments}

\paragraph{First-order formulas}

\begin{definition}\label{def:fol_formula}\mimprovised
  For a fixed \hyperref[def:fol_signature]{first-order signature} \( \Sigma \), we introduce a \hyperref[def:formal_grammar]{formal grammar} for \hyperref[con:proposition]{formulas}:
  \begin{bnf*}
    \bnfprod{equality formula}       {\bnftsq{(} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( \syneq \)} \bnfsp \bnfpn{term} \bnfsp \bnftsq{)}} \\
    \bnfprod{quantifier formula}     {\bnfpn{quantifier} \bnfsp \bnfpn{individual variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{formula}} \\
    \bnfprod{atomic formula}         {\bnfpn{constant formula} \bnfor} \\
    \bnfmore                         {\bnfpn{equality formula} \bnfor} \\
    \bnfmore                         {\bnfpn{predicate application} \bnfor} \\
    \bnfprod{formula}                {\bnfpn{atomic formula} \bnfor} \\
    \bnfmore                         {\bnfpn{negation formula} \bnfor} \\
    \bnfmore                         {\bnfpn{connective formula} \bnfor} \\
    \bnfmore                         {\bnfpn{quantifier formula}}
  \end{bnf*}

  \begin{itemize}
    \item The \( \bnfpn{predicate application} \) rules are based on the analogous \( \bnfpn{function application} \) rules from \cref{def:fol_term}.

    \item The \( \bnfpn{individual variable} \) and \( \bnfpn{term} \) rules are also taken from \cref{def:fol_term}.

    \item The \( \bnfpn{negation formula} \) and \( \bnfpn{connective formula} \) rules are exactly as in for propositional formulas in \cref{def:propositional_formula}, so we have avoided stating them explicitly.

    \item The \( \bnfpn{quantifier} \) rule lists the corresponding symbols from the alphabet.
  \end{itemize}

  Similarly to the case of propositional formulas in \cref{def:propositional_subformula}, we denote by \( \op*{Form}_\Sigma \) the set of all \term[en=first-order formulas (\cite[23]{CitkinMuravitsky2022ConsequenceRelations})]{first-order formulas} over \( \Sigma \), and by \( \op*{Atom}_\Sigma \) those that are \term[ru=атомарные (формулы) (\cite[56]{КолмогоровДрагалин2006Логика}), en=atomic (formulas) (\cite[def. 2.1.8]{Hinman2005Logic})]{atomic}.
\end{definition}
\begin{comments}
  \item Within the metalanguage, we will denote abstract formulas via \( \varphi \), \( \psi \), \( \theta \) and other letters in accordance with \cref{rem:mathematical_logic_conventions/greek_alphabet}. This convention will later lead us to a formal definition of formula schemas in \cref{def:fol_formula_schema}.

  \item First-order formulas are implemented in \identifier{math.logic.formulas}, with a parser in \identifier{math.logic.parsing}.
\end{comments}

\begin{proposition}\label{thm:fol_formula_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:fol_formula]{first-order terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:fol_formula_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:fol_formula_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:fol_formula_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  The proof is more complicated, but similar to \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{remark}\label{rem:fol_formula_conventions}
  In order to simplify exposition, we use several \enquote{abuse-of-notation} conventions. As in the case of \cref{rem:propositional_formula_notation_conventions}, these exist only in the metalanguage and the formulas themselves are assumed to have the former form within the object language.
  \begin{thmenum}
    \thmitem{rem:fol_formula_conventions/parentheses} We use the parentheses conventions from \cref{rem:propositional_formula_notation_conventions}.

    \thmitem{rem:fol_formula_conventions/notation} As discussed in \cref{rem:fol_application_notation}, we will mostly disregard the difference between different notation for function and predicate applications if we are only interested in the \hyperref[con:abstract_syntax_tree]{abstract syntax trees} of the terms and formulas.

    \thmitem{rem:fol_formula_conventions/relativization} Bounded quantifiers, which we discuss in general in \cref{con:predicate_logic/relativization}, are not allowed by the syntax of first-order logic.

    For any predicate \( p(x, \cdots) \), we use the following notational shorthands:
    \begin{center}
      \begin{tabular}{l l}
        \multicolumn{1}{c}{Formula}           & \multicolumn{1}{c}{Formula} \\
        \midrule
        \( \qforall {p(x, \cdots)} \varphi \) & \( \qforall x \parens[\big]{ p(x, \cdots) \synimplies \varphi } \) \\
        \( \qexists {p(x, \cdots)} \varphi \) & \( \qexists x \parens[\big]{ p(x, \cdots) \synwedge \varphi } \)   \\
      \end{tabular}
    \end{center}

    The particular choice of abbreviations is justified in \cref{thm:relativized_first_order_quantifiers_are_dual}.

    \thmitem{rem:fol_formula_conventions/unique_existence} We will use the abbreviation in \cref{rem:exists_unique_abbreviation} to emulate the unique existence quantifier \( \qExists x \varphi \) discussed in \cref{con:description_operator/unique_existence}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:fol_subformula}\mimprovised
  Analogously to how we handled propositional subformulas in \cref{def:propositional_subformula}, we define the set of all \term{subformulas} of a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as follows:
  \begin{equation*}
    \op*{Subform}(\varphi) \coloneqq \begin{cases}
      \set{ \varphi },                                                        &\varphi \in \op*{Atom}_\Sigma, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \synneg \psi, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi) \cup \op*{Subform}(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}

  The only difference is the presence of the quantifier case.
\end{definition}

\begin{proposition}\label{thm:fol_formula_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \psi \) of the first-order term \( \varphi \) is a \hyperref[def:fol_subformula]{subformula} of \( \varphi \) if and only if \( \psi \) is itself a formula.
\end{proposition}
\begin{proof}
  Like in the case of \( \muplambda \)-terms in \cref{thm:lambda_subterm_characterization}, there are variable binders, but unlike in that case, the variables themselves are not considered formulas. So, there are no nuances to handle, and we can proceed as in the propositional case in \cref{thm:propositional_formula_characterization}.
\end{proof}

\begin{definition}\label{def:fol_formula_ast}\mimprovised
  We implicitly associate with each first-order formula \( \varphi \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\varphi) \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_formula_ast/const} If \( \varphi \) is a logical constant, i.e. \( \syntop \) or \( \synbot \), we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:fol_formula_ast/equality} If \( \varphi = \tau \syneq \sigma \), assuming we have built \( T(\tau) \) and \( T(\sigma) \) in accordance with \cref{def:fol_formula_ast}, we define \( T(\varphi) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( \syneq \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/application} If \( \varphi = p(\tau_1, \ldots, \tau_n) \), assuming we have built \( T(\tau_k) \) for \( k = 1, \ldots, n \) in accordance with \cref{def:fol_formula_ast}, we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( p \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/negation} Analogously to the propositional negation trees from \cref{def:propositional_formula_ast/negation}, if \( \varphi = \synneg \psi \), assuming we have already built \( T(\psi) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) to a new root labeled with \( \synneg \):
    \begin{equation*}
      \includegraphics[page=3]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/connective} Analogously to the propositional connective formula trees from \cref{def:propositional_formula_ast/connective}, if \( \varphi = \psi \syncirc \theta \), assuming we have built \( T(\psi) \) and \( T(\theta) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) and \( T(\theta) \) to a new root labeled with \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=4]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/quantifier} Analogously to the untyped \( \muplambda \)-abstraction trees from \cref{def:lambda_term_ast/abstraction}, if \( \varphi = \quantifier Q x \psi \), where \( Q \) is a quantifier, assuming we have built \( T(\psi) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) to a new root labeled with \( Q x \):
    \begin{equation*}
      \includegraphics[page=5]{output/def__fol_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{algorithm}[Signature translation of first-order formulas]\label{alg:fol_formula_signature_translation}
  Given a \hyperref[def:fol_signature_category/morphism]{signature morphism} \( s: \Sigma \to \Theta \), we can translate any \hyperref[def:fol_formula]{first-order formula} from \( \op*{Form}_\Sigma \) to \( \op*{Form}_\Theta \) with the aid of \fullref{alg:fol_term_signature_translation}:
  \begin{equation*}
    \varphi[s] \coloneqq \begin{cases}
      \varphi,                                                                 &\varphi = \syntop \T{or} \varphi = \synbot, \\
      \tau[s] \syneq \sigma[s],                                                &\varphi = (\tau \syneq \sigma), \\
      s(p)\parens[\big]{ \tau_1[s], \ldots, \tau_n[s]) },                      &\varphi = p(\tau_1, \ldots, \tau_n), \\
      \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item As discussed in \cref{rem:fol_application_notation}, we allow exchanging prefix and infix symbols.

  \item This straightforward algorithm becomes powerful when combined with \hyperref[def:fol_definitional_extension]{definitional extensions}; see \cref{rem:signature_translation_and_definitional_extensions}.

  \item This algorithm can be found as \identifier{math.logic.signature_translation.translate_formula} in \cite{notebook:code}.
\end{comments}

\paragraph{Variable binding}

\begin{definition}\label{def:fol_variable_occurrence}\mimprovised
  Similarly to variable occurrences of \( \muplambda \)-terms defined in \cref{def:lambda_variable_occurrence}, we define an \term[en=occurrence (\cite[63]{VanDalen2004LogicAndStructure})]{occurrence} of an individual variable \( x \) in a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as a variable node with label \( x \) in the \hyperref[def:fol_formula_ast]{abstract syntax tree} of \( \varphi \).

  We analogously call a variable occurrence of \( x \) \term[ru=свободное (вхождение) (\cite[88]{Герасимов2014Вычислимость}), en=free occurrence (\cite[def. 9.1.2]{CitkinMuravitsky2022ConsequenceRelations})]{free} in \( \varphi \) if the root of the AST can be reached without passing through a quantifier. If an occurrence is not free, we say that it is \term[ru=связоное (вхождение) (\cite[88]{Герасимов2014Вычислимость}), en=bound occurrence (\cite[def. 9.1.2]{CitkinMuravitsky2022ConsequenceRelations})]{bound}.
\end{definition}

\begin{definition}\label{def:fol_variable_freeness}\mcite[88]{Герасимов2014Вычислимость}
  In analogy with how we handled variable freeness in \( \muplambda \)-terms defined in \cref{def:lambda_variable_freeness}, we say that a variable \( x \) is \term[ru=свободная (переменная), en=free (variable) (\cite[63]{VanDalen2004LogicAndStructure})]{free} in a first-order formula \( \varphi \) if \( x \) has at least one \hyperref[def:fol_variable_occurrence]{free occurrence} in \( \varphi \) and \term[ru=связанная (переменная), en=bound (variable) (\cite[63]{VanDalen2004LogicAndStructure})]{bound} if it has a \hyperref[def:lambda_variable_occurrence]{bound occurrence} in \( M \).
\end{definition}
\begin{comments}
  \item We may use the recursive definitions from \cref{thm:fol_variable_freeness_characterization} instead.
\end{comments}

\begin{proposition}\label{thm:fol_variable_freeness_characterization}
  The set of all \hyperref[def:fol_variable_freeness]{free variables} of a first-order formula can be characterized as follows:
  \begin{equation*}
    \op*{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                &\varphi = \syntop \T{or} \varphi = \synbot, \\
      \op*{Var}(\tau) \cup \op*{Var}(\sigma),     &\varphi = \tau \syneq \sigma, \\
      \bigcup_{k=1}^n \op*{Var}(\tau_k),          &\varphi = p(\tau_1, \ldots, \tau_n), \\
      \op*{Free}(\psi),                           &\varphi = \synneg \psi, \\
      \op*{Free}(\psi) \cup \op*{Free}(\theta),   &\varphi = \synneg \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \op*{Free}(\psi) \setminus \set{ x },       &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}

  Similarly, the bound variables can be characterized via
  \begin{equation*}
    \op*{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                &\varphi \in \op*{Atom}_\Sigma, \\
      \op*{Bound}(\psi),                          &\varphi = \synneg \psi, \\
      \op*{Bound}(\psi) \cup \op*{Bound}(\theta), &\varphi = \synneg \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \op*{Bound}(\psi) \cup \set{ x },           &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item We show an analogous result for \( \muplambda \)-terms in \cref{thm:lambda_variable_freeness_characterization}.
\end{comments}
\begin{proof}
  Straightforward.
\end{proof}

\begin{definition}\label{def:closed_fol_formula}\mcite[def. 2.3.8]{VanDalen2004LogicAndStructure}
  We say that a \hyperref[def:fol_formula]{first-order formula} is \term[ru=замкнутая формула (\cite[61]{КолмогоровДрагалин2006Логика})]{closed} if it has no \hyperref[def:fol_variable_freeness]{free variables}. Closed formulas are also called \term[ru=предложения (\cite[61]{КолмогоровДрагалин2006Логика})]{sentences}.

  In fact, \enquote{sentence} is a more general placeholder word used in many definitions in \cref{sec:logical_consequence}. For the reasons outlined in \cref{rem:implicit_quantification_and_deduction}, we will only consider closed formulas for the sentence functor when defining an \hyperref[def:institution]{institution} in \cref{def:fol_institution/sentences}. Furthermore, we will be explicit about when we want to work with \hyperref[def:fol_universal_closure]{universal closures} (see e.g. the theory of semirings in \cref{def:semiring/theory}), and will mostly avoid relying on \hyperref[con:implicit_universal_quantification]{implicit universal quantification}.
\end{definition}

\paragraph{Generalized equivalence relations}

\begin{definition}\label{def:generalized_equivalence_relation}
\end{definition}

\paragraph{First-order semantics}

\begin{definition}\label{def:fol_structure}\mimprovised
  Fix a \hyperref[def:truth_value_algebra]{truth value algebra} \( \BbbT \). A \term[ru=структура (\cite[73]{ШеньВерещагин2017ЯзыкиИИсчисления})]{structure} \( \mscrX = (X, I) \) over the \hyperref[def:fol_signature]{first-order signature} \( \Sigma \) consists of the following:
  \begin{thmenum}
    \thmitem{def:fol_structure/universe} A \hi{nonempty} set \( X \), called a \term[en=universe (\cite[def. 2.1.15]{Hinman2005Logic})]{universe}.
    \thmitem{def:fol_structure/interpretation} A map \( I \), called an \term{interpretation}, that sends each \( n \)-ary function symbol to a function \( X^n \to X \) and every \( n \)-ary predicate to a function \( X^n \to \BbbT \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item It is important the universe is nonempty; see \cref{rem:higher_order_logic_empty_universe} for a broader discussion.

  \item In accordance with \cref{rem:cardinality_auxiliary_terminology}, we use cardinality-related terminology like \enquote{finite} and \enquote{countably infinite} for the structure itself when we mean the cardinality of the universe.

  \item Both \enquote{universe} and \enquote{interpretation}, as well other related terms, are used inconsistently in the literature. See \cref{rem:model_theory_structure_terminology}.
\end{comments}

\begin{remark}\label{rem:fol_structure_notation}
  We have defined a \hyperref[def:fol_structure]{first-order structure} as a pair \( \mscrX = (X, I) \). Each area of mathematics has its own conventions and structures are usually specified as simply as possible without being ambiguous.

  One convention is to denote the universes via compatible letters like we did with \( X \) and \( \mscrX \), or like we would do with \( G \) and \( \mscrG \). Such notation is used, for example, by \incite[def. II.1.2]{Эдельман1975Логика}.

  This allows us to say \enquote{Let \( \mscrP = (P, \leq_P) \) and \( \mscrQ = (Q, \leq_Q) \) be \hyperref[def:partially_ordered_set]{partially ordered sets}} and easily keep track which is which.

  Outside logic, for more complicated signature like that of the \hyperref[def:group/theory]{theory of groups}, it is burdensome to specify the entire interpretation since it is tantamount specifying a quadruple \( (G, e, (\anon)^{-1}, \cdot) \). Often it is sufficient to write only the domain \( G \) and say \enquote{let \( G \) be a group}. Since the binary operation of the group determines the others, we may also say \enquote{let \( (G, \ast) \) be a group} instead of \enquote{let \( G \) be a group with respect to some operation \( {\ast} \)}. This is technically wrong, but it is both convenient and conventional. The rest of the definition of the group can easily be inferred. In case of ambiguity, the simplest disambiguation is to use lower indices with the name of the structure, e.g. \( +_G \) and \( +_H \) may be the addition operation in different abelian groups.
\end{remark}

\begin{definition}\label{def:fol_variable_assignment}\mcite[def. 2.1.17; 92]{Andrews2002Logic}
  A \term[ru=оценка (\cite[def. 2.2.7]{Герасимов2014Вычислимость}), en=variable assignment (\cite[271]{Farmer2008STTVirtues}); assignment (\cite[def. 2.1.17]{Hinman2005Logic})]{variable assignment} in a given \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \) is any function \( v: \op*{Var} \to X \).

  For every variable \( x \) and every \( a \) from \( X \) we also define the \term{modified assignment} of \( v \) at \( x \) with \( a \):
  \begin{equation*}
    v_{x \mapsto a}(y) \coloneqq \begin{cases}
      a,    &y = x, \\
      v(y), &\T{otherwise.}
    \end{cases}
  \end{equation*}

  For more than one variable, we use the notation
  \begin{equation*}
    v_{x_1 \mapsto a_1, \ldots, x_n \mapsto a_n}(y) \coloneqq ((\ldots(v_{x_1 \mapsto a_1})\ldots)_{x_n \mapsto a_n})(y).
  \end{equation*}

  We can also modify \( v \) at \( x \) with a variable \( z \):
  \begin{equation*}
    v_{x \mapsto z}(y) \coloneqq \begin{cases}
      v(z),   &y = x, \\
      v(y), &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item \incite{Andrews2002Logic} introduces no term for modified assignments, and neither do \cite[rem. 2.2.17]{Hinman2005Logic} or \cite[def. 2.2.9]{Герасимов2014Вычислимость}.
\end{comments}

\begin{definition}\label{def:kronecker_delta}\mimprovised
  We define the \term[ru=дельта-функция Кронекера (\cite[45]{БарановСтечкин2004ЭкстремальнаяКомбинаторика}), en=Kronecker delta function (\cite[16]{Hall1986CombinatorialTheory})]{Kronecker delta function} on a \hyperref[def:semiring]{semiring} \( R \) as
  \begin{equation}\label{eq:def:kronecker_delta}
    \delta_{i,j} \coloneqq \begin{cases}
      1_R, &i = j, \\
      0_R, &i \neq j.
    \end{cases}
  \end{equation}

  It is also traditionally called the \term[bg=символ на Кронекер (\cite[26]{Боянов2008ЧислениМетоди}), ru=символ Кронекера (\cite[461]{Тыртышников2007ЛинейнаяАлгебра}), en=Kronecker delta symbol (\cite[33]{Knuth1997ArtVol1}); Kronecker symbol (\cite[213]{Bourbaki1998Algebra1to3})]{Kronecker delta symbol}.

  The definition naturally extends to a \hyperref[con:truth_value_algebra]{truth value algebra}, where it becomes
  \begin{equation}\label{eq:def:kronecker_delta/truth}
    \delta_{i,j} = \begin{cases}
      T, &i = j, \\
      F, &i \neq j.
    \end{cases}
  \end{equation}
\end{definition}
\begin{comments}
  \item We generalize the \enquote{Kronecker symbol} from \cite[213]{Bourbaki1998Algebra1to3} from rings to semirings, so that we are able to encompass truth value algebras. We use the latter when defining denotations for equality in \cref{def:fol_denotation} and \cref{def:hol_term_denotation}.
\end{comments}

\begin{definition}\label{def:fol_denotation}\mimprovised
  For the reasons outlined in \cref{rem:intuitionistic_first_order_semantics}, we will be working over the \hyperref[def:truth_value_algebra/classical]{classical truth value algebra} \( \BbbT = \set{ T, F } \).

  Let \( \mscrX = (X, I) \) be a \hyperref[def:fol_structure]{first-order structure} over \( \Sigma \), and let \( v: \op*{Var} \to X \) be a \hyperref[def:fol_variable_assignment]{variable assignment}.

  \begin{thmenum}
    \thmitem{def:fol_denotation/terms} We define the \term[ru=значение (терма) (\cite[def. 2.2.9]{Герасимов2014Вычислимость}), en=denotation (\cite[91]{Hinman2005Logic})]{denotation} \( \Bracks{\tau}_\mscrX^v \) of a \hyperref[def:fol_term]{first-order term} \( \tau \) as follows:
    \begin{empheq}[left={\Bracks{\varphi}_I} \coloneqq \empheqlbrace]{align}
      &v(\tau),                                                                             &&\tau \in \op*{Var},                   \label{eq:def:fol_denotation/terms/var} \\
      &I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &&\tau = f(\sigma_1, \ldots, \sigma_n). \label{eq:def:fol_denotation/terms/fun}
    \end{empheq}

    If \( \tau \) is a \hyperref[def:closed_fol_term]{closed term}, the \hyperref[def:fol_denotation]{denotation} \( \Bracks{\tau}_\mscrX^v \) does not depend on \( v \), and we simply write \( \Bracks{\tau}_\mscrX \).

    \thmitem{def:fol_denotation/term_function} Based on how we defined functions on propositional formulas in \cref{def:propositional_denotation/function}, assuming that \( \op*{Var}(\tau) \subseteq \set{ x_1, \ldots, x_n } \), we can define the function
    \begin{equation*}
      \begin{aligned}
        &\Bracks{\tau}_\mscrX: X^n \to X, \\
        &\Bracks{\tau}_\mscrX(a_1, \ldots, a_n) \coloneqq \Bracks{\tau}_\mscrX^v,
      \end{aligned}
    \end{equation*}
    where \( v \) is any variable assignment such that \( v(x_k) = a_k \) for \( k = 1, \ldots, n \).

    Unless otherwise noted, we assume that \( x_1, \ldots, x_n \) are precisely the variables of \( \tau \) ordered lexicographically.

    \thmitem{def:fol_denotation/formulas} We define the \term[ru=истинностное значение (формулы) (\cite[def. 2.2.10]{Герасимов2014Вычислимость}), en=denotation (\cite[91]{Hinman2005Logic})]{denotation} \( \Bracks{\varphi}_\mscrX^v \) of a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as follows:
    \begin{empheq}[left={\Bracks{\varphi}_\mscrX^v} \coloneqq \empheqlbrace]{align}
      &T,                                                                               &&\varphi = \syntop,                   \label{eq:def:fol_denotation/formulas/top} \\
      &F,                                                                               &&\varphi = \synbot,                   \label{eq:def:fol_denotation/formulas/bot} \\
      &\oline{\Bracks{\psi}_\mscrX^v},                                                  &&\varphi = \synneg \psi,              \label{eq:def:fol_denotation/formulas/neg} \\
      &\Bracks{\psi}_\mscrX^v \relcirc \Bracks{\theta}_\mscrX^v,                        &&\varphi = \psi \syncirc \theta,      \label{eq:def:fol_denotation/formulas/conn} \\
      &\delta\parens[\big]{ \Bracks{N}_\mscrX^v, \Bracks{K}_\mscrX^v },                 &&\varphi = (N \syneq K),              \label{eq:def:fol_denotation/formulas/eq} \\
      &I(p)\parens[\big]{ \Bracks{\psi_1}_\mscrX^v, \ldots, \Bracks{\psi_n}_\mscrX^v }, &&\varphi = p(\phi_1, \ldots, \phi_n). \label{eq:def:fol_denotation/formulas/pred} \\
      &\bigwedge\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X },   &&\varphi = \qforall x \psi,           \label{eq:def:fol_denotation/formulas/forall} \\
      &\bigvee\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X },     &&\varphi = \qexists x \psi,           \label{eq:def:fol_denotation/formulas/exists}
    \end{empheq}

    Most of the cases above are simply the familiar propositional denotation rules from \cref{def:propositional_denotation}.
    \begin{itemize}
      \item In \eqref{eq:def:fol_denotation/formulas/eq}, \( \delta \) is the \hyperref[def:kronecker_delta]{Kronecker delta function} (written using prefix notation).

      \item In \eqref{eq:def:fol_denotation/formulas/pred}, we utilize predicate functions from the structure's interpretation.

      \item The cases \eqref{eq:def:fol_denotation/formulas/forall} and \eqref{eq:def:fol_denotation/formulas/exists} evaluates \( \psi \) using a \hyperref[def:hol_variable_assignment/modified]{modified assignment} parameterized by the elements of \( X_\sigma \).
    \end{itemize}

    Even though we have restricted ourselves to the two-element truth value algebra, the denotations above (except for equality) work more generally. We will thus be explicit about when we rely on classical semantics.

    If the denotation \( \Bracks{\varphi}_\mscrX^v \) does not depend on \( v \), we use the simpler notation \( \Bracks{\varphi}_\mscrX \). Unlike for terms, this can happen even if \( \varphi \) is not a \hyperref[def:closed_fol_formula]{closed formula} --- see \cref{rem:implicit_quantification_and_deduction}.

    \thmitem{def:fol_denotation/formula_valuation} Just as we have associated a function with every term, if \( \op*{Free}(\varphi) \subseteq \set{ x_1, \ldots, x_n } \), we can define the function
    \begin{equation*}
      \begin{aligned}
        &\Bracks{\varphi}_\mscrX: X^n \to \BbbT, \\
        &\Bracks{\varphi}_\mscrX(a_1, \ldots, a_n) \coloneqq \Bracks{\varphi}_\mscrX^v,
      \end{aligned}
    \end{equation*}
    where \( v \) is any variable assignment such that \( v(x_k) = a_k \) for \( k = 1, \ldots, n \).

    Unless otherwise noted, we assume that \( x_1, \ldots, x_n \) are precisely the \hi{free} variables of \( \varphi \), ordered lexicographically.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The term \enquote{denotation} is inspired by Russell's theory of denotations discussed in \cref{con:denotation}. It is used inconsistently in the literature. See \cref{rem:model_theory_structure_terminology}.

  \item First-order denotations are implemented as \identifier{evaluate_term} and \identifier{evaluate_formula} in the module \identifier{math.logic.structure} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:model_theory_structure_terminology}
  \hyperref[def:propositional_interpretation]{Propositional interpretations}, \hyperref[def:fol_structure]{first-order structures} and \hyperref[def:hol_structure]{higher-order structures} can act as \hyperref[con:logical_model]{models} for the corresponding \hyperref[def:logical_theory]{logical theories}. In particular, they act as models in the corresponding \hyperref[def:institution]{institutions}. Unlike in general institutions, however, we refer to them as \enquote{models} only with respect to a theory.

  \begin{table}[!ht]
    \centering
    \scriptsize
    \begin{tabular}{*{6}{l}}
      \toprule
      Source                                                      & Structure          & Universe    & Interpretation   & Assignment & Denotation     \\
      \midrule
      \cite[ch. 2]{Hinman2005Logic}                               & Structure          & Universe    & ---              & Assignment & Denotation     \\
      \cite[ch. 2]{VanDalen2004LogicAndStructure}                 & Structure          & Universe    & ---              & ---        & Interpretation \\
      \cite[84]{Kleene2002Logic}                                  & ---                & Domain      & Assignment       &            & ---            \\
      \cite[115]{Andrews2002Logic}                                & Interpretation     & Domain      & Assignment       &            & Value          \\
      \cite[70, 72, 73]{КолмогоровДрагалин2006Логика}             & Интерпретация      & Носитель    & Интерпретация    & ---        & Значение       \\
                                                                  & (interpretation)   & (carrier)   & (interpretation) & ---        & (value)        \\
      \cite[142]{Мальцев1970АлгебраическиеСистемы}                & Алгебр. система    & ---         & ---              & ---        & Значение       \\
                                                                  & (algebraic system) &             &                  & ---        & (value)        \\
      \cite[ch. 3]{ШеньВерещагин2017ЯзыкиИИсчисления}             & ---                & ---         & Интерпретация    & Оценка     & Значение       \\
                                                                  &                    &             & (interpretation) & (value)    & (value)        \\
      \cite[ch. 2]{Эдельман1975Логика}                            & Модель             & Основн. мн. &                  &            &                \\
                                                                  & (model)            & (fund. set) &                  &            &                \\
      \cite[\S 2.2]{Герасимов2014Вычислимость}                    & Интерпретация      & Носитель    & ---              & Оценка     & Значение       \\
                                                                  & (interpretation)   & (carrier)   &                  & (value)    & (value)        \\
      \bottomrule
    \end{tabular}
    \caption{A terminological comparison for \hyperref[def:fol_structure]{first-order structures}.}\label{tab:rem:model_theory_structure_terminology}
  \end{table}

  As it often happens, the terminology is inconsistent across authors. As an example, in \cref{tab:rem:model_theory_structure_terminology} we list some of the terminology for\hyperref[def:first_order_structure]{first-order structures} used by different authors. Their entire formulations are so fundamentally different that making an explicit comparison beyond the essential result is not worth the effort. This is unlike most cases outside logic, where the differences are indeed terminological (see e.g. \cref{rem:order_homomorphism_terminology} for order functions or \cref{rem:graph_walk_terminology} for graph walks).

  For propositional logic, the comparison is somewhat simpler because there is only one concept involved --- that of a (classical) \hyperref[def:propositional_interpretation]{propositional interpretation}. It is called an \enquote{assignment} in \cite[50]{Andrews2002Logic}, an \enquote{atomic truth assignment} in \cite[def. 1.1.6]{Hinman2005Logic}, a \enquote{denotation} in \cite[def. 1.2.1]{VanDalen2004LogicAndStructure}, \cite[\S 2.5.6]{Mimram2020ProgramEqualsProof} and \cite[\S 3.2]{CitkinMuravitsky2022ConsequenceRelations}, and an \enquote{interpretation} (\enquote{интерпретация}) in \cite[def. 1.1.10]{Герасимов2014Вычислимость}.

  For higher-order logic, Henkin's original terminology from \cite[84]{Henkin1950CompletenessInTheoryOfTypes} seems to be respected by \cite[238]{Andrews2002Logic} and \cite[271]{Farmer2008STTVirtues}. We will slightly deviate from this in \fullref{sec:henkin_semantics} in order to say consistent with our presentation of first-order logic.
\end{remark}

\begin{definition}\label{def:fol_homomorphism}\mcite[def. 3.3.1]{VanDalen2004LogicAndStructure}
  Fix a \hyperref[def:first_order_signature]{first-order signature} \( \Sigma \). We define a \term{homomorphism} between the \hyperref[def:fol_structure]{structures} \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) over \( \Sigma \) as a function \( h: X \to Y \) which satisfies the following conditions:
  \begin{thmenum}
    \thmitem{def:fol_homomorphism/functions} For every function symbol \( f \) of arity \( n \) over \( \Sigma \), we have
    \begin{equation*}
      h\parens[\big]{ I(f)(x_1, \ldots, x_n) } = I(f)\parens[\big]{ h(x_1), \ldots, h(x_n) }.
    \end{equation*}

    \thmitem{def:fol_homomorphism/predicates} For every predicate symbol \( p \) of arity \( n \) over \( \Sigma \), we have
    \begin{equation*}
      I(p)(x_1, \ldots, x_n) \leq I(p)\parens[\big]{ h(x_1), \ldots, h(x_n) }.
    \end{equation*}

    If equality holds, we say that the homomorphism is \term{strong}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item We may use the notation \( h: \mscrX \to \mscrY \) in accordance with the general practice for category morphisms described in \cref{rem:categorical_morphism_notation}.

  \item \Cref{thm:first_order_homomorphism_as_substructure} provides a condition equivalent to \cref{def:first_order_homomorphism/functions}.

  \item The inequality for predicates leads precisely to the desired notion of homomorphism for \hyperref[def:partially_ordered_set]{partially ordered sets} and \hyperref[def:directed_graph]{directed graphs}. The adjective \enquote{strong} is based on Knauer's \enquote{strong graph homomorphisms} defined in \cite[def. 1.4.3]{Knauer2019AlgebraicGraphTheory}.

  \incite[def. 3.3.1]{VanDalen2004LogicAndStructure} and \incite[49]{Мальцев1970АлгебраическиеСистемы} define homomorphisms like we do, and neither discuss strong homomorphisms. \incite[def. 2.3.26(i)]{Hinman2005Logic} considers strong homomorphisms by default (and simply calls them \enquote{homomorphisms}), while later in \cite[rem. 2.3.27]{Hinman2005Logic} he mentions that our weaker homomorphisms are also useful and calls them \enquote{positive homomorphisms}.
\end{comments}

\begin{definition}\label{def:fol_structure_reduct}\mcite[example 5]{MossakowskiKrumnackMaibaum2015DerivedSignatureMorphisms}
  For every \hyperref[def:fol_signature_category/morphism]{signature morphism} \( s: \Sigma \to \Theta \) and every \hyperref[def:fol_structure]{structure} \( \mscrY = (Y, J) \) over \( \Theta \), we define the \term{model reduct} of \( \mscrY \) as the structure \( \red_s(\mscrY) \coloneqq (Y, J_s) \), where, for every (function or predicate) symbol \( f \) in \( \Sigma \),
  \begin{equation}\label{eq:def:fol_structure_reduct/interpretation}
    J_s(f) \coloneqq J(s(f)).
  \end{equation}

  When defining institutions in \cref{def:fol_institution/models/hom}, we will need to extend \( \red_s \) to a \hyperref[def:functor]{functor} by also reducing \hyperref[def:gol_homomorphism]{homomorphisms}. Given structures \( \mscrY = (Y, J) \) and \( \mscrZ = (Z, K) \) over \( \Theta \), for every \( g: Y \to Z \), we define \( \red_s(g) \) as \( g \) itself.
\end{definition}
\begin{comments}
  \item Reducts are implemented in the module \identifier{math.logic.structure.reduct} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:fol_structure_reduct_denotation}
  Fix a \hyperref[def:fol_signature_category/morphism]{signature morphism} \( s: \Sigma \to \Theta \) and a \hyperref[def:fol_structure]{structure} \( \mscrY = (Y, J) \) over \( \Theta \). Let \( v: \op*{Var} \to Y \) be a variable assignment.

  The \hyperref[def:fol_denotation]{denotations} of \( \mscrY \) and its \hyperref[def:fol_structure_reduct]{reduct} \( \red_s(\mscrY) \) are compatible in the following sense:
  \begin{thmenum}
    \thmitem{thm:fol_structure_reduct_denotation/terms} For every term \( \tau \) over \( \Sigma \), we have
    \begin{equation*}
      \Bracks[\big]{\tau[s]}_\mscrY^v = \Bracks{\tau}_{\red_s(\mscrY)}^v,
    \end{equation*}
    where we obtain \( \tau[s] \) via \fullref{alg:fol_term_signature_translation}.

    \thmitem{thm:fol_structure_reduct_denotation/formulas} For every formula \( \varphi \) over \( \Sigma \), we have
    \begin{equation*}
      \Bracks[\big]{\varphi[s]}_\mscrY^v = \Bracks{\varphi}_{\red_s(\mscrY)}^v,
    \end{equation*}
    where we obtain \( \varphi[s] \) via \fullref{alg:fol_formula_signature_translation}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:fol_structure_reduct_denotation/terms} We use \fullref{thm:induction_on_rooted_trees} on the abstract syntax tree of \( \tau \):
  \begin{itemize}
    \item If \( \tau \in \op*{Var} \), then \( \tau[s] = \tau \) and
    \begin{equation*}
      \Bracks[\big]{\tau[s]}_\mscrY^v
      \reloset {\eqref{eq:def:fol_denotation/terms/var}} =
      v(\tau)
      \reloset {\eqref{eq:def:fol_denotation/terms/var}} =
      \Bracks{\tau}_{\red_s(\mscrY)}^v.
    \end{equation*}

    \item If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), where the inductive hypothesis holds for \( \sigma_1, \ldots, \sigma_n \), then
    \begin{balign*}
      \Bracks[\big]{\tau[s]}_\mscrY^v
      &=
      \Bracks[\big]{ s(f)\parens[\big]{ \sigma_1[s], \ldots, \sigma_n[s] }}_\mscrY^v
      \reloset {\eqref{eq:def:fol_denotation/terms/fun}} = \\ &=
      J(s(f))\parens[\Big]{ \Bracks[\big]{\sigma_1[s]}_\mscrY^v, \ldots, \Bracks[\big]{\sigma_n[s]}_\mscrY^v }
      \reloset {\T{ind.}} = \\ &=
      J(s(f))\parens[\Big]{ \Bracks[\big]{\sigma_1}_{\red_s(\mscrY)}^v, \ldots, \Bracks[\big]{\sigma_n}_{\red_s(\mscrY)}^v }
      \reloset {\eqref{eq:def:fol_denotation/terms/fun}} = \\ &=
      \Bracks{ f(\sigma_1, \ldots, \sigma_n) }_{\red_s(\mscrY)}^v
      = \\ &=
      \Bracks{\tau}_{\red_s(\mscrY)}^v.
    \end{balign*}
  \end{itemize}

  \SubProofOf{thm:fol_structure_reduct_denotation/formulas} Analogous.
\end{proof}

\begin{definition}\label{def:fol_institution}\mimprovised
  Suppose that we are given a \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \), which is safe to assume to be the smallest suitable one as explained in \cref{def:large_and_small_sets}.

  We define an \hyperref[def:institution]{institution} based on \hyperref[def:fol_structure]{first-order structures} as follows:
  \begin{thmenum}
    \thmitem{def:fol_institution/signatures} We take the category of \( \mscrU \)-small signatures \( \ucat{Sign} \) from \cref{def:fol_signature_category}.

    \thmitem{def:fol_institution/sentences} We define the \hyperref[def:institution/sentences]{sentence functor} as follows:
    \begin{thmenum}
      \thmitem{def:fol_institution/sentences/obj} Let \( \op*{Sen}(\Sigma) \) be the set of \hyperref[def:closed_fol_formula]{closed formulas} over \( \Sigma \).
      \thmitem{def:fol_institution/sentences/hom} Let \( \op*{Sen}(s: \Sigma \to \Theta) \) be the function \( \varphi \mapsto \varphi[s] \), which translates formulas using \fullref{alg:fol_formula_signature_translation}.
    \end{thmenum}

    \thmitem{def:fol_institution/models} We define the \hyperref[def:institution/models]{model functor} as follows:
    \begin{thmenum}
      \thmitem{def:fol_institution/models/obj} Let \( \ucat{Mod}(\Sigma) \) be the category of \( \mscrU \)-small \hyperref[def:fol_structure]{first-order structures} and \hyperref[def:fol_homomorphism]{their homomorphisms}.

      \thmitem{def:fol_institution/models/hom} For the signature translation \( s: \Sigma \to \Theta \), we define the \hyperref[def:fol_institution/models/hom]{model reduct functor} \( \ucat{Mod}(s): \ucat{Mod}(\Theta) \to \ucat{Mod}(\Sigma) \) via the operator \( \red_s \) from \cref{def:fol_structure_reduct}.
    \end{thmenum}

    \thmitem{def:fol_institution/satisfaction} Finally, let the \hyperref[def:institution/satisfaction]{satisfaction} relation \( \mscrX \vDash_{\Sigma} \varphi \) hold for \( \mscrX = (X, I) \) if and only if \( \Bracks{\varphi}_\mscrX = T \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The cardinality restrictions discussed in \cref{rem:language_alphabet_cardinality/category} ensure that the formulas are hereditarily finite sets and thus belong to every \hyperref[def:grothendieck_universe]{Grothendieck universe}. Thus, they do not affect the \hyperref[def:category_size]{size} of the categories above.
\end{comments}
\begin{defproof}
  Fix a signature morphism \( s: \Sigma \to \Theta \) and a structure \( \mscrY = (Y, J) \) over \( \Theta \). We must verify \eqref{eq:def:institution/satisfaction}, which we restate here:
  \begin{equation*}
    \mscrY \vDash_\Theta \underbrace{\op*{Sen}(s)(\varphi)}_{\varphi[s]}
    \quad\T{if and only if}\quad
    \underbrace{\ucat{Mod}(s)}_{\red_s}(\mscrY) \vDash_\Sigma \varphi
  \end{equation*}

  This follows directly from \cref{thm:fol_structure_reduct_denotation}, which states that
  \begin{equation*}
    \Bracks[\big]{\varphi[s]}_\mscrY = \Bracks{\varphi}_{\red_s(\mscrY)}.
  \end{equation*}
\end{defproof}

\begin{definition}\label{def:fol_semantics}\mimprovised
  By the (\hyperref[def:truth_value_algebra/classical]{classical}) \enquote{\hyperref[con:syntax_semantics_duality]{semantics} of first-order logic} we mean the \hyperref[def:fol_institution]{first-order institutions} and all related notions like \hyperref[def:institution/models]{models}, \hyperref[def:institution/satisfaction]{satisfaction}, \hyperref[def:institutional_entailment]{semantic entailment} and \hyperref[def:semantic_equivalence]{semantic equivalence}.

  \begin{thmenum}
    \thmitem{def:fol_semantics/satisfaction} We use the terminology from \cref{def:institutional_satisfaction} regarding satisfaction and validity.

    However, as per \cref{rem:model_theory_structure_terminology}, unlike in general institutions, we refer to interpretations as \enquote{models} only with respect to a theory.

    Instead, we say that \( \mscrX \) is a \term[ru=модель (\cite[2.6.21]{Герасимов2014Вычислимость}), en=model (\cite[def. def.2.2.13(ii)]{Hinman2005Logic})]{model} \hi{of} the set of \hyperref[def:closed_fol_formula]{closed first-order formulas} \( \Gamma \) and write \( \mscrX \vDash \Gamma \) if and only if \( \Bracks{\varphi}_\mscrX = T \) for every formula \( \varphi \in \Gamma \).

    We also say that \( \varphi \) is \term[en=valid (\cite[144]{VanDalen2004LogicAndStructure})]{valid} in \( \mscrX \).

    \thmitem{def:fol_semantics/entailment} We use the terminology and notation from \cref{def:institutional_entailment} regarding entailment: \( \Gamma \vDash \varphi \) if and only if, whenever \( \mscrX \) satisfies \( \Gamma \), it also satisfies \( \varphi \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item \Fullref{thm:fol_semantic_deduction_theorem} may fail if we are not working with closed formulas; see \cref{rem:implicit_quantification_and_deduction}.
\end{comments}

\begin{theorem}[First-order semantic deduction theorem]\label{thm:fol_semantic_deduction_theorem}
  With respect to \hyperref[def:fol_semantics]{classical first-order semantics}, for \hyperref[def:closed_fol_formula]{closed formulas} we have
  \begin{equation*}
    \Gamma, \varphi \vDash \psi \T{if and only if} \Gamma \vDash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item It is important here that the formulas are closed --- see \cref{rem:implicit_quantification_and_deduction}.
  \item This is one of several deduction theorems presented here --- see \cref{rem:deduction_theorem_list/fol_semantic}.
\end{comments}
\begin{proof}
  Since the formulas are closed, we can prove the theorem analogously to \fullref{thm:propositional_semantic_deduction_theorem}.
\end{proof}

\paragraph{Implicit and explicit quantification}

\begin{definition}\label{def:fol_universal_closure}\mcite[def. 2.2.28]{Hinman2005Logic}
  We call a \term[ru=универсальное замыкание (\cite[89]{Герасимов2014Вычислимость})]{universal closure} of the \hyperref[def:hol_term/formula]{higher-order logical formula} \( \varphi \) any formula of the form
  \begin{equation*}
    \qforall {x_1} \ldots \qforall {x_n} \varphi,
  \end{equation*}
  where \( x_1, \ldots, x_n \) is an \hyperref[def:set_enumeration]{enumeration} of the free variables of \( \varphi \).

  Using the \hyperref[def:lexicographic_order]{lexicographic order} on the variables, we may pick a canonical closure, which we will simply call \enquote{the} (lexicographic) universal closure of \( \varphi \).
\end{definition}

\begin{definition}\label{def:fol_universal_validity}\mcite[105]{Hinman2005Logic}
  If, for some \hyperref[def:fol_formula]{first-order formula} \( \varphi \) and some \hyperref[def:fol_structure]{first-order structure} \( \mscrX \), the \hyperref[def:fol_denotation/formula]{denotation} \( \Bracks{ \varphi }_\mscrX^v \) equals \( T \) for any variable assignment \( v \) in \( \mscrX \), we say that \( \varphi \) is \term[ru=общезначимая (формула) (\cite[def. 2.4.1]{Герасимов2014Вычислимость})]{universally valid} in \( \mscrX \).
\end{definition}
\begin{comments}
  \item \hyperref[def:closed_fol_formula]{Closed formulas} are universally valid, but the notion is more general --- see \cref{rem:implicit_quantification_and_deduction}.

  \item Universal validity is closely related to \hyperref[def:fol_universal_closure]{universal closures} --- see \cref{thm:fol_universal_validity_iff_closure_validity}.
\end{comments}

\begin{proposition}\label{thm:fol_universal_validity_iff_closure_validity}
 A \hyperref[def:fol_formula]{first-order formula} is \hyperref[def:fol_universal_validity]{universally valid} in the \hyperref[def:fol_structure]{structure} \( \mscrX \) if and only if any of its \hyperref[def:fol_universal_closure]{universal closures} is \hyperref[def:fol_semantics/satisfaction]{valid} in \( \mscrX \).
\end{proposition}
\begin{comments}
  \item Universal closures are nevertheless better behaved than simply universally valid formulas --- see \cref{rem:implicit_quantification_and_deduction}.
\end{comments}
\begin{proof}
  Fix a \hyperref[def:hol_structure]{structure} \( \mscrX = (X, I) \) over the \hyperref[def:hol_signature]{signature} \( \Sigma \).

  Let \( \varphi \) be a formula and let \( x_1, \ldots, x_n \) be any ordering of its variables.

  \SufficiencySubProof Suppose that \( \Bracks{ \varphi }_\mscrX^v = T \) for any assignment \( v \). Then
  \begin{equation*}
    \Bracks{ \qforall {x_n} \varphi }_\mscrX^v
    \reloset {\eqref{eq:def:fol_denotation/formulas/forall}} =
    \bigwedge\set[\big]{ \Bracks{ \varphi }_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    =
    \bigwedge\set[\big]{ T \given* a \in X }
    =
    T.
  \end{equation*}

  Proceeding by induction, we conclude that
  \begin{equation*}
    \Bracks{ \qforall {x_1} \ldots \qforall {x_n} \varphi }_\mscrX^v = T.
  \end{equation*}

  Since \( v \) is arbitrary, we conclude that the universal closure of \( \varphi \) is valid in \( \mscrX \).

  \NecessitySubProof Conversely, suppose that \( \Bracks{ \qforall {x_1} \ldots \qforall {x_n} \varphi }_\mscrX = T \).

  Aiming at a contradiction, suppose that, for some assignment \( v_0 \), we have \( \Bracks{ \varphi }_\mscrX^{v_0} < T \). Then, for any assignment \( v \) in \( \mscrX \),
  \begin{equation*}
    \Bracks{ \qforall {x_n} \varphi }_\mscrX^v
    \reloset {\eqref{eq:def:fol_denotation/formulas/forall}} =
    \bigwedge\set[\big]{ \Bracks{ \varphi }_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    \leq
    \Bracks{ \varphi }_\mscrX^{v_0}
    <
    T.
  \end{equation*}

  By induction, we conclude that  \( \Bracks{ \qforall {x_1} \ldots \qforall {x_n} \varphi }_\mscrX^v < T \).

  The obtained contradiction shows that \( \varphi \) must be universally valid if its universal closure is.
\end{proof}

\begin{remark}\label{rem:intuitionistic_first_order_semantics}
  It is tempting to extend \cref{def:fol_denotation} so that the denotation of a first-order formula takes its \hyperref[def:truth_value_algebra]{truth values} over arbitrary \hyperref[def:heyting_algebra]{Heyting algebras} rather than taking only \hyperref[def:boolean_value]{Boolean values}. The definition extends transparently, but has undesired consequences.

  Fix a structure \( \mscrX = (X, I) \) and a variable assignment \( v: \op*{Var} \to X \). For any two terms \( \tau \) and \( \sigma \), the denotation of equality based on \hyperref[def:kronecker_delta]{Kronecker's \( \delta \) function} gives us
  \begin{equation*}
    \Bracks{\tau \syneq \sigma}_\mscrX^v
    =
    \delta(\Bracks{\tau}_\mscrX^v, \Bracks{\sigma}_\mscrX^v)
    =
    \begin{cases}
      T, &\Bracks{\tau}_\mscrX^v = \Bracks{\sigma}_\mscrX^v \\
      F, &\T{otherwise.}
    \end{cases}
  \end{equation*}

  As shown in \cref{def:kronecker_delta}, in any Heyting algebra the complement of \( T \) is \( F \) and vice versa. Thus,
  \begin{equation*}
    \Bracks{\tau \syneq \sigma}_\mscrX^v = T \T{if and only if} \Bracks{\synneg (\tau \syneq \sigma)}_\mscrX^v = F.
  \end{equation*}

  Therefore, the following formula is \hyperref[def:fol_universal_validity]{universally valid}:
  \begin{equation*}
    (\tau \syneq \sigma) \synvee \synneg (\tau \syneq \sigma)
  \end{equation*}

  This is a particular instance of the law \eqref{eq:thm:classical_tautologies/lem}. The \hyperref[con:brouwer_heyting_kolmogorov_interpretation]{Brouwer-Heyting-Kolmogorov} interpretation suggests that either \( \tau \syneq \sigma \) or \( \tau \syneq \sigma \) should be universally valid, but neither is.

  There is a more technical argument to be made. In the intuitionistic natural deduction system from \cref{def:fol_natural_deduction_systems}, the only equality rule introduction is \ref{inf:def:fol_natural_deduction_systems/equality/intro}, so, unless \( \tau \) coincides with \( \sigma \), a proof of the above must rely on discharging assumptions. A careful inspection shows that the intuitionistic rules \ref{inf:def:propositional_natural_deduction_systems/or/elim}, \ref{inf:def:propositional_natural_deduction_systems/imp/intro}, \ref{inf:def:propositional_natural_deduction_systems/iff/intro}, \ref{inf:def:fol_natural_deduction_systems/equality/intro} and \ref{inf:def:fol_natural_deduction_systems/eigenvariables/exists_elim} with dischargeable premises do not allow obtaining the desired proof tree. So, as defined, the natural deduction system is \hyperref[def:general_logic/completeness]{incomplete} with respect to our semantics.

  This particular denotation is also discussed in \cite{MathSE:topological_semantics_for_first_order_logic}, where generalized equivalence relations are suggested for evaluating equality. \incite*{Scott1968IntuitionisticAnalysis} suggests a particular adaptation of \hyperref[def:truth_value_algebra/topological]{topological semantics} for first-order logic.

  Since we are not generally interested in first-order intuitionistic semantics, we have restricted ourselves to classical logic.
\end{remark}

\begin{definition}\label{def:fol_implicit_universal_quantification}\mimprovised
  We can extend the satisfaction relation from \cref{def:fol_semantics/satisfaction} for arbitrary \hyperref[def:fol_formula]{first-order formulas} as follows.

  In a given \hyperref[def:fol_structure]{structure} \( \mscrX \), let \( \mscrX \vDash \varphi \) if and only if \( \Bracks{\varphi}_\mscrX^v = T \) for every variable assignment \( v \) in \( \mscrX \). Instead of using variable assignments, we can rely on the \hyperref[def:fol_universal_closure]{universal closure} of \( \varphi \) by requiring \( \Bracks{\qforall {x_1} \ldots \qforall {x_n} \varphi}_\mscrX = T \). This approach, which we will call \term{implicit universal quantification}, is used in \cite[def. 2.2.1]{Hinman2005Logic} and \cite[94]{Герасимов2014Вычислимость}.

  This easily extends to sets of formulas, so we let \( \mscrX \vDash \Gamma \) if and only if \( \mscrX \vDash \psi \) for every \( \psi \) in \( \Gamma \). For the corresponding entailment relation, let \( \Gamma \vDash \varphi \) if and only if \( \mscrX \vDash \varphi \) whenever \( \mscrX \vDash \Gamma \).
\end{definition}

\begin{remark}\label{rem:implicit_quantification_and_deduction}
  For first-order logic, we have defined the \hyperref[def:institution]{institution} in \cref{def:fol_institution} only for \hyperref[def:closed_fol_formula]{closed first-order formulas}. It is tempting to allow formulas with free variables via \hyperref[def:fol_implicit_universal_quantification]{implicit universal quantification}.

  Unfortunately, \fullref{thm:fol_semantic_deduction_theorem} no longer holds in this setting.

  Consider the following simple example. For any unary predicate symbol \( p \), with implicit quantification \cref{thm:fol_universal_validity_iff_closure_validity} implies that \( \mscrX \vDash p(x) \) if and only if \( \mscrX \vDash \qforall x p(x) \). Therefore,
  \begin{equation*}
    p(x) \gleichstark \qforall x p(x).
  \end{equation*}

  On the other hand, with a fixed structure \( \mscrX = (X, I) \) and variable assignment \( v: \op*{Var} \to X \), we have
  \begin{balign*}
    &\phantom{{}={}}
    \Bracks{ p(x) \synimplies \qforall x p(x) }_\mscrX^v
    \reloset {\eqref{eq:def:fol_denotation/formulas/conn}} = \\ &=
    \Bracks{ p(x) }_\mscrX^v \rightarrow \Bracks{ \qforall x p(x) }_\mscrX^v
    \reloset {\eqref{eq:def:fol_denotation/formulas/forall}} = \\ &=
    \Bracks{ p(x) }_\mscrX^v \rightarrow \bigwedge\set[\big]{ \Bracks{ p(x) }_\mscrX^{v_{x \mapsto a}} \given* a \in X }.
    \reloset {\eqref{eq:def:fol_denotation/formulas/pred}} = \\ &=
    p(v(x)) \rightarrow \bigwedge\set{ p(x) \given a \in X }.
  \end{balign*}

  This clearly fails if \( p(v(x)) = T \) and \( p(a) = F \) for some \( a \neq v(x) \).
\end{remark}
