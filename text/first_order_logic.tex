\section{First-order logic}\label{sec:first_order_logic}

First-order logic is a particularly convenient form of \hyperref[con:predicate_logic]{predicate logic}. We give here the following definition, and then dedicate several sections to explaining it:
\begin{definition}\label{def:first_order_logic}\mimprovised
  We call \term[ru=логика первого порядка (\cite[83]{Герасимов2014Вычислимость}), en=first-order logic (\cite[58]{VanDalen2004LogicAndStructure})]{first-order logic} the \hyperref[def:general_logic]{general logic} specified by the (\hyperref[def:truth_value_algebra/classical]{classical}) \hyperref[def:fol_institution]{first-order institution} and the corresponding \hyperref[def:fol_natural_deduction]{natural deduction system}.

  We will also consider more general natural deduction systems, but, as discussed in \cref{rem:intuitionistic_equality}, we will avoid studying the corresponding semantics because of its complications.
\end{definition}
\begin{comments}
  \item The soundness requirement in general logics from \cref{def:general_logic} is satisfied due to \fullref{thm:first_order_natural_deduction_soundness}.

  \item First-order logic can be regarded as a special case of \hyperref[def:higher_order_logic]{higher-order logic}. See \cref{ex:def:bounded_hol/first}.
\end{comments}

\paragraph{First-order signatures}

\begin{definition}\label{def:predicate_logic_alphabet}\mimprovised
  The \hyperref[def:formal_language/alphabet]{alphabet} of \hyperref[con:improper_symbol]{improper symbols} of \hyperref[con:predicate_logic]{predicate logic} extends the \hyperref[def:propositional_alphabet]{alphabet of propositional logic} and the \hyperref[def:substitution_schema_alphabet]{alphabet of substitution schemas} with the following new symbols:
  \begin{thmenum}
    \thmitem{def:predicate_logic_alphabet/quantifiers}\mcite[80]{Kleene2002Logic} The set \( \op*{Quant} \) of \term[ru=кванторы (\cite[82]{Герасимов2014Вычислимость})]{quantifiers}, namely
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/quantifiers/universal} The \term[ru=квантор всеобщости (\cite[86]{Герасимов2014Вычислимость})]{universal quantifier} \enquote{\( \synforall \)}.
      \thmitem{def:predicate_logic_alphabet/quantifiers/existential}\mcite[80]{Kleene2002Logic} The \term[ru=квантор существования (\cite[86]{Герасимов2014Вычислимость})]{existential quantifier} \enquote{\( \synexists \)}.
    \end{thmenum}

    \thmitem{def:predicate_logic_alphabet/equality}\mcite[def. 2.1.2(vi)]{Hinman2005Logic} The \hyperref[def:fol_signature/notation]{infix} \term{equality symbol} \enquote{\( \syneq \)}

    \thmitem{def:predicate_logic_alphabet/aux} In addition to the parentheses and brackets, two more auxiliary symbols:
    \begin{thmenum}
      \thmitem{def:predicate_logic_alphabet/aux/comma} The comma \enquote{\( , \)} for delimiting \hyperref[con:function_arguments]{function arguments}.

      \thmitem{def:predicate_logic_alphabet/aux/dot} The dot \enquote{\( . \)} for separating quantifiers from their bodies.

      \thmitem{def:predicate_logic_alphabet/aux/asterisk} The asterisk \enquote{\( * \)} for labeling \hyperref[def:fol_natural_deduction_proof_tree/eigenvariables]{eigenvariables}.
    \end{thmenum}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item This alphabet is intended for first-order logic, but will also be reused for higher-order logic in \fullref{sec:higher_order_logic}.

  \item As discussed in \cref{rem:quantifier_notation}, the dot has no functional role and is only used as visual aid for complicated formulas.

  \item We will need asterisks and substitutions when defining \hyperref[con:schemas_and_instances]{schemas} in \cref{def:fol_formula_schema}.
\end{comments}

\begin{definition}\label{def:fol_signature}\mcite[282]{Meseguer1989GeneralLogics}
  A \hyperref[con:logical_system_signature]{signature} \( \Sigma \) for first-order logic consists of the following:
  \begin{thmenum}
    \thmitem{def:fol_signature/functions} A possibly empty \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Fun}_\Sigma \), whose elements we call \term[ru=функциональные символы (\cite[84]{Герасимов2014Вычислимость})]{function symbols}.

    \thmitem{def:fol_signature/predicates} A possibly empty alphabet \( \op*{Pred}_\Sigma \), whose elements we call \term[ru=реляционные символы (\cite[84]{Герасимов2014Вычислимость})]{relation symbols}.

    \thmitem{def:fol_signature/arity}\mcite[38]{CitkinMuravitsky2022ConsequenceRelations} A function \( {\#}: \op*{Fun}_\Sigma \cup \op*{Pred}_\Sigma \to \BbbZ_{\geq 0} \) determining the corresponding symbol's \term[ru=арность (\cite[84]{Герасимов2014Вычислимость}); валентность (\cite[73]{ШеньВерещагин2017ЯзыкиИИсчисления})]{arity}.

    Based on this arity, we will use the prefixes from \cref{def:operation_arity_terminology} like \enquote{nullary}, \enquote{unary}, \enquote{binary}, etc.

    \thmitem{def:fol_signature/constants}\mcite[84]{Герасимов2014Вычислимость} We will call nullary functional symbols \term[ru=предметная константа, en=constants (\cite[83]{Hinman2005Logic})]{individual constants}.

    \thmitem{def:fol_signature/notation}\mimprovised In accordance with \cref{rem:fol_application_notation}, we allow \hyperref[def:set_partition]{partitioning} the set \( \op*{Fun}_\Sigma \cup \op*{Pred}_\Sigma \) of all signature symbols into three subsets called \( \op*{Prefix}_\Sigma \), \( \op*{Cond}_\Sigma \) (condensed notation) and \( \op*{Infix}_\Sigma \), based on the \hyperref[def:function_application_notation]{application notation} for we want to use.

    \begin{itemize}
      \item We force all nullary symbols into \( \op*{Cond}_\Sigma \), and assume that unary symbols belong there by default.
      \item We only allow binary symbols in \( \op*{Infix}_\Sigma \), and assume that all binary symbol belong there by default.
      \item All non-nullary symbols by default go to \( \op*{Prefix}_\Sigma \).
    \end{itemize}
  \end{thmenum}

  As per \cref{rem:improper_symbols_and_parsing}, we disallow as function or predicate symbols the \hyperref[con:improper_symbol]{improper symbols} from the \hyperref[def:predicate_logic_alphabet]{alphabet of predicate logic} and the \hyperref[def:inference_rule_alphabet]{alphabet of inference rules}, as well as the \hyperref[def:sequent_alphabet]{sequent relation symbol}.
\end{definition}
\begin{comments}
  \item We discuss in \cref{rem:language_alphabet_cardinality} some cardinality considerations; we mention here only that both alphabets are by default assumed to be finite. In accordance with \cref{rem:cardinality_auxiliary_terminology}, we use cardinality-related terminology like \enquote{finite} and \enquote{countably infinite} for the signature itself when we mean the larger of the cardinalities of the alphabets.

  \item Constant symbols are often separated from function symbols, for example in \cite[def. 2.1.2]{Hinman2005Logic} and \cite[def. 2.2.1]{VanDalen2004LogicAndStructure}. In these cases nullary predicate symbols are disallowed altogether.
\end{comments}

\begin{concept}\label{con:syntactic_translation}
  It is often the case that some \hyperref[con:expression]{expression} is defined in one \hyperref[con:metalanguage]{object language} but needed in another. A process by which we transform expressions systematically is called \term{syntactic translation}.
\end{concept}

\begin{definition}\label{def:fol_signature_category}\mcite[282]{Meseguer1989GeneralLogics}
  For a fixed \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \), assumed by default to be the universe \hyperref[def:universe_of_hereditary_finite_sets]{\( V_\omega \)} of hereditarily finite sets, we define the \hyperref[def:category]{category} \( \ucat{Sign} \) of \( \mscrU \)-small \hyperref[def:fol_signature]{first-order signatures} as follows:
  \begin{thmenum}
    \thmitem{def:fol_signature_category/objects} The objects are, unsurprisingly, the \( \mscrU \)-small signatures.

    \thmitem{def:fol_signature_category/morphisms} A signature morphism \( t: \Sigma \to \Theta \) simply maps the function symbols of \( \Sigma \) to function symbols of \( \Theta \) with the same arity, and analogously for predicate symbols.

    We allow changing the notation of a symbol, e.g. sending a prefix symbol to an infix symbol and vice versa.

    \thmitem{def:fol_signature_category/composition} The composition of morphisms is their set-theoretic composition.

    \thmitem{def:fol_signature_category/identity} The identity on \( \Sigma \) is simply the set-theoretic identity.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Signature morphisms will be used to define institutions in \cref{def:fol_institution}. We first need to construct the corresponding sentences and translations.
\end{comments}

\begin{definition}\label{def:fol_signature_extension}\mcite[def. 2.6.1]{Hinman2005Logic}
  We say that the \hyperref[def:fol_signature]{first-order signature} \( \Sigma^+ \) is an \term{extension} of \( \Sigma \) if every function or predicate symbol in \( \Sigma \) is also in \( \Sigma^+ \) and has the same arity and notation.
\end{definition}
\begin{comments}
  \item Every signature extension induces a \hyperref[def:fol_signature_category/morphisms]{signature morphism}.
\end{comments}

\paragraph{First-order terms}

\begin{definition}\label{def:fol_term}\mimprovised
  For a fixed \hyperref[def:fol_signature]{first-order signature} \( \Sigma \), we introduce a \hyperref[def:formal_grammar]{formal grammar} for \hyperref[con:predicate_logic/predicate]{terms}:
  \begin{bnf*}
    \bnfprod{individual variable}  {\bnfpn{Small Latin identifier}}                                  \\
    \bnfprod{term}                 {\bnfpn{individual variable} \bnfor \bnfpn{function application}}
  \end{bnf*}

  For every function symbol \( f \), we introduce a dedicated rule based on the function application grammar rules from \cref{def:function_application_notation}:
  \begin{bnfextra*}
    \bnfprod{function application} {f \bnfsp \bnftsq{(} \bnfsp \overbrace{\bnfpn{term} \bnfsp \bnftsq{,} \bnfsp \bnfsk \bnfsp \bnftsq{,} \bnfsp \bnfpn{term}}^{\# f \T*{terms separated by commas}} \bnfsp \bnftsq{)}} \bnfe{if \( f \in \op*{Prefix}_\Sigma \)} \\
    \bnfprod{function application} {\bnftsq{(} \bnfsp \bnfpn{term} \bnfsp f \bnfsp \bnfpn{term} \bnfsp \bnftsq{)}}                                                                                                               \bnfe{if \( f \in \op*{Infix}_\Sigma \)}  \\
    \bnfprod{function application} {f \bnfsp \underbrace{\bnfpn{term} \bnfsp \bnfsk \bnfsp \bnfpn{term}}_{\# f \T*{terms}}}                                                                                            \bnfe{if \( f \in \op*{Cond}_\Sigma \)}
  \end{bnfextra*}

  \begin{itemize}
    \item For the variables we have used the identifier rules from \cref{def:variable_identifier}.
    \item The function application rules are discussed in \cref{rem:fol_application_notation}.
  \end{itemize}

  We will denote the set of all \term[ru=индивидные переменные / предметные переменные (\cite[84]{Герасимов2014Вычислимость}), en=individual variables (\cite[57]{VanDalen2004LogicAndStructure})]{individuals variables} by \( \op*{Var} \) and the set of all \term{first-order terms} over \( \Sigma \) by \( \op*{Term}_\Sigma \).
\end{definition}
\begin{comments}
  \item A general discussion of terms and variables in predicate logic can be found in \cref{con:predicate_logic}.

  \item Within the metalanguage, we will denote abstract terms via \( \tau \), \( \sigma \), \( \rho \) and other letters in accordance with \cref{rem:mathematical_logic_conventions/greek_alphabet}. This convention will later lead us to a formal definition of formula schemas in \cref{def:fol_formula_schema}.

  \item We implicitly associate with each propositional formula an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} --- see \cref{def:fol_term_ast}. The grammar of first-order terms is unambiguous as shown via \cref{thm:fol_term_grammar/unambiguous}, which makes it possible to perform proofs via \fullref{thm:induction_on_abstract_syntax}.

  \item First-order terms are implemented in the module \identifier{math.logic.terms} in \cite{notebook:code}, with a parser in \identifier{math.logic.parsing}.
\end{comments}

\begin{remark}\label{rem:fol_application_notation}
  We have defined first-order terms in \cref{def:fol_term} so that function application differs syntactically between symbols using prefix, condensed prefix and infix notation. We will do the same in \cref{def:fol_formula} for predicate application. Supporting different notations greatly increases the readability of some symbolic expressions in \cite{notebook:code}.

  Examples of function and predicate symbols that use infix notation abound --- all binary operations from \fullref{ch:group_theory}, \fullref{ch:ring_theory} and \fullref{ch:order_theory}, as well as the order relations from the latter. Other examples include the binary Peano arithmetic operations in \fullref{sec:natural_numbers} and the set membership predicate and most defined operations in \fullref{ch:set_theory}.

  Examples of condensed notation are mostly restricted to unary operators, where writing parentheses adds little benefit. This includes nearly all unary operators from \fullref{ch:set_theory}, as well as various kinds of \hyperref[def:morphism_invertibility/involution]{involutions}, \hyperref[def:moore_closure_operator]{closure operators}, and the \hyperref[sec:trigonometric_functions]{trigonometric functions}.

  Unlike metalingual \enquote{abuse-of-notation} conventions like those in \cref{rem:fol_formula_conventions}, supporting more than prefix notation does not require sacrificing syntactic unambiguity or useful properties like the subterm characterization in \cref{thm:lambda_subterm_characterization}. Furthermore, we already support infix notation for connective and equality formulas, and condensed prefix notation for logical negation.

  One thing should be noted, however. Since we mostly deal with \hyperref[con:abstract_syntax_tree]{abstract syntax trees}, the actual notation is not relevant outside the object language. We want \fullref{alg:fol_term_signature_translation} to produce an isomorphic syntax tree, but we have allowed signature morphisms to exchange symbols with different notation.

  Correspondingly, when only the abstract structure of a term (or formula) is concerned, we assume that a metalingual schema for function application like \( f(x, y) \) encompasses prefix, infix and condensed prefix symbols. Otherwise, we would have to add meaningless cases when using \hyperref[con:evaluation]{pattern matching}. For instance, when defining term denotations in \cref{alg:fol_term_denotation}, we prefer writing
  \begin{equation*}
    \Bracks{\tau}_\mscrX^v \coloneqq \begin{cases}
      v(x),                                                                                &\tau = x \in \op*{Var}, \\
      I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &\tau = f(\sigma_1, \ldots, \sigma_n)
    \end{cases}
  \end{equation*}
  instead of
  \begin{equation*}
    \Bracks{\tau}_\mscrX^v \coloneqq \begin{cases}
      v(x),                                                                             &\tau = x \in \op*{Var}, \\
      I(\anon)\parens[\big]{ \Bracks{\sigma}_\mscrX^v, \Bracks{\rho}_\mscrX^v },           &\tau = \sigma \anon \rho, \\
      I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &\tau = f \sigma_1 \ldots \sigma_n, \\
      I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &\tau = f(\sigma_1, \ldots, \sigma_n)
    \end{cases}
  \end{equation*}
\end{remark}

\begin{proposition}\label{thm:fol_term_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:fol_term]{first-order terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:fol_term_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:fol_term_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:fol_term_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  We can prove the proposition similarly to \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{definition}\label{def:fol_subterm}\mimprovised
  We define the set of all \term{subterms} of a \hyperref[def:fol_term]{first-order term} \( \tau \) as follows:
  \begin{equation*}
    \op*{Subterm}(\tau) \coloneqq \begin{cases}
      \set{ x },                                                 &\tau = x \in \op*{Var}, \\
      \set{ \tau } \cup \bigcup_{k=1}^n \op*{Subterm}(\sigma_k), &\tau = f(\sigma_1, \ldots, \sigma_n).
    \end{cases}
  \end{equation*}

  We denote by \( \op*{Var}(\tau) \) those subterms of \( \tau \) that are variables.
\end{definition}

\begin{proposition}\label{thm:fol_term_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \rho \) of the first-order term \( \tau \) is a \hyperref[def:fol_subterm]{subterm} of \( \tau \) if and only if \( \rho \) is itself a formula.
\end{proposition}
\begin{proof}
  We can adapt the proof of \cref{thm:propositional_formula_characterization}. There are no variable binders, so we are safe from the \( \muplambda \)-term nuances in \cref{thm:lambda_subterm_characterization}.
\end{proof}

\begin{definition}\label{def:fol_term_ast}\mimprovised
  We implicitly associate with each first-order term \( \tau \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\tau) \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_term_ast/variable} If \( \tau \) is a variable, we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:fol_term_ast/application} If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), assuming we have built \( T(\sigma_k) \) for \( k = 1, \ldots, n \), we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( f \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__fol_term_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:closed_fol_term}\mcite[def. 2.3.8]{VanDalen2004LogicAndStructure}
  We say that a \hyperref[def:fol_term]{first-order term} is \term[ru=замкнутый терм (\cite[62]{КолмогоровДрагалин2006Логика})]{closed} if it has no variables.
\end{definition}
\begin{comments}
  \item Closed terms are also called \enquote{ground terms}, for example by \incite[def. 3.1.5]{BaaderNipkow2012TermRewriting}.
\end{comments}

\begin{algorithm}[Signature translation of first-order terms]\label{alg:fol_term_signature_translation}
  Given a \hyperref[def:fol_signature_category/morphisms]{signature morphism} \( t: \Sigma \to \Theta \), we can easily translate any \hyperref[def:fol_term]{first-order term} from \( \op*{Term}_\Sigma \) to \( \op*{Term}_\Theta \):
  \begin{equation*}
    \tau[t] \coloneqq \begin{cases}
      x,                                                     &\tau = x \in \op*{Var}, \\
      t(f)\parens[\big]{ \sigma_1[t], \ldots, \sigma_n[t] }, &\tau = f(\sigma_1, \ldots, \sigma_n).
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item As discussed in \cref{rem:fol_application_notation}, we allow translation to change the notation of symbols.
  \item This algorithm can be found as \identifier{math.logic.signature_translation.translate_term} in \cite{notebook:code}.
\end{comments}

\paragraph{First-order formulas}

\begin{definition}\label{def:fol_formula}\mimprovised
  For a fixed \hyperref[def:fol_signature]{first-order signature} \( \Sigma \), we introduce a \hyperref[def:formal_grammar]{formal grammar} for \hyperref[con:proposition]{formulas}:
  \begin{longbnf*}
    \bnfprod{equality formula}       {\bnftsq{(} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( \syneq \)} \bnfsp \bnfpn{term} \bnfsp \bnftsq{)}} \\
    \bnfprod{quantifier formula}     {\bnfpn{quantifier} \bnfsp \bnfpn{individual variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{formula}} \\
    \bnfprod{atomic formula}         {\bnfpn{constant formula} \bnfor} \\
    \bnfmore                         {\bnfpn{equality formula} \bnfor} \\
    \bnfmore                         {\bnfpn{predicate application} \bnfor} \\
    \bnfprod{formula}                {\bnfpn{atomic formula} \bnfor} \\
    \bnfmore                         {\bnfpn{negation formula} \bnfor} \\
    \bnfmore                         {\bnfpn{connective formula} \bnfor} \\
    \bnfmore                         {\bnfpn{quantifier formula}}
  \end{longbnf*}

  \begin{itemize}
    \item The \( \bnfpn{predicate application} \) rules are based on the analogous \( \bnfpn{function application} \) rules from \cref{def:fol_term}.

    \item The \( \bnfpn{individual variable} \) and \( \bnfpn{term} \) rules are also taken from \cref{def:fol_term}.

    \item The \( \bnfpn{negation formula} \) and \( \bnfpn{connective formula} \) rules are exactly as in for propositional formulas in \cref{def:propositional_formula}, so we have avoided stating them explicitly.

    \item The \( \bnfpn{quantifier} \) rule lists the corresponding symbols from the alphabet.
  \end{itemize}

  Similarly to the case of propositional formulas in \cref{def:propositional_subformula}, we denote by \( \op*{Form}_\Sigma \) the set of all \term[en=first-order formulas (\cite[23]{CitkinMuravitsky2022ConsequenceRelations})]{first-order formulas} over \( \Sigma \), and by \( \op*{Atom}_\Sigma \) those that are \term[ru=атомарные (формулы) (\cite[56]{КолмогоровДрагалин2006Логика}), en=atomic (formulas) (\cite[def. 2.1.8]{Hinman2005Logic})]{atomic}.
\end{definition}
\begin{comments}
  \item Within the metalanguage, we will denote abstract formulas via \( \varphi \), \( \psi \), \( \theta \) and other letters in accordance with \cref{rem:mathematical_logic_conventions/greek_alphabet}. This convention will later lead us to a formal definition of formula schemas in \cref{def:fol_formula_schema}.

  \item First-order formulas are implemented in \identifier{math.logic.formulas}, with a parser in \identifier{math.logic.parsing}.
\end{comments}

\begin{proposition}\label{thm:fol_formula_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:fol_formula]{first-order terms} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:fol_formula_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:fol_formula_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:fol_formula_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  The proof is more complicated, but similar to that of \cref{thm:propositional_formula_grammar}.
\end{proof}

\begin{remark}\label{rem:fol_formula_conventions}
  In order to simplify exposition, we use several \enquote{abuse-of-notation} conventions. As in the case of \cref{rem:propositional_formula_notation_conventions}, these exist only in the metalanguage and the formulas themselves are assumed to have the former form within the object language.
  \begin{thmenum}
    \thmitem{rem:fol_formula_conventions/parentheses} We use the parentheses conventions from \cref{rem:propositional_formula_notation_conventions}.

    \thmitem{rem:fol_formula_conventions/notation} As discussed in \cref{rem:fol_application_notation}, we will mostly disregard the difference between different notation for function and predicate applications if we are only interested in the \hyperref[con:abstract_syntax_tree]{abstract syntax trees} of the terms and formulas.

    \thmitem{rem:fol_formula_conventions/relativization} Bounded quantifiers, which we discuss in general in \cref{con:predicate_logic/relativization}, are not allowed by the syntax of first-order logic.

    For any predicate \( p(x, \cdots) \), we use the following notational shorthands:
    \begin{center}
      \begin{tabular}{l l}
        \multicolumn{1}{c}{Formula}           & \multicolumn{1}{c}{Formula} \\
        \midrule
        \( \qforall {p(x, \cdots)} \varphi \) & \( \qforall x \parens[\big]{ p(x, \cdots) \synimplies \varphi } \) \\
        \( \qexists {p(x, \cdots)} \varphi \) & \( \qexists x \parens[\big]{ p(x, \cdots) \synwedge \varphi } \)   \\
      \end{tabular}
    \end{center}

    The particular choice of abbreviations is justified in \cref{thm:fol_quantifier_duality_relativized}.

    \thmitem{rem:fol_formula_conventions/unique_existence} We will use the abbreviation in \cref{rem:exists_unique_abbreviation} to emulate the unique existence quantifier \( \qExists x \varphi \) discussed in \cref{con:description_operator/unique_existence}.

    \thmitem{rem:fol_formula_conventions/necessary_signature} We will build our theories with minimal signatures and then legitimize new symbols via \hyperref[def:fol_definitional_extension]{definitional extensions}. This is formally justified by \cref{thm:fol_definitional_extension_conservative}, which shows that such an extension is necessarily \hyperref[def:fol_conservative_extension]{conservative}.

    An example is \fullref{ch:set_theory}, where we start with only the relation \( {\synin} \), but soon add many other functional and relation symbols. Then in \fullref{sec:zermelo_fraenkel_set_theory} we prove that these constitute valid definitional extensions in \logic{ZFC}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:fol_subformula}\mimprovised
  Analogously to how we handled propositional subformulas in \cref{def:propositional_subformula}, we define the set of all \term{subformulas} of a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as follows:
  \begin{equation*}
    \op*{Subform}(\varphi) \coloneqq \begin{cases}
      \set{ \varphi },                                                        &\varphi \in \op*{Atom}_\Sigma, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \synneg \psi, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi) \cup \op*{Subform}(\theta), &\varphi = \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \set{ \varphi } \bigcup \op*{Subform}(\psi),                            &\varphi = \quantifier Q x \psi, Q \in \op*{Quant.}
    \end{cases}
  \end{equation*}

  The only difference is the presence of the quantifier case.
\end{definition}

\begin{proposition}\label{thm:fol_formula_characterization}
  The \hyperref[def:formal_language/substring]{substring} \( \psi \) of the first-order term \( \varphi \) is a \hyperref[def:fol_subformula]{subformula} of \( \varphi \) if and only if \( \psi \) is itself a formula.
\end{proposition}
\begin{proof}
  Like in the case of \( \muplambda \)-terms in \cref{thm:lambda_subterm_characterization}, there are variable binders, but unlike in that case, the variables themselves are not considered formulas. So, there are no nuances to handle, and we can proceed as in the propositional case in \cref{thm:propositional_formula_characterization}.
\end{proof}

\begin{definition}\label{def:fol_formula_ast}\mimprovised
  We implicitly associate with each first-order formula \( \varphi \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\varphi) \) as follows:
  \begin{thmenum}
    \thmitem{def:fol_formula_ast/const} If \( \varphi \) is a logical constant, i.e. \( \syntop \) or \( \synbot \), we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:fol_formula_ast/equality} If \( \varphi = \tau \syneq \sigma \), assuming we have built \( T(\tau) \) and \( T(\sigma) \) in accordance with \cref{def:fol_formula_ast}, we define \( T(\varphi) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( \syneq \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/application} If \( \varphi = p(\tau_1, \ldots, \tau_n) \), assuming we have built \( T(\tau_k) \) for \( k = 1, \ldots, n \) in accordance with \cref{def:fol_formula_ast}, we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} these trees to a new root labeled with \( p \):
    \begin{equation*}
      \includegraphics[page=2]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/negation} Analogously to the propositional negation trees from \cref{def:propositional_formula_ast/negation}, if \( \varphi = \synneg \psi \), assuming we have already built \( T(\psi) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) to a new root labeled with \( \synneg \):
    \begin{equation*}
      \includegraphics[page=3]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/connective} Analogously to the propositional connective formula trees from \cref{def:propositional_formula_ast/connective}, if \( \varphi = \psi \syncirc \theta \), assuming we have built \( T(\psi) \) and \( T(\theta) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) and \( T(\theta) \) to a new root labeled with \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=4]{output/def__fol_formula_ast}
    \end{equation*}

    \thmitem{def:fol_formula_ast/quantifier} Analogously to the untyped \( \muplambda \)-abstraction trees from \cref{def:lambda_term_ast/abstraction}, if \( \varphi = \quantifier Q x \psi \), where \( Q \) is a quantifier, assuming we have built \( T(\psi) \), we define \( T(\varphi) \) by grafting \( T(\psi) \) to a new root labeled with \( Q x \):
    \begin{equation*}
      \includegraphics[page=5]{output/def__fol_formula_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{algorithm}[Signature translation of first-order formulas]\label{alg:fol_formula_signature_translation}
  Given a \hyperref[def:fol_signature_category/morphisms]{signature morphism} \( t: \Sigma \to \Theta \), we can translate any \hyperref[def:fol_formula]{first-order formula} from \( \op*{Form}_\Sigma \) to \( \op*{Form}_\Theta \) with the aid of \fullref{alg:fol_term_signature_translation}:
  \begin{equation*}
    \varphi[t] \coloneqq \begin{cases}
      \varphi,                                                                 &\varphi = \syntop \T{or} \varphi = \synbot, \\
      \tau[t] \syneq \sigma[t],                                                &\varphi = (\tau \syneq \sigma), \\
      t(p)\parens[\big]{ \tau_1[t], \ldots, \tau_n[t]) },                      &\varphi = p(\tau_1, \ldots, \tau_n), \\
      \hyperref[rem:straightforward_traversal]{\T{straightforward traversal}}, &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{algorithm}
\begin{comments}
  \item As discussed in \cref{rem:fol_application_notation}, we allow exchanging prefix and infix symbols.

  \item This straightforward algorithm becomes powerful when combined with \hyperref[def:fol_definitional_extension]{definitional extensions}; see \cref{rem:signature_translation_and_definitional_extensions}.

  \item This algorithm can be found as \identifier{math.logic.signature_translation.translate_formula} in \cite{notebook:code}.
\end{comments}

\paragraph{Variable binding}

\begin{definition}\label{def:fol_variable_occurrence}\mimprovised
  Similarly to variable occurrences of \( \muplambda \)-terms defined in \cref{def:lambda_variable_occurrence}, we define an \term[en=occurrence (\cite[63]{VanDalen2004LogicAndStructure})]{occurrence} of an individual variable \( x \) in a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as a variable node with label \( x \) in the \hyperref[def:fol_formula_ast]{abstract syntax tree} of \( \varphi \).

  We analogously call a variable occurrence of \( x \) \term[ru=свободное (вхождение) (\cite[88]{Герасимов2014Вычислимость}), en=free occurrence (\cite[def. 9.1.2]{CitkinMuravitsky2022ConsequenceRelations})]{free} in \( \varphi \) if the root of the AST can be reached without passing through a quantifier. If an occurrence is not free, we say that it is \term[ru=связоное (вхождение) (\cite[88]{Герасимов2014Вычислимость}), en=bound occurrence (\cite[def. 9.1.2]{CitkinMuravitsky2022ConsequenceRelations})]{bound}.
\end{definition}

\begin{definition}\label{def:fol_variable_freeness}\mcite[88]{Герасимов2014Вычислимость}
  In analogy with how we handled variable freeness in \( \muplambda \)-terms defined in \cref{def:lambda_variable_freeness}, we say that a variable \( x \) is \term[ru=свободная (переменная), en=free (variable) (\cite[63]{VanDalen2004LogicAndStructure})]{free} in a first-order formula \( \varphi \) if \( x \) has at least one \hyperref[def:fol_variable_occurrence]{free occurrence} in \( \varphi \) and \term[ru=связанная (переменная), en=bound (variable) (\cite[63]{VanDalen2004LogicAndStructure})]{bound} if it has a \hyperref[def:lambda_variable_occurrence]{bound occurrence} in \( M \).
\end{definition}
\begin{comments}
  \item We may use the recursive definitions from \cref{thm:fol_variable_freeness_characterization} instead.
\end{comments}

\begin{proposition}\label{thm:fol_variable_freeness_characterization}
  The set of all \hyperref[def:fol_variable_freeness]{free variables} of a first-order formula can be characterized as follows:
  \begin{equation*}
    \op*{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                &\varphi = \syntop \T{or} \varphi = \synbot, \\
      \op*{Var}(\tau) \cup \op*{Var}(\sigma),     &\varphi = \tau \syneq \sigma, \\
      \bigcup_{k=1}^n \op*{Var}(\tau_k),          &\varphi = p(\tau_1, \ldots, \tau_n), \\
      \op*{Free}(\psi),                           &\varphi = \synneg \psi, \\
      \op*{Free}(\psi) \cup \op*{Free}(\theta),   &\varphi = \synneg \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \op*{Free}(\psi) \setminus \set{ x },       &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}

  Similarly, the bound variables can be characterized via
  \begin{equation*}
    \op*{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                &\varphi \in \op*{Atom}_\Sigma, \\
      \op*{Bound}(\psi),                          &\varphi = \synneg \psi, \\
      \op*{Bound}(\psi) \cup \op*{Bound}(\theta), &\varphi = \synneg \psi \syncirc \theta, {\syncirc} \in \op*{Conn}, \\
      \op*{Bound}(\psi) \cup \set{ x },           &\varphi = \quantifier Q x \psi, Q \in \op*{Quant}.
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item We show an analogous result for \( \muplambda \)-terms in \cref{thm:lambda_variable_freeness_characterization}.
\end{comments}
\begin{proof}
  Straightforward.
\end{proof}

\begin{definition}\label{def:closed_fol_formula}\mcite[def. 2.3.8]{VanDalen2004LogicAndStructure}
  We say that a \hyperref[def:fol_formula]{first-order formula} is \term[ru=замкнутая формула (\cite[61]{КолмогоровДрагалин2006Логика})]{closed} if it has no \hyperref[def:fol_variable_freeness]{free variables}. Closed formulas are also called \term[ru=предложения (\cite[61]{КолмогоровДрагалин2006Логика})]{sentences}.
\end{definition}
\begin{comments}
  \item In fact, \enquote{sentence} is a more general placeholder word used in many definitions in \cref{sec:logical_consequence}. As discussed in \cref{rem:implicit_quantification_and_deduction}, allowing arbitrary formulas breaks some important results like \fullref{thm:fol_semantic_deduction_theorem}, so we will we will only consider closed formulas for the sentence functor when defining an \hyperref[def:institution]{institution} in \cref{def:fol_institution/sentences}.

  There will be cases like the binary relation axioms in \cref{def:binary_relation} where we will adapt non-closed formulas using \hyperref[def:fol_implicit_universal_quantification]{implicit universal quantification}, but we will use this convention sparingly.
\end{comments}

\paragraph{First-order denotation}

\begin{definition}\label{def:fol_structure}\mcite[def. 2.2.3]{Герасимов2014Вычислимость}
  A \term[en=structure (\cite[def. 2.1.15]{Hinman2005Logic})]{structure} \( \mscrX = (X, I) \) over the \hyperref[def:fol_signature]{first-order signature} \( \Sigma \) consists of the following:
  \begin{thmenum}
    \thmitem{def:fol_structure/universe} A set \( X \), called a \term[ru=носитель (\cite[def. 2.2.4]{Герасимов2014Вычислимость}), en=universe (\cite[def. 2.1.15]{Hinman2005Logic})]{universe}.

    Unless explicitly noted otherwise, we require \( X \) to be nonempty. See \cref{rem:fol_empty_universe/semantics} for a broader discussion.

    \thmitem{def:fol_structure/interpretation} A map \( I \), called an \term{interpretation}, that sends each \( n \)-ary function symbol to a function \( X^n \to X \) and every \( n \)-ary predicate to a \hyperref[def:boolean_function]{Boolean-valued function} \( X^n \to \set{ \semtop, \sembot } \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item In accordance with \cref{rem:cardinality_auxiliary_terminology}, we use cardinality-related terminology like \enquote{finite} and \enquote{countably infinite} for the structure itself when we mean the cardinality of the universe.

  \item Structures require nontrivial adaptations for \hyperref[con:intuitionistic_logic]{intuitionistic logic}; see \cref{rem:intuitionistic_equality}.

  \item Both \enquote{universe} and \enquote{interpretation}, as well other related terms, are used inconsistently in the literature. See \cref{rem:model_theory_structure_terminology}.
\end{comments}

\begin{remark}\label{rem:model_theory_structure_terminology}
  \hyperref[def:propositional_interpretation]{Propositional interpretations}, \hyperref[def:fol_structure]{first-order structures} and \hyperref[def:hol_structure]{higher-order structures} can act as \hyperref[con:logical_model]{models} for the corresponding \hyperref[def:logical_theory]{logical theories}. In particular, they act as models in the corresponding \hyperref[def:institution]{institutions}. Unlike in general institutions, however, we refer to them as \enquote{models} only with respect to a theory.

  \begin{table}[!ht]
    \centering
    \scriptsize
    \begin{tabular}{*{6}{l}}
      \toprule
      Source                                                      & Structure          & Universe    & Interpretation   & Assignment & Denotation     \\
      \midrule
      \cite[ch. 2]{Hinman2005Logic}                               & Structure          & Universe    & ---              & Assignment & Denotation     \\
      \cite[ch. 2]{VanDalen2004LogicAndStructure}                 & Structure          & Universe    & ---              & ---        & Interpretation \\
      \cite[\S 13.6.1]{TroelstraVanDalen1988ConstructivismVol2}   & Structure          & ---         & ---              & ---        & ---            \\
      \cite[84]{Kleene2002Logic}                                  & ---                & Domain      & Assignment       &            & ---            \\
      \cite[115]{Andrews2002Logic}                                & Interpretation     & Domain      & Assignment       &            & Value          \\
      \cite[70, 72, 73]{КолмогоровДрагалин2006Логика}             & Интерпретация      & Носитель    & Интерпретация    & ---        & Значение       \\
                                                                  & (interpretation)   & (carrier)   & (interpretation) & ---        & (value)        \\
      \cite[142]{Мальцев1970АлгебраическиеСистемы}                & Алгебр. система    & ---         & ---              & ---        & Значение       \\
                                                                  & (algebraic system) &             &                  & ---        & (value)        \\
      \cite[ch. 3]{ШеньВерещагин2017ЯзыкиИИсчисления}             & ---                & ---         & Интерпретация    & Оценка     & Значение       \\
                                                                  &                    &             & (interpretation) & (value)    & (value)        \\
      \cite[ch. 2]{Эдельман1975Логика}                            & Модель             & Основн. мн. &                  &            &                \\
                                                                  & (model)            & (fund. set) &                  &            &                \\
      \cite[\S 2.2]{Герасимов2014Вычислимость}                    & Интерпретация      & Носитель    & ---              & Оценка     & Значение       \\
                                                                  & (interpretation)   & (carrier)   &                  & (value)    & (value)        \\
      \bottomrule
    \end{tabular}
    \caption{A terminological comparison for \hyperref[def:fol_structure]{first-order structures}.}\label{tab:rem:model_theory_structure_terminology}
  \end{table}

  As it often happens, the terminology is inconsistent across authors. As an example, in \cref{tab:rem:model_theory_structure_terminology} we list some of the terminology for \hyperref[def:fol_structure]{first-order structures} used by different authors. Their entire formulations are so fundamentally different that making an explicit comparison beyond the essential result is not worth the effort. This is unlike most cases outside logic, where the differences are indeed terminological (see e.g. \cref{rem:sigma_algebra_terminology} for algebras of subsets or \cref{rem:graph_walk_terminology} for graph walks).

  For propositional logic, the comparison is somewhat simpler because there is only one concept involved --- that of a (classical) \hyperref[def:propositional_interpretation]{propositional interpretation}. It is called an \enquote{assignment} in \cite[50]{Andrews2002Logic}, an \enquote{atomic truth assignment} in \cite[def. 1.1.6]{Hinman2005Logic}, a \enquote{denotation} in \cite[def. 1.2.1]{VanDalen2004LogicAndStructure}, \cite[\S 2.5.6]{Mimram2020ProgramEqualsProof} and \cite[\S 3.2]{CitkinMuravitsky2022ConsequenceRelations}, and an \enquote{interpretation} (\enquote{интерпретация}) in \cite[def. 1.1.10]{Герасимов2014Вычислимость}.

  For higher-order logic, Henkin's original terminology from \cite[84]{Henkin1950CompletenessInTheoryOfTypes} seems to be respected by \cite[238]{Andrews2002Logic} and \cite[271]{Farmer2008STTVirtues}. We will slightly deviate from this in \fullref{sec:henkin_semantics} in order to say consistent with our presentation of first-order logic.
\end{remark}

\begin{remark}\label{rem:fol_structure_notation}
  We have defined a \hyperref[def:fol_structure]{first-order structure} as a pair \( \mscrX = (X, I) \). Each area of mathematics has its own conventions and structures are usually specified as simply as possible without being ambiguous.

  One convention is to denote the universes via compatible letters like we did with \( X \) and \( \mscrX \), or like we would do with \( G \) and \( \mscrG \). Such notation is used, for example, by \incite[def. II.1.2]{Эдельман1975Логика}.

  This allows us to say \enquote{Let \( \mscrP = (P, \leq_P) \) and \( \mscrQ = (Q, \leq_Q) \) be \hyperref[def:partially_ordered_set]{partially ordered sets}} and easily keep track which is which.

  Outside logic, for more complicated signature like that of the \hyperref[def:group/theory]{theory of groups}, it is burdensome to specify the entire interpretation since it is tantamount specifying a quadruple \( (G, e, (\anon)^{-1}, \cdot) \). Often it is sufficient to write only the domain \( G \) and say \enquote{let \( G \) be a group}. Since the binary operation of the group determines the others, we may also say \enquote{let \( (G, \ast) \) be a group} instead of \enquote{let \( G \) be a group with respect to some operation \( {\ast} \)}. This is technically wrong, but it is both convenient and conventional. The rest of the definition of the group can easily be inferred. In case of ambiguity, the simplest disambiguation is to use lower indices with the name of the structure, e.g. \( +_G \) and \( +_H \) may be the addition operation in different abelian groups.
\end{remark}

\begin{definition}\label{def:fol_variable_assignment}\mcite[def. 2.1.17; 92]{Andrews2002Logic}
  A \term[ru=оценка (\cite[def. 2.2.7]{Герасимов2014Вычислимость}), en=variable assignment (\cite[271]{Farmer2008STTVirtues}); assignment (\cite[def. 2.1.17]{Hinman2005Logic})]{variable assignment} in a given \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \) is any function \( v: \op*{Var} \to X \).

  For every variable \( x \) and every \( a \) from \( X \) we also define the \term{modified assignment} of \( v \) at \( x \) with \( a \):
  \begin{equation*}
    v_{x \mapsto a}(y) \coloneqq \begin{cases}
      a,    &y = x, \\
      v(y), &\T{otherwise.}
    \end{cases}
  \end{equation*}

  For more than one variable, we use the notation
  \begin{equation*}
    v_{x_1 \mapsto a_1, \ldots, x_n \mapsto a_n}(y) \coloneqq ((\ldots(v_{x_1 \mapsto a_1})\ldots)_{x_n \mapsto a_n})(y).
  \end{equation*}

  We can also modify \( v \) at \( x \) with a variable \( z \):
  \begin{equation*}
    v_{x \mapsto z}(y) \coloneqq \begin{cases}
      v(z),   &y = x, \\
      v(y), &\T{otherwise.}
    \end{cases}
  \end{equation*}
\end{definition}
\begin{comments}
  \item \incite{Andrews2002Logic} introduces no term for modified assignments, and neither do \cite[rem. 2.2.17]{Hinman2005Logic} or \cite[def. 2.2.9]{Герасимов2014Вычислимость}.

  \item Modified assignments are needed for defining denotations for quantifier formulas in \cref{alg:fol_formula_denotation}, but are also useful on other places like \cref{thm:renaming_assignment_compatibility}.
\end{comments}

\begin{algorithm}[First-order term denotation]\label{alg:fol_term_denotation}\mimprovised
  Fix a \hyperref[def:fol_structure]{first-order structure} \( \mscrX = (X, I) \) over \( \Sigma \), as well as a \hyperref[def:fol_variable_assignment]{variable assignment} \( v: \op*{Var} \to X \).

  We define the \term[ru=значение (терма) (\cite[def. 2.2.9]{Герасимов2014Вычислимость}), en=denotation (\cite[91]{Hinman2005Logic})]{denotation} \( \Bracks{\tau}_\mscrX^v \) of a \hyperref[def:fol_term]{first-order term} \( \tau \) as follows:
  \begin{empheq}[left={\Bracks{\varphi}_I} \coloneqq \empheqlbrace]{align}
    &v(x),                                                                                &&\tau = x \in \op*{Var},                   \label{eq:alg:fol_term_denotation/var} \\
    &I(f)\parens[\big]{ \Bracks{\sigma_1}_\mscrX^v, \ldots, \Bracks{\sigma_n}_\mscrX^v }, &&\tau = f(\sigma_1, \ldots, \sigma_n). \label{eq:alg:fol_term_denotation/fun}
  \end{empheq}

  If \( \tau \) is a \hyperref[def:closed_fol_term]{closed term}, the \hyperref[alg:fol_formula_denotation]{denotation} \( \Bracks{\tau}_\mscrX^v \) does not depend on \( v \), and we simply write \( \Bracks{\tau}_\mscrX \).
\end{algorithm}
\begin{comments}
  \item The term \enquote{denotation} is inspired by Russell's theory of denotations discussed in \cref{con:denotation}. It is used inconsistently in the literature. See \cref{rem:model_theory_structure_terminology}.

  \item First-order denotations are implemented as \identifier{evaluate_term} and \identifier{evaluate_formula} in the module \identifier{math.logic.structure} in \cite{notebook:code}.
\end{comments}

\begin{definition}\label{def:fol_parameterized_term_denotation}
  We can define \hyperref[con:parametrized_denotation]{parametrized denotations} based on \fullref{alg:fol_term_denotation}. Assuming that \( \op*{Var}(\tau) \subseteq \set{ x_1, \ldots, x_n } \), consider the function
  \begin{equation*}
    \begin{aligned}
      &\Bracks{\tau}_\mscrX: X^n \to X, \\
      &\Bracks{\tau}_\mscrX(a_1, \ldots, a_n) \coloneqq \Bracks{\tau}_\mscrX^v,
    \end{aligned}
  \end{equation*}
  where \( v \) is any variable assignment such that \( v(x_k) = a_k \) for \( k = 1, \ldots, n \).

  Unless otherwise noted, we assume that \( x_1, \ldots, x_n \) are precisely the variables of \( \tau \) ordered lexicographically.
\end{definition}

\begin{definition}\label{def:kronecker_delta}\mimprovised
  We define the \term[ru=дельта-функция Кронекера (\cite[45]{БарановСтечкин2004ЭкстремальнаяКомбинаторика}), en=Kronecker delta function (\cite[16]{Hall1986CombinatorialTheory})]{Kronecker delta function} on a \hyperref[def:semiring]{semiring} \( R \) as
  \begin{equation}\label{eq:def:kronecker_delta}
    \delta_{i,j} \coloneqq \begin{cases}
      1_R, &i = j, \\
      0_R, &i \neq j.
    \end{cases}
  \end{equation}

  It is also traditionally called the \term[bg=символ на Кронекер (\cite[26]{Боянов2008ЧислениМетоди}), ru=символ Кронекера (\cite[461]{Тыртышников2007ЛинейнаяАлгебра}), en=Kronecker delta symbol (\cite[33]{Knuth1997ArtVol1}); Kronecker symbol (\cite[213]{Bourbaki1998Algebra1to3})]{Kronecker delta symbol}.

  The definition naturally extends to a \hyperref[con:truth_value_algebra]{truth value algebra}, where it becomes
  \begin{equation}\label{eq:def:kronecker_delta/truth}
    \delta_{i,j} = \begin{cases}
      \semtop, &i = j, \\
      \sembot, &i \neq j.
    \end{cases}
  \end{equation}
\end{definition}
\begin{comments}
  \item We generalize the \enquote{Kronecker symbol} from \cite[213]{Bourbaki1998Algebra1to3} from rings to semirings, so that we are able to encompass truth value algebras. We use the latter when defining denotations for equality in \hyperref[def:fol_structure]{first-order structures}.
\end{comments}

\begin{algorithm}[First-order formula denotation]\label{alg:fol_formula_denotation}\mimprovised
  Fix a \hyperref[def:fol_structure]{first-order structure} \( \mscrX = (X, I) \) over \( \Sigma \), as well as a \hyperref[def:fol_variable_assignment]{variable assignment} \( v: \op*{Var} \to X \).

  We define the \term[ru=истинностное значение (формулы) (\cite[def. 2.2.10]{Герасимов2014Вычислимость}), en=denotation (\cite[91]{Hinman2005Logic})]{denotation} \( \Bracks{\varphi}_\mscrX^v \) of a \hyperref[def:fol_formula]{first-order formula} \( \varphi \) as follows:
  \begin{empheq}[left={\Bracks{\varphi}_\mscrX^v} \coloneqq \empheqlbrace]{align}
    &\semtop,                                                                         &&\varphi = \syntop,                   \label{eq:alg:fol_formula_denotation/formulas/top} \\
    &\sembot,                                                                         &&\varphi = \synbot,                   \label{eq:alg:fol_formula_denotation/formulas/bot} \\
    &\oline{\Bracks{\psi}_\mscrX^v},                                                  &&\varphi = \synneg \psi,              \label{eq:alg:fol_formula_denotation/formulas/neg} \\
    &\Bracks{\psi}_\mscrX^v \bincirc \Bracks{\theta}_\mscrX^v,                        &&\varphi = \psi \syncirc \theta,      \label{eq:alg:fol_formula_denotation/formulas/conn} \\
    &\delta\parens[\big]{ \Bracks{N}_\mscrX^v, \Bracks{K}_\mscrX^v },                 &&\varphi = (N \syneq K),              \label{eq:alg:fol_formula_denotation/formulas/eq} \\
    &I(p)\parens[\big]{ \Bracks{\tau_1}_\mscrX^v, \ldots, \Bracks{\tau_n}_\mscrX^v }, &&\varphi = p(\tau_1, \ldots, \tau_n), \label{eq:alg:fol_formula_denotation/formulas/pred} \\
    &\bigwedge\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X },   &&\varphi = \qforall x \psi,           \label{eq:alg:fol_formula_denotation/formulas/forall} \\
    &\bigvee\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X },     &&\varphi = \qexists x \psi,           \label{eq:alg:fol_formula_denotation/formulas/exists}
  \end{empheq}

  Most of the cases above are simply the familiar propositional denotation rules from \fullref{alg:propositional_denotation}.
  \begin{itemize}
    \item In \eqref{eq:alg:fol_formula_denotation/formulas/eq}, \( \delta \) is \hyperref[def:kronecker_delta]{Kronecker's delta function}. Only this case must be generalized for \hyperref[con:intuitionistic_logic]{intuitionistic logic} --- see \cref{rem:intuitionistic_equality}.

    \item In \eqref{eq:alg:fol_formula_denotation/formulas/pred}, we utilize predicate functions from the structure's interpretation.

    \item The cases \eqref{eq:alg:fol_formula_denotation/formulas/forall} and \eqref{eq:alg:fol_formula_denotation/formulas/exists} evaluates \( \psi \) using a \hyperref[def:hol_variable_assignment/modified]{modified assignment} parameterized by the elements of \( X_\sigma \). We see here why it is important that the \hyperref[def:truth_value_algebra/classical]{classical truth value algebra} is \hyperref[def:heyting_algebra/complete]{complete}.
  \end{itemize}

  If the denotation \( \Bracks{\varphi}_\mscrX^v \) does not depend on \( v \), we use the simpler notation \( \Bracks{\varphi}_\mscrX \). Unlike for terms, this can happen even if \( \varphi \) is not a \hyperref[def:closed_fol_formula]{closed formula} --- see \cref{rem:implicit_quantification_and_deduction}.
\end{algorithm}
\begin{comments}
  \item The term \enquote{denotation} is inspired by Russell's theory of denotations discussed in \cref{con:denotation}. It is used inconsistently in the literature. See \cref{rem:model_theory_structure_terminology}.

  \item First-order denotations are implemented as \identifier{evaluate_term} and \identifier{evaluate_formula} in the module \identifier{math.logic.structure} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:fol_empty_universe/semantics}
  In \cref{def:fol_structure}, we have explicitly disallowed the universe \( X \) of a first-order structure \( \mscrX = (X, I) \) to be empty.

  Without this restriction, \( I \) must interpret predicate and function symbols of positive arity as empty functions. But there is no way to interpret individual constants. Similarly, it is not possible to define \hyperref[def:fol_variable_assignment]{variable assignments}. As shown in \cref{rem:fol_empty_universe/natural_deduction}, proof theory is similarly unprepared for such cases.

  Nevertheless, as long as we restrict ourselves to closed formulas over a signature without individual constants, empty structures are sometimes useful. Such cases includes the theories of \hyperref[def:preordered_set]{preordered sets} and \hyperref[def:semigroup]{semigroup}, as well as higher-order theories like that of \hyperref[def:topological_space]{topological spaces}.
\end{remark}

\begin{proposition}\label{thm:fol_equality_characterization}
  \Fullref{alg:fol_formula_denotation} is defined so that, for any equality formula \( (\tau \syneq \sigma) \) and any variable assignment \( v \) into \( \mscrX \), we have \( \Bracks{\tau \syneq \sigma}_\mscrX^v = \semtop \) if and only if \( \Bracks{\tau}_\mscrX^v = \Bracks{\sigma}_\mscrX^v \).
\end{proposition}
\begin{proof}
  Trivial.
\end{proof}

\begin{remark}\label{rem:intuitionistic_equality}
  For \hyperref[def:propositional_logic]{propositional logic}, it was straightforward to generalize \fullref{alg:propositional_denotation} to \hyperref[def:truth_value_algebra]{truth value algebras} other than \( \set{ \semtop, \sembot } \). This lead to some complications as shown in \cref{thm:propositional_satisfaction_characterization}, but these have not caused us much trouble.

  On the other hand, for \hyperref[def:first_order_logic]{first-order logic} has \hyperref[def:fol_formula]{equality formulas} such as \( \tau \syneq \sigma \), and it seems reasonable that they satisfy \cref{thm:fol_equality_characterization}, i.e. that the denotation of equality corresponds to metatheoretic equality. It is harder to dispose of this property, so we have chosen to restrict ourselves to classical semantics. Nevertheless, we will sketch how to generalize the semantics.

  It is possible to simply change the truth value algebra in \fullref{alg:fol_formula_denotation}. In the absence of predicate symbols, this reduces to either \hyperref[def:truth_value_algebra/degenerate]{degenerate} or classical semantics.

  We will present other approaches. First, we need to generalize \hyperref[def:equivalence_relation]{equivalence relations}. Given a complete \hyperref[def:truth_value_algebra]{truth value algebra} \( \BbbT \) and a \hyperref[def:fol_structure]{structure} \( \mscrX = (X, I) \), consider some function \( \delta: X^2 \to \BbbT \) such that the following conditions hold:
  \begin{thmenum}[series=rem:intuitionistic_equality]
    \thmitem{rem:intuitionistic_equality/reflexivity} We have \( \delta(a, a) = \semtop \) for every element \( a \) of \( X \).
    \thmitem{rem:intuitionistic_equality/symmetry} We have \( \delta(a, b) = \delta(b, a) \) for all \( a \) and \( b \) in \( X \).
    \thmitem{rem:intuitionistic_equality/transitivity} We have \( \delta(a, b) \wedge \delta(b, c) \leq \delta(a, c) \) for all \( a \), \( b \) and \( c \) in \( X \).
  \end{thmenum}

  This is the approach used in \cite[def. 6.2]{TroelstraVanDalen1988ConstructivismVol2}. A more general approach from \cite[100]{Драгалин1979Интуиционизм} is to replace \ref{rem:intuitionistic_equality/reflexivity} with
  \begin{thmenum}[resume=rem:intuitionistic_equality]
    \thmitem{rem:intuitionistic_equality/reflexivity_ineq} We have \( \delta(a, b) \leq \delta(a, a) \) for all \( a \) and \( b \) in \( X \).
    \thmitem{rem:intuitionistic_equality/join} We have \( \bigvee_{a \in X} \delta(a, a) = \semtop \).
  \end{thmenum}

  Dragalin suggests regarding the value \( \delta(a, a) \) as a \enquote{measure of definedness} (\enquote{мера определённости}).

  In any case, both aforementioned sources require the following coherence conditions for every \( n \)-ary functional symbol \( f \) and every \( n \)-ary predicate symbol \( p \):
  \begin{align}
    &\delta(a_1, b_1) \wedge \cdots \wedge \delta(a_n, b_n) \leq \delta\parens[\big]{ I(f)(a_1, \ldots, a_n), I(f)(b_1, \ldots, b_n) }, \label{eq:def:fol_structure/interpretation/function_equality} \\
    &\delta(a_1, b_1) \wedge \cdots \wedge \delta(a_n, b_n) \wedge I(p)(a_1, \ldots, a_n) \leq I(p)(b_1, \ldots, b_n). \label{eq:def:fol_structure/interpretation/predicate_equality}
  \end{align}

  Every additional notion requires similar coherence conditions, and they are sometimes not obvious. For example, it is not obvious how to adapt the conditions for homomorphisms in \cref{def:fol_homomorphism} or the conditions for elementary embeddings in \cref{def:elementary_embedding}.
\end{remark}

\paragraph{First-order semantics}

\begin{definition}\label{def:fol_homomorphism}\mcite[def. 3.3.1]{VanDalen2004LogicAndStructure}
  We define a \term{homomorphism} between the \hyperref[def:fol_structure]{structures} \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) over the same signature \( \Sigma \) as a function \( h: X \to Y \) which satisfies the following conditions:
  \begin{thmenum}
    \thmitem{def:fol_homomorphism/functions} For every function symbol \( f \) of arity \( n \) over \( \Sigma \), we must have
    \begin{equation}\label{eq:def:fol_homomorphism/functions}
      h\parens[\big]{ I(f)(x_1, \ldots, x_n) } = J(f)\parens[\big]{ h(x_1), \ldots, h(x_n) }.
    \end{equation}

    \thmitem{def:fol_homomorphism/predicates} For every predicate symbol \( p \) of arity \( n \) over \( \Sigma \), we must have
    \begin{equation}\label{eq:def:fol_homomorphism/predicates}
      I(p)\parens[\big]{ x_1, \ldots, x_n } \leq J(p)\parens[\big]{ h(x_1), \ldots, h(x_n) }.
    \end{equation}

    If the converse inequality in \eqref{eq:def:fol_homomorphism/predicates} holds for all predicates, we say that the homomorphism is \term{strong}.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item We may use the notation \( h: \mscrX \to \mscrY \) in accordance with the general practice for category morphisms described in \cref{rem:categorical_morphism_notation}.

  \item \Cref{thm:first_order_homomorphism_as_substructure} provides a condition equivalent to \cref{def:fol_homomorphism/functions}, while for strong homomorphism \cref{thm:def:fol_function_respect/atomic} packs the two conditions into one.

  \item The inequality for predicates leads precisely to the desired notion of homomorphism for \hyperref[def:partially_ordered_set]{partially ordered sets} and \hyperref[def:directed_graph]{directed graphs}. The adjective \enquote{strong} is based on Knauer's \enquote{strong graph homomorphisms} defined in \cite[def. 1.4.3]{Knauer2019AlgebraicGraphTheory}.

  \incite[def. 3.3.1]{VanDalen2004LogicAndStructure} and \incite[49]{Мальцев1970АлгебраическиеСистемы} define homomorphisms like we do, and neither discuss strong homomorphisms. \incite[def. 2.3.26(i)]{Hinman2005Logic} considers strong homomorphisms by default (and simply calls them \enquote{homomorphisms}), while later in \cite[rem. 2.3.27]{Hinman2005Logic} he mentions that our weaker homomorphisms are also useful and calls them \enquote{positive homomorphisms}.
\end{comments}

\begin{definition}\label{def:fol_structure_expansion}\mcite[def. 2.6.3]{Hinman2005Logic}
  Let \( \Sigma^+ \) be an \hyperref[def:fol_signature_extension]{extension} of the \hyperref[def:fol_signature]{first-order signature} \( \Sigma \).

  We say that the \hyperref[def:fol_structure]{structure} \( \mscrX^+ = (X^+, I^+) \) over \( \Sigma^+ \) is an \term{expansion} of \( \mscrX = (X, I) \) over \( \Sigma^+ \) if \( X = X^+ \) and if the interpretations of all symbols in \( \Sigma \) (and also of \( \syneq \)) coincide.

  In this case we call \( \mscrX^+ \) a \term{reduct} of \( \mscrX \).
\end{definition}
\begin{comments}
  \item Reducts are implemented in the module \identifier{math.logic.structure.reduct} in \cite{notebook:code}.
  \item The definition is based on \bycite[def. 2.6.3]{Hinman2005Logic}, with small adjustments made for the intuitionistic treatment of formal equality.
\end{comments}

\begin{definition}\label{def:fol_reduct_along_morphism}\mcite[example 5]{MossakowskiKrumnackMaibaum2015DerivedSignatureMorphisms}
  For every \hyperref[def:fol_signature_category/morphisms]{signature morphism} \( t: \Sigma \to \Theta \) and every \hyperref[def:fol_structure]{structure} \( \mscrY = (Y, J) \) over \( \Theta \), we define the \term{reduct} of \( \mscrY \) along \( t \) as the structure \( \red_t(\mscrY) \coloneqq (Y, J_t) \), where, for every function or predicate symbol \( f \) in \( \Sigma \), and also for \( {\syneq} \),
  \begin{equation}\label{eq:def:fol_reduct_along_morphism/interpretation}
    J_t(f) \coloneqq J(t(f)).
  \end{equation}

  When defining institutions in \cref{def:fol_institution/models/hom}, we will need to extend \( \red_t \) to a \hyperref[def:functor]{functor} by also reducing \hyperref[def:gol_homomorphism]{homomorphisms}. Given structures \( \mscrY = (Y, J) \) and \( \mscrZ = (Z, K) \) over \( \Theta \), for every \( g: Y \to Z \), we define \( \red_t(g) \) as \( g \) itself.
\end{definition}
\begin{comments}
  \item These induced reducts generalize \cref{def:fol_structure_expansion} to cases where \( \Theta \) is not an extension of \( \Sigma \). They are needed for defining the institutions in \cref{def:fol_institution}.

  \item Reducts are implemented in the module \identifier{math.logic.structure.reduct} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:fol_structure_reduct_denotation}
  Fix a \hyperref[def:fol_signature_category/morphisms]{signature morphism} \( t: \Sigma \to \Theta \) and a \hyperref[def:fol_structure]{structure} \( \mscrY = (Y, J) \) over \( \Theta \). Let \( v: \op*{Var} \to Y \) be a variable assignment.

  The \hyperref[alg:fol_formula_denotation]{denotations} of \( \mscrY \) and its \hyperref[def:fol_reduct_along_morphism]{reduct} \( \red_t(\mscrY) \) are compatible in the following sense:
  \begin{thmenum}
    \thmitem{thm:fol_structure_reduct_denotation/terms} For every term \( \tau \) over \( \Sigma \), we have
    \begin{equation*}
      \Bracks[\big]{\tau[t]}_\mscrY^v = \Bracks{\tau}_{\red_t(\mscrY)}^v,
    \end{equation*}
    where we obtain \( \tau[t] \) via \fullref{alg:fol_term_signature_translation}.

    \thmitem{thm:fol_structure_reduct_denotation/formulas} For every formula \( \varphi \) over \( \Sigma \), we have
    \begin{equation*}
      \Bracks[\big]{\varphi[t]}_\mscrY^v = \Bracks{\varphi}_{\red_t(\mscrY)}^v,
    \end{equation*}
    where we obtain \( \varphi[t] \) via \fullref{alg:fol_formula_signature_translation}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:fol_structure_reduct_denotation/terms} We use \fullref{thm:induction_on_abstract_syntax} on \( \tau \):
  \begin{itemize}
    \item If \( \tau = x \in \op*{Var} \), then \( \tau[t] = \tau = x \) and
    \begin{equation*}
      \Bracks[\big]{\tau[t]}_\mscrY^v
      \reloset {\eqref{eq:alg:fol_term_denotation/var}} =
      v(x)
      \reloset {\eqref{eq:alg:fol_term_denotation/var}} =
      \Bracks{\tau}_{\red_t(\mscrY)}^v.
    \end{equation*}

    \item If \( \tau = f(\sigma_1, \ldots, \sigma_n) \), where the inductive hypothesis holds for \( \sigma_1, \ldots, \sigma_n \), then
    \begin{balign*}
      \Bracks[\big]{\tau[t]}_\mscrY^v
      &=
      \Bracks[\big]{ t(f)\parens[\big]{ \sigma_1[t], \ldots, \sigma_n[t] }}_\mscrY^v
      \reloset {\eqref{eq:alg:fol_term_denotation/fun}} = \\ &=
      J(t(f))\parens[\big]{ \Bracks[\big]{\sigma_1[t]}_\mscrY^v, \ldots, \Bracks[\big]{\sigma_n[t]}_\mscrY^v }
      \reloset {\T{ind.}} = \\ &=
      J(t(f))\parens[\big]{ \Bracks[\big]{\sigma_1}_{\red_t(\mscrY)}^v, \ldots, \Bracks[\big]{\sigma_n}_{\red_t(\mscrY)}^v }
      \reloset {\eqref{eq:alg:fol_term_denotation/fun}} = \\ &=
      \Bracks{ f(\sigma_1, \ldots, \sigma_n) }_{\red_t(\mscrY)}^v
      = \\ &=
      \Bracks{\tau}_{\red_t(\mscrY)}^v.
    \end{balign*}
  \end{itemize}

  \SubProofOf{thm:fol_structure_reduct_denotation/formulas} Analogous.
\end{proof}

\begin{definition}\label{def:fol_institution}\mimprovised
  Suppose that we are given a \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \), which is safe to assume to be the smallest suitable one as explained in \cref{def:large_and_small_sets}.

  We define an \hyperref[def:institution]{institution} based on \hyperref[def:fol_structure]{first-order structures} as follows:
  \begin{thmenum}
    \thmitem{def:fol_institution/signatures} We take the category of \( \mscrU \)-small signatures \( \ucat{Sign} \) from \cref{def:fol_signature_category}.

    \thmitem{def:fol_institution/sentences} We define the \hyperref[def:institution/sentences]{sentence functor} as follows:
    \begin{thmenum}
      \thmitem{def:fol_institution/sentences/obj} Let \( \op*{Sen}(\Sigma) \) be the set of \hyperref[def:closed_fol_formula]{closed formulas} over \( \Sigma \).
      \thmitem{def:fol_institution/sentences/hom} Let \( \op*{Sen}(t: \Sigma \to \Theta) \) be the function \( \varphi \mapsto \varphi[t] \), which translates formulas using \fullref{alg:fol_formula_signature_translation}.
    \end{thmenum}

    \thmitem{def:fol_institution/models} We define the \hyperref[def:institution/models]{model functor} as follows:
    \begin{thmenum}
      \thmitem{def:fol_institution/models/obj} Let \( \ucat{Mod}(\Sigma) \) be the category of \( \mscrU \)-small \hyperref[def:fol_structure]{first-order structures} and \hyperref[def:fol_homomorphism]{their homomorphisms}.

      \thmitem{def:fol_institution/models/hom} For the signature translation \( s: \Sigma \to \Theta \), we define the \hyperref[def:fol_institution/models/hom]{model reduct functor} \( \ucat{Mod}(s): \ucat{Mod}(\Theta) \to \ucat{Mod}(\Sigma) \) via the operator \( \red_t \) from \cref{def:fol_reduct_along_morphism}.
    \end{thmenum}

    \thmitem{def:fol_institution/satisfaction} Finally, let the \hyperref[def:institution/satisfaction]{satisfaction} relation \( \mscrX \vDash_{\Sigma} \varphi \) hold for \( \mscrX = (X, I) \) if and only if \( \Bracks{\varphi}_\mscrX = \semtop \).
  \end{thmenum}
\end{definition}
\begin{comments}
  \item The cardinality restrictions discussed in \cref{rem:language_alphabet_cardinality/category} ensure that the formulas are hereditarily finite sets and thus belong to every \hyperref[def:grothendieck_universe]{Grothendieck universe}. Thus, they do not affect the \hyperref[def:category_size]{size} of the categories above.
\end{comments}
\begin{defproof}
  Fix a signature morphism \( s: \Sigma \to \Theta \) and a structure \( \mscrY = (Y, J) \) over \( \Theta \). We must verify \eqref{eq:def:institution/satisfaction}, which we restate here:
  \begin{equation*}
    \mscrY \vDash_\Theta \underbrace{\op*{Sen}(s)(\varphi)}_{\varphi[s]}
    \quad\T{if and only if}\quad
    \underbrace{\ucat{Mod}(s)}_{\red_t}(\mscrY) \vDash_\Sigma \varphi
  \end{equation*}

  This follows directly from \cref{thm:fol_structure_reduct_denotation}, which states that
  \begin{equation*}
    \Bracks[\big]{\varphi[s]}_\mscrY = \Bracks{\varphi}_{\red_t(\mscrY)}.
  \end{equation*}
\end{defproof}

\begin{definition}\label{def:fol_semantics}\mimprovised
  By the \enquote{\hyperref[con:syntax_semantics_duality]{semantics} of first-order logic} we mean the \hyperref[def:fol_institution]{first-order institutions} and all related notions like \hyperref[def:institution/models]{models}, \hyperref[def:institution/satisfaction]{satisfaction}, \hyperref[def:institutional_entailment]{semantic entailment} and \hyperref[def:semantic_equivalence]{semantic equivalence}.

  \begin{thmenum}
    \thmitem{def:fol_semantics/model} We use the terminology from \cref{def:institutional_satisfaction} regarding satisfaction and validity.

    However, as per \cref{rem:model_theory_structure_terminology}, unlike in general institutions, we will refer to structures as \enquote{models} only with respect to a theory.

    We say that \( \mscrX \) is a \term[ru=модель (\cite[2.6.21]{Герасимов2014Вычислимость}), en=model (\cite[def. def.2.2.13(ii)]{Hinman2005Logic})]{model} \hi{of} the set of closed formulas \( \Gamma \) and write \( \mscrX \vDash \Gamma \) if and only if \( \Bracks{\varphi}_\mscrX = \semtop \) for every (closed) formula \( \varphi \in \Gamma \).

    We also say that \( \varphi \) is \term[en=valid (\cite[144]{VanDalen2004LogicAndStructure})]{valid} in \( \mscrX \).

    It is possible to extend this relation to arbitrary formulas, not necessarily closed, by requiring \( \Bracks{\varphi}_\mscrX^v = \semtop \) for every variable assignment \( v \) into \( \mscrX \). We call this convention \enquote{\hyperref[def:fol_implicit_universal_quantification]{implicit universal quantification}}, but only use it sparingly because, as explained in \cref{rem:implicit_quantification_and_deduction}, it breaks \fullref{thm:fol_semantic_deduction_theorem}.

    \thmitem{def:fol_semantics/satisfaction} If \( \mscrX \) is a model of the closed formula \( \varphi \), we also say that \( \mscrX \) \term{satisfies} \( \varphi \), in accordance with the general terminology for institutions.

    It is possible to generalize this notion to arbitrary formulas, not necessarily closed. We say that the variable assignment \( v \) \term[en=satisfies (\cite[def. 2.1.23(i)]{Hinman2005Logic})]{satisfies} the formula \( \varphi \) if \( \Bracks{\varphi}_\mscrX^v = \semtop \). Note that in this case the assignment \( v \) satisfies \( \varphi \), not the structure \( \mscrX \). This notion is not the same as implicit existential quantification for \( \mscrX \).

    We say that \( \varphi \) is \term[ru=выполнимая (формула) (\cite[def. 2.4.1]{Герасимов2014Вычислимость}), en=satisfiable (formula) (\cite[71]{VanDalen2004LogicAndStructure})]{satisfiable} in \( \mscrX \) if at least one assignment satisfies it.

    \thmitem{def:fol_semantics/tautology} We call the closed formula \( \varphi \) a \term[ru=тавтология (\cite[def. 2.4.1]{Герасимов2014Вычислимость}), en=tautology (\cite[97]{Hinman2005Logic})]{tautology} if \( \Bracks{\varphi}_\mscrX = \semtop \) for every interpretation \( \mscrX \), and a \term[ru=противоречивая формула (\cite[def. 2.4.1]{Герасимов2014Вычислимость})]{contradiction} if \( \Bracks{\varphi}_\mscrX < \semtop \) for every \( \mscrX \).

    This is consistent with \cref{def:tautology}, where a tautology must be satisfied in every model (and a contradiction --- in no model).

    \thmitem{def:fol_semantics/entailment} We use the terminology and notation from \cref{def:institutional_entailment} regarding entailment: \( \Gamma \vDash \varphi \) if and only if \( \mscrX \) satisfies \( \varphi \) whenever it satisfies \( \Gamma \).

    \thmitem{def:fol_semantics/equivalence} In accordance with \cref{def:semantic_equivalence}, we say that the \hi{closed} formulas \( \varphi \) and \( \psi \) are \term[en=logically equivalent (formulas) (\cite[def. 2.2.1(ii)]{Hinman2005Logic})]{semantically equivalent} when the structure \( \mscrX \) a model of \( \varphi \) if and only if it is a model of \( \psi \).

    We can extend this to more general formulas by requiring that \( \Bracks{\varphi}_\mscrX^v = \Bracks{\psi}_\mscrX^v \) for every variable assignment \( v \).

    We denote this by \( \varphi \gleichstark \psi \).
  \end{thmenum}
\end{definition}

\begin{theorem}[First-order semantic deduction theorem]\label{thm:fol_semantic_deduction_theorem}
  For arbitrary \hyperref[def:fol_semantics]{first-order semantics}, we have
  \begin{equation*}
    \Gamma, \varphi \vDash \psi \T{if and only if} \Gamma \vDash \varphi \synimplies \psi.
  \end{equation*}
\end{theorem}
\begin{comments}
  \item It is important here that the formulas are closed --- see \cref{rem:implicit_quantification_and_deduction}.
  \item This is one of several deduction theorems presented here --- see \cref{rem:deduction_theorem_list}.
\end{comments}
\begin{proof}
  Since the formulas are closed and do not depend on assignments, we can prove the theorem analogously to \fullref{thm:propositional_semantic_deduction_theorem}.
\end{proof}

\paragraph{Substitution}

\begin{definition}\label{def:atomic_fol_propositional_formula_translation}\mimprovised
  For translating \hyperref[def:propositional_formula]{propositional formulas} into \hyperref[def:fol_formula]{first-order formulas} over the \hyperref[def:fol_signature]{signature} \( \Sigma \) as a map \( \Bbbt: \op*{Prop} \to \op*{Form}_\Sigma \) for which only finitely many variables are not \hyperref[def:function_fixed_point]{fixed points}. We will call the map \( \Bbbt \) an \term{atomic translation}.
\end{definition}

\begin{algorithm}[Propositional formula translation]\label{alg:fol_propositional_formula_translation}
  We extend the \hyperref[def:atomic_fol_propositional_formula_translation]{atomic formula translation} \( \Bbbt \) to an operation \( \varphi \mapsto \varphi[\Bbbt] \) on compound propositional formulas via \hyperref[rem:straightforward_traversal]{straightforward traversal} similarly to how it is done in \fullref{alg:propositional_substitution}. Of course, this extension will only be valid when the propositional variables are in the domain of the atomic translation map.
\end{algorithm}
\begin{comments}
  \item This algorithm can be found as \identifier{math.logic.propositional.apply_prop_formula_translation} in \cite{notebook:code}.
\end{comments}

\begin{proposition}\label{thm:fol_propositional_formula_translation_semantics}
  \Fullref{alg:fol_propositional_formula_translation} allows us to reuse much of what we proved for propositional logic.

  Fix a \hyperref[def:fol_structure]{first-order structure} \( \mscrX \) over \( \Sigma \), a \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) into \( \mscrX \) and an \hyperref[def:atomic_fol_propositional_formula_translation]{atomic translation} \( \Bbbt \). For simplicity of exposition, suppose that \( \Bbbt \) is defined for all propositional variables under consideration.

  Define the \hyperref[def:propositional_interpretation]{propositional interpretation}
  \begin{equation}\label{eq:thm:fol_propositional_formula_translation_semantics/compatibility}
    I(p) \coloneqq \Bracks{p[\Bbbt]}_\mscrX^v.
  \end{equation}

  Then, for any propositional formula \( \varphi \), we have \( \Bracks{\varphi}_I = \Bracks{\varphi[\Bbbt]}_\mscrX^v \). In particular,
  \begin{equation*}
    I \vDash \varphi \T{if and only if} \mscrX \vDash \varphi[\Bbbt].
  \end{equation*}
\end{proposition}
\begin{proof}
  Straightforward induction on \( \varphi \).
\end{proof}

\begin{proposition}\label{thm:fol_quantifiers_and_semantic_equivalence}
  Two \hyperref[def:fol_formula]{first-order formulas} \( \varphi \) and \( \psi \) are \hyperref[def:fol_semantics/equivalence]{semantically equivalent} if and only if \( \quantifier Q x \varphi \) and \( \quantifier Q x \psi \).

  The choice of quantifier \( Q \) and variable \( x \) here are arbitrary.
\end{proposition}
\begin{comments}
  \item This proposition allows us to use propositional semantic equivalences inside quantifier bodies.
\end{comments}
\begin{proof}
  \SufficiencySubProof Suppose that \( \varphi \gleichstark \psi \). Fix a variable assignment \( v \) in some structure \( \mscrX \). For \( Q = {\synforall} \), we have
  \begin{equation}\label{eq:thm:fol_quantifiers_and_semantic_equivalence/proof}
    \Bracks{\qforall x \varphi}_\mscrX^v
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} =
    \bigwedge\set[\big]{ \Bracks{\varphi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    =
    \bigwedge\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} =
    \Bracks{\qforall x \psi}_\mscrX^v.
  \end{equation}

  The case \( Q = {\synexists} \) is analogous.

  \NecessitySubProof Conversely, if \( \qforall x \varphi \gleichstark \qforall x \psi \), then \eqref{eq:thm:fol_quantifiers_and_semantic_equivalence/proof} implies that \( \Bracks{\varphi}_\mscrX^{v_{x \mapsto a}} = \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \) for every \( a \), including \( a = v(x) \).
\end{proof}

\paragraph{Quantifier duality}

\begin{algorithm}[First-order formula dualization]\label{alg:fol_formula_dualization}
  We can extend \fullref{alg:propositional_formula_dualization} to \hyperref[def:fol_formula]{first-order formulas} by treating atomic formulas as propositional variables and handling quantifiers as follows:
  \begin{equation}\label{eq:alg:fol_formula_dualization/quantifiers}
    \oline{T}(\quantifier Q x \psi) \coloneqq \quantifier {Q^{\oppos}} x \oline{T}(\psi).
  \end{equation}

  Here \( Q^{\oppos} \) is the dual quantifier of \( Q \); that is, the only other quantifier.
\end{algorithm}
\begin{defproof}
  We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( \Bracks{\oline{T}(\varphi)}_\mscrX^v = \oline{\Bracks{\varphi}_\mscrX^v} \) for every variable assignment \( v \) in every structure \( \mscrX = (X, I) \).

  All cases except \eqref{eq:alg:fol_formula_dualization/quantifiers} have already been handled in the propositional case. If \( \varphi = \qforall x \psi \), where the inductive hypothesis holds for \( \psi \), we have
  \begin{balign*}
    \Bracks{\oline{T}(\qforall x \psi)}_\mscrX^v
    &=
    \Bracks{\qexists x \oline{T}(\psi)}_\mscrX^v
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/exists}} = \\ &=
    \bigvee\set[\big]{ \Bracks{\oline{T}(\psi)}_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    \reloset {\T{ind.}} = \\ &=
    \bigvee\set[\big]{ \oline{\Bracks{\psi}_\mscrX^{v_{x \mapsto a}}} \given* a \in X }
    \reloset {\eqref{eq:thm:de_morgans_laws/complement_of_join}} = \\ &=
    \oline{\bigwedge\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }}
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} = \\ &=
    \oline{\Bracks{\qforall x \psi}_\mscrX^v}.
  \end{balign*}

  The case where \( \varphi = \synneg \psi \) is similar.
\end{defproof}

\begin{proposition}\label{thm:fol_quantifier_duality}
  For any \hyperref[def:fol_formula]{first-order formula} \( \varphi \) and \hyperref[def:predicate_logic_alphabet/quantifiers]{quantifier} \( Q \), we have the \hyperref[def:fol_semantics/equivalence]{semantic equivalence}
  \begin{equation}\label{eq:thm:fol_quantifier_duality}
    \quantifier Q x \varphi \gleichstark \synneg \quantifier {Q^{\oppos}} x \synneg \varphi
  \end{equation}
\end{proposition}
\begin{comments}
  \item This is a particular form of \fullref{thm:de_morgans_laws}.
\end{comments}
\begin{proof}
  For \( Q = {\synforall} \), we have
  \begin{balign*}
    \Bracks{\synneg \qexists x \synneg \varphi}_\mscrX^v
    &\reloset {\eqref{eq:alg:fol_formula_denotation/formulas/neg}} =
    \oline{\Bracks{\qexists x \synneg \varphi}_\mscrX^v}
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/exists}} = \\ &=
    \oline{\bigvee\set[\big]{ \Bracks{\synneg \varphi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }}
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/neg}} = \\ &=
    \oline{\bigvee\set[\big]{ \oline{\Bracks{\varphi}_\mscrX^{v_{x \mapsto a}}} \given* a \in X }}
    \reloset {\eqref{eq:thm:de_morgans_laws/complement_of_join}} = \\ &=
    \bigwedge\set[\big]{ \Bracks{\varphi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} = \\ &=
    \Bracks{\qforall x \varphi}_\mscrX^v.
  \end{balign*}

  For \( Q = {\synexists} \), we simply have to use the dual law from \fullref{thm:de_morgans_laws}.
\end{proof}

\begin{corollary}\label{thm:fol_quantifier_duality_relativized}
  A variant of \cref{thm:fol_quantifier_duality} also holds for \hyperref[rem:fol_formula_conventions/relativization]{relativized quantifier formulas}:
  \begin{equation}\label{eq:thm:fol_quantifier_duality}
    \quantifier Q {p(x, \cdots)} \varphi \gleichstark \synneg \quantifier {Q^{\oppos}} {p(x, \cdots)} \synneg \varphi
  \end{equation}
\end{corollary}
\begin{proof}
  Here we will utilize \cref{thm:fol_quantifiers_and_semantic_equivalence}. For \( Q = {\synforall} \), we have
  \begin{balign*}
    \Bracks{\synneg \qexists {p(x, \cdots)} \synneg \varphi}_\mscrX^v
    &=
    \Bracks{\synneg \qexists x p(x, \cdots) \synwedge \synneg \varphi}_\mscrX^v
    \reloset {\eqref{eq:thm:fol_quantifier_duality}} = \\ &=
    \Bracks{\qforall x \synneg (p(x, \cdots) \synwedge \synneg \varphi)}_\mscrX^v
    \reloset {\eqref{eq:thm:classical_equivalences/de_morgan/complement_of_meet}} = \\ &=
    \Bracks{\qforall x (\synneg p(x, \cdots)) \synvee \varphi}_\mscrX^v
    \reloset {\eqref{eq:thm:classical_equivalences/conditional_as_disjunction}} = \\ &=
    \Bracks{\qforall x p(x, \cdots) \synimplies \varphi}_\mscrX^v
    = \\ &=
    \Bracks{\qforall {p(x, \cdots)} \varphi}_\mscrX^v
  \end{balign*}

  For \( Q = {\synexists} \), we have to use the dual law from \cref{thm:classical_equivalences/de_morgan}.
\end{proof}

\paragraph{Implicit and explicit quantification}

\begin{definition}\label{def:fol_quantifier_closure}\mcite[def. 2.2.28]{Hinman2005Logic}
  We call a \term[ru=универсальное замыкание (\cite[89]{Герасимов2014Вычислимость})]{universal closure} of the \hyperref[def:fol_formula]{first-order formula} \( \varphi \) any formula of the form
  \begin{equation*}
    \qforall {x_1} \ldots \qforall {x_n} \varphi,
  \end{equation*}
  where \( x_1, \ldots, x_n \) is an \hyperref[def:set_enumeration]{enumeration} of the free variables of \( \varphi \).

  Using the \hyperref[def:lexicographic_order]{lexicographic order} on the variables, we may pick a canonical closure, which we will simply call \enquote{the} (lexicographic) universal closure of \( \varphi \).

  \term[ru=экзистенциальное замыкание (\cite[90]{Герасимов2014Вычислимость})]{Existential closures} are defined analogously.
\end{definition}

\begin{definition}\label{def:fol_universal_validity}\mcite[105]{Hinman2005Logic}
  If, for some \hyperref[def:fol_formula]{first-order formula} \( \varphi \) and some \hyperref[def:fol_structure]{first-order structure} \( \mscrX \), the \hyperref[alg:fol_formula_denotation/formula]{denotation} \( \Bracks{ \varphi }_\mscrX^v \) equals \( \semtop \) for any variable assignment \( v \) in \( \mscrX \), we say that \( \varphi \) is \term[ru=общезначимая (формула) (\cite[def. 2.4.1]{Герасимов2014Вычислимость})]{universally valid} in \( \mscrX \).
\end{definition}
\begin{comments}
  \item \hyperref[def:closed_fol_formula]{Closed formulas} are universally valid, but the notion is more general --- see \cref{rem:implicit_quantification_and_deduction}.

  \item Universal validity is closely related to \hyperref[def:fol_quantifier_closure]{universal closures} --- see \cref{thm:fol_universal_validity_iff_closure_validity}.
\end{comments}

\begin{proposition}\label{thm:fol_universal_validity_iff_closure_validity}
 A \hyperref[def:fol_formula]{first-order formula} is \hyperref[def:fol_universal_validity]{universally valid} in the \hyperref[def:fol_structure]{structure} \( \mscrX \) if and only if any of its \hyperref[def:fol_quantifier_closure]{universal closures} is \hyperref[def:fol_semantics/model]{valid} in \( \mscrX \).
\end{proposition}
\begin{comments}
  \item Universal closures are nevertheless better behaved than simply universally valid formulas --- see \cref{rem:implicit_quantification_and_deduction}.
\end{comments}
\begin{proof}
  Fix a \hyperref[def:hol_structure]{structure} \( \mscrX = (X, I) \) over the \hyperref[def:hol_signature]{signature} \( \Sigma \).

  Let \( \varphi \) be a formula and let \( x_1, \ldots, x_n \) be any ordering of its variables.

  \SufficiencySubProof Suppose that \( \Bracks{ \varphi }_\mscrX^v = \semtop \) for any assignment \( v \). Then
  \begin{equation*}
    \Bracks{ \qforall {x_n} \varphi }_\mscrX^v
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} =
    \bigwedge\set[\big]{ \Bracks{ \varphi }_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    =
    \bigwedge\set[\big]{ \semtop \given* a \in X }
    =
    \semtop.
  \end{equation*}

  Proceeding by induction, we conclude that
  \begin{equation*}
    \Bracks{ \qforall {x_1} \ldots \qforall {x_n} \varphi }_\mscrX^v = \semtop.
  \end{equation*}

  Since \( v \) is arbitrary, we conclude that the universal closure of \( \varphi \) is valid in \( \mscrX \).

  \NecessitySubProof Conversely, suppose that \( \Bracks{ \qforall {x_1} \ldots \qforall {x_n} \varphi }_\mscrX = \semtop \).

  Aiming at a contradiction, suppose that, for some assignment \( v_0 \), we have \( \Bracks{ \varphi }_\mscrX^{v_0} < \semtop \). Then, for any assignment \( v \) in \( \mscrX \),
  \begin{equation*}
    \Bracks{ \qforall {x_n} \varphi }_\mscrX^v
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} =
    \bigwedge\set[\big]{ \Bracks{ \varphi }_\mscrX^{v_{x \mapsto a}} \given* a \in X }
    \leq
    \Bracks{ \varphi }_\mscrX^{v_0}
    <
    \semtop.
  \end{equation*}

  By induction, we conclude that  \( \Bracks{ \qforall {x_1} \ldots \qforall {x_n} \varphi }_\mscrX^v < \semtop \).

  The obtained contradiction shows that \( \varphi \) must be universally valid if its universal closure is.
\end{proof}

\begin{definition}\label{def:fol_implicit_universal_quantification}\mimprovised
  The concept of \hyperref[def:fol_universal_validity]{universal validity} allows us to extend the model relation from \cref{def:fol_semantics/model} to arbitrary \hyperref[def:fol_formula]{first-order formulas}.

  In a given \hyperref[def:fol_structure]{structure} \( \mscrX \), let \( \mscrX \vDash \varphi \) if and only if \( \Bracks{\varphi}_\mscrX^v = T \) for every variable assignment \( v \) in \( \mscrX \). Instead of using variable assignments, we can rely on the \hyperref[def:fol_quantifier_closure]{universal closure} of \( \varphi \) by requiring \( \Bracks{\qforall {x_1} \ldots \qforall {x_n} \varphi}_\mscrX = T \). This approach, which we will call \term{implicit universal quantification}, is used in \cite[def. 2.2.1]{Hinman2005Logic} and \cite[94]{Герасимов2014Вычислимость}.

  This easily extends to sets of formulas, so we let \( \mscrX \vDash \Gamma \) if and only if \( \mscrX \vDash \psi \) for every \( \psi \) in \( \Gamma \). For the corresponding entailment relation, let \( \Gamma \vDash \varphi \) if and only if \( \mscrX \vDash \varphi \) whenever \( \mscrX \vDash \Gamma \).
\end{definition}
\begin{comments}
  \item We will be specific about using implicit quantification because, as explained in \cref{rem:implicit_quantification_and_deduction}, it breaks \fullref{thm:fol_semantic_deduction_theorem}.
\end{comments}

\begin{remark}\label{rem:implicit_quantification_and_deduction}
  For first-order logic, we have defined the \hyperref[def:institution]{institution} in \cref{def:fol_institution} only for \hyperref[def:closed_fol_formula]{closed first-order formulas}. It is tempting to allow formulas with free variables via \hyperref[def:fol_implicit_universal_quantification]{implicit universal quantification}.

  Unfortunately, \fullref{thm:fol_semantic_deduction_theorem} no longer holds in this setting.

  Consider the following simple example. For any unary predicate symbol \( p \), with implicit quantification \cref{thm:fol_universal_validity_iff_closure_validity} implies that \( \mscrX \vDash p(x) \) if and only if \( \mscrX \vDash \qforall x p(x) \). Therefore,
  \begin{equation*}
    p(x) \gleichstark \qforall x p(x).
  \end{equation*}

  On the other hand, with a fixed structure \( \mscrX = (X, I) \) and variable assignment \( v: \op*{Var} \to X \), we have
  \begin{balign*}
    &\phantom{{}={}}
    \Bracks{ p(x) \synimplies \qforall x p(x) }_\mscrX^v
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/conn}} = \\ &=
    \Bracks{ p(x) }_\mscrX^v \rightarrow \Bracks{ \qforall x p(x) }_\mscrX^v
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} = \\ &=
    \Bracks{ p(x) }_\mscrX^v \rightarrow \bigwedge\set[\big]{ \Bracks{ p(x) }_\mscrX^{v_{x \mapsto a}} \given* a \in X }.
    \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/pred}} = \\ &=
    I(p)(v(x)) \rightarrow \bigwedge\set{ p(x) \given a \in X }.
  \end{balign*}

  This clearly fails if \( I(p)(v(x)) = \semtop \) and \( I(p)(a) = \sembot \) for some \( a \neq v(x) \).
\end{remark}

\paragraph{Term models}

\begin{definition}\label{def:fol_equation}\mimprovised
  \hyperref[def:first_order_logic]{First-order logic} naturally encodes \hyperref[def:equation]{equations} as equality formulas. Thus, we will also refer to equality formulas as \term{first-order equations}.
\end{definition}
\begin{comments}
  \item This is not to be confused with \hyperref[def:differential_equation]{first-order differential equations} or \hyperref[def:difference_equation]{first-order difference equations}.
\end{comments}

\begin{definition}\label{def:fol_equational_theory}\mimprovised
  We say that a subset \( \Alpha \) of a (syntactic or semantic) \hyperref[def:general_logic_theory]{first-order theory} \( \Gamma \) is \term{equational} if \( \Alpha \) consists of \hyperref[def:fol_quantifier_closure]{universal closures} of \hyperref[def:fol_equation]{equations}.

  We call \( \Gamma \) an \term{equational theory} if it has such an axiomatization.
\end{definition}
\begin{comments}
  \item The definition is based in \cite[def. 3.5.3]{BaaderNipkow2012TermRewriting}, who, without dealing with logic, present an equational theory as a set of pairs of terms (their terms resemble our first-order terms). The general notion is attributed to Garrett Birkhoff's discussion of universal algebra in \cite[ch. VI]{Birkhoff1967LatticeTheory}.
\end{comments}

\begin{definition}\label{def:fol_free_term_model}\mimprovised
  Fix an \hyperref[def:fol_equational_theory]{equational theory} \( \Gamma \) over the \hyperref[def:fol_signature]{signature} \( \Sigma \) with no relation symbols. Also fix an \hyperref[def:formal_language/alphabet]{alphabet} \( V \), whose elements we will treat as \hyperref[con:free_construction/indeterminate]{indeterminates} (i.e. generalized syntactic variables).

  We will build a \hyperref[def:fol_semantics/model]{model} \( \mscrT_\Gamma(V) \) of \( \Gamma \) consisting of generalized \hyperref[def:fol_term_ast]{abstract syntax trees} of terms over \( \Sigma \). We will call \( \mscrT_\Gamma(V) \) a \term[en=term algebra (\cite[def. 3.4.1]{BaaderNipkow2012TermRewriting})]{free term model} of \( \Gamma \).

  \begin{thmenum}
    \thmitem{def:fol_free_term_model/intermediate} First, let \( P \) be the set of syntax trees obtained via \fullref{thm:recursively_defined_abstract_syntax} from the function symbols in \( \Sigma \) and from the indeterminates \( V \) considered as nullary symbols.

    On \( P \), we define the interpretation \( I(f) \) of the \( n \)-ary function \( f \) as
    \begin{equation*}
      I(f)(T_1, \ldots, T_n) \coloneqq B_+^f(T_1, \ldots, T_n),
    \end{equation*}
    where \( B_+^f(T_1, \ldots, T_n) \) is the tree obtained by \hyperref[def:ordered_tree_grafting]{grafting} \( T_1, \ldots, T_n \) to a new root labeled by \( f \). By construction, this tree belongs to \( \mscrP \).

    Then \( \mscrP \coloneqq (P, I) \) is a \hyperref[def:fol_structure]{structure} over \( \Sigma \). At this point is is unrelated to the theory \( \Gamma \).

    \thmitem{def:fol_free_term_model/relation} Fix a particular equational axiomatization \( A \) of \( \Gamma \). Let \( {\cong} \) be the \hyperref[def:first_order_congruence]{congruence} obtained via \fullref{thm:recursively_defined_relations} subject to the following rules:

    \begin{thmenum}
      \thmitem{def:fol_free_term_model/relation/base} We impose the standard equivalence relation conditions on all syntax trees:
      \begin{paracol}{3}
        \begin{nthcolumn}{0}
          \ParacolAlignmentHack
          \begin{equation*}\taglabel[\ensuremath{ \logic{TM}_R }]{inf:def:fol_free_term_model/relation/base/reflexivity}
            \begin{prooftree}
              \infer0[\ref{inf:def:fol_free_term_model/relation/base/reflexivity}]{ T \cong T }
            \end{prooftree}
          \end{equation*}
        \end{nthcolumn}

        \begin{nthcolumn}{1}
          \ParacolAlignmentHack
          \begin{equation*}\taglabel[\ensuremath{ \logic{TM}_S }]{inf:def:fol_free_term_model/relation/base/symmetry}
            \begin{prooftree}
              \hypo{ T \cong S }
              \infer1[\ref{inf:def:fol_free_term_model/relation/base/symmetry}]{ S \cong T }
            \end{prooftree}
          \end{equation*}
        \end{nthcolumn}

        \begin{nthcolumn}{2}
          \ParacolAlignmentHack
          \begin{equation*}\taglabel[\ensuremath{ \logic{TM}_T }]{inf:def:fol_free_term_model/relation/base/transitivity}
            \begin{prooftree}
              \hypo{ T \cong S }
              \hypo{ S \cong R }
              \infer2[\ref{inf:def:fol_free_term_model/relation/base/transitivity}]{ T \cong R }
            \end{prooftree}
          \end{equation*}
        \end{nthcolumn}
      \end{paracol}

      \thmitem{def:fol_free_term_model/relation/functions} For every function symbol \( f \) of arity \( n \), we impose
      \begin{equation*}\taglabel[\ensuremath{ \logic{TM}_f }]{inf:def:fol_free_term_model/relation/functions}
        \begin{prooftree}
          \hypo{ T_1 \cong S_1 }
          \hypo{ \cdots }
          \hypo{ T_n \cong S_n }
          \infer3[\ref{inf:def:fol_free_term_model/relation/functions}]{ I(f)(T_1, \ldots, T_1) \cong I(f)(S_1, \ldots, S_n) }
        \end{prooftree}
      \end{equation*}

      \thmitem{def:fol_free_term_model/relation/axioms} For every axiom \( \varphi = \qforall {x_1} \cdots \qforall {x_n} (\tau \syneq \sigma) \) in \( A \), we impose
      \begin{equation*}\taglabel[\ensuremath{ \logic{TM}_{\tau \syneq \sigma} }]{inf:def:fol_free_term_model/relation/axioms}
        \begin{prooftree}
          \hypo{ T_1 \cong S_1 }
          \hypo{ \cdots }
          \hypo{ T_n \cong S_n }
          \infer3[\ref{inf:def:fol_free_term_model/relation/axioms}]{ \Bracks{\tau}_\mscrP(T_1, \ldots, T_n) \cong \Bracks{\sigma}_\mscrP(S_1, \ldots, S_n) }
        \end{prooftree}
      \end{equation*}
    \end{thmenum}

    The congruence would be trivial without the last rule. Furthermore, any two axiomatizations of \( \Gamma \) are by definition \hyperref[def:equivalent_sets_of_sentences]{equivalent}, so the congruence does not depend on the particular choice of equational axiomatization \( A \).

    \thmitem{def:fol_free_term_model/quotient} The desired free term model \( \mscrT_\Gamma(V) \) is then the \hyperref[def:first_order_quotient]{quotient structure} \( \mscrP / {\cong} \).
  \end{thmenum}
\end{definition}

\begin{theorem}[Free term model universal property]\label{thm:fol_free_term_model_universal_property}\mimprovised
  The \hyperref[def:fol_free_term_model]{free term model} \( \mscrT_\Gamma(V) = (T, I) \) is the unique up to a unique isomorphism \hyperref[def:fol_semantics/model]{model} of \( \Gamma \) that satisfies the following \hyperref[rem:universal_mapping_property]{universal mapping property}:
  \begin{displayquote}
    For every model \( \mscrY = (Y, J) \) of \( \Gamma \) and every function \( e: V \to Y \) into the universe \( Y \) of \( \mscrY \), there exists a unique \hyperref[def:fol_homomorphism]{first-order homomorphism} \( \Phi_e: \mscrT_\Gamma(V) \to \mscrY \) such that the following diagram commutes:
    \begin{equation}\label{eq:thm:fol_term_model_universal_property}
      \begin{aligned}
        \includegraphics[page=1]{output/thm__fol_free_term_model_universal_property}
      \end{aligned}
    \end{equation}
  \end{displayquote}
\end{theorem}
\begin{comments}
  \item Via \cref{rem:universal_mapping_property}, \( V \mapsto \mscrT_\Gamma(V) \) becomes \hyperref[def:category_adjunction]{left adjoint} to the \hyperref[def:concrete_category]{forgetful functor}
  \begin{equation*}
    U: \ucat{Mod}(\Sigma) \to \ucat{Set},
  \end{equation*}
  which sends a model of \( \Sigma \) to its universe.

  \item Many theories have distinct definitions for their free objects; these include \hyperref[def:free_group]{free groups}, \hyperref[def:free_semimodule]{free (semi)modules} and \hyperref[def:polynomial_algebra]{polynomial algebras}. They satisfy the same universal property, so, by \cref{thm:functor_adjoint_uniqueness}, they are isomorphic to the corresponding free term models. See \cref{ex:def:fol_free_term_model/free_monoids} for a broader discussion.
\end{comments}
\begin{proof}
  We want the function \( \Phi_e: T \to Y \) to extend \( e \), thus the image of the coset \( [B_+^v] \), where \( B_+^v \) is an indeterminate tree, must be \( e(v) \). This is well-defined because no other tree is congruent to \( B_+^v \).

  We also want \( \Phi_e \) to be a homomorphism. Thus, for the function application tree coset \( [B_+^f(T_1, \ldots, T_n)] \), \( \Phi_e \) must recursively apply itself to the subtrees. The rule \ref{inf:def:fol_free_term_model/relation/axioms} makes sure that \( \Phi_e \) does not depend on the choice of function application tree in a coset. This leads to the only possible definition
  \begin{equation*}
    \Phi_e([T]) \coloneqq \begin{cases}
      e(v),                                                      &T = [B_+^v], \\
      J(f)\parens[\big]{ \Phi_e([T_1]), \ldots, \Phi_e([T_n]) }, &T = [B_+^f(T_1, \ldots, T_n)].
    \end{cases}
  \end{equation*}
\end{proof}

\begin{example}\label{ex:def:fol_free_term_model}
  We list examples of \hyperref[def:fol_free_term_model]{free term models}:
  \begin{thmenum}
    \thmitem{ex:def:fol_free_term_model/free_magma} A simple example of a free term model is based on the empty theory over a single binary operation.

    As explained in \cref{rem:magma_terminology}, models of this theory are sometimes referred to as \enquote{magmas}, so for this example let us call \( \mscrT_\varnothing(V) \) the \term{free magma} over \( V \).

    The congruence in the construction of \( \mscrT_\varnothing(V) \) is trivial, so the cosets are singleton sets. We thus do not need to distinguish between the syntax trees and their cosets.

    The following trees correspond to elements more conveniently written as \( (xy)z \) and \( x(yz) \):
    \begin{equation*}
      \includegraphics[page=1]{output/ex__def__fol_free_term_model}
      \qquad
      \includegraphics[page=2]{output/ex__def__fol_free_term_model}
    \end{equation*}

    Here \( x \), \( y \) and \( z \) are metalinguistic variables denoting arbitrary syntax trees.

    \thmitem{ex:def:fol_free_term_model/free_semigroup} By adding associativity to the empty theory, we obtain a very different free term model.

    The trees above corresponding to \( (xy)z \) and \( x(yz) \) are now congruent. It is thus less convenient to regard them as trees and more convenient to regard them as \hyperref[def:ordered_tuple]{ordered triples}. This extends to quadruples, quintuples and so forth. The grafting product of trees corresponds to concatenation of tuples.

    Thus, we may regard the free term model \( \mscrT_{\Gamma_1}(V) \) over the \hyperref[def:semigroup/theory]{first-order theory of semigroups} \( \Gamma_1 \) as the \hyperref[def:formal_language/kleene_plus]{Kleene plus} \( V^+ \), the set of nonempty strings of indeterminates. More formally, we have just demonstrated an isomorphism between \( \mscrT_{\Gamma_1}(V) \) and \( V^+ \).

    \thmitem{ex:def:fol_free_term_model/free_monoid} This naturally leads to the definition of free monoid in \cref{def:free_monoid} as the \hyperref[def:formal_language/kleene_star]{Kleene star} \( V^* \).

    Indeed, consider the free term model \( \mscrT_{\Gamma_2}(V) \) over the \hyperref[def:monoid/theory]{first-order theory of monoids} \( \Gamma_2 \). In \( \mscrT_{\Gamma_2}(V) \), we expect the equalities \( x = ex = xe \), where \( x \) is arbitrary and \( e = B_+^{\synneutral} \) is the neutral element in \( \mscrT_{\Gamma_2}(V) \). Thus, the following syntax trees must be regarded as congruent to \( x \):
    \begin{equation*}
      \includegraphics[page=3]{output/ex__def__fol_free_term_model}
      \qquad
      \includegraphics[page=4]{output/ex__def__fol_free_term_model}
    \end{equation*}

    This ensures that the grafting product with the neutral element tree \( e = B_+^{\synneutral} \) acts as concatenation with the empty string.

    Again, we have just demonstrated an isomorphism between \( \mscrT_{\Gamma_2}(V) \) and \( V^* \). However, even if an explicit isomorphism is not obvious, the universal properties provide one of us. In this case \( \mscrT_{\Gamma_2}(V) \) satisfies \fullref{thm:fol_free_term_model_universal_property}, while \( V^* \) satisfies \fullref{thm:free_monoid_universal_property}. Both are left adjoint to the same forgetful functor \( U: \cat{Mon} \to \cat{Set} \), so, by \cref{thm:functor_adjoint_uniqueness}, they are isomorphic.

    \thmitem{ex:def:fol_free_term_model/free_commutative_monoid} Further in one direction is the free commutative monoid, defined in \cref{def:free_commutative_monoid} as the \hyperref[def:free_semimodule]{free semimodule} \( \BbbN^{\oplus V} \).

    Consider the theory \( \Gamma_3 \) obtained by adding the commutativity axiom \eqref{eq:def:binary_operation/commutative} to \( \Gamma_2 \). Due to \fullref{thm:free_commutative_monoid_universal_property}, we again have an implicit isomorphism between \( \mscrT_{\Gamma_3}(V) \) and \( \BbbN^{\oplus V} \).

    This also follows naturally because, in the free term model \( \mscrT_{\Gamma_3}(V) \), the condition \( xy = yx \) requires us to additionally regard the following trees as congruent:
    \begin{equation*}
      \includegraphics[page=5]{output/ex__def__fol_free_term_model}
      \qquad
      \includegraphics[page=6]{output/ex__def__fol_free_term_model}
    \end{equation*}

    It thus becomes convenient to regard cosets in \( \mscrT_{\Gamma_3}(V) \) as \hyperref[def:multiset]{multisets} of \hyperref[def:multiset_cardinality/infinite]{finite order} over \( V \), i.e. as finitely-supported functions from \( V \) to \( \BbbN \).

    \thmitem{ex:def:fol_free_term_model/free_group} Instead of extending monoids to commutative monoids, we may extend them to \hyperref[def:group]{groups}. Let \( \Gamma_4 \) be the \hyperref[def:group/theory]{first-order theory of groups}.

    Compared to the free term model \( \mscrT_{\Gamma_2}(V) \) of monoids, in \( \mscrT_{\Gamma_4}(V) \) each element \( x \) has a corresponding inverse \( x^{-1} \), encoded by the tree
    \begin{equation*}
      \includegraphics[page=7]{output/ex__def__fol_free_term_model}
    \end{equation*}

    The theory additionally requires us to regard the following trees as congruent, for any \( x \), to the neutral element \( e = B_+^{\synneutral} \):
    \begin{equation*}
      \includegraphics[page=8]{output/ex__def__fol_free_term_model}
      \qquad
      \includegraphics[page=9]{output/ex__def__fol_free_term_model}
    \end{equation*}

    Symbolically, this amounts to reducing \( x^{-1}x \) and \( xx^{-1} \) to \( e \).

    The free group \( F(V) \), as defined in \cref{def:free_group}, provides an alternative definition that leads to a similar result. The corresponding universal property is \fullref{thm:free_group_universal_property}.

    \thmitem{ex:def:fol_free_term_model/polynomial_algebra} A more complicated example stems from the \hyperref[def:algebra_over_semiring/commutative]{first-order theory of commutative algebras} \( \Gamma_5 \) over a fixed \hyperref[def:semiring]{(semi)ring} \( R \).

    The free term model \( \mscrT_{\Gamma_5}(V) \) requires many adjustments. However, due to \fullref{thm:polynomial_algebra_universal_property}, we know that the free term model is isomorphic to the \hyperref[def:polynomial_algebra]{polynomial algebra} \( R[V] \).

    This is shown explicitly in \cref{ex:def:fol_free_term_model}.

    \thmitem{ex:def:fol_free_term_model/lattices} Unlike the examples discussed above, for the \hyperref[def:lattice/theory]{theory of lattices} \( \Gamma_6 \), we use free term model \( \mscrT_{\Gamma_6}(V) \) when defining free lattices in \cref{def:free_lattice}.
  \end{thmenum}
\end{example}

\paragraph{Elementary embeddings}

\begin{remark}\label{rem:fol_homomorphism_refinements}
  We discuss here several flavors of \hyperref[def:fol_homomorphism]{first-order homomorphisms}. Their relationship is visualized in \cref{fig:rem:fol_homomorphism_refinements} and made precise in \cref{thm:def:fol_function_respect} and \cref{thm:def:elementary_embedding}. A systematic discussion can be found in \cite{MathSE:fol_homomorphism_isomorphism_and_related_notions}.

  We list some counterexample to this hierarchy in \cref{ex:rem:fol_homomorphism_refinements}.

  \begin{figure}[!ht]
    \hfill
    \begin{forest}
      [
        {\hyperref[def:fol_homomorphism]{homomorphism}}, name=basic
          [
            {\hyperref[def:fol_homomorphism]{strong} \\ \hyperref[def:fol_homomorphism]{homomorphism}}, align=center, name=strong
              [
                {\hyperref[def:first_order_embedding]{embedding}}, name=embedding
                  [
                    {\hyperref[def:elementary_embedding]{elementary} \\ \hyperref[def:elementary_embedding]{embedding}}, align=center, name=elementary
                      [{\hyperref[def:first_order_isomorphism]{isomorphism}}, name=isomorphism]
                  ]
              ]
          ]
      ]
      \draw[-, dashed] (embedding) to[in=east, out=east] node[right] {\hyperref[def:function_invertibility/injective]{injective}} (strong);
      \draw[-, dashed] (isomorphism) to[in=west, out=west] node[left] {\hyperref[def:function_invertibility/surjective]{surjective}} (embedding);
    \end{forest}
    \hfill\hfill
    \caption{First-order homomorphisms and related notions.}\label{fig:rem:fol_homomorphism_refinements}
  \end{figure}
\end{remark}

\begin{definition}\label{def:fol_function_respect}\mcite[def. 2.3.4]{Hinman2005Logic}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature}.

  We say that the function \( h: X \to Y \) \term{respects} the term \( \tau \) (or the formula \( \varphi \)) if, for every \hyperref[def:fol_variable_assignment]{variable assignment} \( v \) into \( \mscrX \), we have
  \begin{align*}
    \Bracks{\tau}_\mscrY^{h \bincirc v} = \Bracks{\tau}_\mscrX^v && \T{(or} \Bracks{\varphi}_\mscrY^{h \bincirc v} = \Bracks{\varphi}_\mscrX^v\T{)}.
  \end{align*}
\end{definition}

\begin{proposition}\label{thm:def:fol_function_respect}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \).

  The term and formula compatibility notions from \cref{def:fol_function_respect} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_function_respect/atomic} A function \( h: X \to Y \) is a \hyperref[def:fol_homomorphism]{strong homomorphism} if and only if it respects atomic formulas.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_function_respect/atomic}
  \SufficiencySubProof* Suppose that \( h: X \to Y \) is a strong homomorphism. Fix an atomic formula \( \varphi \) and a variable assignment \( v \).

  We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) to show that \( h \) respects \( \varphi \).
  \begin{itemize}
    \item If \( \varphi \) is a constant, by definition \( \Bracks{\varphi}_\mscrX^v = \semtop = \Bracks{\varphi}_\mscrY^{h \bincirc v} \) if \( \varphi = \syntop \) and similarly if \( \varphi = \synbot \).

    \item If \( \varphi = (\tau \syneq \sigma) \), where the inductive hypothesis holds for \( \tau \) and \( \sigma \), then
    \begin{equation*}
      \Bracks{\tau \syneq \sigma}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/eq}} =
      \parens[\big]{ \Bracks{\tau}_\mscrX^v \approx_\mscrX \Bracks{\sigma}_\mscrX^v }
      \reloset {\T{ind.}} =
      \parens[\big]{ \Bracks{\tau}_\mscrY^{h \bincirc v} \approx_\mscrY \Bracks{\sigma}_\mscrY^{h \bincirc v} }
      \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/eq}} =
      \Bracks{\tau \syneq \sigma}_\mscrY^{h \bincirc v}
    \end{equation*}

    \item If \( \varphi = p(\tau_1, \ldots, \tau_n) \), we proceed similarly.
  \end{itemize}

  \NecessitySubProof* Suppose that \( h: X \to Y \) respects atomic formulas. We will show that it is a homomorphism.

  \begin{itemize}
    \item For a predicate symbol \( p \) in \( \Sigma \) of arity \( n \), since \( h \) respects atomic formulas, we have
    \begin{equation*}
      \Bracks{p(\synx_1, \ldots, \synx_n)}_\mscrX^v = \Bracks{p(\synx_1, \ldots, \synx_n)}_\mscrY^{h \bincirc v}.
    \end{equation*}

    Given elements \( a_1, \ldots, a_n \) in \( X \), we can take any assignment \( v \) satisfying \( v(\synx_k) = a_k \) for \( k = 1, \ldots, n \) to conclude that
    \begin{equation*}
      J(p)\parens[\big]{ h(a_1), \ldots, h(a_n) } = h\parens[\big]{ I(p)(a_1, \ldots, a_n) },
    \end{equation*}
    as desired.

    \item For a functional symbol \( f \) in \( \Sigma \) of arity \( n \), we consider the following equality formulas:
    \begin{equation}\label{thm:def:fol_function_respect/atomic/proof/functions}
      \Bracks{f(\synx_1, \ldots, \synx_n) \syneq \syny}_\mscrX^v = \Bracks{f(\synx_1, \ldots, \synx_n) \syneq \syny}_\mscrY^{h \bincirc v}
    \end{equation}
    for every variable assignment \( v \).

    Fix elements \( a_1, \ldots, a_n \) in \( X \) and consider any assignment \( v \) that satisfies \( v(\synx_k) = a_k \) for \( k = 1, \ldots, n \), and also
    \begin{equation*}
      v(\syny) = I(f)(a_1, \ldots, a_n).
    \end{equation*}

    From \eqref{thm:def:fol_function_respect/atomic/proof/functions} it follows that
    \begin{equation*}
      \parens[\big]{ I(f)(a_1, \ldots, a_n) \approx_\mscrX v(\syny) } = \parens[\big]{ J(f)\parens[\big]{ h(a_1), \ldots, h(a_n) } \approx_\mscrY h(v(\syny)) }.
    \end{equation*}

    Since the interpretation of formal equality is standard, this amounts to
    \begin{equation*}
      I(f)(a_1, \ldots, a_n) = v(\syny) \T{if and only if} J(f)\parens[\big]{ h(a_1), \ldots, h(a_n) } = h(v(\syny)),
    \end{equation*}
    hence
    \begin{equation*}
      h(v(\syny)) = J(f)\parens[\big]{ h(a_1), \ldots, h(a_n) } = h\parens[\big]{ I(f)(a_1, \ldots, a_n) }.
    \end{equation*}

    Therefore, \( h \) is compatible with function application.
  \end{itemize}
\end{proof}

\begin{definition}\label{def:elementary_embedding}\mcite[def. 2.3.30; def. 2.3.43]{Hinman2005Logic}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \).

  We say that the function \( h: X \to Y \) is an \term[ru=элементарное вложение (\cite[237]{Мальцев1970АлгебраическиеСистемы})]{elementary embedding} if it \hyperref[def:fol_function_respect]{respects} every formula over \( \Sigma \).

  If \( \mscrX \) is a \hyperref[def:first_order_substructure]{substructure} of \( \mscrY \) and the inclusion \( \iota: X \to Y \) is an elementary embedding, we call \( \mscrX \) an \term[ru=элементарная подмодель (\cite[237]{Мальцев1970АлгебраическиеСистемы})]{elementary substructure} of \( \mscrY \) and \( \mscrY \) --- an \term{elementary extension} of \( \mscrX \).
\end{definition}
\begin{comments}
  \item In this definition, we only require \( h \) to be a function. As shown in \cref{thm:def:elementary_embedding/embedding}, if \( h \) is an elementary embedding, it is an embedding in the sense of \cref{def:first_order_embedding}. The converse is not generally true --- see \cref{ex:def:elementary_embedding/non_elementary}. Thus, it makes sense to say \enquote{non-elementary embedding}.
\end{comments}

\begin{proposition}\label{thm:def:elementary_embedding}
  \hyperref[def:elementary_embedding]{Elementary embeddings} for \hyperref[def:fol_structure]{structures} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:elementary_embedding/embedding} Every elementary embedding is a first-order embedding in the sense of \cref{def:first_order_embedding}.

    \thmitem{thm:def:elementary_embedding/isomorphism} Every \hyperref[def:first_order_isomorphism]{isomorphism} is an elementary embedding.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:elementary_embedding/embedding} An elementary embedding necessarily respects atomic formulas, so \cref{thm:def:fol_function_respect/atomic} implies that it is a strong homomorphism. We must only show injectivity.

  Let \( h: X \to Y \) be an elementary embedding from \( \mscrX = (X, I) \) to \( \mscrY = (Y, J) \). Suppose that \( h(a) = h(b) \). Let \( v \) be an assignment such that \( v(\synx) = a \) and \( v(\syny) = b \). Then
  \begin{equation*}
    \Bracks{\synx \syneq \syny}_\mscrX^v = \underbrace{\Bracks{\synx \syneq \syny}_\mscrY^{h \bincirc v}}_{h(a) \approx_\mscrY h(b) = \semtop},
  \end{equation*}
  hence \( a = b \).

  \SubProofOf{thm:def:elementary_embedding/isomorphism} Let \( h: X \to Y \) be an isomorphism between the structures \( \mscrX = (X, I) \) to \( \mscrY = (Y, J) \) over \( \Sigma \).

  Let \( \varphi \) be an arbitrary formula over \( \Sigma \) and let \( v \) be a variable assignment into \( \mscrX \).

  We will use \fullref{thm:induction_on_abstract_syntax} on \( \varphi \) simultaneously on all assignments \( v \) to show that \( h \) respects \( \varphi \).
  \begin{itemize}
    \item Since \( h \) is an isomorphism, it is a strong homomorphism, and hence by \cref{thm:def:fol_function_respect/atomic} it respects atomic formulas. So, it remains to verify only non-atomic formulas.

    \item If \( \varphi = (\psi \syncirc \theta) \), where the inductive hypothesis holds for \( \psi \) and \( \theta \), we have
    \begin{equation*}
      \Bracks{\psi \bincirc \theta}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/conn}} =
      \Bracks{\psi}_\mscrX^v \bincirc \Bracks{\theta}_\mscrX^v
      \reloset {\T{ind.}} =
      \Bracks{\psi}_\mscrY^{h \bincirc v} \bincirc \Bracks{\theta}_\mscrY^{h \bincirc v}
      \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/conn}} =
      \Bracks{\psi \bincirc \theta}_\mscrY^{h \bincirc v}
    \end{equation*}

    \item If \( \varphi = \qforall x \psi \), where the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Bracks{\qforall x \psi}_\mscrX^v
      \reloset {\eqref{eq:alg:fol_formula_denotation/formulas/forall}} =
      \bigwedge\set[\big]{ \Bracks{\psi}_\mscrX^{v_{x \mapsto a}} \given* a \in X }
      \reloset {\T{ind.}} =
      \bigwedge\set[\big]{ \Bracks{\psi}_\mscrY^{h \bincirc v_{x \mapsto a}} \given* a \in X }
      =
      \bigwedge\set[\big]{ \Bracks{\psi}_\mscrY^{(h \bincirc v)_{x \mapsto b}} \given* b \in Y },
    \end{equation*}
    where we have used that \( (h \bincirc v)_{x \mapsto b} = h \bincirc v_{x \mapsto h^{-1}(b)} \).

    \item If \( \varphi = \qexists x \psi \), we proceed similarly.
  \end{itemize}
\end{proof}

\begin{example}\label{ex:rem:fol_homomorphism_refinements}
  We list counterexamples of the hierarchy of homomorphism-related notions from \cref{fig:rem:fol_homomorphism_refinements}:
  \begin{thmenum}
    \thmitem{ex:rem:fol_homomorphism_refinements/not_strong} Not every homomorphism is strong.

    Consider the constant function \( f(x) = 0 \) in \( \BbbR \). It is trivially an \hyperref[def:order_function/preserving]{order-preserving map} and hence an \hyperref[def:preordered_set/homomorphism]{order homomorphism}, i.e. a first-order homomorphism in the \hyperref[def:preordered_set/theory]{theory of preordered sets}. Yet, it is not a strong homomorphism because \( f(1) \leq f(0) \).

    \thmitem{ex:rem:fol_homomorphism_refinements/not_embedding} \Cref{fig:ex:rem:fol_homomorphism_refinements/not_embedding} demonstrates a nontrivial (but very simple) strong homomorphism between \hyperref[def:directed_graph]{simple directed graphs} that is injective.

    \begin{figure}[!ht]
      \centering
      \includegraphics[page=1]{output/ex__rem__fol_homomorphism_refinements__non_embedding}
      \caption{A non-injective \hyperref[def:directed_graph/homomorphism]{strong graph homomorphism}.}\label{fig:ex:rem:fol_homomorphism_refinements/not_embedding}
    \end{figure}

    \thmitem{ex:rem:fol_homomorphism_refinements/not_elementary}\mcite{MathSE:fol_homomorphism_isomorphism_and_related_notions} The inclusion of \( \BbbN \) into \( \BbbZ \) is an order homomorphism.

    It is not an elementary embedding because it does not respect the formula \( \qexists \synx \qforall \syny {\synx \synleq \syny} \).

    \thmitem{ex:rem:fol_homomorphism_refinements/not_isomorphism} Any two unbounded \hyperref[def:dense_total_order]{dense total orders} are elementarily equivalent. This is proven in \cite[ch. 2.4]{Hinman2005Logic}.

    Hence, as ordered sets, \( \BbbQ \) and \( \BbbR \) are elementarily equivalent. But they are not isomorphic because they have different cardinalities.
  \end{thmenum}
\end{example}

\begin{definition}\label{def:elementary_equivalence}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be \hyperref[def:fol_structure]{structures} over a common \hyperref[def:fol_signature]{signature} \( \Sigma \).

  We say that \( \mscrX \) and \( \mscrY \) are \term[ru=элементарно эквивалентные (алгебраические системы) (\cite[235]{Мальцев1970АлгебраическиеСистемы}), en=elementarily equivalent (\cite[def. 2.3.3]{Hinman2005Logic})]{elementarily equivalent} and write \( \mscrX \equiv \mscrY \) if any of the following hold:
  \begin{thmenum}
    \thmitem{def:elementary_equivalence/direct}\mcite[def. 2.3.3]{Hinman2005Logic} \( \mscrX \vDash \varphi \) if and only if \( \mscrY \vDash \varphi \) for every \hi{closed} formula \( \varphi \) over \( \Sigma \).

    \smallskip

    \thmitem{def:elementary_equivalence/theory}\mcite[prop. 2.4.10(ii)]{Hinman2005Logic} The \hyperref[def:fol_theory/model]{theories} \( \op*{Th}(\mscrX) \) and \( \op*{Th}(\mscrY) \) coincide.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:cardinality_control_formulas}
  We can control the cardinality of \hyperref[def:fol_semantics/model]{first-order models} using the family of formulas \( \chi^{\geq n} \), defined as the \hyperref[def:fol_quantifier_closure]{existential closures} of
  \begin{equation*}
    \chi^{\geq n} \coloneqq \begin{cases}
      \syntop,                                                                                                                                                      &n = 1, \\
      \qforall {\synx_1} \ldots \qforall {\synx_{n-1}} \qexists \syny \synneg (\synx_1 \syneq \syny) \synwedge \cdots \synwedge \synneg (\synx_{n-1} \syneq \syny), &n > 1.
    \end{cases}
  \end{equation*}

  For \( n > 1 \), we define \( \chi^{< n} \) as the opposite of \( \chi^{\geq n} \) obtained via \fullref{alg:fol_formula_dualization}:
  \begin{equation*}
    \chi^{< n} \coloneqq \qexists {\synx_1} \ldots \qexists {\synx_{n-1}} \qforall \syny (\synx_1 \syneq \syny) \synvee \cdots \synvee (\synx_{n-1} \syneq \syny).
  \end{equation*}

  Then a structure satisfies \( \chi^{\geq n} \) if and only if it has at least \( n \) elements, and it satisfies \( \chi^{< n} \) if and only if it has less than \( n \) elements. It is thus natural to also define
  \begin{equation*}
    \chi^{=n} \coloneqq \begin{cases}
      \chi^{<2},                           &n = 1, \\
      \chi^{\geq n} \synwedge \chi^{<n+1}, &n > 1.
    \end{cases}
  \end{equation*}
\end{proposition}
\begin{comments}
  \item We handle the special case \( n = 1 \) separately because
  \begin{equation*}
    \chi^{\geq 1} \synwedge \chi^{<2} = \syntop \synwedge \qexists {\synx_1} \qforall {\syny} (\synx_1 \syneq \syny) = \syntop \synwedge \chi^{=1},
  \end{equation*}
  which can be simplified (as justified in \fullref{alg:propositional_constant_collapse}).

  An adaptation of the obtained formula \( \chi^{=1} \) is used for defining contractible types in \cref{def:contractible_type}.

  \item In classical logic, we can define \( \chi^{< n} \) as \( \synneg \chi^{\geq n} \). Using the specifically constructed complemented dual extends this more generally.

  \item These formulas are implemented in the module \identifier{math.logic.theories.equality} in \cite{notebook:code}.
\end{comments}
\begin{proof}
  Trivial.
\end{proof}

\begin{lemma}\label{thm:fol_finite_structure_characterizing_formula}\mcite[thm. 2.3.11(ii)]{Hinman2005Logic}
  Fix a finite structure \( \mscrX = (X, I) \) of finite cardinality \( n \) over \( \Sigma \).

  Then there exists a closed formula \( \varphi_\mscrX \) that characterizes \( \mscrX \) in the sense that every structure over \( \Sigma \) satisfying \( \varphi_\mscrX \) is \hyperref[def:first_order_isomorphism]{isomorphic} to \( \mscrX \).

  For this to hold, we need \( \Sigma \) to contain no predicate symbols.
\end{lemma}
\begin{proof}
  Let \( a_1, \ldots a_n \) be an enumeration of the elements of \( X \). First, we will define set \( \Gamma_\mscrX \) of atomic formulas that capture the structure of \( \mscrX \):
  \begin{itemize}
    \item Fix a function symbol \( f \) in \( \Sigma \) of arity \( m \). For every \( m \)-tuple \( a_{i_1}, \ldots, a_{i_m} \) from \( X \), if \( f(a_{i_1}, \ldots, a_{i_m}) = a_j \), add to \( \Gamma_\mscrX \) the formula
    \begin{equation*}
      f(\synx_{i_1}, \ldots, \synx_{i_m}) \syneq \synx_j.
    \end{equation*}

    \item Fix a predicate symbol \( p \) in \( \Sigma \) of arity \( m \). For every \( m \)-tuple \( a_{i_1}, \ldots, a_{i_m} \) from \( X \) add to \( \Gamma_\mscrX \) the formula
    \begin{equation*}
      p(\synx_{i_1}, \ldots, \synx_{i_m})
    \end{equation*}
    if \( I(p)(a_{i_1}, \ldots, a_{i_m}) = \semtop \) and
    \begin{equation*}
      \synneg p(\synx_{i_1}, \ldots, \synx_{i_m})
    \end{equation*}
    otherwise.
  \end{itemize}

  For \( \varphi_\mscrX \) itself, we can take any \hyperref[def:fol_quantifier_closure]{existential closure} of any conjunction of all formulas in \( \Gamma_\mscrX \).

  Clearly \( \mscrX \) satisfies \( \varphi_\mscrX \) by sending \( \synx_i \) to \( a_i \). By elementary equivalence, \( \mscrY \) also satisfies \( \varphi_\mscrY \). Then there exists a variable assignment \( v \) into \( Y \) such that
  \begin{equation*}
    J(f)\parens[\big]{ v(\synx_{i_1}), \ldots, v(\synx_{i_m}) } = v(\synx_j)
  \end{equation*}
  for every function application formula in \( \Gamma_\mscrX \), i.e. if and only if
  \begin{equation*}
    I(f)(a_{i_1}, \ldots, a_{i_m}) = a_j.
  \end{equation*}

  Similarly,
  \begin{equation*}
    J(p)\parens[\big]{ v(\synx_{i_1}), \ldots, v(\synx_{i_m}) } = I(p)\parens[\big]{ a_{i_1}, \ldots, a_{i_m} }
  \end{equation*}

  Then \( v \) defines an embedding \( h: X \to Y \) by sending \( a_i \) to \( v(\synx_i) \).

  To show that \( h \) is an isomorphism, we will use the cardinality control formulas from \cref{thm:cardinality_control_formulas}. Let \( n \) be the cardinality of \( X \). Then \( \mscrX \vDash \chi^{=n} \). By elementary equivalence, we have \( \mscrY \vDash \chi^{=n} \), which implies that \( Y \) also has cardinality \( n \).
\end{proof}

\begin{proposition}\label{thm:def:elementary_equivalence}
  \hyperref[def:elementary_equivalence]{Elementary equivalence} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:elementary_equivalence/isomorphic} If two structures are \hyperref[def:first_order_isomorphism]{isomorphic}, they are elementarily equivalent.

    \thmitem{thm:def:elementary_equivalence/embedding} If a structure \hyperref[def:first_order_embedding]{embeds} into another, it is elementarily equivalent to its image.

    \thmitem{thm:def:elementary_equivalence/elementary_embedding} Assuming \hyperref[def:truth_value_algebra/classical]{classical semantics}, if a structure \hyperref[def:elementary_embedding]{elementarily embeds} into another, they are elementarily equivalent.

    \thmitem{thm:def:elementary_equivalence/finite}\mcite[thm. 2.3.11(i)]{Hinman2005Logic} Assuming classical semantics, if two structures are elementarily equivalent and one of them is finite, they are isomorphic.

    The assumption of classical semantics can be lifted if the signature has no predicate symbols.

    \thmitem{thm:def:elementary_equivalence/infinite} If two structures are elementarily equivalent and one of them is infinite, so is the other.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:elementary_equivalence/isomorphic} \Cref{thm:def:elementary_embedding/isomorphism} implies that every isomorphism, as well as its inverse, are elementary embeddings.

  \SubProofOf{thm:def:elementary_equivalence/embedding} Follows from \cref{thm:def:elementary_equivalence/isomorphic}.

  \SubProofOf{thm:def:elementary_equivalence/elementary_embedding} Assume we are working with classical semantics. Let \( \mscrX = (Y, J) \) and \( \mscrY = (X, I) \) be structures over \( \Sigma \). Let \( h: X \to Y \) be an elementary embedding.

  Since \( h \) preserves all formulas, it preserves closed ones in particular, so every closed formula valid in \( \mscrX \) is also valid in \( \mscrY \).

  Conversely, let \( \varphi \) be a closed formula valid in \( \mscrY \).

  Aiming at a contradiction, suppose that it is not valid in \( \mscrX \). \Fullref{thm:propositional_semantic_lem} implies that \( \synneg \varphi \) is valid in \( \mscrX \). Since \( \synneg \varphi \) is closed, it does not depend on a variable assignment; thus, because \( h \) is an elementary embedding, we conclude that \( \synneg \varphi \) is also valid in \( \mscrY \).

  But then both \( \varphi \) and \( \synneg \varphi \) are valid in \( \mscrY \), which contradicts \cref{thm:def:fol_theory/model_theory_consistency}.

  The obtained contradiction shows that \( \varphi \) must be valid in \( \mscrX \). Generalizing on \( \varphi \), we conclude that \( \mscrX \) and \( \mscrY \) are elementarily equivalent.

  \SubProofOf{thm:def:elementary_equivalence/finite} Assume we are working with classical semantics. Let \( \mscrX \) and \( \mscrY \) be elementarily equivalent structures over \( \Sigma \). Suppose that \( \mscrX \) is finite.

  \Cref{thm:fol_finite_structure_characterizing_formula} gives us a closed formula \( \varphi_\mscrX \) that characterizes \( \mscrX \). By elementary equivalence, \( \mscrY \) satisfies \( \varphi_\mscrX \), hence it is isomorphic to \( \mscrX \).

  \SubProofOf{thm:def:elementary_equivalence/infinite} Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be structures over \( \Sigma \). Suppose that \( X \) is infinite.

  Again, we can use the cardinality control formulas from \cref{thm:cardinality_control_formulas}. We have \( \mscrX \vDash \chi^{\geq n} \) for every \( n \geq 1 \). By elementary equivalence, \( \mscrY \vDash \chi^{\geq n} \) for every \( n \geq 1 \), which implies that \( Y \) is also infinite.
\end{proof}

\begin{definition}\label{def:pure_equality}\mimprovised
  Over the empty \hyperref[def:fol_signature]{first-order signature}, consider the \hyperref[def:fol_theory]{theory} axiomatized by an empty set of sentences. Its only terms are variables and its atomic formulas are either logical constants or equality formulas. For this reason, we call it the \term{theory of pure equality} and denote it by \( \op*{Th}_{\syneq} \). Similarly, we denote the signature by \( \op*{Sign}_{\syneq} \).
\end{definition}

\begin{proposition}\label{thm:pure_equality_isomorphism}
  The \hyperref[def:pure_equality]{theory of pure equality} \( \op*{Th}_{\syneq} \) for \hyperref[def:fol_structure]{structures} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:pure_equality_isomorphism/function} Every function \( f: X \to Y \) between the structures \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) over \( \op*{Sign}_{\syneq} \) is a \hyperref[def:fol_homomorphism]{homomorphism}.

    \thmitem{thm:pure_equality_isomorphism/subset} Given two structures \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) over \( \op*{Sign}_{\syneq} \), if \( X \) is a subset of \( Y \), \( \mscrX \) is a substructure of \( \mscrY \).

    \thmitem{thm:pure_equality_isomorphism/model} Every structure over \( \op*{Sign}_{\syneq} \) is a model of \( \op*{Th}_{\syneq} \).

    \thmitem{thm:pure_equality_isomorphism/extensions} Every theory over every signature is an \hyperref[def:fol_theory/extension]{extension} of \( \op*{Th}_{\syneq} \).

    \thmitem{thm:pure_equality_isomorphism/isomorphism} Two structures over \( \op*{Sign}_{\syneq} \) are \hyperref[def:first_order_isomorphism]{isomorphic} if and only if they have the same \hyperref[thm:cardinality_existence]{cardinality}.

    \thmitem{thm:pure_equality_isomorphism/finite_elementary_equivalence} Two \hi{finite} structures over \( \op*{Sign}_{\syneq} \) are \hyperref[def:elementary_equivalence]{elementary equivalent} if and only if they have the same cardinality.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:pure_equality_isomorphism/function} The function \( f: X \to Y \) is vacuously a homomorphism because there are no function or predicate symbols.

  \SubProofOf{thm:pure_equality_isomorphism/subset} Also vacuous.

  \SubProofOf{thm:pure_equality_isomorphism/model} Since \( \op*{Th}_{\syneq} \) is the consequence closure of the empty set, \cref{thm:institutional_satisfaction_closure} implies that every structure \( \mscrX \) over \( \op*{Sign}_{\syneq} \) satisfying \( \varnothing \) also satisfies \( \op*{Th}_{\syneq} \).

  \SubProofOf{thm:pure_equality_isomorphism/extensions} The proof is trivial, but we will spell out the details.

  Let \( \iota: \op*{Sign}_{\syneq} \to \Sigma \) be the signature inclusion morphism into some signature \( \Sigma \).

  Consider some structure \( \mscrX \) over \( \Sigma \). Its \hyperref[def:fol_reduct_along_morphism]{reduct} \( \red_\iota(\mscrX) \) along \( \iota \) is a structure over \( \op*{Sign}_{\syneq} \). \Cref{thm:pure_equality_isomorphism/model} implies that \( \red_\iota(\mscrX) \) satisfies \( \op*{Th}_{\syneq} \), and \cref{def:institution/satisfaction} implies that \( \mscrX \) satisfies the translation \( \op*{Sen}(\iota)[\op*{Th}_{\syneq}] \).

  \SubProofOf{thm:pure_equality_isomorphism/isomorphism} Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, J) \) be two structures over \( \op*{Sign}_{\syneq} \).

  \SufficiencySubProof* Let \( h: X \to Y \) be an isomorphism. Then it is bijective, hence \( X \) and \( Y \) have the same cardinality.

  \NecessitySubProof* Suppose that \( X \) and \( Y \) have the same cardinality. Then there exists a bijective map \( h: X \to Y \), which is vacuously an isomorphism because there are no function or predicate symbols.

  \SubProofOf{thm:pure_equality_isomorphism/finite_elementary_equivalence}

  \SufficiencySubProof* \Cref{thm:def:elementary_equivalence/finite} implies that, if two structures are finite and elementarily equivalent, they are isomorphic.

  \NecessitySubProof* \Cref{thm:pure_equality_isomorphism/isomorphism} implies that, if two structures have the same cardinality, they are isomorphic. Then \cref{thm:def:elementary_embedding/isomorphism} implies that they are elementarily equivalent.
\end{proof}

\paragraph{Definitional extensions}

\begin{definition}\label{def:fol_theory}\mimprovised
  We restate here some definitions related to \hyperref[def:logical_theory]{logical theories}, adapted to \hyperref[def:first_order_logic]{first-order logic}.

  First and foremost, a (syntactic or semantic) \term[ru=теория (\cite[def. 3.1.1]{Герасимов2014Вычислимость}), en=theory (\cite[def. 2.4.1]{Hinman2005Logic})]{theory} is, as in \cref{def:general_logic_theory}, a set of sentences closed under logical consequence. For any set of sentences \( \Gamma \), we denote its consequence closure by \( \op*{Th}(\Gamma) \).

  \begin{thmenum}
    \thmitem{def:fol_theory/morphism} As in \cref{def:entailment_system_theory/morphism}, we call the \hyperref[def:fol_signature_category/morphisms]{first-order signature morphism} \( t: \Sigma \to \Theta \) a \term{theory morphisms} from \( (\Sigma, \Gamma) \) to \( (\Theta, \Delta) \) if the translation via \fullref{alg:fol_formula_signature_translation} of the formulas in \( \Gamma \) belong to \( \Delta \).

    \thmitem{def:fol_theory/extension} Of special interest is the case where \( t: \Sigma \to \Sigma^+ \) is the inclusion map of a \hyperref[def:fol_signature_extension]{signature extension}. In this case translation is does nothing, and \( t \) is a theory morphism from \( (\Sigma, \Gamma) \) to \( (\Sigma^+, \Gamma^+) \) if and only if \( \Gamma \) is a subset of \( \Gamma^+ \).

    We call \( \Gamma^+ \) an \term{extension} of \( \Gamma \).

    \thmitem{def:fol_theory/category} Based on theories and their morphisms, as per \cref{def:category_of_theories}, we have a (syntactic or semantic) category of theories \( \ucat{Th} \) for every \hyperref[def:grothendieck_universe]{Grothendieck universe} \( \mscrU \).

    \thmitem{def:fol_theory/conservative} As in \cref{def:entailment_system_theory/conservative}, we say that a theory morphism or extension is \term[en=conservative extension (\cite[180]{Hinman2005Logic})]{conservative} when \( \Gamma \nvDash_\Sigma \varphi \) implies \( \Delta \nvDash_\Theta \op*{Sen}(t)(\varphi) \).

    \thmitem{def:fol_theory/model}\mcite[def. 2.4.4]{Hinman2005Logic} As in \cref{def:theory_of_institutional_model}, we define the \term{theory} \( \op*{Th}(\mscrX) \) \hi{of} a structure \( \mscrX \) as the set of all sentences valid in \( \mscrX \).
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:def:fol_theory}
  \hyperref[def:fol_theory]{First-order theories} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:fol_theory/model_theory_consistency} For every structure \( \mscrX \), the theory \( \op*{Th}(\mscrX) \) is \hyperref[def:consistent_set_of_sentences]{consistent}.

    \thmitem{thm:def:fol_theory/model_theory_completeness} For every structure \( \mscrX \), the theory \( \op*{Th}(\mscrX) \) is \hyperref[def:complete_set_of_sentences]{complete}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:def:fol_theory/model_theory_consistency} Follows from \fullref{thm:propositional_semantic_lnc} (translated via \fullref{alg:fol_propositional_formula_translation}). We use the equivalent condition \cref{thm:propositional_semantic_inconsistency/unsatisfiable} for consistency.

  \SubProofOf{thm:def:fol_theory/model_theory_completeness} Fix a structure \( \mscrX \).

  A formula \( \varphi \) is either valid in \( \mscrX \) or not. In the latter case \fullref{thm:propositional_semantic_lem} implies that \( \synneg \varphi \) is valid.

  \Cref{thm:propositional_complete_set} then implies that \( \op*{Th}(\mscrX) \) is complete.
\end{proof}
