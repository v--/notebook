\section{Simply typed lambda terms}\label{sec:simply_typed_lambda_terms}

Unlike untyped lambda calculus, whose presentation is mostly uniform across authors, type theory has many incompatible flavors. A concise history is described in \fullref{rem:type_theory}. We will only consider so-called \enquote{simple types}. As discussed in \fullref{rem:arrow_typing_rules_only}, typed \( \lambda \)-calculus shifts the perspective from terms to type derivations.

\paragraph{Type systems}

\begin{remark}\label{rem:type_theory}
  \incite*[237]{Russell1908TypeTheory} gives the following definition:
  \begin{displayquote}
    A \textit{type} is defined as the range of significance of a propositional function, i.e., as the collection of arguments for which the said function has values.
  \end{displayquote}

  Russell himself was trying to resolve \hyperref[rem:self_reference]{self-referential} paradoxes by circumventing \hyperref[con:impredicativity]{impredicativity}. This is briefly discussed in \fullref{rem:self_reference}.

  He used \enquote{individuals} loosely for \enquote{terms of elementary propositions}, where he defined terms as \enquote{whatever can be regarded as the \textit{subject} of the proposition}.

  A clearer formalization is due to Alonzo Church. In \cite{Church1940STT}, he extends untyped \( \synlambda \)-calculus with what he, based on intermediate works by other authors, calls \enquote{simple types}. He uses the letter \( \omicron \) for \enquote{the type of propositions} and \( \iota \) for \enquote{the type of individuals}. Given the types \( \alpha \) and \( \beta \), Church regards the type \( (\alpha\beta) \) as
  \begin{displayquote}
    \textellipsis the type of functions of one variable for which the range of the independent variable comprises the type \( \beta \) and the range of the dependent variable is contained in the type \( \alpha \).
  \end{displayquote}

  Thus, he used two \enquote{base types} and one \enquote{type constructor}, resulting in infinitely many types. He assigned to each \( \synlambda \)-term a subscript indicating its type, with certain coherence conditions that exclude \hyperref[def:typability]{untypable terms}. The term \( x_\omicron \) would thus correspond to our notion of propositional formula, while the term \( x_\iota \) --- to a first-order variable.

  Subsequent works by Curry and Howard lead to the Curry-Howard correspondence discussed in \fullref{con:curry_howard_correspondence}. This in turn lead Martin-Löf to introduce \hyperref[con:dependent_types]{dependent types} and systemize the presentation of type theory via \hyperref[con:typing_rule]{typing rules}.

  At this point, notation started unifying across authors, ultimately leading to \enquote{\( M: \tau \)} rather than \enquote{\( M_\tau \)} or \enquote{\( M^\tau \)} for \hyperref[def:type_assertion]{type assertions} postulating that the term \( M \) has type \( \tau \), and to \( \tau \synimplies \sigma \) for \enquote{function types}, replacing Church's equivalent \( (\sigma\tau) \) (and swapping \( \tau \) and \( \sigma \)). As we will see in \fullref{con:type_annotation} and \fullref{def:typed_lambda_term}, superscript notation is still convenient for type annotation.

  These conventions were already present in \bycite{CoquandHuet1986CoC}. His paper introduces the \enquote{calculus of constructions} in which functions can be defined from terms to types, from types to terms and from types to types. This generalizes Martin-L\"of's dependent products, which can be regarded as functions from terms to types. \incite[192]{Barendregt1992LambdaCalculiWithTypes} places simple type theory and the calculus of constructions as the least and most powerful type systems in his \enquote{\( \synlambda \)-cube}, where the axes correspond to the aforementioned three kinds of functions. These are further generalized by \enquote{pure type systems}, again discussed in the same article. As types become more complicated, they require flexible syntax, and the line between types and terms starts blurring.

  Another significant development is \enquote{\hyperref[con:homotopy_type_theory]{homotopy type theory}}, introducing semantics for types based on topological spaces. In the eponymous community-written book, \cite{UnivalentProject2024OctoberHoTT}, homotopy type theory is attributed to \cite{Voevodski2006HoTT} and \cite{AwodeyWarren2009HoTT}.

  Simple, dependent and homotopy type theory are presented in a unified manner in \cite{Mimram2020ProgramEqualsProof}, with connections to proof theory based on \fullref{sec:curry_howard_correspondence}.
\end{remark}

\begin{definition}\label{def:type_assertion}\mimprovised
  Suppose we are given two \hyperref[def:formal_grammar/schema]{formal grammars} producing strings called \term{terms} and \term{types}, correspondingly. Terms and types may intersect or even coincide, as mentioned in \fullref{rem:type_theory}.

  We will be interested in expressions generated by the following rule:
  \begin{bnf*}
    \bnfprod{type assertion} {\bnfpn{term} \bnfsp \bnftsq{\( : \)} \bnfsp \bnfpn{type}}.
  \end{bnf*}
\end{definition}
\begin{comments}
  \item When terms are given an interpretation as some objects, we may say \enquote{\( x \) is an object of type \( \tau \)} rather than \enquote{\( x \) is a term of type \( \tau \)}.

  \item On a metatheoretic level, this is one of several kinds of \hyperref[con:judgment]{judgments} that Martin-L\"of uses for his type systems; see \fullref{rem:typing_judgments} for a broader discussion.

  \item This terminology is unfortunately not well-established. For example, \incite[def. 2A4]{Hindley1997BasicSTT} and \incite[380]{BarendregtDekkersStatman2013LambdaCalculusWithTypes} prefer the phrase \enquote{type assignment}, \incite[def. 5.1.10]{Barendregt1992LambdaCalculiWithTypes} uses \enquote{statement}, while \incite[ch. 4]{Mimram2020ProgramEqualsProof} uses the type assertion syntax without introducing terminology for such expressions.

  \item Unlike the terminology, the colon notation for \hyperref[rem:typing_judgments]{typing judgments} is ubiquitous, as discussed in \cite{MathSE:origin_of_colon_notation_for_type_assertions}. The set membership notation \( M \in \tau \) is used by Martin-L\"of in his earlier works \cite{MartinLöf1975IntuitionisticTypeTheory} and \cite{MartinLöf1984IntuitionisticTypeTheory}, but in \cite{MartinLöf1994TypeJudgments} he already uses colons.
\end{comments}

\begin{remark}\label{rem:type_universes}
  If in some flavors of \hyperref[rem:type_theory]{type theory} terms and types share a common syntax, we can express the statement \enquote{\( \tau \) is a type} via the \hyperref[def:type_assertion]{type assertion}
  \begin{equation*}
    \tau: \op*{Type},
  \end{equation*}
  where \( \op*{Type} \) is a predefined constant term.

  Unfortunately, as described in \incite[\S 8.2.3]{Mimram2020ProgramEqualsProof}, in a sufficiently general setting this leads to a variant of \fullref{thm:russels_paradox} due to Jean-Yves Girard. A workaround suggested by Mimram resembling the \hyperref[def:axiom_of_universes]{axiom of Grothendieck universes} is the introduction of a sequence of type universes
  \begin{equation*}
    \op*{Type}_0: \op*{Type}_1: \op*{Type}_2: \cdots
  \end{equation*}
  such that \( \tau: \op*{Type}_k \) implies \( \tau: \op*{Type}_{k+1} \).
\end{remark}

\begin{remark}\label{rem:typing_judgments}
  Martin-L\"of builds his type theory on several kinds of \hyperref[con:judgment]{judgments}. In \cite[19]{UnivalentProject2024OctoberHoTT}, they are classified as either \hyperref[def:type_assertion]{type assertion} judgment or \hyperref[con:equality]{definitional equality} judgments.

  \incite*[14]{MartinLöf1984IntuitionisticTypeTheory} distinguishes between the judgments \enquote{\( \tau \) is a type} and \enquote{\( x \) is an object of type \( \tau \)}\fnote{To be precise, these aren't exact quotes because Martin-L\"of refers to types as \enquote{sets} in this concrete work, and uses set-membership notation, which is a deviation from his other, even earlier, works.}, and similarly between \enquote{\( \tau \) and \( \sigma \) are equal sets} and \enquote{\( x \) and \( y \) are equal objects of type \( \tau \)}. As discussed in \fullref{rem:type_universes}, however, these amount to the same judgment since we can regard types as objects of a \enquote{type universe}.
\end{remark}

\begin{definition}\label{def:type_context}\mcite[def. 2A5]{Hindley1997BasicSTT}
  A \term[en=type-context (\cite[def. 2A5]{Hindley1997BasicSTT})]{type context} is a (set-based) \hyperref[def:logical_context]{logical context} whose entries are \hyperref[def:type_assertion]{type assertion} for \hi{distinct variables}. We have purposely not specified syntax for the terms nor the types, and we simply assume that the terms contain a subset consisting of variables.

  We say that the assertion \( x: \tau \) is \term{consistent} with the context \( \Gamma \) if \( \Gamma \) contains no type assertion for \( x \).
\end{definition}
\begin{comments}
  \item We generalize the definition from the case of \hyperref[def:simple_type]{simple types} considered by Hindley.

  \item The decision to restrict ourselves to variables comes is discussed in \fullref{rem:type_context_only_variables}.

  \item Another possibility, instead of requiring the variables to be distinct, is, as in \cite[159]{Mimram2020ProgramEqualsProof}, to allow contexts to contain more than one type assertion per variable and only consider the last assertion.
\end{comments}

\begin{definition}\label{def:abstract_type_system}\mimprovised
  A \term{abstract type system} is, roughly, a systematic way of evaluating \hyperref[def:type_assertion]{type assertions}, usually via a collection of \hyperref[con:typing_rule]{typing rules}.

  Such a system must feature a \hyperref[def:consequence_relation]{consequence relation} on \hyperref[def:type_assertion]{type assertions} whose contexts must be \hyperref[def:type_context]{type contexts}, i.e. contain type assertions for distinct variables.
\end{definition}
\begin{comments}
  \item A very general definition is given by \incite[def. 5.2.1]{Barendregt1992LambdaCalculiWithTypes}, who considers \enquote{pure type systems} with a concrete common syntax for both terms and types, but with only an informal notion of typing rules. Here we abstract away both the syntax and the way of obtaining a consequence relation.
\end{comments}

\paragraph{Simple types}

\begin{definition}\label{def:simple_type}\mimprovised
  Fix a nonempty finite \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Base} \), whose elements we will call \term{base types}. We introduce \term{simple types} based on the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{arrow type}   {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}} \\
    \bnfprod{type}         {\bnfpn{base type} \bnfor \bnfpn{arrow type}}
  \end{bnf*}

  We will also find useful the following extensions:
  \begin{bnf*}
    \bnfprod{product type} {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \syntimes \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}} \\
    \bnfprod{sum type}     {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synplus \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}}
  \end{bnf*}

  We handle product types in \fullref{def:product_type} and sum types in \fullref{def:sum_type}, and use both in \fullref{alg:proof_tree_to_type_derivation} and \fullref{alg:type_derivation_to_proof_tree}, but avoid them otherwise. In order to be explicit about specifying these and possibly other extensions, we introduce simple type systems in \fullref{def:simple_type_system}.
\end{definition}
\begin{comments}
  \item As it often happens, usage in the literature is not consistent. We discuss this in \fullref{rem:simple_type_terminology_and_notation}. To avoid ambiguity, we will be explicit about which types we allow in our applications.

  \item We will mostly restrict ourselves to arrow types because handling each extension requires additional work. The literature listed in \fullref{rem:simple_type_terminology_and_notation} avoids extensions unless necessary.

  \item \fullref{rem:simple_type_parentheses}.
\end{comments}

\begin{remark}\label{rem:simple_type_terminology_and_notation}
  \hyperref[def:simple_type]{Simple types} are unfortunately not standardized, and naturally, allow variations in their definition.

  For example, the following authors consider arrow types (but not e.g. product types), however their definitions differ by their handling of base types:
  \begin{itemize}
    \item \incite[56]{Church1940STT}, \incite[\S 51]{Andrews2002Logic} and \incite[269]{Farmer2008STTVirtues} allow exactly two base types --- of propositions and individuals, as discussed in \fullref{rem:type_theory}.

    \item \incite[def. 3.2.2]{Barendregt1992LambdaCalculiWithTypes}, \incite{Hindley1997BasicSTT} and \incite[def. 1.2.1]{TroelstraSchwichtenberg2000BasicProofTheory} disallow base types, thus leaving only arrow types and \enquote{type variables} (resembling the variable placeholders from \fullref{def:lambda_term_schema}).

    \item \incite[def. 1.1.11]{BarendregtDekkersStatman2013LambdaCalculusWithTypes} allow an arbitrary nonempty set of base types, which they call \enquote{type atoms}.
  \end{itemize}

  \incite[ch. 4]{Mimram2020ProgramEqualsProof} initially only considers arrow types without base types, but later allows two base types --- the empty and unit types -- as well as product and sum types.

  Additionally, what we call \enquote{arrow type} is also treated differently across authors:
  \begin{itemize}
    \item \incite[56]{Church1940STT} and \incite[\S 51]{Andrews2002Logic} use the notation \enquote{\( (\tau\sigma) \)} for what we would write as \( \sigma \synimplies \tau \). This is discussed in \fullref{rem:type_theory}.

    Neither introduce a dedicated term for arrow types.

    \item \incite[def. 1.2.1]{TroelstraSchwichtenberg2000BasicProofTheory} and \incite[269]{Farmer2008STTVirtues} use arrow notation and call them \enquote{function types}.

    \item \incite[\S 4.1.1]{Mimram2020ProgramEqualsProof} uses the arrow notation and calls them \enquote{arrow types}.

    \item \incite[def. 1.1.11]{BarendregtDekkersStatman2013LambdaCalculusWithTypes} uses the arrow notation and calls them \enquote{function space types}.

    \item \incite[def. 2A1]{Hindley1997BasicSTT} uses the arrow notation and calls them \enquote{composite types}.

    \item \incite[def. 3.2.2]{Barendregt1992LambdaCalculiWithTypes} use the arrow notation but introduces no special term.
  \end{itemize}
\end{remark}

\begin{proposition}\label{thm:simple_type_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:simple_type]{simple types} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:simple_type_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:simple_type_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:simple_type_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  Similar to \fullref{thm:propositional_formula_grammar}.
\end{proof}

\begin{remark}\label{rem:simple_type_parentheses}
  We use some \enquote{abuse-of-notation} \hyperref[con:metalogic]{metalingual} syntactic conventions:
  \begin{thmenum}
    \thmitem{rem:simple_type_parentheses/outermost} As in \fullref{rem:propositional_formula_parentheses/outermost} and \fullref{rem:lambda_term_parentheses/outermost}, we avoid writing the outermost parentheses in types.

    \thmitem{rem:simple_type_parentheses/arrow} We suppose that the arrow in arrow types is \hyperref[rem:binary_operation_syntax_trees/associativity]{right-associative}, which allows us to vastly simplify notation in some cases. This helps highlight the types of terms than can be \enquote{applied} to abstractions. See \fullref{ex:def:type_derivation_tree/pairs} and \fullref{ex:def:type_derivation_tree/disjoint} for examples.

    This convention is used by our main sources --- \incite[2A1.1]{Hindley1997BasicSTT}, \incite[notation 3.1.2]{Barendregt1992LambdaCalculiWithTypes} and \incite[\S 4.1.1]{Mimram2020ProgramEqualsProof}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:simple_type_ast}\mimprovised
  We implicitly associate with each \hyperref[def:simple_type]{simple type} \( \tau \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\tau) \) as follows:
  \begin{thmenum}
    \thmitem{def:simple_type_ast/atom} If \( \tau \) is a base type, we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:simple_type_ast/application} If \( \tau = \sigma \syncirc \rho \), where \( {\syncirc} \in \set{ \synimplies, \synplus, \syntimes } \), assuming we have already built \( T(\sigma) \) and \( T(\rho) \), we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} \( T(\sigma) \) and \( T(\rho) \) to a new root labeled with \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__simple_type_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\paragraph{Type annotations}

\begin{concept}\label{con:type_annotation}
  The \hyperref[def:type_assertion]{type assertion} \( M: \tau \) is a syntactic construction, and it is possible to assign different meanings to it. The obvious one is to perceive it as a \hyperref[rem:typing_judgments]{typing judgment} expressing that the term \( M \) has type \( \tau \).

  Another possibility, used across programming languages, is merely to highlight intention. In this case we call \( \tau \) a \term{type annotation} for \( M \) --- it is part of the language's syntax, and it merely expresses the intended type of \( M \). Whether or not \( M \) will have type \( \tau \) depends on how the language is interpreted. We will make this precise when discussing typed terms in \fullref{ex:def:type_derivation_tree}.

  For convenience, we follow Howard's convention from \cite{Howard1980FormulasAsTypes} of denoting type annotations by superscripts, i.e. \( M^\tau \) rather than \( M: \tau \). Not only is it the notation more concise, it also allows us to distinguish annotations from assertions.
\end{concept}
\begin{comments}
  \item Superscripts are also used in \cite{Mimram2020ProgramEqualsProof} and \cite[ch. 5]{Hindley1997BasicSTT}. On the other hand, \incite{Barendregt1992LambdaCalculiWithTypes} uses colons for both annotations and assertions.

  \item The phrase \enquote{type annotation} is used, for example, in TypeScript's handbook, \cite{TypeScriptDocs:5.7:handbook}, as well as in Python's documentation, \cite{PythonDocs:3.13:typing} (the latter also call annotations \enquote{type hints}).

  \incite[186]{Mimram2020ProgramEqualsProof} also uses \enquote{type annotation} when discussing Church style typing.
\end{comments}

\begin{definition}\label{def:typed_lambda_term}\mimprovised
  We consider the extension of the grammar schema of untyped \( \synlambda \)-term from \fullref{def:lambda_term} in which \hyperref[def:lambda_abstractor]{abstractor variables} have \hyperref[con:type_annotation]{type annotations} attached. Note that annotated variables are not by themselves considered terms --- variable annotations are only used in the abstractor.

  More precisely, we have the following grammar based on that of untyped \( \synlambda \)-terms from \fullref{def:lambda_term}:
  \begin{bnf*}
    \bnfprod{annotated variable} {\bnfpn{variable} \bnfsp \bnftsq{:} \bnfsp \bnfpn{type}}, \\
    \bnfprod{typed application}  {\bnftsq{\( ( \)} \bnfsp \bnfpn{typed term} \bnfsp \bnfpn{typed term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{typed abstraction}  {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{annotated variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{typed term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{typed term}         {\bnfpn{constant} \bnfor \bnfpn{variable} \bnfor} \\
    \bnfmore                     {\bnfpn{typed application} \bnfor \bnfpn{typed abstraction}.}
  \end{bnf*}

  Following \fullref{con:type_annotation}, in the \hyperref[con:metalanguage]{metalanguage}, we will use the notation \( \qabs {x^\tau} M \) rather than \( \qabs {x: \tau} M \).
\end{definition}
\begin{comments}
  \item This definition is dependent on our choice for the syntax of types; unless noted otherwise, we suppose we are dealing with \hyperref[def:simple_type]{simple types}.

  \item Even though most concepts from untyped terms transfer via \fullref{alg:type_erasure}, some like \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence} require modification --- see \fullref{def:typed_term_alpha_equivalence}.

  \item Our definition is based on \bycite[def. 3.2.1]{Barendregt1992LambdaCalculiWithTypes}, who prefers calling such terms \enquote{pseudoterms} because the grammar may produce \enquote{ill-typed} terms that are not \hyperref[def:typability]{typable} according to the rules in \fullref{def:arrow_typing_rules}.

  We borrow the phrase \enquote{typed term} from \incite[ch. 5]{Hindley1997BasicSTT}, who however follows Church in annotating every term. Our variant, also used by \incite[\S 4.1.3]{Mimram2020ProgramEqualsProof}, only guarantees uniqueness (but not existence) of a type for each term; this is shown in \fullref{thm:typed_term_habitation_uniqueness}.
\end{comments}

\begin{algorithm}[Type erasure]\label{alg:type_erasure}
  To each \hyperref[def:typed_lambda_term]{typed \( \synlambda \)-terms} there corresponds an \hyperref[def:lambda_term]{untyped \( \synlambda \)-term} obtained by removing the type annotations from all abstractor variables.
\end{algorithm}
\begin{comments}
  \item The phrase \enquote{type erasure} is used for \( \synlambda \)-terms by \incite[def. 5A2]{Hindley1997BasicSTT}.
  \item Erasure naturally extends to \hyperref[def:simple_type_schema]{\( \synlambda \)-term schemas}.
  \item This algorithm can be found as \identifier{lambda_.erasure.erase_annotations} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:mixed_lambda_term}\mimprovised
  We can define \term{mixed \( \synlambda \)-terms} by allowing both \hyperref[def:lambda_term]{untyped abstractions} and \hyperref[def:typed_lambda_term]{typed abstractions}.

  Mixed terms purport to gradual typing systems --- see \fullref{rem:gradually_typed_terms} for a broader discussion. We will not find use of them in this monograph since we will not study gradual typing. Furthermore, the adaptations for \( \alpha \)-equivalence and reductions in \fullref{sec:type_derivation_algorithms} becomes much more complicated with mixed terms involved, which is another reason to avoid them.

  We do allow mixed terms in the program code for this chapter --- the module \identifier{lambda_.terms.terms} in \cite{notebook:code} --- however the reason for this is mostly technical as it allows us to simplify several constructs. Typed and untyped terms generally require different approaches.
\end{remark}

\paragraph{Schemas for simply typed \( \synlambda \)-terms}\hfill

To formalize typing rules in \fullref{def:simple_typing_rule}, we first need to introduce schemas for simple types and \( \synlambda \)-terms.

\begin{definition}\label{def:simple_type_schema}
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:simple_type]{simple types} in an obvious way:
  \begin{bnf*}
    \bnfprod{type placeholder}    {\bnfpn{Small Greek identifier}} \\
    \bnfprod{arrow type schema}   {\bnftsq{(} \bnfsp \bnfpn{type schema} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type schema} \bnfsp \bnftsq{)}} \\
    \bnfprod{type schema}         {\bnfpn{base type} \bnfor \bnfpn{type placeholder} \bnfor \bnfpn{arrow type schema}},
  \end{bnf*}
  where we use the variable identifier rules from \fullref{def:variable_identifier}.

  Product and sum types are handled similarly.
\end{definition}
\begin{comments}
  \item To distinguish type schemas from term schemas, which we also denote via capital Greek identifiers, for types we will prefer letters from the start of the alphabet. Thus, \( \Psi: \Alpha \) is a type assertion for term and type schemas.
\end{comments}

\begin{definition}\label{def:lambda_term_schema}
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:lambda_term]{\( \synlambda \)-terms}:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Capital Latin identifier}}, \\
    \bnfprod{application schema}   {\bnftsq{\( ( \)} \bnfsp \bnfpn{term schema} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{abstraction schema}   {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable placeholder} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term schema}          {\bnfpn{constant} \bnfor \bnfpn{variable placeholder} \bnfor \bnfpn{term placeholder} \bnfor} \\
    \bnfmore                       {\bnfpn{application schema} \bnfor \bnfpn{abstraction schema}}.
  \end{bnf*}
  and also extend this to \hyperref[def:typed_lambda_term]{typed \( \synlambda \)-terms} by allowing annotations to variable placeholders in abstractor schemas.
\end{definition}
\begin{comments}
  \item This syntax does not allow us to distinguish between variables and variable placeholders, however the distinction should be quite clear from the context.

  \item Similarly to propositional formula schemas, we will denote arbitrary schemas via capital Greek identifiers like \( \Phi \).
\end{comments}

\begin{definition}\label{def:lambda_schema_instantiation}
  We define \hyperref[con:schemas_and_instances]{schema instantiations} for \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \synlambda \)-term schemas} and \hyperref[def:simple_type_schema]{simple type schemas} as \hyperref[def:set_valued_map/partial]{partial maps} sending \hyperref[def:lambda_term_schema]{variable placeholders} to \hyperref[def:lambda_term]{variables}, \hyperref[def:lambda_term_schema]{\( \synlambda \)-term placeholders} to \hyperref[def:lambda_term]{\( \synlambda \)-terms} and \hyperref[def:simple_type_schema]{type placeholders} to \hyperref[def:simple_type]{simple types}.

  \begin{thmenum}
    \thmitem{def:lambda_schema_instantiation/types} We extend the instantiation \( \Bbbs \) to compound simple types straightforwardly:
    \begin{equation}\label{eq:def:lambda_schema_instantiation/types}
      \Phi[\Bbbs] \coloneqq \begin{cases}
        \tau,                                  &\tau \T{is a base type},        \\
        \Bbbs(\tau),                           &\tau \T{is a placeholder},      \\
        \sigma[\Bbbs] \synimplies \rho[\Bbbs], &\tau = \sigma \synimplies \rho, \\
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_schema_instantiation/terms} For terms, we will not concern ourselves with \hyperref[def:lambda_variable_occurrence]{free and bound occurrence} of variables as in the case of \hyperref[def:lambda_term_substitution]{substitution} --- schemas are not meant for that. We suppose that all occurrences of the same variable placeholder refer to the same variable.

    Thus, we extend \( \Bbbs \) to compound \( \synlambda \)-term schemas as follows:
    \begin{equation}\label{eq:def:lambda_schema_instantiation/terms}
      \Phi[\Bbbs] \coloneqq \begin{cases}
        M,                                       &M \T{is a constant},             \\
        \Bbbs(M),                                &M \T{is a variable placeholder}, \\
        \Bbbs(M),                                &M \T{is a term placeholder},     \\
        N[\Bbbs] \thinspace K[\Bbbs],            &M = NK,                          \\
        \qabs {\Bbbs(x)} N[\Bbbs],               &M = \qabs x N,                   \\
        \qabs {\Bbbs(x)^{\Bbbs(\tau)}} N[\Bbbs], &M = \qabs {x^\tau} N.              \\
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_schema_instantiation/assertion} Finally, given an assertion \( \Psi: \Alpha \), we let
    \begin{equation}\label{eq:def:lambda_schema_instantiation/assertion}
      (\Phi: \Alpha)[\Bbbs] \coloneqq \Phi[\Bbbs]: \Alpha[\Bbbs]
    \end{equation}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Of course, an application of an instantiation is only valid if the placeholders are in its domain.

  \item Another possibility is to keep instantiations for term and type schemas distinct. However, that would complicate handling typed terms and type assertions unnecessarily.
\end{comments}

\paragraph{Typing rules}

\begin{concept}\label{con:typing_rule}
  A \term{typing rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[rem:typing_judgments]{typing judgments}, likely for \hyperref[con:schemas_and_instances]{schemas} rather than terms and types.
\end{concept}
\begin{comments}
  \item We base this informal definition on Martin-L\"of discussion in \cite{MartinLöf1984IntuitionisticTypeTheory} of rules for his type theory consisting of \hyperref[def:type_assertion]{type assertion} and \hyperref[con:equality]{definitional equality} judgments.

  \item See \fullref{rem:type_theory_rule_classification} for a classification of rules used in type theory.
\end{comments}

\begin{definition}\label{def:simple_typing_rule}\mimprovised
  A \term{simple typing rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \synlambda \)-term schemas} and \hyperref[def:simple_type_schema]{simple type schemas}.

  As in the case of natural deduction rules defined in \fullref{def:natural_deduction_rule}, and using the same formalism, we allow dischargeable type assertions to be attached to the premises. In light of \fullref{rem:type_context_only_variables}, we allow only variable assertions to be discharged.
\end{definition}
\begin{comments}
  \item This precise definition will allow us to mechanize the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for simple types.

  \item Typing rules are often presented in another form that resembles sequent calculus rather than natural deduction --- see \fullref{rem:sequence_calculus_typing_rules}.
\end{comments}

\begin{definition}\label{def:arrow_typing_rules}\mcite[26]{TroelstraSchwichtenberg2000BasicProofTheory}
  The fundamental \hyperref[def:type_derivation_tree]{typing rules} for \hyperref[def:simple_type]{simple types} only concern arrow types:
  \begin{equation*}\taglabel[\ensuremath{ \rightarrow^- }]{inf:def:arrow_typing_rules/elim}
    \begin{prooftree}
      \hypo{ \synM: \syn\tau \synimplies \syn\sigma }
      \hypo{ \synN: \syn\tau }
      \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synM \synN: \syn\sigma }
    \end{prooftree}
  \end{equation*}
  \begin{paracol}{2}
    \begin{leftcolumn}
      \centering
      \begin{equation*}\taglabel[\ensuremath{ \rightarrow^+ }]{inf:def:arrow_typing_rules/intro/implicit}
        \begin{prooftree}
          \hypo{ [\synx: \syn\tau] }
          \ellipsis {} { \synM: \syn\sigma }
          \infer1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \synM: \syn\tau \synimplies \syn\sigma }
        \end{prooftree}
      \end{equation*}
      (for \hyperref[def:lambda_term]{untyped terms})\phantom{\( \rightarrow^+ \)}
    \end{leftcolumn}

    \begin{rightcolumn}
      \centering
      \begin{equation*}\taglabel[\ensuremath{ \rightarrow_{\T{tt}}^+ }]{inf:def:arrow_typing_rules/intro/explicit}
        \begin{prooftree}
          \hypo{ [\synx: \syn\tau] }
          \ellipsis {} { \synM: \syn\sigma }
          \infer1[\ref{inf:def:arrow_typing_rules/intro/explicit}]{ \qabs {\synx^{\syn\tau}} \synM: \syn\tau \synimplies \syn\sigma }
        \end{prooftree}
      \end{equation*}
      (for \hyperref[def:typed_lambda_term]{typed terms})\phantom{\( \rightarrow_\tau^+ \)}
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item These are the typing rules present in this or a more general form in all our cited works of type theory --- see \fullref{rem:sequence_calculus_typing_rules}. We will require them to be a part of every \hyperref[def:simple_type_system]{simple type system}.
\end{comments}

\begin{remark}\label{rem:sequence_calculus_typing_rules}
  Consider the \hyperref[def:simple_typing_rule]{typing rule}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\synx: \syn\tau] }
      \ellipsis {} { \synM: \syn\sigma }
      \infer1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \synM: \syn\tau \synimplies \syn\sigma }
    \end{prooftree}
  \end{equation*}

  \incite[\S 4.1.4]{Mimram2020ProgramEqualsProof} and \incite[def. 2A8]{Hindley1997BasicSTT} express this rule in a form that resembles \hyperref[rem:sequent_calculus]{sequent calculus}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma, x: \syn\tau \synvdash \synM: \syn\sigma }
      \infer1{ \syn\Gamma \synvdash \qabs \synx \synM: \syn\tau \synimplies \syn\sigma }
    \end{prooftree}
  \end{equation*}

  For expressing a generalization of this rule in their more complicated type systems, the sequent calculus style is used by \incite{CoquandHuet1986CoC}, \incite{AwodeyWarren2009HoTT}, \incite{Voevodski2006HoTT}.

  Barendregt introduces both styles of rules in \cite[def. 3.1.3]{Barendregt1992LambdaCalculiWithTypes}, however prefers natural deduction style discharging for the actual proof trees.

  We prefer the natural deduction style rules since we find them easier to define formally, analyze and mechanize. This convention is used by Martin-L\"of, for example in \cite{MartinLöf1984IntuitionisticTypeTheory}. \incite[26]{TroelstraSchwichtenberg2000BasicProofTheory} also use this style to highlight the connection with natural deduction for formulas.
\end{remark}

\paragraph{Type derivations}

\begin{definition}\label{def:simple_type_signature}\mimprovised
  A \term{simple type signature} \( \Sigma \) is a specification of the following:
  \begin{itemize}
    \item A possibly empty set \( \op*{Const}_\Sigma \) of \hyperref[def:lambda_term]{\( \synlambda \)-term} \hyperref[def:lambda_term/const]{constants}, along with a subset \( \op*{Term}_\Sigma \) of \( \synlambda \)-terms we wish to restrict ourselves to.

    \item A nonempty set \( \op*{Base}_\Sigma \) of \hyperref[def:simple_type]{base types}, along with a subset \( \op*{Types}_\Sigma \) of simple types we wish to restrict ourselves to.
  \end{itemize}
\end{definition}

\begin{definition}\label{def:simple_type_system}\mimprovised
  A \term{simple type system} over a \hyperref[def:simple_type_signature]{simple type signature} is, unsurprisingly, a collection of \hyperref[def:simple_typing_rule]{simple typing rules}.

  Will presuppose that such a system includes the rule \ref{inf:def:arrow_typing_rules/elim} and either \ref{inf:def:arrow_typing_rules/intro/implicit} or \ref{inf:def:arrow_typing_rules/intro/explicit} (or even possibly both).
\end{definition}
\begin{comments}
  \item With every type system we will associate its typing style, defined in \fullref{def:simple_type_system_style}, and its derivability relation, defined in \fullref{def:simple_type_derivability}.

  \item We do not enforce this, but for the concrete systems we will make sure that the properties in \fullref{thm:def:simple_type_derivability} and \fullref{thm:typed_term_habitation_uniqueness} hold.
\end{comments}

\begin{definition}\label{def:simple_type_system_style}\mimprovised
  The arrow \hyperref[def:simple_typing_rule]{typing rules} in \fullref{def:arrow_typing_rules} feature distinct rules for \hyperref[def:typed_lambda_term]{typed} and \hyperref[def:lambda_term]{untyped \( \synlambda \)-terms}. Such a distinction is only necessary (and only possible) for rules featuring abstractor schemas.

  We call a rule using typed abstractors \term{explicitly typed} and a rule featuring untyped abstractors \term{implicitly typed}. We call this property the \term{typing style} of a rule. If both typed and untyped abstractions are used in a single rule, it is neither typed nor untyped, but we introduce no special term in this case since we consider it to be pathological.

  We call a \hyperref[def:simple_type_system]{simple type system} \term{explicitly typed} or \term{implicitly typed} if all its abstractor rules are of the corresponding kind. If the system features both kinds of rules, we call it \term{gradually typed}. Determining the typing style of a system is always possible since we have assumed that all systems include \ref{inf:def:arrow_typing_rules/intro/explicit} or \ref{inf:def:arrow_typing_rules/intro/implicit} (or both).
\end{definition}
\begin{comments}
  \item The importance of the typing style of a system is discussed in \fullref{rem:typing_style}.

  \item The phrases \enquote{explicit typing} and \enquote{implicit typing} are used by \incite[119]{Barendregt1992LambdaCalculiWithTypes} as alternatives for what we described in \fullref{rem:typing_style} as Church and Curry style typing, correspondingly.
\end{comments}

\begin{remark}\label{rem:mixed_terms_and_typing_style}
  We mentioned in \fullref{def:simple_type_system_style} that we consider pathological the rules featuring both typed and untyped abstractors, yet we did not hesitate to call a system featuring such rules \enquote{gradually typed}.

  Our reasoning is that a gradually typed system should allow typed, untyped, and even mixed \( \synlambda \)-terms. A rule with mixed schemas is instead able to \hi{only} handle terms that are neither typed nor untyped, making it suitable for very specific circumstances. We generally find it counterproductive to devote our attention to such rules.

  There may also be cases where mixing typed and untyped abstractors results in a legitimate rule, like the following, expressing \fullref{alg:type_erasure}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \qabs {\synx^{\syn\tau}} \synM: \syn\tau \synimplies \syn\sigma }
      \infer1{ \qabs \synx \synM: \syn\tau \synimplies \syn\sigma }
    \end{prooftree}
  \end{equation*}

  It is however merely an abbreviation of a proof tree featuring the more carefully crafted arrow type rules:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \qabs {\synx^{\syn\tau}} \synM: \syn\tau \synimplies \syn\sigma }
      \hypo{ \synx: \syn\tau }
      \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synM: \sigma }
      \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \synM: \tau \synimplies \tau }
    \end{prooftree}
  \end{equation*}
\end{remark}

\begin{definition}\label{def:type_derivation_tree}\mimprovised
  In analogy with natural deduction proof trees, which we define in \fullref{def:natural_deduction_proof_tree}, we will define here a family of \hyperref[def:labeled_tree]{labeled trees}, which we will call \term{type derivation trees}. Although we will be working in \hyperref[def:simple_type_system]{simple type systems}, the definition easily extends to more complicated systems.

  A fundamental difference compared to proof trees is that type derivations allow deriving the type of an arbitrarily complex \( \synlambda \)-term from a \hyperref[def:type_context]{type context} restricted to only variables. This is justified in \fullref{rem:type_context_only_variables}.

  As in the case of natural deduction proof trees, the labels of type derivations are triples:
  \begin{thmenum}[series=def:type_derivation_tree]
    \thmitem{def:type_derivation_tree/conclusion} A \hyperref[def:type_assertion]{type assertion}, which we call the \term{conclusion}.
    \thmitem{def:type_derivation_tree/rule_name} An empty string or the name of a \hyperref[def:simple_typing_rule]{typing rule}.
    \thmitem{def:type_derivation_tree/context} A \hyperref[def:type_context]{type context}, whose entries we will call \term{open assumptions}.
  \end{thmenum}

  We define two kinds of derivation trees:
  \begin{thmenum}[resume=def:type_derivation_tree]
    \thmitem{def:type_derivation_tree/assumption} We define \term{assumption} trees similarly to natural deduction assumptions, but only for variable type assertions. For the assertion \( x: \tau \), we define assumption tree as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with the following label:
    \begin{itemize}
      \item The conclusion is \( x: \tau \).
      \item The rule name is empty.
      \item The context is the singleton set with entry \( x: \tau \).
    \end{itemize}

    We will not need to annotate terms with markers --- the variable plays the role of a marker for the type.

    \thmitem{def:type_derivation_tree/application} We define \term{rule application} trees based on a straightforward adaptation of \fullref{def:natural_deduction_proof_tree/application} for natural deduction rule applications, with schema instantiation based on \fullref{def:lambda_schema_instantiation}.

    Again, some assumptions of the subtrees can be \term{discharged} if the rule allows it. The important difference is that we have no markers, so there is a unique choice of type assertion that can be discharged.

    Of course, we must only allow rule applications whose context of open assumptions satisfies \fullref{def:type_context} --- each variable must have at most one assertion.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Rule application is implemented programmatically as \identifier{lambda_.type_derivation.tree.apply} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:arrow_typing_rules_only}
  Rather than working with \hyperref[def:lambda_term]{\( \synlambda \)-terms}, as in the case of untyped \( \synlambda \)-calculus, we will often work with \hyperref[def:type_derivation_tree]{type derivation trees}. Thus, the assertion \( M: \alpha \) will presuppose the existence of a tree \( T \) deriving it, and proving other assertions will be based mostly on transforming \( T \).

  Although we allow general type systems with many rules, for proving properties of these systems we will only use \ref{inf:def:arrow_typing_rules/elim} and either \ref{inf:def:arrow_typing_rules/intro/implicit} or \ref{inf:def:arrow_typing_rules/intro/explicit}. Any other additional rules must be handled separately, which complicates the proofs by requiring additional cases to be verified. We will suppose that any additional rules are compatible with the theorems we will prove, however we will not prove that explicitly. The rules that we will consider will concern specific constant terms, so these theorems will necessarily hold for all terms not containing constants.

  Another nuance of working with derivation trees is that variable has a fixed type, so we may just as well assume that the terms are explicitly typed. Thus, most of the time we will not need the rule \ref{inf:def:arrow_typing_rules/intro/implicit} for untyped terms.

  The following is a list of results relying only on only \ref{inf:def:arrow_typing_rules/elim} and \ref{inf:def:arrow_typing_rules/intro/explicit}:
  \begin{thmenum}
    \thmitem{rem:arrow_typing_rules_only/assumptions_and_free_variables} Correspondence of free variables and assumption contexts: \fullref{thm:assumptions_and_free_variables}.

    \thmitem{rem:arrow_typing_rules_only/derivability} Base properties of derivability: \fullref{thm:def:simple_type_derivability}.

    \thmitem{rem:arrow_typing_rules_only/type_uniqueness} Type uniqueness for typed term: \fullref{thm:typed_term_habitation_uniqueness}.

    \thmitem{rem:arrow_typing_rules_only/type_inference} Type inference: \fullref{alg:simply_typed_term_type_derivation}.

    \thmitem{rem:arrow_typing_rules_only/substitution} Typed substitution: \fullref{alg:simply_typed_substitution} and \fullref{thm:typed_substitution_assertions}.

    \thmitem{rem:arrow_typing_rules_only/alpha_equivalence} Typed \( \alpha \)-equivalence: \fullref{alg:simply_typed_alpha_conversion} and \fullref{thm:alpha_equivalent_term_typing}.
  \end{thmenum}
\end{remark}

\begin{proposition}\label{thm:assumptions_and_free_variables}
  Let \( T \) be a \hyperref[def:type_derivation_tree]{type derivation tree} with conclusion \( M: \tau \).

  Then the variables having \hyperref[def:type_derivation_tree/context]{open assumptions} in \( T \) are precisely the free variable of \( M \).
\end{proposition}
\begin{comments}
  \item As discussed in \fullref{rem:arrow_typing_rules_only}, we restrict ourselves to the two arrow typing rules from \fullref{def:arrow_typing_rules}.
\end{comments}
\begin{proof}
  We will use simple case analysis on the structure of \( T \):
  \begin{itemize}
    \item If \( T \) is an assumption tree, then \( M \) must be a variable, and thus \( x: \tau \) is an open assumption in \( T \) if and only if \( M = x \).

    \item If \( T \) is an application of \ref{inf:def:arrow_typing_rules/elim}, then \( M = NK \) and \( T \) has subtrees deriving \( N: \rho \to \sigma \) and \( K: \rho \) for some type \( \rho \). We suppose that the inductive hypothesis holds for \( T_N \) and \( T_K \).

    Since nothing is discharged by this rule application, the open assumptions of \( M \) are the union of those of \( N \) and \( K \). The same holds for free variables.

    \item If \( T \) is an application of \ref{inf:def:arrow_typing_rules/intro/implicit}, \( M = \qabs y N \), \( \sigma = \rho \synimplies \delta \), and \( T \) has a subtree deriving \( N: \delta \) with the additional assumption \( y: \rho \). But this is precisely the additional free variable compared to those of \( M \).

    \item If \( T \) is an application of \ref{inf:def:arrow_typing_rules/intro/explicit}, we proceed identically.
  \end{itemize}
\end{proof}

\begin{definition}\label{def:simple_type_derivability}\mimprovised
  In a fixed \hyperref[def:simple_type_system]{simple type system} (specifying terms, types and rules), we define a \hyperref[def:consequence_relation]{consequence relation} on type assertions as follows: for a \hyperref[def:type_context]{type context} \( \Gamma \) and a \hyperref[def:type_assertion]{type assertion} \( M: \tau \), we let \( \Gamma \vdash M: \tau \) if there exists a \hyperref[def:type_derivation_tree]{type derivation tree} with conclusion \( M: \tau \) whose \hyperref[def:natural_deduction_proof_tree/context]{open assumptions} are all in \( \Gamma \).

  As per \fullref{def:logical_framework}, we say that the type assertion \( M: \tau \) is \term[en=derivable (\cite[def. 3.1.4]{Barendregt1992LambdaCalculiWithTypes})]{derivable} from \( \Gamma \) if this relation holds.
\end{definition}
\begin{defproof}
  We can prove that \( {\vdash} \) is indeed a consequence relation analogously to our proof of consistency in \fullref{def:natural_deduction_entailment}.
\end{defproof}
\begin{comments}
  \item We introduce additional terminology in \fullref{def:typability} and \fullref{def:type_habitation}.

  \item Note that \( \Gamma \) by definition consists of type assertions for variables and not for more general \( \synlambda \)-terms. This is discussed in \fullref{rem:type_context_only_variables}.
\end{comments}

\begin{remark}\label{rem:type_context_only_variables}
  In \fullref{def:simple_type_derivability} we have only defined a \hyperref[def:consequence_relation]{consequence relation} for \hyperref[def:type_context]{type context} consisting of type assertions for variables, i.e. \( \Gamma \vdash M: \tau \) can hold for an arbitrarily complex term \( M \), however the context \( \Gamma \) must have only variable type assertions. The types in both the context and the consequence are allowed to be arbitrarily complex.

  This is seemingly different from, for example, natural deduction proofs, where the context may consist of arbitrarily complex formulas. We would like to point out the following:
  \begin{itemize}
    \item Consistency conditions are simple to express for formulas, but in type theory they would depend circularly on typing derivations.

    \item While logic studies \hyperref[def:consequence_relation]{logical consequence} and \hyperref[con:hypothetical_judgment]{hypothetical judgments}, for type theory terms should ideally be typed unconditionally. Thus, while in logic \hyperref[def:propositional_tautology]{tautologies} with empty contexts are a curiosity, in type theory contexts are an instrument for dealing with \hyperref[def:lambda_variable_freeness]{free variables}.

    \item By the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, formulas correspond to types, not to terms.
  \end{itemize}

  Our sources which define type contexts only allow variable type assertions in them ---
  \incite[19]{MartinLöf1984IntuitionisticTypeTheory},
  \incite[def. 2A5]{Hindley1997BasicSTT},
  \incite[def. 5.1.5]{Barendregt1992LambdaCalculiWithTypes} and
  \incite[\S 4.1]{Mimram2020ProgramEqualsProof}.
\end{remark}

\begin{proposition}\label{thm:def:simple_type_derivability}
  \hyperref[def:simple_type_derivability]{Type derivability} for \hyperref[def:simple_type_system]{simple type systems} only featuring the base rules from \fullref{def:arrow_typing_rules} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:simple_type_derivability/combinator} If \( {}\vdash M: \sigma \), then \( M \) is a \hyperref[def:lambda_combinator]{combinator}.

    \thmitem{thm:def:simple_type_derivability/assumption_removal} We have \( \Gamma, x: \tau \vdash M: \sigma \) if and only if \( \Gamma \vdash \qabs x M: \tau \to \sigma \).
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item \Fullref{thm:def:simple_type_derivability/assumption_removal} allows us to remove assumptions by prefixing the term with an abstractor. It also demonstrates the \hyperref[con:inference_rule_admissibility]{admissibility} of the \hyperref[rem:sequent_calculus]{sequent calculus} style variation of the rule \ref{inf:def:arrow_typing_rules/intro/implicit} described in \fullref{rem:sequence_calculus_typing_rules}.

  \item The restriction to only the base rules is discussed in \fullref{rem:arrow_typing_rules_only}.
\end{comments}
\begin{proof}
  \SubProofOf{thm:def:simple_type_derivability/combinator} It follows from \fullref{thm:assumptions_and_free_variables} that \( x: \tau \) is an open assumption for a derivation of \( M: \sigma \) if and only if \( x \) is not free in \( M \). If \( M \) is a combinator, it has no free variables, hence derivations of \( M \) have no open assumptions.

  \SubProofOf{thm:def:simple_type_derivability/assumption_removal}

  \SufficiencySubProof* Let \( P \) be a derivation tree for \( M: \sigma \) from \( \Gamma, x: \tau \). We will build a tree deriving \( \qabs x M: \tau \to \sigma \) from \( \Gamma \).

  \begin{itemize}
    \item If \( x: \tau \) is an open assumption, it is discharged during a simple application of \ref{inf:def:arrow_typing_rules/intro/implicit}:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ x: \tau }
        \ellipsis { \( P \) } { M: \sigma }
        \infer[left label=\( x \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs x M: \tau \synimplies \sigma }
      \end{prooftree}
    \end{equation*}

    Discharging \( x: \tau \) leaves us with \( \Gamma \vdash \qabs x M: \tau \synimplies \sigma \).

    \item Otherwise, if \( x: \tau \) is not an open assumption in \( P \), then \( \Gamma \vdash P \) by \fullref{def:simple_type_derivability}. During application of \ref{inf:def:arrow_typing_rules/intro/implicit} nothing is discharged, and we again obtain \( \Gamma \vdash \qabs x M: \tau \synimplies \sigma \).
  \end{itemize}

  \NecessitySubProof* Conversely, if \( P \) is a derivation tree of \( \qabs x M: \tau \to \sigma \) from \( \Gamma \), it must be an application tree for \ref{inf:def:arrow_typing_rules/intro/implicit}, and hence \( x: \tau \) is either discharged during the application, or it is not and the derivation of \( M: \sigma \) does not depend on it. In both cases, we conclude that \( \Gamma, x: \tau \vdash M \).
\end{proof}

\begin{definition}\label{def:typability}\mcite[def. 2D1]{Hindley1997BasicSTT}
  For a fixed \hyperref[def:abstract_type_system]{abstract type system}, we say that the term \( M \) is \term{typable} in the \hyperref[def:type_context]{type context} \( \Gamma \) if there exists a type \( \tau \) such that \( \Gamma \vdash M: \tau \).

  We say that \( M \) is \term{typable} (without a context specified) if there exists a context in which it is typable.
\end{definition}
\begin{comments}
  \item We will often be interested in \hyperref[def:lambda_combinator]{combinators}, in which case, due to \fullref{thm:def:simple_type_derivability/combinator}, we may restrict ourselves to empty contexts: a combinator is typable if and only if there exists a type \( \tau \) such that \( {}\vdash M: \tau \).

  \item We generalize Hindley's definition for simple types to our notion of abstract type systems.
\end{comments}

\begin{definition}\label{def:type_habitation}\mcite[8A1]{Hindley1997BasicSTT}
  For a fixed \hyperref[def:abstract_type_system]{abstract type system}, if \( {}\vdash M: \tau \), we say that \( M \) is an \term[en=untyped inhabitant (\cite[8A1]{Hindley1997BasicSTT})]{inhabitant} of \( \tau \). If the type \( \tau \) has at least one habitant, we say that it is \term{inhabited}.
\end{definition}
\begin{comments}
  \item We base our definition of habitant on the notion of \enquote{untyped inhabitants} for \hyperref[def:simple_type]{simple type} from \cite[def. 8A1]{Hindley1997BasicSTT}. Hindley also defines \enquote{typed habitants} for valid \hyperref[def:typed_lambda_term]{typed terms} and \enquote{\( \sigma \)-normal habitants} for terms in \hyperref[def:lambda_term_normal_form]{\( \sigma \)-normal form}.

  \item Unlike for \hyperref[def:typability]{typability}, this definition only applies to derivations from the empty context. This restricts us to inhabitants without free variables.
\end{comments}

\begin{example}\label{ex:def:type_derivation_tree}
  We list examples of \hyperref[def:type_derivation_tree]{type derivation trees} for \hyperref[def:simple_type_system]{simple type systems}:
  \begin{thmenum}
    \thmitem{ex:def:type_derivation_tree/var} A variable \( x \) is typable in any \hyperref[def:type_context]{type context} containing \( x \). Due to \fullref{thm:assumptions_and_free_variables}, it is not typable without a context unless we introduce a special rule for this.

    \thmitem{ex:def:type_derivation_tree/const} The typability of constants depends on special rules introduced for them.

    \thmitem{ex:def:type_derivation_tree/i} The combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) inhabits \( \tau \synimplies \tau \) for any type \( \tau \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \synx: \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    \hyperref[def:simple_type_system_style]{Explicit typing} can restrict each term to at most one type --- the rule \ref{inf:def:arrow_typing_rules/intro/explicit} is only applicable if \( x \) is annotated with the same type it has in the context:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/explicit}]{ \qabs {\synx^\tau} \synx: \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    However, instead of having one term \( I \), we obtain one term \( I^\tau \) for each type \( \tau \).

    \thmitem{ex:def:type_derivation_tree/k} The combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \synx \) inhabits \( \tau \synimplies \sigma \synimplies \tau \) for any pair of types \( \tau \) and \( \sigma \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \syny \synx: \sigma \synimplies \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \qabs \syny \synx: \tau \synimplies \sigma \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    During the first rule application, we do not discharge any assumptions since there are no compatible assumptions to discharge.

    Via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, this type corresponds to the \hyperref[def:minimal_implication_logic]{minimal implicational logic} axiom \eqref{eq:def:minimal_implication_logic/intro} --- see \fullref{ex:con:curry_howard_correspondence/minimal_implicational}.

    \thmitem{ex:def:type_derivation_tree/s} The combinator \( \ref{eq:ex:def:lambda_term/combinator/s} = \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz) \) is a little more complicated:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau \synimplies (\sigma \synimplies \rho) }
        \hypo{ \synz: \tau }
        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synx \synz: \sigma \synimplies \rho }

        \hypo{ \syny: \tau \synimplies \sigma }
        \hypo{ \synz: \tau }
        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \syny \synz: \sigma }

        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synx \synz (\syny \synz): \rho }
        \infer[left label=\( \synz \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synz \synx \synz (\syny \synz): \tau \synimplies \rho }
        \infer[left label=\( \syny \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \syny \qabs \synz \synx \synz (\syny \synz): (\tau \synimplies \sigma) \synimplies (\tau \synimplies \rho) }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ S: (\tau \synimplies (\sigma \synimplies \rho)) \synimplies ((\tau \synimplies \sigma) \synimplies (\tau \synimplies \rho)) }
      \end{prooftree}
    \end{equation*}

    Via the Curry-Howard correspondence, this type corresponds to the axiom \eqref{eq:def:minimal_implication_logic/dist} --- see \fullref{ex:con:curry_howard_correspondence/minimal_implicational}.

    \thmitem{ex:def:type_derivation_tree/typed_incompatible} The typed term
    \begin{equation*}
      I_\alpha I_\beta = (\qabs {\synx^\alpha} \synx) (\qabs {\synx^\beta} \synx)
    \end{equation*}
    is not generally \hyperref[def:typability]{typable} unless \( \alpha = \beta \synimplies \beta \) (or unless the type system contains a special typing rule).

    \thmitem{ex:def:type_derivation_tree/self_application} The term \( xx \) is not typable because \ref{inf:def:arrow_typing_rules/elim} requires the existence of types \( \tau \) and \( \sigma \) so that \( x \) inhibits \( x: \tau \to \sigma \) and \( x: \tau \) simultaneously. This is not possible because type contexts disallow variables to have more than one type assigned.

    We can regard \( xx \) as an instance of \hyperref[con:impredicativity]{impredicativity} --- namely, function self-application, in which a function applies to itself.

    We have shown in \fullref{ex:def:beta_eta_reduction/omega} that some terms like \( \ref{eq:ex:def:lambda_term/combinator/big_omega} = (\qabs \synx \synx \synx) (\qabs \synx \synx \synx) \) containing self-application lead to infinite chains of \hyperref[def:beta_eta_reduction]{\( \sigma \)-reductions}.

    The impossibility of infinite sequences of reduction leads is captured by the concept of strong normalization defined in \fullref{def:strongly_normalizing_lambda_term}.

    \thmitem{ex:def:type_derivation_tree/pairs} Consider the \hyperref[def:ordered_tuple]{ordered pair} combinators \ref{ex:def:beta_eta_reduction/pairs/intro}, \ref{ex:def:beta_eta_reduction/pairs/elim_left} and \ref{ex:def:beta_eta_reduction/pairs/elim_right} from \fullref{ex:def:beta_eta_reduction/pairs}.

    We have shown that, for arbitrary terms \( A \) and \( B \), we have
    \begin{align*}
      P_{-L} (P_+ A B) \bred* A
      &&
      P_{-R} (P_+ A B) \bred* B.
    \end{align*}

    Similarly to the previous cases, we can find a type for
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pairs/intro} = \qabs \synx \qabs \syny \qabs \synf \synf \synx \syny
    \end{equation*}
    by fixing types \( \tau \), \( \sigma \), \( \rho \) and matching them to obtain the following derivation:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \tau \synimplies (\sigma \synimplies \rho) }
        \hypo{ \synx: \tau }
        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synf \synx: \sigma \synimplies \rho }

        \hypo{ \syny: \sigma }
        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synf \synx \syny: \rho }
        \infer[left label=\( \synf \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synf \synf \synx \syny: (\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho }
        \infer[left label=\( \syny \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \syny \qabs \synf \synf \synx \syny: \sigma \synimplies ((\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho) }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ P_+: \tau \synimplies (\sigma \synimplies ((\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho)) }
      \end{prooftree}
    \end{equation*}

    The convention of \( \synimplies \) being right-associative discussed in \fullref{rem:simple_type_parentheses/arrow} allows us to simplify the assertion
    \begin{equation*}
      P_+: \tau \synimplies (\sigma \synimplies ((\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho))
    \end{equation*}
    to
    \begin{equation*}
      P_+: \tau \synimplies \sigma \synimplies (\tau \synimplies \sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    If \( A: \tau \) and \( B: \sigma \), after two applications of \ref{inf:def:arrow_typing_rules/elim} we obtain
    \begin{equation*}
      P_+ A B: (\tau \synimplies \sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    For the combinator
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pairs/elim_left} = \qabs \synp \synp (\qabs \synx \qabs \syny \synx)
    \end{equation*}
    we have
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synp: (\tau \synimplies \sigma \synimplies \tau) \synimplies \rho }

        \hypo{ \synx: \tau }
        \infer1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \syny \synx: \sigma \synimplies \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \qabs \syny \synx: \tau \synimplies \sigma \synimplies \tau }

        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synp (\qabs \synx \qabs \syny \synx): \rho }
        \infer[left label=\( \synp \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ P_{-L}: ((\tau \synimplies \sigma \synimplies \tau) \synimplies \rho) \synimplies \rho }
      \end{prooftree}
    \end{equation*}

    We have derived types for both \( P_+ A B \) and \( P_{-L} \), and can conclude that the rule \ref{inf:def:arrow_typing_rules/elim} is only applicable to \( P_{-L} (P_+ A B) \) if \( \rho = \tau \), in which case \( P_{-L} (P_+ A B): \tau \), as expected.

    On the other hand, for
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pairs/elim_right} = \qabs \synp \synp (\qabs \synx \qabs \syny \syny)
    \end{equation*}
    we can similarly derive
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synp: (\tau \synimplies \sigma \synimplies \sigma) \synimplies \rho }

        \hypo{ \syny: \sigma }
        \infer[left label=\( \syny \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \syny \syny: \sigma \synimplies \sigma }
        \infer1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synx \qabs \syny \syny: \tau \synimplies \sigma \synimplies \sigma }

        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synp (\qabs \synx \qabs \syny \syny): \rho }
        \infer[left label=\( \synp \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ P_{-R}: ((\tau \synimplies \sigma \synimplies \sigma) \synimplies \rho) \synimplies \rho }
      \end{prooftree}
    \end{equation*}

    The rule \ref{inf:def:arrow_typing_rules/elim} is only applicable to \( P_{-R} (P_+ A B) \) if \( \rho = \sigma \), in which case \( P_{-R} (P_+ A B): \sigma \).

    We see here how the ability to derive multiple types for \( P_+ \) is actually beneficial --- we can use the same combinator in different situations.

    Now consider the \hyperref[def:typed_lambda_term]{typed term} corresponding to \( P_+ \):
    \begin{equation*}
      P_+^{\tau,\sigma,\rho} \coloneqq \qabs {\synx^\tau} \qabs {\syny^\sigma} \qabs {\synf^{\tau \synimplies \sigma \synimplies \rho}} \synf \synx \syny
    \end{equation*}

    We must have \( \rho = \tau \) if we want to be able to apply \( P_{-R} \) and \( \rho = \sigma \) if we want to apply \( P_{+R} \). Thus, unless \( \tau = \sigma \), at least one of the following is not \hyperref[def:typability]{typable}:
    \begin{align*}
      P_{-L} (P_+^{\tau,\sigma,\rho} A B)
      &&
      P_{-R} (P_+^{\tau,\sigma,\rho} A B)
    \end{align*}

    The latter issue is discussed in \cite{MathOF:product_type_in_simply_typed_lambda_terms}, where it is also proven that no such explicitly typed triple of combinators exist.

    We will find it convenient to have a dedicated constant term \( \synP_+ \) such that \( \synP_+ A B \) has a dedicated type --- namely, the product type \( \tau \syntimes \sigma \), which we will introduce in \fullref{def:product_type}.

    \thmitem{ex:def:type_derivation_tree/disjoint} Consider the combinators \ref{eq:ex:def:beta_eta_reduction/disjoint/intro_left}, \ref{eq:ex:def:beta_eta_reduction/disjoint/intro_right} and \ref{eq:ex:def:beta_eta_reduction/disjoint/elim} from \fullref{ex:def:beta_eta_reduction/disjoint}.

    Since \( S_- \) and \( P_+ \) are \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent}, we conclude that they can be assigned the same types\fnote{This will be proven formally in \fullref{thm:alpha_equivalent_term_typing}.}.

    On the other hand, for
    \begin{equation*}
      S_{+L} = \qabs \synx \qabs \synf \qabs \syng \synf \synx
    \end{equation*}
    we have
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \tau \synimplies \rho }
        \hypo{ \synx: \tau }
        \infer2[\ref{inf:def:arrow_typing_rules/elim}]{ \synf \synx: \rho }
        \infer1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \syng \synf \synx: (\sigma \synimplies \rho) \synimplies \rho }
        \infer[left label=\( \synf \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ \qabs \synf \qabs \syng \synf \synx: (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho \synimplies \rho) }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_typing_rules/intro/implicit}]{ S_{+L}: \tau \synimplies (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho }
      \end{prooftree}
    \end{equation*}

    Similarly, we can derive
    \begin{equation*}
      S_{+R}: \sigma \synimplies (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    Suppose that \( A: \tau \), \( F: \tau \synimplies \rho \) and \( G: \sigma \synimplies \rho \). Then, in order for \ref{inf:def:arrow_typing_rules/elim} to be applicable to
    \begin{equation*}
      S_- F G (S_{+L} A),
    \end{equation*}
    the combinator \( S_- \) must inhabit
    \begin{equation*}
      (\tau \synimplies \rho) \synimplies (\sigma \synimplies \rho) \synimplies ((\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho) \synimplies \delta
    \end{equation*}
    for some type \( \delta \).

    According to \fullref{ex:def:type_derivation_tree/pairs}, such a derivation is possible if \( \delta = \rho \). This type corresponds to Haskell's
    \begin{verbatim}
      either :: (a -> c) -> (b -> c) -> Either a b -> c,
    \end{verbatim}\vspace{-\baselineskip}
    as long as we identify \verb|Either a b| with
    \begin{equation*}
      (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    This works even with explicit typing, but the identification is not particularly apt because \verb|Either a b| must depend on \( \rho \). One solution to this is to introduce sum types, which we will define in \fullref{def:sum_type}.

    As long as \( F \) and \( G \) are fixed, however, they determine \( \rho \), and we have
    \begin{equation*}
      S_- F G (S_{+L} A): \rho
    \end{equation*}
    and
    \begin{equation*}
      S_- F G (S_{+R} B): \rho
    \end{equation*}
  \end{thmenum}
\end{example}
\begin{comments}
  \item Many of these examples are verified programmatically in the modules \identifier{lambda_.type_derivation.test_tree} and \identifier{lambda_.type_derivation.test_inference} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:typing_style}
  \Fullref{ex:def:type_derivation_tree} highlights how the \hyperref[def:simple_type_system_style]{typing style} of a system can drastically affect its \hyperref[def:typability]{typability}. The rule \ref{inf:def:arrow_typing_rules/intro/explicit} itself demonstrates how \hyperref[con:type_annotation]{type annotations} help guide us during type derivation.

  \Fullref{thm:typed_term_habitation_uniqueness} proves that this tackles the non-uniqueness of type derivations for \hyperref[def:lambda_combinator]{combinators} shown in \fullref{ex:def:type_derivation_tree/i} --- the combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) inhabits \( \tau \synimplies \tau \) for any type \( \tau \), however, when \( \tau \) is fixed, \ref{inf:def:arrow_typing_rules/intro/explicit} uniquely determines \hi{the} type of \( I^\tau = \qabs {\synx^\tau} \synx \) as \( \tau \synimplies \tau \) at the cost of introducing a distinct abstraction term for every possible annotation of the abstractor variable.

  Another possibility is to annotate every term like Church originally did in \cite{Church1940STT}. In this case type contexts become obsolete. The notation becomes much more verbose, however, and, in light of \fullref{thm:typed_term_habitation_uniqueness}, there is little gain. Compare the following typed variations of the combinator \ref{eq:ex:def:lambda_term/combinator/k}:
  \begin{equation*}
    \qabs {\synx^\tau} \qabs {\syny^\sigma} \synx
  \end{equation*}
  and
  \begin{equation*}
    (\qabs {\synx^\tau} (\qabs {\syny^\sigma} \synx^\tau)^{\sigma \synimplies \tau})^{\tau \synimplies \sigma \synimplies \tau}.
  \end{equation*}

  The second convention is referred to as \enquote{Church style typing}, for example by \cite[ch. 5]{Hindley1997BasicSTT}. Even though it is not as historically accurate, the first convention, is also referred to as \enquote{Church style}, for example by \incite[ch. 4]{Mimram2020ProgramEqualsProof}. This relates to explicitly typed systems, where the rules have type annotations, however we should distinguish between the typing style of rules (i.e. explicit or implicit) and the typing style of terms (i.e. typed or untyped). Explicitly typed systems require typed terms, but not vice versa.

  As a contradistinction, implicitly typed systems are referred to by both the aforementioned authors as \enquote{Curry style} in honor of Haskell Curry for his work \cite{Curry1934FunctionalityInCombinatoryLogic}. Curry did not consider \( \synlambda \)-terms nor types, but worked with abstract combinators applied to each other in what he called \enquote{combinatory logic}. We can deduce a relation to typing systems from the following quote:
  \begin{displayquote}
    Let \( F \) denote an entity whose interpretation is such that \( FXY \) represents, in the notation of combinatory logic, the category of functions on \( X \) to \( Y \), while the formula \( \vdash FXYf \) represents the statement that \( f \) belongs to that category.
  \end{displayquote}

  Here \( f \) is merely a symbol, while \( \vdash FXYf \) translates into the type assertion \( f: X \synimplies Y \). Since the type \( X \synimplies Y \) is not attached to \( f \), the latter is also allowed to inhabit another type, which contrasts with Church's usage mentioned earlier.

  Ironically, the programming language Haskell, also named after Haskell Curry, uses type annotations and is thus not Curry style. Unlike a true Church style type system, however, Haskell's allows not annotating terms for which the types can be inferred.
\end{remark}

\begin{proposition}\label{thm:typed_term_habitation_uniqueness}
  In the \hyperref[def:simple_type_system_style]{explicitly typed} \hyperref[def:simple_type_system]{simple type system} featuring only the arrow typing rules \ref{inf:def:arrow_typing_rules/elim} and \ref{inf:def:arrow_typing_rules/intro/explicit}, we can \hyperref[def:simple_type_derivability]{derive} at most one type for any \hyperref[def:typed_lambda_term]{typed term} from a fixed \hyperref[def:type_context]{type context}.
\end{proposition}
\begin{comments}
  \item In particular, a typed combinator can \hyperref[def:type_habitation]{inhabit} at most one type.

  \item We can also interpret this result as a statement for untyped combinators --- each of them can be typed uniquely \enquote{up to a choice of types for bound variables}.

  \item The restriction to only the base rules is discussed in \fullref{rem:arrow_typing_rules_only}.
\end{comments}
\begin{proof}
  Let \( T \) be a tree deriving \( M: \tau \) from the type context \( \Gamma \).

  We will use \fullref{thm:induction_on_rooted_trees} on \( T \) to show that if \( T' \) derives \( M: \tau' \) from \( \Gamma \), the trees are equal and \( \tau = \tau' \):
  \begin{itemize}
    \item If \( T \) is an assumption tree, then \( M \) must be a variable, and \( \Gamma \vdash M \) only if \( \Gamma \) contains a type assertion for \( M \). Since type contexts have at most one type assertion per variable, it follows that the type \( \tau \) of \( M \) is uniquely determined.

    \item If \( T \) is an application of \ref{inf:def:arrow_typing_rules/elim}, then \( M = NK \) and \( T \) has a subtree \( T_N \) deriving \( N: \sigma \to \tau \) for some type \( \sigma \), and a subtree \( T_K \) deriving \( K: \sigma \). We suppose that the inductive hypothesis holds for \( T_N \) and \( T_K \).

    Let \( T' \) be a tree deriving \( M: \tau' \) from \( \Gamma \). Since \( M = NK \), \( T' \) must be an application tree of \ref{inf:def:arrow_typing_rules/elim}, with subtrees \( T_N' \) and \( T_K' \) deriving \( N: \sigma' \to \tau' \) and \( K: \sigma' \) from the assumptions in \( \Gamma \).

    The inductive hypothesis on \( T_N \) implies that the types \( \sigma' \to \tau' \) and \( \sigma \to \tau \) are equal, and thus so are \( \tau' \) and \( \tau \).

    \item If \( T \) is an application of \ref{inf:def:arrow_typing_rules/intro/explicit}, then \( M = \qabs {x^\sigma} N \), \( \tau = \sigma \synimplies \rho \) and \( T \) has a subtree \( S \) deriving \( N: \rho \) from \( \Gamma, x: \sigma \).

    Let \( T' \) be a tree deriving \( M: \tau' \) from \( \Gamma \). Then \( \tau' = \sigma \synimplies \rho' \) \( T' \) is an application of \ref{inf:def:arrow_typing_rules/intro/explicit}, and we have a subtree \( S' \) deriving \( N: \rho' \) from \( \Gamma, x: \sigma \).

    It is extremely important here that \( \sigma \) and \( \sigma' \) are equal, which is only possible due to the annotation of \( x \).

    The inductive hypothesis implies that \( S \) and \( S' \) are equal, and that \( \rho = \rho' \). Then also \( \tau = \tau' \).
  \end{itemize}
\end{proof}
