\section{Simply typed lambda terms}\label{sec:simply_typed_lambda_terms}

Unlike untyped lambda calculus, whose presentation is mostly uniform across authors, type theory has many incompatible flavors. A concise history is described in \fullref{rem:type_theory}. We will only consider so-called \enquote{simple types}.

\paragraph{Type systems}

\begin{remark}\label{rem:type_theory}
  \incite*[237]{Russell1908TypeTheory} gives the following definition:
  \begin{displayquote}
    A \textit{type} is defined as the range of significance of a propositional function, i.e., as the collection of arguments for which the said function has values.
  \end{displayquote}

  Russell himself was trying to resolve \hyperref[rem:self_reference]{self-referential} paradoxes by circumventing \hyperref[con:impredicativity]{impredicativity}. This is briefly discussed in \fullref{rem:self_reference}.

  He used \enquote{individuals} loosely for \enquote{terms of elementary propositions}, where he defined terms as \enquote{whatever can be regarded as the \textit{subject} of the proposition}.

  A clearer formalization is due to Alonzo Church. In \cite{Church1940STT}, he extends untyped \( \synlambda \)-calculus with what he, based on intermediate works by other authors, calls \enquote{simple types}. He uses the letter \( \omicron \) for \enquote{the type of propositions} and \( \iota \) for \enquote{the type of individuals}. Given the types \( \alpha \) and \( \beta \), Church regards the type \( (\alpha\beta) \) as
  \begin{displayquote}
    \textellipsis the type of functions of one variable for which the range of the independent variable comprises the type \( \beta \) and the range of the dependent variable is contained in the type \( \alpha \).
  \end{displayquote}

  Thus, he used two \enquote{base types} and one \enquote{type constructor}, resulting in infinitely many types. He assigned to each \( \synlambda \)-term a subscript indicating its type, with certain coherence conditions that we will discuss in \fullref{def:simple_type_theory}. The term \( x_\omicron \) would thus correspond to our notion of propositional formula, while the term \( x_\iota \) --- to a first-order variable.

  Subsequent works by Curry and Howard lead to the Curry-Howard correspondence discussed in \fullref{con:curry_howard_correspondence}. This in turn lead Martin-Löf to introduce \hyperref[rem:dependent_type]{dependent types} and systemize the presentation of type theory via \hyperref[def:typing_rule]{typing rules}.

  At this point, notation started unifying across authors, ultimately leading to \enquote{\( M: \alpha \)} rather than \enquote{\( M_\alpha \)} or \enquote{\( M^\alpha \)} for \hyperref[def:type_assertion]{type assertions} postulating that the term \( M \) has type \( \alpha \), and to \( \alpha \synimplies \beta \) for \enquote{function types}, replacing Church's equivalent \( (\beta\alpha) \) (and swapping \( \alpha \) and \( \beta \)).

  These conventions were already present in \bycite{CoquandHuet1986CoC}. His paper introduces the \enquote{calculus of constructions} in which functions can be defined from terms to types, from types to terms and from types to types. This generalizes Martin-L\"of's dependent products, which can be regarded as functions from terms to types. \incite[192]{Barendregt1992Types} places simple type theory and the calculus of constructions as the least and most powerful type systems in his \enquote{\( \synlambda \)-cube}, where the axes correspond to the aforementioned three kinds of functions. These are further generalized by \enquote{pure type systems}, again discussed in the same article. As types become more complicated, they require flexible syntax, and the line between types and terms starts blurring.

  Another significant development is \enquote{homotopy type theory}, introducing semantics for types based on topological spaces. In the eponymous community-written book, \cite{UnivalentProject2024OctoberHoTT}, homotopy type theory is attributed to \cite{Voevodski2006HoTT} and \cite{AwodeyWarren2009HoTT}.

  Simple, dependent and homotopy type theory are described in a unified manner in \cite{Mimram2020Types} in the context of proof theory.
\end{remark}

\begin{definition}\label{def:type_assertion}\mimprovised
  Suppose we are given two \hyperref[def:formal_grammar/schema]{formal grammars} producing strings called \term{terms} and \term{types}, correspondingly. Terms and types may intersect or even coincide, as mentioned in \fullref{rem:type_theory}.

  We will be interested in expressions generated by the following grammar:
  \begin{bnf*}
    \bnfprod{type assertion} {\bnfpn{term} \bnfsp \bnftsq{\( : \)} \bnfsp \bnfpn{type}}.
  \end{bnf*}
\end{definition}
\begin{comments}
  \item When terms are given an interpretation as some objects, we may say \enquote{\( x \) is an object of type \( \alpha \)} rather than \enquote{\( x \) is a term of type \( \alpha \)}.

  \item On a metatheoretic level, this is one of several kinds of \hyperref[con:judgment]{judgments} that Martin-L\"of uses for his type systems; see \fullref{rem:type_judgments} for a broader discussion.

  \item This terminology is unfortunately not well-established. For example, \incite[def. 2A4]{Hindley1997STT} and \incite[380]{BarendregtDekkersStatman2013Types} prefer the term \enquote{type assignment}, \incite[def. 5.1.10]{Barendregt1992Types} uses \enquote{statement}, while \incite[ch. 4]{Mimram2020Types} uses the type assertion syntax without introducing terminology for such expressions.

  \item Unlike the terminology, the colon notation itself is ubiquitous, as discussed in \cite{MathSE:origin_of_colon_notation_for_type_assertions}. Predecessors include the following:
  \begin{itemize}
    \item The subscript notation \( M_\alpha \) used by \cite{Church1940STT} and the modern by old-fashioned \cite{Andrews2002STT}.
    \item The superscript notation \( M^\alpha \) used by \cite{Howard1980FormulasAsTypes}.
    \item The set membership notation \( M \in \alpha \) used by Martin-L\"of in his earlier works \cite{MartinLöf1975IntTypeTheory} and \cite{MartinLöf1984IntTypeTheory}. In \cite{MartinLöf1994TypeJudgments} he already uses colons.
  \end{itemize}
\end{comments}

\begin{remark}\label{rem:type_universes}
  If in some flavors of \hyperref[rem:type_theory]{type theory} terms and types share a common syntax, we can express the statement \enquote{\( \alpha \) is a type} via the \hyperref[def:type_assertion]{type assertion}
  \begin{equation*}
    \alpha: \op*{Type},
  \end{equation*}
  where \( \op*{Type} \) is a predefined constant term.

  Unfortunately, as described in \incite[\S 8.2.3]{Mimram2020Types}, in a sufficiently general setting this leads to a variant of \fullref{thm:russels_paradox} due to Jean-Yves Girard. A workaround suggested by Mimram resembling the \hyperref[def:axiom_of_universes]{axiom of Grothendieck universes} is the introduction of a sequence of type universes
  \begin{equation*}
    \op*{Type}_0: \op*{Type}_1: \op*{Type}_2: \cdots
  \end{equation*}
  such that \( \alpha: \op*{Type}_k \) implies \( \alpha: \op*{Type}_{k+1} \).
\end{remark}

\begin{definition}\label{con:definitional_equality}
  An important concept in type theory is \term{definitional equality}. \incite[40]{MartinLöf1984IntTypeTheory} describes it as follows:
  \begin{displayquote}
    Definitional equality is intensional equality, or equality of meaning (synonymy). We use the symbol \( {\equiv} \) or \( {=_{\T{def.}}} \) (which was first introduced by Burali-Forti). Definitional equality \( {\aequiv} \) is a relation between linguistic expressions; it should not be confused with equality between objects (sets, elements of a set, etc.) which we denote by \( {=} \). Definitional equality is the equivalence relation generated by abbreviatory definitions, changes of bound variables and the principle of substituting equals for equals.
  \end{displayquote}

  Thus, roughly, definitional equality is a binary relation in an \hyperref[con:metalogic]{object language} with the intended interpretation of an \hyperref[def:equivalence_relation]{equivalence relation}.

  Martin-L\"of himself uses \hyperref[def:inference_rule]{inference rules} to specify definitional equality, which on a metatheoretic level amounts to using \fullref{thm:recursively_defined_relations}.
\end{definition}

\begin{remark}\label{rem:type_theory_judgments}
  Martin-L\"of builds his type theory on several kinds of \hyperref[con:judgment]{judgments}. \cite[19]{UnivalentProject2024OctoberHoTT} classifies these as either \hyperref[def:type_assertion]{type assertion} judgment or \hyperref[con:definitional_equality]{definitional equality} judgments.

  \incite*[14]{MartinLöf1984IntTypeTheory} distinguishes between the judgments \enquote{\( \alpha \) is a type} and \enquote{\( x \) is an object of type \( \alpha \)}\fnote{To be precise, these aren't exact quotes because Martin-L\"of refers to types as \enquote{sets} in this concrete work, and uses set-membership notation, which is a deviation from his other, even earlier, works.}, and similarly between \enquote{\( \alpha \) and \( \beta \) are equal sets} and \enquote{\( x \) and \( y \) are equal objects of type \( \alpha \)}. As discussed in \fullref{rem:type_universes}, however, these amount to the same judgment since we can regard types as objects of a \enquote{type universe}.
\end{remark}

\paragraph{Simple types}

\begin{definition}\label{def:simple_type}
  Fix a nonempty finite \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Base} \), whose elements we will call \term{base types}. We introduce \term{simple types} based on the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{arrow type}   {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}} \\
    \bnfprod{type}         {\bnfpn{base type} \bnfor \bnfpn{arrow type} \bnfor \bnfpn{product type} \bnfor \bnfpn{sum type}}
  \end{bnf*}
\end{definition}
\begin{comments}
  \item As it often happens, usage in the literature is not consistent. We discuss this in \fullref{rem:simple_type_etymology}. To avoid ambiguity, we will be explicit about which types we allow in our applications.

  \item Type theory is by its nature extensible. We will introduce several extensions like product types in \fullref{def:product_type} and sum types in \fullref{def:sum_type}. Handling each extension requires additional work, however, so we follow the tradition of only allowing arrow types for presenting the base theory.
\end{comments}

\begin{remark}\label{rem:simple_type_etymology}
  \hyperref[def:simple_type]{Simple types} are unfortunately not standardized, and naturally, allow variations in their definition.

  For example, the following authors consider arrow types (but not e.g. product types), however their definitions differ by their handling of base types:
  \begin{itemize}
    \item \incite[56]{Church1940STT}, \incite[\S 51]{Andrews2002STT} and \incite[269]{Farmer2008STTVirtues} allow exactly two base types --- of propositions and individuals, as discussed in \fullref{rem:type_theory}.

    \item \incite[def. 3.2.2]{Barendregt1992Types}, \incite{Hindley1997STT} and \incite[def. 1.2.1]{TroelstraSchwichtenberg2000Proofs} disallow base types, thus leaving only arrow types and \enquote{type variables} (resembling the variable placeholders from \fullref{def:lambda_term_schema}).

    \item \incite[def. 1.1.11]{BarendregtDekkersStatman2013Types} allow an arbitrary nonempty set of base types, which they call \enquote{type atoms}.
  \end{itemize}

  \incite[ch. 4]{Mimram2020Types} initially only considers arrow types without base types, but later allows two base types --- the empty and unit types -- as well as product and sum types.

  Additionally, what we call \enquote{arrow type} is also treated differently:
  \begin{itemize}
    \item \incite[56]{Church1940STT} and \incite[\S 51]{Andrews2002STT} use the notation \enquote{\( (\alpha\beta) \)} for what we would write as \( \beta \synimplies \alpha \). This is discussed in \fullref{rem:type_theory}.

    Neither introduce a dedicated term for arrow types.

    \item \incite[def. 1.2.1]{TroelstraSchwichtenberg2000Proofs} and \incite[269]{Farmer2008STTVirtues} use arrow notation and call them \enquote{function types}.

    \item \incite[\S 4.1.1]{Mimram2020Types} uses the arrow notation and calls them \enquote{arrow types}.

    \item \incite[def. 1.1.11]{BarendregtDekkersStatman2013Types} uses the arrow notation and calls them \enquote{function space types}.

    \item \incite[def. 2A1]{Hindley1997STT} uses the arrow notation and calls them \enquote{composite types}.

    \item \incite[def. 3.2.2]{Barendregt1992Types} use the arrow notation but introduces no special term.
  \end{itemize}
\end{remark}

\paragraph{Schemas for simply typed \( \synlambda \)-terms}\hfill

To formalize typing rules in \fullref{def:simple_typing_rule}, we first need to introduce schemas for \( \synlambda \)-terms and simple types.

\begin{definition}\label{def:lambda_term_schema}
  Similarly to \hyperref[def:propositional_formula_schema]{propositional formula schemas}, we define schemas for \hyperref[def:lambda_term]{\( \synlambda \)-terms}:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Capital Latin identifier}}, \\
    \bnfprod{atom schema}          {\bnfpn{variable placeholder} \bnfor \bnfpn{constant}}, \\
    \bnfprod{application schema}   {\bnftsq{\( ( \)} \bnfsp \bnfpn{term schema} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{abstraction schema}   {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable schema} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term schema}          {\bnfpn{atom schema} \bnfor \bnfpn{term placeholder} \bnfor} \\
    \bnfmore                       {\bnfpn{application schema} \bnfor \bnfpn{abstraction schema}}.
  \end{bnf*}
\end{definition}
\begin{comments}
  \item See \fullref{con:schemas_and_instances} for a discussion of schemas in general.

  \item This syntax does not allow us to distinguish between variables and variable placeholders, however the distinction should be quite clear from the context.

  \item Similarly to propositional formula schemas, we will denote arbitrary schemas via capital Greek identifiers like \( \Phi \).
\end{comments}

\begin{definition}\label{def:simple_type_schema}
  We define schemas for \hyperref[def:simple_type]{simple types} in an obvious way:
  \begin{bnf*}
    \bnfprod{type placeholder}    {\bnfpn{Small Greek identifier}} \\
    \bnfprod{arrow type schema}   {\bnftsq{(} \bnfsp \bnfpn{type schema} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type schema} \bnfsp \bnftsq{)}} \\
    \bnfprod{type schema}         {\bnfpn{base type} \bnfor \bnfpn{type placeholder} \bnfor \bnfpn{arrow type schema}}
  \end{bnf*}
\end{definition}
\begin{comments}
  \item See \fullref{con:schemas_and_instances} for a discussion of schemas in general.
  \item To distinguish type schemas from term schemas, which we also denote via capital Greek identifiers, for types we will prefer letters from the start of the alphabet. Thus, \( \Psi: \Alpha \) is a type assertion for term and type schemas.
\end{comments}

\begin{definition}\label{def:lambda_schema_instantiation}
  In analogy with \hyperref[def:propositional_schema_instantiation]{schema instantiations} for \hyperref[def:propositional_formula_schema]{propositional formula schemas}, we define instantiations for \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \synlambda \)-term schemas} and \hyperref[def:simple_type_schema]{simple type schemas} as \hyperref[def:set_valued_map/partial]{partial maps} sending \hyperref[def:lambda_term_schema]{variable placeholders} to \hyperref[def:lambda_term]{variables} and \hyperref[def:lambda_term_schema]{\( \synlambda \)-term placeholders} to \hyperref[def:lambda_term]{\( \synlambda \)-terms} and \hyperref[def:simple_type_schema]{type placeholders} to \hyperref[def:simple_type]{simple types}.

  \begin{thmenum}
    \thmitem{def:lambda_schema_instantiation/terms} We will not concern ourselves with \hyperref[def:lambda_variable_occurrence]{free and bound occurrence} of variables as for \hyperref[def:lambda_term_schema_substitution]{substitution}, but extend an instantiation \( \sigma \) to arbitrary \( \synlambda \)-term schemas straightforwardly:
    \begin{equation}\label{eq:def:lambda_schema_instantiation/terms}
      \Phi[\sigma] \coloneqq \begin{cases}
        M,                               &M \T{is a constant}, \\
        \sigma(M),                       &M \T{is a variable}, \\
        \sigma(M),                       &M \T{is a placeholder}, \\
        N[\sigma] \thinspace K[\sigma],  &M = NK,              \\
        \qabs {\sigma(x)} N[\sigma],     &M = \qabs x N.       \\
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_schema_instantiation/types} For simple types we also extend the instantiation straightforwardly:
    \begin{equation}\label{def:lambda_schema_instantiation}
      \Phi[\sigma] \coloneqq \begin{cases}
        \alpha,                                   &\alpha \T{is a base type},   \\
        \sigma(\alpha),                           &\alpha \T{is a placeholder}, \\
        \beta[\sigma] \synimplies \gamma[\sigma], &\alpha = \beta \synimplies \gamma,  \\
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_schema_instantiation/assertion} Finally, given an assertion \( \Omega = \Psi: \Alpha \), we let
    \begin{equation}\label{eq:def:lambda_schema_instantiation/assertion}
      \Omega[\sigma] = \Phi[\sigma]: \Alpha[\sigma]
    \end{equation}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Of course, \( \Phi[\sigma] \) is only valid if the variables and placeholders of \( \Phi \) are in the domain of \( \sigma \).

  \item Another possibility is to keep instantiations for term and type schemas distinct, however our main use case is to instantiate type assertions and that would complicate us unnecessarily.
\end{comments}

\paragraph{Typing rules}

\begin{definition}\label{def:simple_typing_rule}\mimprovised
  A \term{simple typing rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \synlambda \)-term schemas} and \hyperref[def:simple_type_schema]{simple type schemas}.

  As in the case of natural deduction rules defined in \fullref{def:natural_deduction_rule}, and using the same formalism, we allow dischargeable type assertions to be attached to the premises.
\end{definition}
\begin{comments}
  \item This definition is very restrictive compared to what is envisioned by Martin-L\"of in \cite{MartinLöf1984IntTypeTheory}, where typing rules are based on very permissive \hyperref[def:type_assertion]{type assertion} and \hyperref[con:definitional_equality]{definitional equality} judgments.

  We will not need this level of generality, however, and using this precise definition will allow us to mechanize the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence} for simple types.

  \item Typing rules are often presented in another form that resembles \hyperref[rem:sequent_calculus]{sequent calculus} --- see \fullref{rem:typing_rule_style}.
\end{comments}

\begin{definition}\label{def:base_typing_rules}\mcite[26]{TroelstraSchwichtenberg2000Proofs}
  The two fundamental \hyperref[def:type_derivation_tree]{typing rules} are as follows:
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{App} }]{inf:def:base_typing_rules/app}
        \begin{prooftree}
          \hypo{ \synM: (\syn\alpha \synimplies \syn\beta) }
          \hypo{ \synN: \syn\alpha }
          \infer2[\ref{inf:def:base_typing_rules/app}]{ \synM \synN: \syn\beta }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \logic{Abs} }]{inf:def:base_typing_rules/abs}
        \begin{prooftree}
          \hypo{ [\synx: \syn\alpha] }
          \ellipsis {} { \synM: \syn\beta }
          \infer1[\ref{inf:def:base_typing_rules/abs}]{ \qabs \synx \synM: \syn\alpha \synimplies \syn\beta }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{definition}

\begin{remark}\label{rem:typing_rule_style}
  Consider the \hyperref[def:simple_typing_rule]{typing rule}
  \begin{equation*}
    \begin{prooftree}
      \hypo{ [\synx: \syn\alpha] }
      \ellipsis {} { \synM: \syn\beta }
      \infer1[\ref{inf:def:base_typing_rules/abs}]{ \qabs \synx \synM: \syn\alpha \synimplies \syn\beta }
    \end{prooftree}
  \end{equation*}

  \incite[\S 4.1.4]{Mimram2020Types} and \incite[def. 2A8]{Hindley1997STT} express this rule in a form that resembles \hyperref[rem:sequent_calculus]{sequent calculus}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \syn\Gamma, x: \syn\alpha \synvdash \synM: \syn\beta }
      \infer1[\ref{inf:def:base_typing_rules/left}]{ \syn\Gamma \syn\vdash \qabs \synx \synM: \syn\alpha \synimplies \syn\beta }
    \end{prooftree}
  \end{equation*}

  For expressing their more complicated type systems, the sequent calculus style is used by \incite{CoquandHuet1986CoC}, \incite{AwodeyWarren2009HoTT}, \incite{Voevodski2006HoTT}.

  We prefer the natural deduction style rules since we find them easier to define formally, analyze and mechanize. This convention is used by Martin-L\"of, for example in \cite{MartinLöf1984IntTypeTheory}, and sometimes also by other authors like \incite[26]{TroelstraSchwichtenberg2000Proofs}.
\end{remark}

\paragraph{Type derivations}

\begin{definition}\label{def:type_context}\mcite[def. 2A5]{Hindley1997STT}
  A \term[en=type-context (\cite[def. 2A5]{Hindley1997STT})]{type context} is a \hyperref[def:logical_context]{logical context} whose entries are \hyperref[def:type_assertion]{type assertion} for \hi{distinct variables}.

  We say that the assertion \( x: \tau \) is \term{consistent} with the context \( \Gamma \) if \( \Gamma \) contains no type assertion for \( x \).
\end{definition}
\begin{comments}
  \item Another possibility, instead of requiring the variables to be distinct, is, as in \cite[159]{Mimram2020Types}, to allow contexts to contain more than one type assertion per variable and only consider the last assertion.
\end{comments}

\begin{remark}\label{rem:type_context_only_variables}
  We will define in \fullref{def:type_derivation_tree_entailment} a \hyperref[def:consequence_relation]{consequence relation} such that \( \Gamma \vdash M: \alpha \) for an arbitrarily complex term \( M \) and a \hyperref[def:type_context]{type context} \( \Gamma \) consisting only of variable type assertions. The types in both the context and the consequence are allowed to be arbitrarily complex.

  This is seemingly different from, for example, natural deduction proofs, where the context may consist of arbitrarily complex formulas. We would like to point out the following:
  \begin{itemize}
    \item Consistency conditions are simple to express for formulas, but in type theory they would depend circularly on typing derivations.

    \item While logic studies \hyperref[def:consequence_relation]{logical consequence} and \hyperref[con:hypothetical_judgment]{hypothetical judgments}, for type theory terms should ideally be typed unconditionally. Thus, while in logic \hyperref[def:propositional_tautology]{tautologies} with empty contexts are a curiosity, in type theory contexts are an instrument for dealing with \hyperref[def:lambda_variable_freeness]{free variables}.

    \item By the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, formulas correspond to types, not to terms.
  \end{itemize}

  Our sources which define type contexts only allow variable type assertions in them ---
  \incite[19]{MartinLöf1984IntTypeTheory},
  \incite[def. 2A5]{Hindley1997STT},
  \incite[def. 5.1.5]{Barendregt1992Types} and
  \incite[\S 4.1]{Mimram2020Types}.
\end{remark}

\begin{definition}\label{def:type_derivation_tree}\mimprovised
  In analogy with natural deduction proof trees, which we define in \fullref{def:natural_deduction_proof_tree}, we will define here a family of \hyperref[def:labeled_tree]{labeled trees}, which we will call \term{type derivation trees}. We purposely keep the definitions as loose as possible to allow extending the basic structure of simple types from \fullref{def:simple_type}.

  A fundamental difference compared to proof trees is that type derivations allow deriving the type of an arbitrarily complex \( \synlambda \)-term a \hyperref[def:type_context]{type context} specifying only the types of variables. This is justified in \fullref{rem:type_context_only_variables}.

  As in the case of natural deduction proof trees, the labels of type derivations are triples:
  \begin{thmenum}[series=def:type_derivation_tree]
    \thmitem{def:type_derivation_tree/conclusion} A \hyperref[def:type_assertion]{type assertion}, which we call the \term{conclusion}.
    \thmitem{def:type_derivation_tree/rule_name} An empty string or the name of a \hyperref[def:simple_typing_rule]{typing rule}.
    \thmitem{def:type_derivation_tree/context} A \hyperref[def:type_context]{type context}, whose entries we will call \term{open assumptions}.
  \end{thmenum}

  We define two kinds of derivation trees:
  \begin{thmenum}[resume=def:type_derivation_tree]
    \thmitem{def:type_derivation_tree/assumption} We define \term{assumption} trees similarly to natural deduction assumptions, but only for variable type assertions. For the assertion \( x: \tau \), we define assumption tree as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with the following label:
    \begin{itemize}
      \item The conclusion is \( x: \tau \).
      \item The rule name is empty.
      \item The context is the singleton list with entry \( x: \tau \).
    \end{itemize}

    We will not need to annotate terms with markers --- the variable plays the role of a marker for the type.

    \thmitem{def:type_derivation_tree/application} We define \term{rule application} trees based on a straightforward adaptation of \fullref{def:natural_deduction_proof_Tree/application} for natural deduction rule applications. Some assumptions of the subtrees can be \term{discharged} or \term{closed} if the rule allows it.
  \end{thmenum}
\end{definition}

\paragraph{Explicit typing}

\begin{definition}\label{def:pseudoterm}\mcite[def. 3.2.1]{Barendregt1992Types}
  A \term{pseudoterm} is a \hyperref[def:lambda_term]{\( \synlambda \)-term} in which the abstraction rule has been modified as follows:
  \begin{bnf*}
    \bnfprod{abstraction} {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable} \bnfsp \bnftsq{:} \bnfsp \bnfpn{type} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term} \bnfsp \bnftsq{\( ) \)}}, \\
  \end{bnf*}
\end{definition}
\begin{comments}
  \item Of course, this definition is dependent on our choice for the syntax of types.
\end{comments}

\paragraph{Simple type systems}\hfill

\begin{remark}\label{rem:church_and_curry_typing}

\end{remark}

\begin{remark}\label{rem:dependent_types}
  \todo{Discuss dependent types}
\end{remark}

\begin{concept}\label{con:curry_howard_correspondence}
  \incite[479]{Howard1980FormulasAsTypes} observes that
  \begin{displayquote}
    H. Curry (1958) has observed that there is a close correspondence between \textit{axioms} of positive implicational propositional logic, on the one hand, and \textit{basic combinators} on the other hand. For example, the combinator \( K = \qabs X \qabs Y X \) corresponds to the axiom \( a \rightimply (b \rightimply a) \).
  \end{displayquote}

  The publication he refers to is \cite[312]{CurryFeys1958CombinatoryLogic}, where Curry begins the section with
  \begin{displayquote}
    We shall study here a striking analogy between the theory of and the theory of functionality and the theory of implication in propositional algebra.
  \end{displayquote}

  The core idea is that the type \( \alpha \synimplies \rho \) can be regarded as a propositional formula, and its \hyperref[def:type_derivation_tree_tree]{type derivation trees} then correspond to \hyperref[def:natural_deduction_proof_tree]{natural deduction proof trees}.

  These ideas are later developed and vastly amplified by Per Martin-L\"of, whose publication \cite{MartinLöf1975IntTypeTheory} introduces \enquote{dependent types} (see \fullref{rem:dependent_types}) for handling higher-order logic, at which Howard only hints. Because of the latter development, \enquote{intuitionistic type theory}, \enquote{dependent type theory} and \enquote{Martin-L\"of type theory} refer to this more abstract setting. \enquote{Simple type theory} continues to refer to the theory with only arrow types. Accidentally, the adjective \enquote{simple} is a contradistinction with Russell's type theory rather than Martin-L\"of's.

  We will call the overall concept of identifying types with formulas the \term{Curry-Howard correspondence}. This phrase is used by \incite[74]{Hindley1997STT}, \incite[45]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020Types}. \incite[341]{BarendregtDekkersStatman2013Types} extend this to \enquote{Curry-de Bruijn-Howard correspondence}. An alternative suggested by Howard himself is \enquote{formulas-as-types correspondence}, also used by \incite[74]{Hindley1997STT}, \incite[\S 1.3.4]{TroelstraSchwichtenberg2000Proofs} and \incite[572]{Barendregt1984LambdaCalculus}. Another variation, \enquote{propositions-as-types correspondence}, is used by \incite[def. 5.4.14]{Barendregt1992Types}, \incite[prop. 6.3.11]{BarendregtDekkersStatman2013Types}, \incite[8]{AwodeyWarren2009HoTT} and \incite[def. 4.1.7]{Mimram2020Types}.

  We formalize the base ideas via \fullref{alg:proof_tree_to_type_derivation} and \fullref{alg:type_derivation_to_proof_tree}.
\end{concept}
\begin{comments}
  \item From the perspective of first-order logic, the correspondence is described in \incite[def. 5.1.11]{Mimram2020Types}.
\end{comments}
