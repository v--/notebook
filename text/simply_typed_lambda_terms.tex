\section{Simply typed lambda terms}\label{sec:simply_typed_lambda_terms}

Unlike untyped lambda calculus, whose presentation is mostly uniform across authors, type theory has many incompatible flavors. A concise history is described in \fullref{rem:type_theory}. We will focus on so-called \enquote{simple types}.

Typed \( \lambda \)-calculus shifts the perspective from terms to type derivations.

\paragraph{Type systems}

\begin{concept}\label{con:ramified_type_theory}
  In his attempt to resolve issues of \hyperref[rem:self_reference]{self-reference} and \hyperref[con:impredicativity]{impredicativity} in logic, Bertrand Russell introduced a \hyperref[con:logical_system]{formal system} which was later called the \term[en=ramified theory of types (\cite[44]{Kleene1971Metamathematics})]{ramified theory of types}.

  He presented this system in \cite{Russell1908TypeTheory}. Along with Alfred Whitehead, he used it to derive a large portion of mathematics. These efforts were published in three volumes --- \cite{WhiteheadRussell1927PrincipiaMathematicaVol1}, \cite{WhiteheadRussell1927PrincipiaMathematicaVol2} and \cite{WhiteheadRussell1927PrincipiaMathematicaVol3}.

  As originally presented, Russell's type theory is quite dated. We will attempt to present his theory with modernized terminology and notation from \fullref{ch:mathematical_logic}, but without complete formalization of the object logic\fnote{If not for the circular dependency, we could have tried to formulate his theory via \hyperref[def:simply_typed_hol]{simply-typed higher-order logic}.}.

  Russell conflates \hyperref[con:syntax_semantics_duality]{syntax and semantics}; he studies \hyperref[con:proposition]{propositions}, each of which is assumed to have a syntactic representation like the formulas of \hyperref[con:higher_order_logic]{higher-order logic}. He also distinguishes between \enquote{propositions}, who have a predetermined truth value, and \enquote{propositional functions}, who depend on externally provided \hyperref[con:variable]{variables}. In our attempt to stay close to the formalisms we use for logic, we will call both \enquote{formulas}. When the formula is intended to be used as a \hyperref[def:boolean_function]{predicate}, we will refer to it as a \enquote{property} of its \hyperref[con:variable_binding]{free variables}.

  Briefly, in Russell's ramified type theory, each formula has two \hyperref[def:labeled_set]{labels} --- one called the \term[en=type (\cite[237]{Russell1908TypeTheory})]{type} and one called the \term[en=order (\cite[44]{Kleene1971Metamathematics})]{order}. Variables accepting formulas are assumed to be annotated with the type and order of formulas they are allowed to range over.

  \begin{thmenum}
    \thmitem{con:ramified_type_theory/types} The purpose of a type is to indicate the intended values a variable can range over. We assume our object language is such that every formula has a well-defined type.

    The \hyperref[con:variable_dependence]{independent variables} range over the base type, which Russell calls the \term{type of individuals}. The nature of individuals is considered irrelevant for the logic\fnote{The only restriction Russell places is that individuals must not be propositions --- a requirement that is meaningless in a more refined formalization.}. We denote this type by \( \syn\iota \)\fnote{Small Greek \( \iota \) with a dot, as per the convention from \fullref{rem:object_language_dots/terminals} of placing dots over terminal symbols.}.

    The other variables that he allows range over formulas. \tcite{In #2, where #1}[56]{Church1940STT} pioneers a dedicated syntax for types, propositions (without free variables) have a dedicated type --- the \term{type of propositions}, denoted by \( \syn\omicron \).

    We reiterate that Russell's propositions and propositional functions are assumed to have a syntactic representation. They are thus restricted to formulas and not abstract predicates. This also means that the available formulas are neatly grouped into types, and the range of a given variable can be determined from the object theory alone. In modern higher-order logic, the type of variables is merely a label, and the values that the variable can take is determined in the metatheory.

    Following the modern notation that we will use in \fullref{sec:higher_order_logic}, if the formula's enumerated free variables have types \( \tau_1, \ldots, \tau_n \), we will denote the type of the formula by
    \begin{equation*}
      \tau_1 \synimplies \cdots \synimplies \tau_n \synimplies \syn\omicron.
    \end{equation*}

    This syntax will be formalized in \fullref{def:simple_type}.

    As an example, consider Leibniz' equality law \eqref{eq:rem:identity_of_indiscernibles/bi}, which we can restate in an informal metalanguage as follows:
    \begin{displayquote}
      The individuals \( x \) and \( y \) are equal if, for every unary property of individuals \( p \), \( p[x] \) holds if and only if \( p[y] \) does.
    \end{displayquote}

    As stated, the law has two free variables --- \( x \) and \( y \) --- both of type \( \syn\iota \); the type of the law is thus \( \syn\iota \synimplies \syn\iota \synimplies \syn\omicron \). It also has one bound variable, \( p \), of type \( \syn\iota \synimplies \syn\omicron \).

    If we substitute one of the variables, say \( y \), with a constant, we will obtain a characterization of the other. For example:
    \begin{displayquote}
      The individual \( x \) equals the integer \( 0 \) if, for every univariate property of individuals \( p \), \( p[x] \) holds if and only if \( p[0] \) does.
    \end{displayquote}

    But this instance of Leibniz's law is itself a univariate property, so we obtain a situation where a formula references itself. To resolve such issues, Russell introduces orders in addition to types.

    \thmitem{con:ramified_type_theory/order} A formula's type is determined by its free variables, while its order is determined by both its free and its bound variables\fnote{In Russell's terminology, free variables were called \enquote{real}, while bound variables were called \enquote{apparent} --- see \fullref{rem:apparent_variables}.}.

    In order to determine the order of a formula, it is sufficient to consider the types of all its variables. We will find useful the following formalism: we define the \term{height} of a type \( \tau \) based on the \hyperref[def:rooted_tree/height]{height} of its \hyperref[def:simple_type_ast]{abstract syntax tree}:
    \begin{itemize}
      \item We define the height of \( \syn\iota \) as \( 1 \).
      \item We define the height of \( \tau_1 \synimplies \cdots \synimplies \tau_n \synimplies \syn\omicron \) as \( 1 \) plus the maximal height among \( \tau_1, \ldots, \tau_n \). In particular, if \( n = 0 \), the height is \( 1 \).
      \item We assume no other types here.
    \end{itemize}

    Then we define the order of a formula as the maximal height of the types of its variables. If a formula contains no variables, i.e. if it is a propositional constant like \( \top \) or \( \bot \), we define the order as \( 0 \)\fnote{Russell suggested using order \( 1 \) for \enquote{elementary propositions} (formulas without any variables), but we find it tidier to distinguish zero-order propositional constants like \( \top \) and \( \bot \) from first-order formulas like \( \qexists {\synx^{\syn\iota}} \qforall {\syny^{\syn\iota}} \synx \doteq \syny \).}.

    In the example above with Leibniz' equality law, the predicate \( p \) can have any order, but the law itself must have a higher order. Otherwise, as already noted, if we substitute \( y \) with a constant, the law will be able to reference itself.

    This also means that we cannot refer to \enquote{every univariate property of individuals} --- we must restrict ourselves to \( n \)-th order properties for a fixed \( n \). This leads to a stratification of the law into distinct formulas, one for each nonnegative integer \( n \). Denote by \( L_n \) the proposition
    \begin{displayquote}
      For every unary property of individuals \( p \) of order \( n \), \( p[x] \) holds if and only if \( p[y] \) does.
    \end{displayquote}

    Then, if \( L_n[a, b] \) holds for some individuals \( a \) and \( b \), they are identical for properties of order \( n \). The formula \( L_n \) itself has order \( n + 1 \).

    This stratification pattern occurred often enough for Russell to also provide a way to circumvent it.

    \thmitem{con:ramified_type_theory/reducibility} Russell calls a formula \enquote{predicative} if its order coincides with the maximal height of the types of its \hi{free} variables. In other words, a formula is predicative if its bound variables are allowed to range over the same formulas as its free variables.

    The motivation for this concept is the following \term[en=axiom of reducibility (\cite[241]{Russell1908TypeTheory})]{axiom of reducibility} stated in \cite[241]{Russell1908TypeTheory}\fnote{By \enquote{function} Russell means a \enquote{propositional function} with an attached syntactic representation. As already mentioned, we perceive such a function as a formula with enumerated free variables.}:
    \begin{displayquote}
      We assume, then, that every function is equivalent, for all its values, to some predicative function of the same arguments.
    \end{displayquote}

    This axiom provides a method of nonconstructive \enquote{reduction} of higher-order formulas to ones of lower order.

    As an example, consider the stratified equality law \( L_n \) discussed above. Suppose that \( L_1[a, b] \) holds for some individuals \( a \) and \( b \). We will show that \( L_n[a, b] \) also holds for any \( n \).

    Fix a property \( q \) of individuals of order \( n \). By the axiom of reducibility, there exists a property \( r \) of order \( 1 \) such that, for every individual \( x \), \( q[x] \) holds if and only if \( r[x] \) does.

    Now, since \( L_1[a, b] \) holds, for every first-order property \( p \) of individuals, \( p[a] \) holds if and only if \( p[b] \) does. In particular, \( r[a] \) and \( r[b] \) have the same truth value. Backtracking, we conclude that \( q[a] \) and \( q[b] \) also have the same truth value.

    Since \( q \) was an arbitrary property of order \( n \), we conclude that \( L_n[a, b] \) holds.

    Therefore, we have collapsed the stratified law of equality into one of lowest possible order.
  \end{thmenum}
\end{concept}

\begin{remark}\label{rem:type_theory}
  We discussed Russell's ramified type theory in \fullref{con:ramified_type_theory}. His theory has influences the introduction of both types and orders. The hierarchy of orders was later found to be superfluous in the presence of the axiom of reducibility, and Russell's theory was called \enquote{ramified} to contrast with the newer \enquote{simple theory of types} which abolishes orders altogether. The latter is discussed in more detail in \fullref{con:simple_type_theory}. The base idea is attributed in \cite[45]{Kleene1971Metamathematics} to Frank Ramsey's \cite{Ramsey1926Foundations}. As can be seen from the following passage, Ramsey tried to discard the concept of orders but retain types:
  \begin{displayquote}
    We must emphasize the essential distinction between order and type. The type of a function is a real characteristic of it depending on the
    arguments it can take; but the order of a proposition or function is not a real characteristic, but what Peano called a pseudo-function. The
    order of a proposition is like the numerator of a fraction. Just as from \enquote{\( x = y \)} we cannot deduce that the numerator of \enquote{\( x \)} is equal to the numerator of \enquote{\( y \)}, from the fact that \enquote{\( p \)} and \enquote{\( q \)} are instances of the
    same proposition we cannot deduce that the order of \enquote{\( p \)} is equal to that of \enquote{\( q \)}.
  \end{displayquote}

  Later, in \cite{Church1940STT}, Alonzo Church extends his untyped \( \muplambda \)-calculus with a concrete syntax for simple types. He uses the base types \( \syn\iota \) of individuals and \( \syn\omicron \) of propositions; both already discussed in \fullref{con:ramified_type_theory/types}. Given the types \( \alpha \) and \( \beta \), Church regards the type \( (\alpha\beta) \) as
  \begin{displayquote}
    \textellipsis the type of functions of one variable for which the range of the independent variable comprises the type \( \beta \) and the range of the dependent variable is contained in the type \( \alpha \).
  \end{displayquote}

  Thus, he used two base types and one \hyperref[con:type_constructor]{type constructor}, resulting in infinitely many types. He assigned to each \( \muplambda \)-term a subscript indicating its type, with certain coherence conditions that exclude \hyperref[def:typability]{untypable terms}. The term \( x_{\syn\omicron} \) would thus correspond to our notion of propositional formula, while the term \( x_{\syn\iota} \) --- to a first-order variable.

  Subsequent works by Curry and Howard lead to the Curry-Howard correspondence, which we discuss in \fullref{con:curry_howard_correspondence}, which required developing \hyperref[con:dependent_type]{dependent types}. This later lead Martin-Löf to introduce \hyperref[def:identity_type]{identity types} and systemize the presentation of dependent type theory via \hyperref[con:typing_rule]{typing rules}. We introduce a refinement of Martin-L\"of's theory in \fullref{def:mltt}.

  At this point, notation started unifying across authors, ultimately leading to \enquote{\( M: \tau \)} rather than \enquote{\( M_\tau \)} or \enquote{\( M^\tau \)} for \hyperref[def:type_assertion]{type assertions} postulating that the term \( M \) has type \( \tau \), and to \( \tau \synimplies \sigma \) for \enquote{function types}, replacing Church's equivalent \( (\sigma\tau) \) (and swapping \( \tau \) and \( \sigma \)). As we will see in \fullref{con:type_annotation} and \fullref{def:typed_lambda_term}, superscript notation is still convenient for type annotations.

  These conventions were already present in the paper \bycite{CoquandHuet1986CoC}. They introduce the \hyperref[def:lambda_cube/combinations]{calculus of constructions}, which Barendregt later shows to be the most powerful system of his \hyperref[def:lambda_cube]{\( \muplambda \)-cube}. The systems of the \( \muplambda \)-cube are instances of the more general \hyperref[def:pure_type_system]{pure type systems}.

  The aforementioned systems feature types that are more complicated syntactically than simple types, and the line between types and terms starts blurring. This is discussed in \fullref{con:pseudoterm_expression}.

  Another significant development is \enquote{homotopy type theory}, introducing semantics for types based on topological spaces. In the eponymous community-written book, \cite{UnivalentFoundationsProgram2024OctoberHoTT}, homotopy type theory is attributed to \cite{Voevodski2006HoTT} and \cite{AwodeyWarren2009HoTT}.
\end{remark}
\begin{comments}
  \item Simple, dependent and homotopy type theory are presented in a unified manner in \cite{Mimram2020ProgramEqualsProof}, with connections to proof theory based on \fullref{sec:curry_howard_correspondence}.
\end{comments}

\begin{definition}\label{def:type_assertion}\mimprovised
  Suppose we are given two \hyperref[def:formal_grammar/schema]{formal grammars} producing strings called \term{terms} and \term{types}, correspondingly. Terms and types may intersect or even coincide, like in the systems in \fullref{sec:dependent_types}.

  We will be interested in expressions generated by the following rule:
  \begin{bnf*}
    \bnfprod{type assertion} {\bnfpn{term} \bnfsp \bnftsq{\( : \)} \bnfsp \bnfpn{type}}.
  \end{bnf*}
\end{definition}
\begin{comments}
  \item When terms are given an interpretation as some objects, we may say \enquote{\( x \) is an object of type \( \tau \)} rather than \enquote{\( x \) is a term of type \( \tau \)}.

  \item On a metatheoretic level, this is one of several kinds of \hyperref[con:judgment]{judgments} that Martin-L\"of uses for his type systems; see \fullref{rem:typing_judgments} for a broader discussion.

  \item This terminology is unfortunately not well-established. For example, \incite[def. 2A4]{Hindley1997BasicSTT} prefers the phrase \enquote{type assignment}, \incite[def. 5.1.10]{Barendregt1992LambdaCalculiWithTypes} uses \enquote{statement}, while \incite[ch. 4]{Mimram2020ProgramEqualsProof} uses the type assertion syntax without introducing terminology for such expressions.

  \item Unlike the terminology, the colon notation for \hyperref[rem:typing_judgments]{typing judgments} is ubiquitous, as discussed in \cite{MathSE:origin_of_colon_notation_for_type_assertions}. The set membership notation \( M \in \tau \) is used by Martin-L\"of in his earlier works \cite{MartinLöf1975IntuitionisticTypeTheory} and \cite{MartinLöf1984IntuitionisticTypeTheory}, but in \cite{MartinLöf1994TypeJudgments} he already uses colons.
\end{comments}

\begin{concept}\label{con:type_universe}
  If, as in the systems in \fullref{sec:dependent_types}, terms and types share a common syntax, we can reserve a special type symbol \( \syn\BbbT \), called a \term[en=universe (\cite[\S 1.3]{UnivalentFoundationsProgram2024OctoberHoTT})]{type universe}, and express the statement \enquote{\( \tau \) is a type} via the \hyperref[def:type_assertion]{type assertion}
  \begin{equation*}
    \tau: \syn\BbbT.
  \end{equation*}

  Rather than using a fixed base type \( \syn\BbbT \), we will use a metalinguistic placeholder \( \BbbT \) that can take any of the possible universes.

  Such a higher-order type is sometimes also called a \term[en=kind (\cite[def. 5.2]{Barendregt1992LambdaCalculiWithTypes})]{kind}, for example in the systems of the \hyperref[def:lambda_cube]{\( \muplambda \)-cube}, with the stipulation that kinds cannot themselves inhabit types or kinds.

  Without this restriction, as described in \incite[\S 8.2.3]{Mimram2020ProgramEqualsProof}, it is possible to obtain a variant of \fullref{thm:russels_paradox} attributed to Jean-Yves Girard.

  A workaround suggested in \cite[\S 1.3]{UnivalentFoundationsProgram2024OctoberHoTT} is the introduction of a sequence
  \begin{equation*}
    \syn\BbbT_0: \syn\BbbT_1: \syn\BbbT_2: \cdots
  \end{equation*}
  such that, for every nonnegative integer \( k \), \( \tau: \syn\BbbT_k \) implies \( \tau: \syn\BbbT_{k+1} \).
\end{concept}
\begin{comments}
  \item Typing rules for universes are given in \fullref{ex:type_universe_rules}
\end{comments}

\begin{remark}\label{rem:typing_judgments}
  Martin-L\"of builds his type theory on several kinds of \hyperref[con:judgment]{judgments}.

  A simplified classification is provided in \cite[19]{UnivalentFoundationsProgram2024OctoberHoTT}, where they are split into \hyperref[def:type_assertion]{type assertion} judgment or \hyperref[con:equality]{definitional equality} judgments.

  \incite*[14]{MartinLöf1984IntuitionisticTypeTheory} himself distinguishes between the judgments \enquote{\( \tau \) is a type} and \enquote{\( x \) is an object of type \( \tau \)}\fnote{To be precise, these aren't exact quotes because Martin-L\"of refers to types as \enquote{sets} in this concrete work, and uses set-membership notation, which is a deviation from his other, even earlier, works.}, and similarly between \enquote{\( \tau \) and \( \sigma \) are equal sets} and \enquote{\( x \) and \( y \) are equal objects of type \( \tau \)}. As discussed in \fullref{con:type_universe}, however, these amount to the same judgment since we can regard types as objects inhabiting a type universe.
\end{remark}

\begin{definition}\label{def:type_context}\mcite[\S A.2.1]{UnivalentFoundationsProgram2024OctoberHoTT}
  A \term[en=type-context (\cite[def. 2A5]{Hindley1997BasicSTT})]{type context} is a \hyperref[def:logical_context]{logical context} with \hyperref[def:logical_context_semantics]{list-based semantics} whose entries are \hyperref[def:type_assertion]{type assertion} for \hi{distinct variables}\fnote{If we drop the uniqueness requirement, we will be able to derive multiple types for the same term from the same context. \incite[\S 4.1.2]{Mimram2020ProgramEqualsProof} allows context to have distinct type assertions for the same variable, but in \cite[\S 4.1.4.2]{Mimram2020ProgramEqualsProof} he still implicitly assumes that the variables are distinct with the justification that they can be renamed.}.

  We have purposely not specified syntax for the terms nor the types, and we simply assume that the terms contain a subset consisting of variables.

  We say that the assertion \( x: \tau \) is \term{consistent} with the context \( \Gamma \) if \( \Gamma \) contains no type assertion for \( x \).
\end{definition}
\begin{comments}
  \item We generalize the definition from the case of \hyperref[def:simple_type]{simple types} considered by Hindley.

  \item In more complicated type systems like those presented in \fullref{sec:dependent_types}, we must additionally ensure that context are well-formed --- see \fullref{rem:well_formed_context}.

  \item The decision to restrict ourselves to variables is explained in \fullref{rem:type_context_only_variables}.

  \item \incite[def. 5.1.1]{Barendregt1992LambdaCalculiWithTypes} calls set-based type contexts \enquote{bases}, and later in \cite[def. 5.1.5]{Barendregt1992LambdaCalculiWithTypes} calls a base a \enquote{context} if it is totally ordered. We will avoid set-based semantics in light of the possible complications of set-based type contexts shown in \fullref{ex:def:mltt_well_formed_context}.
\end{comments}

\begin{definition}\label{def:abstract_type_system}\mimprovised
  An \term{abstract type system} is, roughly, a systematic way of evaluating \hyperref[def:type_assertion]{type assertions}, usually via a collection of \hyperref[con:typing_rule]{typing rules}.

  Such a system must feature a \hyperref[def:consequence_relation]{consequence relation} on \hyperref[def:type_assertion]{type assertions} whose contexts must be \hyperref[def:type_context]{type contexts}, i.e. contain type assertions for distinct variables.
\end{definition}
\begin{comments}
  \item Although this definition is sufficient for simple types, as discussed \fullref{rem:well_formed_context}, for more complicated type systems we will need to ensure that the type assertions and contexts are well-formed. We will elucidate this in \fullref{def:mltt_well_formed_context}.
\end{comments}

\paragraph{Simple types}

\begin{definition}\label{def:simple_type}\mimprovised
  Fix a nonempty finite \hyperref[def:formal_language/alphabet]{alphabet} \( \op*{Base} \), whose elements we will call \term{base types}. We introduce \term{simple types} based on the following \hyperref[def:formal_grammar/schema]{grammar schema}:
  \begin{bnf*}
    \bnfprod{type variable} {\bnfpn{Small Greek identifier}} \\
    \bnfprod{atomic type}   {\bnfpn{base type} \bnfor \bnfpn{type variable}} \\
    \bnfprod{arrow type}    {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}} \\
    \bnfprod{type}          {\bnfpn{atomic type} \bnfor \bnfpn{arrow type}}
  \end{bnf*}
  where we have used the variable identifier rules from \fullref{def:variable_identifier}.

  There are variations to this grammar. For example, in \hyperref[def:simply_typed_hol]{simply-typed higher-order logic} we disallow type variables, while for \hyperref[def:simple_algebraic_types]{simple algebraic types} we will also find useful the following extensions:
  \begin{bnf*}
    \bnfprod{product type} {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \syntimes \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}} \\
    \bnfprod{sum type}     {\bnftsq{(} \bnfsp \bnfpn{type} \bnfsp \bnftsq{\( \synplus \)} \bnfsp \bnfpn{type} \bnfsp \bnftsq{)}}
  \end{bnf*}

  In order to distinguish between different subsets of types, we define simple type systems in \fullref{def:simple_type_system}.
\end{definition}
\begin{comments}
  \item As it often happens, usage in the literature is not consistent. See, for example, \fullref{con:simple_type_theory} and \fullref{rem:arrow_type_name}. To avoid ambiguity, we will be explicit about which types we allow. Furthermore, we will sometimes restrict ourselves to arrow types because handling each extension requires additional work.

  \item We will use the parenthesis convention from \fullref{rem:simple_type_parentheses}.
\end{comments}

\begin{remark}\label{rem:arrow_type_name}
  What we call \enquote{arrow type} is treated differently across authors:
  \begin{itemize}
    \item \incite[56]{Church1940STT} and \incite[\S 51]{Andrews2002Logic} use the notation \enquote{\( (\tau\sigma) \)} for what we would write as \( \sigma \synimplies \tau \). This is discussed in \fullref{rem:type_theory}.

    Neither introduce a dedicated term for arrow types.

    \item \incite[\S 6.2.3]{GirardEtAl1989ProofsAndTypes} uses arrow notation and call them \enquote{arrow types}.

    \item \incite[def. 1.2.1]{TroelstraSchwichtenberg2000BasicProofTheory} and \incite[269]{Farmer2008STTVirtues} use arrow notation and call them \enquote{function types}.

    \item \incite[\S 4.1.1]{Mimram2020ProgramEqualsProof} uses the arrow notation and calls them \enquote{arrow types}.

    \item \incite[def. 2A1]{Hindley1997BasicSTT} uses the arrow notation and calls them \enquote{composite types}.

    \item \incite[def. 3.2.2]{Barendregt1992LambdaCalculiWithTypes} also uses the arrow notation but introduces no special term.
  \end{itemize}
\end{remark}

\begin{concept}\label{con:simple_type_theory}
  The phrase \term[en=simple type theory (\cite[ix]{Hindley1997BasicSTT})]{simple type theory} refers to several distinct \hyperref[def:abstract_type_system]{type systems}, depending on the authors. All of them revolve around simple types as defined in \fullref{def:simple_type}.

  \begin{thmenum}
    \thmitem{con:simple_type_theory/hol} The original usage, due to \bycite[56]{Church1940STT}, allows two base types, arrow types and no type variables, with the specific typing rules discussed in \fullref{def:simply_typed_hol}. The intended usage of this system is as \hyperref[con:higher_order_logic]{higher-order logic}.

    Other authors who follow this convention are \incite[\S 51]{Andrews2002Logic} and \incite[269]{Farmer2008STTVirtues}.

    As Church himself points out, the adjective \enquote{simple} is a contradistinction with Russell's \hyperref[con:ramified_type_theory]{ramified type theory}, even though it is indeed simpler than later developments like \hyperref[con:dependent_type]{dependent types}.

    \thmitem{con:simple_type_theory/arrow} Simple type theory can also be regarded as a type system in and of itself. In this case base types are disallowed, but type variables are allowed, and the rules are \ref{inf:def:arrow_type/elim} and either \ref{inf:def:arrow_type/intro/implicit} or \ref{inf:def:arrow_type/intro/explicit}.

    This system is studied in \incite[def. 3.2.2]{Barendregt1992LambdaCalculiWithTypes}, \incite{Hindley1997BasicSTT} and \incite[def. 1.2.1]{TroelstraSchwichtenberg2000BasicProofTheory}.

    This is \enquote{the} system we will refer to as both \enquote{simple type theory} and \enquote{simply typed \( \muplambda \)-calculus}. It is sometimes denoted by \( \muplambda_{\rightarrow} \), as mentioned in \fullref{def:lambda_cube/term_on_term}. It represents the weakest system in Barendregt's \hyperref[def:lambda_cube]{\( \muplambda \)-cube}.

    \incite{GirardEtAl1989ProofsAndTypes} extends this theory with product types (whose logical counterpart he calls the \enquote{the noble part of natural deduction} in \cite[\S 5.3]{GirardEtAl1989ProofsAndTypes}).

    \thmitem{con:simple_type_theory/algebraic} Through the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, we obtain a much richer system, discussed in \fullref{sec:curry_howard_correspondence}. We use the phrase \enquote{simple algebraic types} in regard to this system.

    \incite[ch. 4]{Mimram2020ProgramEqualsProof} initially only considers type variables and arrow types, without base types, but later allows the full spectrum of simple algebraic types.

    Richer type systems often fundamentally rely on the Curry-Howard correspondence and thus extend this system. Such a system is the Martin-L\"of type theory presented in \fullref{def:mltt}.
  \end{thmenum}
\end{concept}

\begin{proposition}\label{thm:simple_type_grammar}
  The \hyperref[def:formal_grammar]{grammar} of \hyperref[def:simple_type]{simple types} has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:simple_type_grammar/unambiguous} It is \hyperref[def:grammar_ambiguity]{unambiguous}.

    \thmitem{thm:simple_type_grammar/balanced} The \hyperref[def:formal_grammar/language]{generated language} has \hyperref[def:paired_delimiters]{balanced parentheses}.

    \thmitem{thm:simple_type_grammar/not_regular} The grammar is not \hyperref[def:chomsky_hierarchy/regular]{regular}.
  \end{thmenum}
\end{proposition}
\begin{proof}
  Similar to \fullref{thm:propositional_formula_grammar}.
\end{proof}

\begin{remark}\label{rem:simple_type_parentheses}
  We use some \enquote{abuse-of-notation} \hyperref[con:metalogic]{metalingual} syntactic conventions:
  \begin{thmenum}
    \thmitem{rem:simple_type_parentheses/outermost} As in \fullref{rem:propositional_formula_parentheses/outermost} and \fullref{rem:lambda_term_parentheses/outermost}, we avoid writing the outermost parentheses in types.

    \thmitem{rem:simple_type_parentheses/arrow} We suppose that the arrow in arrow types is \hyperref[rem:binary_operation_syntax_trees/associativity]{right-associative}, which allows us to vastly simplify notation in some cases. This helps highlight the types of terms than can be \enquote{applied} to abstractions. See \fullref{ex:def:type_derivation_tree/pairs} and \fullref{ex:def:type_derivation_tree/disjoint} for examples.

    This convention is used by our main sources --- \incite[2A1.1]{Hindley1997BasicSTT}, \incite[notation 3.1.2]{Barendregt1992LambdaCalculiWithTypes} and \incite[\S 4.1.1]{Mimram2020ProgramEqualsProof}.
  \end{thmenum}
\end{remark}

\begin{definition}\label{def:simple_type_ast}\mimprovised
  We implicitly associate with each \hyperref[def:simple_type]{simple type} \( \tau \) an \hyperref[con:abstract_syntax_tree]{abstract syntax tree} \( T(\tau) \) as follows:
  \begin{thmenum}
    \thmitem{def:simple_type_ast/atom} If \( \tau \) is an atomic type, we define \( T(\tau) \) as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with label \( \tau \).

    \thmitem{def:simple_type_ast/application} If \( \tau = \sigma \syncirc \rho \), where \( {\syncirc} \in \set{ \synimplies, \synplus, \syntimes } \), assuming we have already built \( T(\sigma) \) and \( T(\rho) \), we define \( T(\tau) \) by \hyperref[def:ordered_tree_grafting_product]{grafting} \( T(\sigma) \) and \( T(\rho) \) to a new root labeled with \( \syncirc \):
    \begin{equation*}
      \includegraphics[page=1]{output/def__simple_type_ast}
    \end{equation*}
  \end{thmenum}
\end{definition}

\paragraph{Type annotations}

\begin{concept}\label{con:type_annotation}
  The \hyperref[def:type_assertion]{type assertion} \( M: \tau \) is a syntactic construction, and it is possible to assign different meanings to it. The obvious one is to perceive it as a \hyperref[rem:typing_judgments]{typing judgment} expressing that the term \( M \) has type \( \tau \).

  Another possibility, used across programming languages, is merely to highlight intention. In this case we call \( \tau \) a \term{type annotation} for \( M \) --- it is part of the language's syntax, and it merely expresses the intended type of \( M \). Whether or not \( M \) will have type \( \tau \) depends on how the language is interpreted. We will make this precise when discussing typed terms in \fullref{ex:def:type_derivation_tree}.

  For convenience, we follow Howard's convention from \cite{Howard1980FormulasAsTypes} of denoting type annotations by superscripts, i.e. \( M^\tau \) rather than \( M: \tau \). Not only is it the notation more concise, it also allows us to distinguish annotations from assertions.
\end{concept}
\begin{comments}
  \item Superscripts are also used in \cite{Mimram2020ProgramEqualsProof} and \cite[ch. 5]{Hindley1997BasicSTT}. On the other hand, \incite{Barendregt1992LambdaCalculiWithTypes} uses colons for both annotations and assertions.

  \item The phrase \enquote{type annotation} is used, for example, in TypeScript's handbook, \cite{TypeScriptDocs:5.7:handbook}, as well as in Python's documentation, \cite{PythonDocs:3.13:typing} (the latter also call annotations \enquote{type hints}).

  \incite[186]{Mimram2020ProgramEqualsProof} also uses \enquote{type annotation} when discussing \hyperref[rem:typing_style]{Church style typing}.
\end{comments}

\begin{definition}\label{def:typed_lambda_term}\mimprovised
  We consider the extension of the grammar schema of untyped \( \muplambda \)-term in which \hyperref[def:lambda_abstractor]{abstractor variables} have \hyperref[con:type_annotation]{type annotations} attached. Note that annotated variables are not by themselves considered terms --- variable annotations are only used in the abstractor.

  More precisely, we have the following grammar based on that of untyped \( \muplambda \)-terms from \fullref{def:lambda_term}:
  \begin{bnf*}
    \bnfprod{annotated variable} {\bnfpn{variable} \bnfsp \bnftsq{:} \bnfsp \bnfpn{type}}, \\
    \bnfprod{typed application}  {\bnftsq{\( ( \)} \bnfsp \bnfpn{typed term} \bnfsp \bnfpn{typed term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{typed abstraction}  {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{annotated variable} \bnfsp \bnftsq{.} \bnfsp \bnfpn{typed term} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{typed term}         {\bnfpn{atom} \bnfor \bnfpn{typed abstraction} \bnfor \bnfpn{typed application}}
  \end{bnf*}

  Following \fullref{con:type_annotation}, in the \hyperref[con:metalanguage]{metalanguage}, we will prefer the more concise notation \( \qabs {x^\tau} M \) to \( \qabs {(x: \tau)} M \).
\end{definition}
\begin{comments}
  \item This definition requires a choice for the syntax of types; unless noted otherwise, we suppose we are dealing with some variation of \hyperref[def:simple_type]{simple types}. In \fullref{def:polymorphic_typed_lambda_calculus} we will extend this syntax for polymorphic types.

  More complicated type systems likely also use a more complicated syntax; examples can be found in \fullref{sec:dependent_types}.

  \item Even though most concepts from untyped terms transfer via \fullref{alg:type_erasure}, some, like \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalence}, require modification --- see \fullref{def:typed_term_alpha_equivalence}.

  \item Our definition is based on \bycite[def. 3.2.1]{Barendregt1992LambdaCalculiWithTypes}. He prefers calling such terms \enquote{pseudoterms} because the grammar may produce \enquote{ill-typed} terms that are not \hyperref[def:typability]{typable} according to the typing rules. He does this in accordance with his more general terminology discussed in \fullref{con:pseudoterm_expression}.

  We avoid Barendregt's terminology here because, unlike general pseudoterms, where the type assertion may be nonsensical, a type assertion involving simply typed terms is always well-formed (but may not be derivable, just like an assertion for untyped terms may not be derivable).

  We borrow the phrase \enquote{typed term} from \incite[ch. 5]{Hindley1997BasicSTT}, who however follows Church in annotating every term. Our variant, also used by \incite[\S 4.1.3]{Mimram2020ProgramEqualsProof}, only guarantees uniqueness (but not existence) of a type for each term; this is shown in \fullref{thm:typed_term_habitation_uniqueness}.
\end{comments}

\begin{remark}\label{rem:mixed_lambda_term}\mimprovised
  Typed and untyped terms generally require different approaches. Nevertheless, we can define \term{mixed \( \muplambda \)-terms} by allowing both \hyperref[def:lambda_term]{untyped abstractions} and \hyperref[def:typed_lambda_term]{typed abstractions}.

  Systems featuring such terms are called gradually-typed; see \fullref{def:simple_type_system_style}. We will not find use of them in this monograph since we will not study gradual typing. Furthermore, the adaptations for \( \alpha \)-equivalence and \( \beta \)- and \( \eta \)-reduction in \fullref{sec:simply_typed_subject_reduction} becomes much more complicated with mixed terms involved, which is another reason to avoid them.
\end{remark}

\begin{algorithm}[Type erasure]\label{alg:type_erasure}
  To each \hyperref[def:typed_lambda_term]{typed} (or even \hyperref[rem:mixed_lambda_term]{mixed}) \( \muplambda \)-term there corresponds an \hyperref[def:lambda_term]{untyped \( \muplambda \)-term} obtained by removing the type annotations from all abstractor variables.
\end{algorithm}
\begin{comments}
  \item The phrase \enquote{type erasure} is used for \( \muplambda \)-terms by \incite[def. 5A2]{Hindley1997BasicSTT}.
  \item Erasure naturally extends to \hyperref[def:simple_type_schema]{\( \muplambda \)-term schemas}.
  \item This algorithm can be found as \identifier{lambda_.erasure.erase_annotations} in \cite{notebook:code}.
\end{comments}

\paragraph{Schemas for simply typed \( \muplambda \)-terms}

To completely formalize the typing rules, which we will do in \fullref{def:simple_typing_rule}, we first need to introduce schemas for simple types and \( \muplambda \)-terms.

\begin{definition}\label{def:simple_type_schema}
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:simple_type]{simple types} in an obvious way:
  \begin{bnf*}
    \bnfprod{type placeholder}    {\bnfpn{Small Greek identifier}} \\
    \bnfprod{arrow type schema}   {\bnftsq{(} \bnfsp \bnfpn{type schema} \bnfsp \bnftsq{\( \synimplies \)} \bnfsp \bnfpn{type schema} \bnfsp \bnftsq{)}} \\
    \bnfprod{type schema}         {\bnfpn{base type} \bnfor \bnfpn{type placeholder} \bnfor \bnfpn{arrow type schema}},
  \end{bnf*}
  where we have used the variable identifier rules from \fullref{def:variable_identifier}.

  Product and sum types are handled similarly.
\end{definition}
\begin{comments}
  \item To distinguish type schemas from term schemas, which we also denote via capital Greek identifiers, for types we will prefer letters from the start of the alphabet. Thus, \( \Psi: \Alpha \) is a type assertion for term and type schemas.

  \item Unlike in \hyperref[def:lambda_term_schema]{untyped \( \muplambda \)-term schemas}, where variables play a special role and thus have a dedicated syntax, here we treat a type variable as we treat any other type.
\end{comments}

\begin{definition}\label{def:lambda_term_schema}
  We define \hyperref[con:schemas_and_instances]{schemas} for \hyperref[def:lambda_term]{\( \muplambda \)-terms}:
  \begin{bnf*}
    \bnfprod{variable placeholder} {\bnfpn{Small Latin identifier}}, \\
    \bnfprod{term placeholder}     {\bnfpn{Capital Latin identifier}}, \\
    \bnfprod{application schema}   {\bnftsq{\( ( \)} \bnfsp \bnfpn{term schema} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{abstraction schema}   {\bnftsq{\( ( \)} \bnfsp \bnftsq{\( \synlambda \)} \bnfsp \bnfpn{variable placeholder} \bnfsp \bnftsq{.} \bnfsp \bnfpn{term schema} \bnfsp \bnftsq{\( ) \)}}, \\
    \bnfprod{term schema}          {\bnfpn{constant} \bnfor \bnfpn{variable placeholder} \bnfor \bnfpn{term placeholder} \bnfor} \\
    \bnfmore                       {\bnfpn{application schema} \bnfor \bnfpn{abstraction schema}}.
  \end{bnf*}
  and also extend this to \hyperref[def:typed_lambda_term]{typed \( \muplambda \)-terms} by allowing annotations to variable placeholders in abstractor schemas.
\end{definition}
\begin{comments}
  \item This syntax does not allow us to distinguish between variables and variable placeholders, however the other grammatical rules should disambiguate this.

  \item Similarly to propositional formula schemas, in the metalanguage we will denote arbitrary schemas via capital Greek identifiers like \( \Phi \).
\end{comments}

\begin{definition}\label{def:lambda_schema_instantiation}
  We define a \hyperref[con:schemas_and_instances]{schema instantiations} for \hyperref[def:type_assertion]{type assertions} featuring \hyperref[def:lambda_term_schema]{\( \muplambda \)-term schemas} and \hyperref[def:simple_type_schema]{simple type schemas} as a \hyperref[def:set_valued_map/partial]{partial map} \( \BbbI \) sending
  \begin{itemize}
    \item \hyperref[def:lambda_term_schema]{variable placeholders} to \hyperref[def:lambda_term]{variables},
    \item \hyperref[def:lambda_term_schema]{\( \muplambda \)-term placeholders} to \hyperref[def:lambda_term]{\( \muplambda \)-terms} and
    \item \hyperref[def:simple_type_schema]{type placeholders} to \hyperref[def:simple_type]{simple types}.
  \end{itemize}

  \begin{thmenum}
    \thmitem{def:lambda_schema_instantiation/types} We extend the instantiation \( \BbbI \) to compound simple types straightforwardly:
    \begin{equation}\label{eq:def:lambda_schema_instantiation/types}
      \Phi[\BbbI] \coloneqq \begin{cases}
        \tau,                                  &\tau \T{is a base type},        \\
        \BbbI(\tau),                           &\tau \T{is a placeholder},      \\
        \sigma[\BbbI] \synimplies \rho[\BbbI], &\tau = \sigma \synimplies \rho, \\
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_schema_instantiation/terms} We will not concern ourselves with \hyperref[def:lambda_variable_occurrence]{free and bound occurrence} of variables as in the case of \hyperref[def:lambda_term_substitution]{substitution}. As discussed in \fullref{rem:pseudoterm_schemas}, lifting this restriction can be quite subtle.

    We suppose that all occurrences of the same variable placeholder refer to the same variable.

    Thus, we extend \( \BbbI \) to compound \( \muplambda \)-term schemas as follows:
    \begin{equation}\label{eq:def:lambda_schema_instantiation/terms}
      \Phi[\BbbI] \coloneqq \begin{cases}
        \Phi,                                       &\Phi \T{is a constant},             \\
        \BbbI(\Phi),                                &\Phi \T{is a variable placeholder}, \\
        \BbbI(\Phi),                                &\Phi \T{is a term placeholder},     \\
        \Psi[\BbbI] \thinspace \Theta[\BbbI],       &\Phi = \Psi\Theta,                  \\
        \qabs {\BbbI(x)} \Psi[\BbbI],               &\Phi = \qabs x \Psi,                \\
        \qabs {\BbbI(x)^{\BbbI(\tau)}} \Psi[\BbbI], &\Phi = \qabs {x^\tau} \Psi.
      \end{cases}
    \end{equation}

    \thmitem{def:lambda_schema_instantiation/assertion} Finally, given an assertion \( \Psi: \Alpha \), we let
    \begin{equation}\label{eq:def:lambda_schema_instantiation/assertion}
      (\Phi: \Alpha)[\BbbI] \coloneqq \Phi[\BbbI]: \Alpha[\BbbI]
    \end{equation}
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Of course, an application of an instantiation is only valid if the placeholders are in its domain.

  \item Another possibility is to keep instantiations for term and type schemas distinct. However, that would complicate handling typed terms and type assertions unnecessarily.
\end{comments}

\begin{algorithm}[Simple type schema inference]\label{alg:simple_type_schema_inference}
  Fix a \hyperref[def:simple_type]{simple type} \( \tau \) and a \hyperref[def:simple_type_schema]{simple type schema} \( \Alpha \) over the same base types.

  We will present a simple algorithm for inferring an \hyperref[def:lambda_schema_instantiation]{instantiation} \( \BbbI \) such that \( \Alpha[\BbbI] = \tau \), if such an instantiation exists.

  We will do case analysis on the abstract syntax tree of \( \Alpha \) as defined in \fullref{def:simple_type_ast}.
  \begin{thmenum}
    \thmitem{alg:simple_type_schema_inference/base_type} If \( \Alpha \) is a base type, either \( \tau \) is the same base type and \( \BbbI \) is the empty instantiation, or otherwise no match is possible and the algorithm errors out.

    \thmitem{alg:simple_type_schema_inference/variable} If \( \Alpha \) is a type variable placeholder, either \( \tau \) is a variable and we define \( \BbbI(\Alpha) \coloneqq \tau \), or no match is possible and the algorithm errors out.

    \thmitem{alg:lambda_term_schema_inference/connective} Suppose that \( \Alpha = \Beta \bincirc \Gamma \), where \( {\bincirc} \) is \( {\rightarrow} \), \( {\times} \) or \( {+} \).

    If \( \tau = \sigma \bincirc \rho \), we proceed further; otherwise, no match is possible and the algorithm errors out.

    If \( \tau \) has the required form, we use the algorithm recursively to obtain instantiations \( \BbbI_\Beta \) and \( \BbbI_\Gamma \) such that \( \Beta[\BbbI_\Beta] = \sigma \) and \( \Gamma[\BbbI_\Gamma] = \rho \). If any of the recursive applications error out, so does the current application.

    Both \( \BbbI_\Beta \) and \( \BbbI_\Gamma \) are partial functions. If they disagree on their common domain, the algorithm errors out.

    Otherwise, we define \( \BbbI \) as the (set-theoretic) union of \( \BbbI_\Alpha \) and \( \BbbI_\Beta \), so that
    \begin{equation*}
      \Alpha[\BbbI] = \Beta[\BbbI_\Beta] \bincirc \Gamma[\BbbI_\Gamma] = \sigma \bincirc \rho = \tau.
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{defproof}
  The algorithm makes it clear that \( \Alpha[\BbbI] = \tau \) in case it finishes successfully. We can prove by contradiction and case analysis that no such instantiation is possible if the algorithm error out.
\end{defproof}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.type_derivation.instantiation.type_inference.infer_instantiation_from_type} in \cite{notebook:code}.
\end{comments}

\begin{algorithm}[Lambda term schema inference]\label{alg:lambda_term_schema_inference}
  Fix a (simply) \hyperref[def:typed_lambda_term]{typed \( \muplambda \)-term} \( M \) and \hyperref[def:lambda_term_schema]{\( \muplambda \)-term schema} \( \Phi \).

  We will present an algorithm analogous to \fullref{alg:simple_type_schema_inference} for inferring an \hyperref[def:lambda_schema_instantiation]{instantiation} \( \BbbI \) such that \( \Phi[\BbbI] = M \), if such an instantiation exists.

  We will do case analysis on the abstract syntax tree of \( \Phi \)\fnote{We have not defined syntax trees for schemas, but they are obvious adjustment of the trees defined in \fullref{def:lambda_term_ast} for untyped \( \muplambda \)-terms and \fullref{def:simple_type_ast} for simple types.}.

  For untyped \( \muplambda \)-terms and schemas, there are no type annotations, so we may simply skip the usage of \fullref{alg:simple_type_schema_inference} in \fullref{alg:lambda_term_schema_inference/abstraction}.

  \begin{thmenum}
    \thmitem{alg:lambda_term_schema_inference/constant} If \( \Phi \) is a constant, either \( M \) is the same constant and \( \BbbI \) is the empty instantiation, or otherwise no match is possible and the algorithm errors out.

    \thmitem{alg:lambda_term_schema_inference/variable} If \( \Phi \) is a variable placeholder, either \( M \) is a variable and we define \( \BbbI(\Phi) \coloneqq M \), or no match is possible and the algorithm errors out.

    \thmitem{alg:lambda_term_schema_inference/application} Suppose that \( \Phi = \Psi \Theta \). If \( M \) is not an application, the algorithm errors out.

    Otherwise, \( M = NK \) and we use the algorithm recursively to obtain \( \BbbI_\Psi \) and \( \BbbI_\Theta \) such that \( \Phi[\BbbI_\Psi] = N \) and \( \Theta[\BbbI_\Theta] = K \). If any of the recursive applications error out, so does the current application.

    As in \fullref{alg:simple_type_schema_inference/connective}, we define \( \BbbI \) as the (set-theoretic) union of \( \BbbI_\Psi \) and \( \BbbI_\Theta \), so that
    \begin{equation*}
      \Phi[\BbbI] = \Psi[\BbbI_\Psi] \thinspace \Theta[\BbbI_\Theta] = N K = M.
    \end{equation*}

    \thmitem{alg:lambda_term_schema_inference/abstraction} Finally, suppose that \( \Phi = \qabs {X^\Alpha} \Psi \). If \( M \) is not an abstraction, the algorithm errors out.

    Otherwise, \( M = \qabs {x^\tau} N \). We use \fullref{alg:simple_type_schema_inference} to obtain an instantiation \( \BbbI_\Alpha \) such that \( \Alpha[\BbbI_\Alpha] = \tau \). If the type instantiation inference errors out, so does the current algorithm.

    We also recursively use this algorithm on to obtain an instantiation \( \BbbI_\Psi \) such that \( \Psi[\BbbI_\Psi] = N \). Of course, if the recursive application errors out, so does the current application.

    Since \( \BbbI_\Alpha \) matches only type placeholders and \( \BbbI_\Psi \) matches only term placeholders, no collisions are possible. We simply define \( \BbbI \) as their union, with the addition of \( \BbbI(X) = x \) in case \( x \) is not free in \( N \).

    Then
    \begin{equation*}
      \Phi[\BbbI] = \qabs {{X[\BbbI]}^{\Alpha[\BbbI_\Alpha]}} \Psi[\BbbI_\Psi] = \qabs {x^\tau} N = M.
    \end{equation*}
  \end{thmenum}
\end{algorithm}
\begin{defproof}
  The algorithm makes it obvious that \( \Phi[\BbbI] = M \) in case it finishes successfully. We can prove by contradiction and case analysis that no such instantiation is possible if the algorithm error out.
\end{defproof}
\begin{comments}
  \item This algorithm can be found as \identifier{lambda_.type_derivation.instantiation.term_inference.infer_instantiation_from_term} in \cite{notebook:code}.
\end{comments}

\paragraph{Typing rules}

\begin{concept}\label{con:typing_rule}
  A \term{typing rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[rem:typing_judgments]{typing judgments}, likely for \hyperref[con:schemas_and_instances]{schemas} rather than terms and types.
\end{concept}
\begin{comments}
  \item We base this informal definition on Martin-L\"of discussion in \cite{MartinLöf1984IntuitionisticTypeTheory} of rules for his type theory consisting of \hyperref[def:type_assertion]{type assertion} and \hyperref[con:equality]{definitional equality} judgments.

  \item Typing rules are often presented in via \hyperref[rem:natural_deduction_explicit_sequents]{explicit sequent style} rather than our preferred implicit sequent style. See \fullref{rem:dependent_type_rule_sequents} for a discussion.

  \item See \fullref{rem:type_theory_rule_classification} for a classification of rules used in type theory.
\end{comments}

\begin{example}\label{ex:type_universe_rules}
  For \hyperref[con:type_universe]{type universes}, \cite[\S A.2.3]{UnivalentFoundationsProgram2024OctoberHoTT} lists the following \hyperref[con:typing_rule]{typing rules} (parameterized by a nonnegative integer \( k \)):
  \begin{paracol}{2}
    \begin{leftcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \BbbT_+ }]{inf:ex:type_universe_rules/intro}
        \begin{prooftree}
          \infer0[\ref{inf:ex:type_universe_rules/intro}]{ \syn\BbbT_k: \syn\BbbT_{k+1} }
        \end{prooftree}
      \end{equation*}
    \end{leftcolumn}

    \begin{rightcolumn}
      \begin{equation*}\taglabel[\ensuremath{ \BbbT_{\logic{cum}} }]{inf:ex:type_universe_rules/cum}
        \begin{prooftree}
          \hypo{ \tau: \syn\BbbT_k }
          \infer1[\ref{inf:ex:type_universe_rules/cum}]{ \tau: \syn\BbbT_{k+1} }
        \end{prooftree}
      \end{equation*}
    \end{rightcolumn}
  \end{paracol}
\end{example}

\begin{definition}\label{def:simple_typing_rule}\mimprovised
  A \term{simple typing rule} is an \hyperref[def:inference_rule]{inference rule} whose entries are \hyperref[def:type_assertion]{type assertions} for \hyperref[def:lambda_term_schema]{\( \muplambda \)-term schemas} and \hyperref[def:simple_type_schema]{simple type schemas}.

  As in the case of natural deduction rules defined in \fullref{def:natural_deduction_rule}, and using the same formalism, we allow dischargeable type assertions to be attached to the premises.
\end{definition}
\begin{comments}
  \item This precise definition will allow us to mechanize the Curry-Howard correspondence for simple types in \fullref{sec:curry_howard_correspondence}.

  \item We will skip brackets around dischargeable assumptions to reduce clutter. This is demonstrated in \fullref{def:arrow_type}.

  \item In light of \fullref{rem:type_context_only_variables}, dischargeable assumptions must feature variables as terms.
\end{comments}

\begin{definition}\label{def:arrow_type}\mcite[26]{TroelstraSchwichtenberg2000BasicProofTheory}
  When defining the syntax of simple types in \fullref{def:simple_type}, we have defined arrow types as \hyperref[con:type_constructor]{type constructors} combining the types \( \tau \) and \( \sigma \) into \( \tau \synimplies \sigma \).

  We present several \hyperref[def:type_derivation_tree]{typing rules} that show the relation between \( \muplambda \)-terms and arrow types:
  \begin{equation*}\taglabel[\ensuremath{ \rightarrow_- }]{inf:def:arrow_type/elim}
    \begin{prooftree}
      \hypo{ \synM: \syn\tau \synimplies \syn\sigma }
      \hypo{ \synN: \syn\tau }
      \infer2[\ref{inf:def:arrow_type/elim}]{ \synM \synN: \syn\sigma }
    \end{prooftree}
  \end{equation*}

  \begin{paracol}{2}
    \begin{leftcolumn}
      \centering
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \rightarrow_+^{\logic{ut}} }]{inf:def:arrow_type/intro/implicit}
        \begin{prooftree}
          \hypo{ \synx: \syn\tau }
          \infer[dashed]1{ \synM: \syn\sigma }
          \infer1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \synM: \syn\tau \synimplies \syn\sigma }
        \end{prooftree}
      \end{equation*}
      (for \hyperref[def:lambda_term]{untyped terms})\phantom{\( \rightarrow_+^{\logic{ut}} \)}
    \end{leftcolumn}

    \begin{rightcolumn}
      \centering
      \ParacolAlignmentHack
      \begin{equation*}\taglabel[\ensuremath{ \rightarrow_+^{\logic{tt}} }]{inf:def:arrow_type/intro/explicit}
        \begin{prooftree}
          \hypo{ \synx: \syn\tau }
          \infer[dashed]1{ \synM: \syn\sigma }
          \infer1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {\synx^{\syn\tau}} \synM: \syn\tau \synimplies \syn\sigma }
        \end{prooftree}
      \end{equation*}
      (for \hyperref[def:typed_lambda_term]{typed terms})\phantom{\( \rightarrow_+^{\logic{tt}} \)}
    \end{rightcolumn}
  \end{paracol}
\end{definition}
\begin{comments}
  \item In more complicated type systems, we instead use \hyperref[def:dependent_product]{dependent products}.
\end{comments}

\paragraph{Type derivations}

\begin{definition}\label{def:simple_type_signature}\mimprovised
  A \term{simple type signature} \( \Sigma \) is a specification of the following:
  \begin{itemize}
    \item A (possibly empty) set \( \op*{Const}_\Sigma \) of \hyperref[def:lambda_term]{\( \muplambda \)-term} \hyperref[def:lambda_term/const]{constants}, along with a subset \( \op*{Term}_\Sigma \) of \( \muplambda \)-terms we wish to restrict ourselves to.

    \item A (possibly empty) set \( \op*{Base}_\Sigma \) of \hyperref[def:simple_type]{base types}, along with a subset \( \op*{Types}_\Sigma \) of simple types we wish to restrict ourselves to.
  \end{itemize}
\end{definition}
\begin{comments}
  \item For simplicity of definition, we put no restrictions on the subsets of \( \muplambda \)-terms and types.
  \item The most restrictive example we will encounter is the simply-typed higher-order logic system defined in \fullref{def:simply_typed_hol}. In it we omit type variables, product and sum types.
\end{comments}

\begin{definition}\label{def:simple_type_system}\mimprovised
  A \term{simple type system} over a \hyperref[def:simple_type_signature]{simple type signature} is, unsurprisingly, a collection of \hyperref[def:simple_typing_rule]{simple typing rules}.

  Unless stated otherwise, we presuppose that such a system includes the rule \ref{inf:def:arrow_type/elim} and either \ref{inf:def:arrow_type/intro/implicit} or \ref{inf:def:arrow_type/intro/explicit} (or even possibly both).
\end{definition}
\begin{comments}
  \item With every type system we will associate its typing style, defined in \fullref{def:simple_type_system_style}, and its derivability relation, defined in \fullref{def:simple_type_derivability}.

  \item We do not enforce this, but for the concrete systems we will make sure that the properties in \fullref{thm:def:simple_type_derivability} and \fullref{thm:typed_term_habitation_uniqueness} hold.

  \item The type system featuring only \ref{inf:def:arrow_type/elim} and \ref{inf:def:arrow_type/intro/explicit} is called \hyperref[con:simple_type_theory/arrow]{simply typed \( \muplambda \)-calculus} and denoted by \( \muplambda_{\rightarrow} \); see \fullref{con:simple_type_theory/arrow}.
\end{comments}

\begin{definition}\label{def:simple_type_system_style}\mimprovised
  \Fullref{def:arrow_type} features distinct \hyperref[def:simple_typing_rule]{typing rules} for \hyperref[def:typed_lambda_term]{typed} and \hyperref[def:lambda_term]{untyped \( \muplambda \)-terms}. Such a distinction is only necessary (and only possible) for rules featuring abstractor schemas.

  We call a rule using typed abstractors \term{explicitly typed} and a rule featuring untyped abstractors \term{implicitly typed}. We call this property the \term{typing style} of a rule. If both typed and untyped abstractions are used in a single rule, it is neither typed nor untyped, but we introduce no special term in this case since we consider it to be pathological.

  We call a \hyperref[def:simple_type_system]{simple type system} \term{explicitly typed} or \term{implicitly typed} if all its abstractor rules are of the corresponding kind. If the system features both kinds of rules, we call it \term{gradually typed}.
\end{definition}
\begin{comments}
  \item Mixed terms and gradual typing are discussed in \fullref{rem:mixed_terms_and_typing_style}.

  \item The importance of the typing style of a system is discussed in \fullref{rem:typing_style}.

  \item In the absence of pathological rules, determining the typing style of a system is generally possible since we have assumed that, by default, systems include \ref{inf:def:arrow_type/intro/explicit} or \ref{inf:def:arrow_type/intro/implicit} (or both).

  \item The phrases \enquote{explicit typing} and \enquote{implicit typing} are used by \incite[119]{Barendregt1992LambdaCalculiWithTypes} as alternatives for what we described in \fullref{rem:typing_style} as Church and Curry style typing, correspondingly.
\end{comments}

\begin{definition}\label{def:type_derivation_tree}\mimprovised
  In analogy with natural deduction proof trees, defined in \fullref{def:natural_deduction_proof_tree}, we will define here a family of \hyperref[def:labeled_tree]{labeled trees}, which we will call \term{type derivation trees}. Although we will focus on \hyperref[def:simple_type_system]{simple type systems}, the definition easily extends to more complicated systems like \hyperref[def:mltt]{Martin-L\"of type theory}.

  As discussed in \fullref{rem:well_formed_context}, for these more complicated type systems we will need to ensure that all assumptions of a derivation tree are well-formed with respect to some type context. We will elucidate this in \fullref{def:mltt_well_formed_context}. For simple types, all type assertions, type contexts and derivation trees are considered well-formed.

  As in the case of natural deduction proof trees, the labels of type derivations are triples:
  \begin{thmenum}[series=def:type_derivation_tree]
    \thmitem{def:type_derivation_tree/conclusion} A \hyperref[def:type_assertion]{type assertion}, which we call the \term{conclusion}.
    \thmitem{def:type_derivation_tree/rule_name} An empty string or the name of a \hyperref[def:simple_typing_rule]{typing rule}.
    \thmitem{def:type_derivation_tree/open} A set of type assertions whose entries we will call \term{open assumptions}.
  \end{thmenum}

  We define two kinds of derivation trees:
  \begin{thmenum}[resume=def:type_derivation_tree]
    \thmitem{def:type_derivation_tree/assumption} We define \term{assumption} trees similarly to natural deduction assumptions, but we require the term of an assumption to be a variable. For the assertion \( x: \tau \), we define assumption tree as the \hyperref[def:canonical_singleton_tree]{canonical singleton tree} with the following label:
    \begin{itemize}
      \item The conclusion is \( x: \tau \).
      \item The rule name is empty.
      \item There is only one open assumption --- \( x: \tau \) itself.
    \end{itemize}

    We will not need to annotate terms with markers --- the variable plays the role of a marker for the type. To avoid clutter, we will skip square brackets around the assertion that we put in \fullref{def:inference_rule}, i.e. we will denote the tree as \( x: \tau \) rather than \( [x: \tau] \).

    \thmitem{def:type_derivation_tree/application} We define \term{rule application} trees based on a straightforward adaptation of \fullref{def:natural_deduction_proof_tree/application} for natural deduction rule applications, with schema instantiation based on \fullref{def:lambda_schema_instantiation}.

    Again, some assumptions of the subtrees can be \term{discharged} if the rule allows it. The important difference is that we have no markers, so there is a unique choice of type assertion that can be discharged.

    Of course, we must only allow rule applications whose open assumptions have only assertions for distinct variables.
  \end{thmenum}
\end{definition}
\begin{comments}
  \item Rule application is implemented programmatically as \identifier{lambda_.type_derivation.tree.apply} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:type_derivation_tree_focus}
  Rather than working with \hyperref[def:lambda_term]{\( \muplambda \)-terms}, as in the case of untyped \( \muplambda \)-calculus, we will often work with \hyperref[def:type_derivation_tree]{type derivation trees}. Thus, the assertion \( M: \alpha \) will presuppose the existence of a tree \( T \) deriving it, and proving other assertions will be based mostly on transforming \( T \).
\end{remark}

\begin{remark}\label{rem:mixed_terms_and_typing_style}
  We mentioned in \fullref{def:simple_type_system_style} that we consider pathological the rules featuring both typed and untyped abstractors. Yet, we allow systems to feature \hi{distinct} rules that handle either typed or untyped terms, and call such a system \enquote{gradually typed}.

  Our reasoning is that a gradually typed system should allow typed, untyped, and even mixed \( \muplambda \)-terms. A rule with mixed schemas is instead able to \hi{only} handle mixed terms, making it suitable for very specific circumstances. We find it counterproductive to devote our attention to such rules.

  There may also be cases where mixing typed and untyped abstractors results in a legitimate rule, like the following, expressing \fullref{alg:type_erasure}:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \qabs {\synx^{\syn\tau}} \synM: \syn\tau \synimplies \syn\sigma }
      \infer1{ \qabs \synx \synM: \syn\tau \synimplies \syn\sigma }
    \end{prooftree}
  \end{equation*}

  It is however merely an abbreviation of a derivation tree featuring the more carefully crafted arrow type rules:
  \begin{equation*}
    \begin{prooftree}
      \hypo{ \qabs {\synx^{\syn\tau}} \synM: \syn\tau \synimplies \syn\sigma }
      \hypo{ \synx: \syn\tau }
      \infer2[\ref{inf:def:arrow_type/elim}]{ \synM: \sigma }
      \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \synM: \tau \synimplies \tau }
    \end{prooftree}
  \end{equation*}
\end{remark}

\begin{proposition}\label{thm:assumptions_and_free_variables}
  Let \( T \) be a \hyperref[def:type_derivation_tree]{type derivation tree} with conclusion \( M: \tau \) featuring only the base arrow typing rules \ref{inf:def:arrow_type/elim}, \ref{inf:def:arrow_type/intro/implicit} and \ref{inf:def:arrow_type/intro/explicit}.

  Then the variables having \hyperref[def:type_derivation_tree/open]{open assumptions} in \( T \) are precisely the free variable of \( M \).
\end{proposition}
\begin{proof}
  We will use case analysis on the structure of \( T \):
  \begin{itemize}
    \item If \( T \) is an assumption tree, then \( M \) must be a variable, and thus \( x: \tau \) is an open assumption in \( T \) if and only if \( M = x \).

    \item If \( T \) is an application of \ref{inf:def:arrow_type/elim}, then \( M = NK \) and \( T \) has subtrees deriving \( N: \rho \to \tau \) and \( K: \rho \) for some type \( \rho \). We suppose that the inductive hypothesis holds for \( T_N \) and \( T_K \).

    Since nothing is discharged by this rule application, the open assumptions of \( M \) are the union of those of \( N \) and \( K \). The same holds for the free variables.

    \item If \( T \) is an application of \ref{inf:def:arrow_type/intro/explicit}, for some type \( \sigma \) we have \( M = \qabs {x^\sigma} y N \), \( \tau = \sigma \synimplies \rho \). Then \( T \) has a subtree deriving \( N: \rho \) with the additional assumption \( y: \sigma \). But this is precisely the additional free variable compared to those of \( M \).

    \item If \( T \) is an application of \ref{inf:def:arrow_type/intro/implicit}, we proceed identically.
  \end{itemize}
\end{proof}

\begin{definition}\label{def:type_derivation_relation}\mimprovised
  As we will discuss in \fullref{rem:well_formed_context}, the order of assertions in a \hyperref[def:type_context]{type context} may be important. On the other hand, following established practice, we have defined consequence relations in \fullref{def:consequence_relation} on set-based contexts where the order does not matter.

  This leads us to adapt consequence relations to \hyperref[rem:well_formed_context]{well-formed} type contexts, with the conditions \eqref{eq:def:consequence_relation/reflexivity}, \eqref{eq:def:consequence_relation/monotonicity} and \eqref{eq:def:consequence_relation/transitivity} adapted straightforwardly. We will call such a relation a \term{type derivation relation}.
\end{definition}
\begin{comments}
  \item For simple type systems, where all type contexts are well-formed ad the order of assumptions does not matter, there is no necessity for this definition because consequence relations are sufficient.

  \item Since lists are by their nature finite, a type derivation relation necessarily satisfies a compactness condition akin to \eqref{eq:def:consequence_relation/compactness}.
\end{comments}

\begin{definition}\label{def:simple_type_derivability}\mimprovised
  In a fixed \hyperref[def:simple_type_system]{simple type system} (specifying terms, types and rules), we define a \hyperref[def:type_derivation_relation]{type derivation relation} as follows: for a \hyperref[rem:well_formed_context]{well-formed} \hyperref[def:type_context]{type context} \( \Gamma \) and a \hyperref[def:type_assertion]{type assertion} \( M: \tau \), we let \( \Gamma \vdash M: \tau \) if there exists a \hyperref[def:type_derivation_tree]{type derivation tree} with conclusion \( M: \tau \) whose \hyperref[def:type_derivation_tree/open]{open assumptions} are a \hyperref[def:subsequence]{sublist} of \( \Gamma \).

  As per \fullref{def:abstract_logic}, we say that the type assertion \( M: \tau \) is \term[en=derivable (\cite[def. 3.1.4]{Barendregt1992LambdaCalculiWithTypes})]{derivable} from \( \Gamma \) if this relation holds.
\end{definition}
\begin{defproof}
  We can prove that \( {\vdash} \) is indeed a consequence relation analogously to our proof of consistency in \fullref{def:natural_deduction_entailment}.
\end{defproof}
\begin{comments}
  \item We introduce additional terminology in \fullref{def:typability} and \fullref{def:type_habitation}.

  \item Note that \( \Gamma \) by definition consists of type assertions for variables and not for more general \( \muplambda \)-terms. This is discussed in \fullref{rem:type_context_only_variables}.
\end{comments}

\begin{remark}\label{rem:type_context_only_variables}
  In \fullref{def:simple_type_derivability} we have only defined a \hyperref[def:consequence_relation]{consequence relation} for \hyperref[def:type_context]{type context} consisting of type assertions for variables, i.e. \( \Gamma \vdash M: \tau \) can hold for an arbitrarily complex term \( M \), however the context \( \Gamma \) must have only variable type assertions. The types in both the context and the consequence are allowed to be arbitrarily complex.

  This is seemingly different from, for example, natural deduction proofs, where the context may consist of arbitrarily complex formulas. We would like to point out the following:
  \begin{itemize}
    \item By the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, formulas correspond to types, not to terms.

    \item By assuming that a complex term \( M \) has type \( \tau \), we must have a derivation of \( M: \tau \). This would extend our considerations for well-formed types from \fullref{rem:well_formed_context} to terms.

    \item While logic studies \hyperref[def:consequence_relation]{logical consequence} and \hyperref[con:hypothetical_judgment]{hypothetical judgments}, for type theory terms should ideally be typed unconditionally. Thus, while in logic \hyperref[def:propositional_tautology]{tautologies} with empty contexts are a curiosity, in type theory contexts are an instrument for dealing with \hyperref[def:lambda_variable_freeness]{free variables}.
  \end{itemize}

  Our sources which define type contexts only allow variable type assertions in them ---
  \cite[19]{MartinLöf1984IntuitionisticTypeTheory},
  \cite[def. 2A5]{Hindley1997BasicSTT},
  \cite[def. 5.1.5]{Barendregt1992LambdaCalculiWithTypes} and
  \cite[\S 4.1]{Mimram2020ProgramEqualsProof}.
\end{remark}

\begin{proposition}\label{thm:def:simple_type_derivability}
  \hyperref[def:simple_type_derivability]{Type derivability} for \hyperref[con:simple_type_theory/arrow]{simple type theory} (i.e. the \hyperref[def:simple_type_system]{simple type system} only featuring the arrow typing rules \ref{inf:def:arrow_type/elim} and either \ref{inf:def:arrow_type/intro/implicit} or \ref{inf:def:arrow_type/intro/explicit}) has the following basic properties:
  \begin{thmenum}
    \thmitem{thm:def:simple_type_derivability/combinator} If \( \vdash M: \sigma \), then \( M \) is a \hyperref[def:lambda_combinator]{combinator}.

    \thmitem{thm:def:simple_type_derivability/assumption_removal} We have \( \Gamma, x: \tau \vdash M: \sigma \) if and only if \( \Gamma \vdash \qabs x M: \tau \to \sigma \).
  \end{thmenum}
\end{proposition}
\begin{comments}
  \item \Fullref{thm:def:simple_type_derivability/assumption_removal} allows us to remove assumptions by prefixing the term with an abstractor.
\end{comments}
\begin{proof}
  \SubProofOf{thm:def:simple_type_derivability/combinator} It follows from \fullref{thm:assumptions_and_free_variables} that \( x: \tau \) is an open assumption for a derivation of \( M: \sigma \) if and only if \( x \) is not free in \( M \). If \( M \) is a combinator, it has no free variables, hence derivations of \( M \) have no open assumptions.

  \SubProofOf{thm:def:simple_type_derivability/assumption_removal}

  \SufficiencySubProof* Let \( P \) be a derivation tree for \( M: \sigma \) from \( \Gamma, x: \tau \). We will build a tree deriving \( \qabs x M: \tau \to \sigma \) from \( \Gamma \).

  \begin{itemize}
    \item If \( x: \tau \) is an open assumption, it is discharged during a simple application of \ref{inf:def:arrow_type/intro/explicit}:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ x: \tau }
        \ellipsis { \( P \) } { M: \sigma }
        \infer[left label=\( x \)]1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {x^\tau} M: \tau \synimplies \sigma }
      \end{prooftree}
    \end{equation*}

    Discharging \( x: \tau \) leaves us with \( \Gamma \vdash \qabs {x^\tau} M: \tau \synimplies \sigma \).

    Applying the implicitly typed rule \ref{inf:def:arrow_type/intro/implicit} is analogous.

    \item Otherwise, if \( x: \tau \) is not an open assumption in \( P \), then \( \Gamma \vdash P \) by \fullref{def:simple_type_derivability}. During application of \ref{inf:def:arrow_type/intro/explicit} (or \ref{inf:def:arrow_type/intro/implicit}) nothing is discharged, and we again obtain \( \Gamma \vdash \qabs {x^\tau} M: \tau \synimplies \sigma \).
  \end{itemize}

  \NecessitySubProof* Conversely, if \( P \) is a derivation tree of \( \qabs x M: \tau \to \sigma \) from \( \Gamma \), it must be an application tree for \ref{inf:def:arrow_type/intro/explicit} (or \ref{inf:def:arrow_type/intro/implicit}), and hence \( x: \tau \) is either discharged during the application, or it is not and the derivation of \( M: \sigma \) does not depend on it. In both cases, we conclude that \( \Gamma, x: \tau \vdash M \).
\end{proof}

\begin{definition}\label{def:typability}\mcite[def. 2D1]{Hindley1997BasicSTT}
  For a fixed \hyperref[def:abstract_type_system]{abstract type system}, we say that the term \( M \) is \term{typable} in the \hyperref[rem:well_formed_context]{well-formed} \hyperref[def:type_context]{type context} \( \Gamma \) if there exists a type \( \tau \) such that \( \Gamma \vdash M: \tau \).

  We say that \( M \) is \term{typable} (without a context specified) if there exists a context in which it is typable.
\end{definition}
\begin{comments}
  \item We will often be interested in \hyperref[def:lambda_combinator]{combinators}, in which case, due to \fullref{thm:def:simple_type_derivability/combinator}, we may restrict ourselves to empty contexts: a combinator is typable if and only if there exists a type \( \tau \) such that \( \vdash M: \tau \).

  \item We generalize Hindley's definition for simple types to our notion of abstract type systems.
\end{comments}

\begin{definition}\label{def:type_habitation}\mcite[def. 8A1]{Hindley1997BasicSTT}
  For a fixed \hyperref[def:abstract_type_system]{abstract type system}, if \( \vdash M: \tau \), we say that \( M \) is an \term[en=untyped inhabitant (\cite[8A1]{Hindley1997BasicSTT})]{inhabitant} of \( \tau \). If the type \( \tau \) has at least one habitant, we say that it is \term{inhabited}.
\end{definition}
\begin{comments}
  \item We base our definition of habitant on the notion of \enquote{untyped inhabitants} for \hyperref[def:simple_type]{simple type} from \cite[def. 8A1]{Hindley1997BasicSTT}. Hindley also defines \enquote{typed habitants} for valid \hyperref[def:typed_lambda_term]{typed terms} and \enquote{\( \beta \)-normal habitants} for terms in \hyperref[def:lambda_term_normal_form]{\( \beta \)-normal form}.

  \item Unlike for \hyperref[def:typability]{typability}, this definition only applies to derivations from the empty context. This restricts us to inhabitants without free variables.

  \item Proving that a type is inhabited reduces to constructing a derivation tree, however proving that it is uninhabited requires reaching a metalogical contradiction. For \hyperref[def:mltt]{Martin-L\"of type theory}, we have introduced a notion of \enquote{propositionally uninhabited} types --- see \fullref{def:propositionally_uninhabited}.
\end{comments}

\begin{example}\label{ex:def:type_derivation_tree}
  We list examples of \hyperref[def:type_derivation_tree]{type derivation trees} for \hyperref[def:simple_type_system]{simple type systems}:
  \begin{thmenum}
    \thmitem{ex:def:type_derivation_tree/var} A variable \( x \) is typable in any \hyperref[def:type_context]{type context} containing \( x \). Due to \fullref{thm:assumptions_and_free_variables}, it is not typable without a context unless we introduce a special rule for this.

    \thmitem{ex:def:type_derivation_tree/const} The typability of constants depends on special rules introduced for them. See, for example, \fullref{sec:curry_howard_correspondence} and \fullref{sec:higher_order_logic}.

    \thmitem{ex:def:type_derivation_tree/i} The combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) inhabits \( \tau \synimplies \tau \) for any type \( \tau \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \synx: \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    \hyperref[def:simple_type_system_style]{Explicit typing} can restrict each term to at most one type --- the rule \ref{inf:def:arrow_type/intro/explicit} is only applicable if \( x \) is annotated with the same type it has in the context:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/explicit}]{ \qabs {\synx^\tau} \synx: \tau \synimplies \tau }
      \end{prooftree}
    \end{equation*}

    However, instead of having one term \( I \), we obtain one term \( I_\tau \) for each type \( \tau \).

    This example motivates \hyperref[def:polymorphic_typed_lambda_calculus]{polymorphic types}; we will return to this particular term in \fullref{ex:def:polymorphic_typed_lambda_calculus/i}.

    \thmitem{ex:def:type_derivation_tree/k} The combinator \( \ref{eq:ex:def:lambda_term/combinator/k} = \qabs \synx \qabs \syny \synx \) inhabits \( \tau \synimplies \sigma \synimplies \tau \) for any pair of types \( \tau \) and \( \sigma \):
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau }
        \infer1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syny \synx: \sigma \synimplies \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \qabs \syny \synx: \tau \synimplies (\sigma \synimplies \tau) }
      \end{prooftree}
    \end{equation*}

    During the first rule application, we do not discharge any assumptions since there are no compatible assumptions to discharge.

    Via the \hyperref[con:curry_howard_correspondence]{Curry-Howard correspondence}, this type corresponds to the \hyperref[def:minimal_implication_logic]{minimal implicational logic} axiom \eqref{eq:def:minimal_implication_logic/intro} --- see \fullref{ex:con:curry_howard_correspondence/minimal_implicational}.

    \thmitem{ex:def:type_derivation_tree/s} The combinator \( \ref{eq:ex:def:lambda_term/combinator/s} = \qabs \synx \qabs \syny \qabs \synz \synx \synz (\syny \synz) \) is a little more complicated:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synx: \tau \synimplies (\sigma \synimplies \rho) }
        \hypo{ \synz: \tau }
        \infer2[\ref{inf:def:arrow_type/elim}]{ \synx \synz: \sigma \synimplies \rho }

        \hypo{ \syny: \tau \synimplies \sigma }
        \hypo{ \synz: \tau }
        \infer2[\ref{inf:def:arrow_type/elim}]{ \syny \synz: \sigma }

        \infer2[\ref{inf:def:arrow_type/elim}]{ \synx \synz (\syny \synz): \rho }
        \infer[left label=\( \synz \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synz \synx \synz (\syny \synz): \tau \synimplies \rho }
        \infer[left label=\( \syny \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syny \qabs \synz \synx \synz (\syny \synz): (\tau \synimplies \sigma) \synimplies (\tau \synimplies \rho) }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ S: (\tau \synimplies (\sigma \synimplies \rho)) \synimplies ((\tau \synimplies \sigma) \synimplies (\tau \synimplies \rho)) }
      \end{prooftree}
    \end{equation*}

    Via the Curry-Howard correspondence, this type corresponds to the axiom \eqref{eq:def:minimal_implication_logic/dist} --- see \fullref{ex:con:curry_howard_correspondence/minimal_implicational}.

    \thmitem{ex:def:type_derivation_tree/typed_incompatible} The typed term
    \begin{equation*}
      I^\alpha I^\beta = (\qabs {\synx^\alpha} \synx) (\qabs {\synx^\beta} \synx)
    \end{equation*}
    is not generally \hyperref[def:typability]{typable} unless \( \alpha = \beta \synimplies \beta \) (or unless the type system contains a special typing rule).

    \thmitem{ex:def:type_derivation_tree/self_application} The term \( xx \) is not typable because \ref{inf:def:arrow_type/elim} requires the existence of types \( \tau \) and \( \sigma \) so that \( x \) inhibits \( x: \tau \to \sigma \) and \( x: \tau \) simultaneously. This is not possible because type contexts disallow variables to have more than one type assigned.

    We can regard this as an instance of \hyperref[con:impredicativity]{impredicativity} --- namely, function self-application.

    We have shown in \fullref{ex:def:beta_eta_reduction/omega} that some terms like \( \ref{eq:ex:def:lambda_term/combinator/big_omega} = (\qabs \synx \synx \synx) (\qabs \synx \synx \synx) \) containing self-application lead to infinite chains of \hyperref[def:beta_eta_reduction]{\( \beta \)-reductions}.

    The impossibility of infinite sequences of reductions is captured by the concept of strong normalization defined in \fullref{def:strongly_normalizing_lambda_term}.

    \thmitem{ex:def:type_derivation_tree/pairs} Consider the \hyperref[def:ordered_tuple]{ordered pair} combinators \ref{ex:def:beta_eta_reduction/pairs/intro}, \ref{ex:def:beta_eta_reduction/pairs/elim_left} and \ref{ex:def:beta_eta_reduction/pairs/elim_right} from \fullref{ex:def:beta_eta_reduction/pairs}.

    We have shown that, for arbitrary terms \( A \) and \( B \), we have
    \begin{align*}
      P_{-L} (P_+ A B) \bred* A
      &&
      P_{-R} (P_+ A B) \bred* B.
    \end{align*}

    Similarly to the previous cases, we can find a type for
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pairs/intro} = \qabs \synx \qabs \syny \qabs \synf \synf \synx \syny
    \end{equation*}
    by fixing types \( \tau \), \( \sigma \), \( \rho \) and matching them to obtain the following derivation:
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \tau \synimplies (\sigma \synimplies \rho) }
        \hypo{ \synx: \tau }
        \infer2[\ref{inf:def:arrow_type/elim}]{ \synf \synx: \sigma \synimplies \rho }

        \hypo{ \syny: \sigma }
        \infer2[\ref{inf:def:arrow_type/elim}]{ \synf \synx \syny: \rho }
        \infer[left label=\( \synf \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synf \synf \synx \syny: (\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho }
        \infer[left label=\( \syny \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syny \qabs \synf \synf \synx \syny: \sigma \synimplies ((\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho) }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ P_+: \tau \synimplies (\sigma \synimplies ((\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho)) }
      \end{prooftree}
    \end{equation*}

    The convention of \( \synimplies \) being right-associative discussed in \fullref{rem:simple_type_parentheses/arrow} allows us to simplify the notation
    \begin{equation*}
      P_+: \tau \synimplies (\sigma \synimplies ((\tau \synimplies (\sigma \synimplies \rho)) \synimplies \rho))
    \end{equation*}
    to
    \begin{equation*}
      P_+: \tau \synimplies \sigma \synimplies (\tau \synimplies \sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    If \( A: \tau \) and \( B: \sigma \), after two applications of \ref{inf:def:arrow_type/elim} we obtain
    \begin{equation*}
      P_+ A B: (\tau \synimplies \sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    For the combinator
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pairs/elim_left} = \qabs \synp \synp (\qabs \synx \qabs \syny \synx)
    \end{equation*}
    we have
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synp: (\tau \synimplies \sigma \synimplies \tau) \synimplies \rho }

        \hypo{ \synx: \tau }
        \infer1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syny \synx: \sigma \synimplies \tau }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \qabs \syny \synx: \tau \synimplies \sigma \synimplies \tau }

        \infer2[\ref{inf:def:arrow_type/elim}]{ \synp (\qabs \synx \qabs \syny \synx): \rho }
        \infer[left label=\( \synp \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ P_{-L}: ((\tau \synimplies \sigma \synimplies \tau) \synimplies \rho) \synimplies \rho }
      \end{prooftree}
    \end{equation*}

    We have derived types for both \( P_+ A B \) and \( P_{-L} \), and can conclude that the rule \ref{inf:def:arrow_type/elim} is only applicable to \( P_{-L} (P_+ A B) \) if \( \rho = \tau \), in which case \( P_{-L} (P_+ A B) \) inhabits \( \tau \), as expected.

    On the other hand, for
    \begin{equation*}
      \ref{ex:def:beta_eta_reduction/pairs/elim_right} = \qabs \synp \synp (\qabs \synx \qabs \syny \syny)
    \end{equation*}
    we can similarly derive
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synp: (\tau \synimplies \sigma \synimplies \sigma) \synimplies \rho }

        \hypo{ \syny: \sigma }
        \infer[left label=\( \syny \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syny \syny: \sigma \synimplies \sigma }
        \infer1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synx \qabs \syny \syny: \tau \synimplies \sigma \synimplies \sigma }

        \infer2[\ref{inf:def:arrow_type/elim}]{ \synp (\qabs \synx \qabs \syny \syny): \rho }
        \infer[left label=\( \synp \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ P_{-R}: ((\tau \synimplies \sigma \synimplies \sigma) \synimplies \rho) \synimplies \rho }
      \end{prooftree}
    \end{equation*}

    The rule \ref{inf:def:arrow_type/elim} is only applicable to \( P_{-R} (P_+ A B) \) if \( \rho = \sigma \), in which case \( P_{-R} (P_+ A B): \sigma \).

    We see here how the ability to derive multiple types for \( P_+ \) is actually beneficial --- we can use the same combinator in different situations.

    Now consider the \hyperref[def:typed_lambda_term]{typed terms} corresponding to \( P_+ \), \( P_{-L} \) and \( P_{-R} \):
    \begin{align*}
      P_+^{\tau,\sigma,\rho} &\coloneqq \qabs {\synx^\tau} \qabs {\syny^\sigma} \qabs {\synf^{\tau \synimplies \sigma \synimplies \rho}} \synf \synx \syny, \\
      P_{-L}^{\tau,\sigma,\rho} &\coloneqq \qabs {\synp^{\tau \synimplies \sigma \synimplies \tau}} \synp (\qabs {\synx^\tau} \qabs {\syny^\sigma} \synx), \\
      P_{-R}^{\tau,\sigma,\rho} &\coloneqq \qabs {\synp^{\tau \synimplies \sigma \synimplies \sigma}} \synp (\qabs {\synx^\tau} \qabs {\syny^\sigma} \syny).
    \end{align*}

    We must have \( \rho = \tau \) if we want to be able to apply \( P_{-L} \) and \( \rho = \sigma \) if we want to apply \( P_{-R} \). Thus, unless \( \tau = \sigma \), at least one of the following is not \hyperref[def:typability]{typable}:
    \begin{align*}
      P_{-L}^{\tau,\sigma,\rho} (P_+^{\tau,\sigma,\rho} A B)
      &&
      P_{-R}^{\tau,\sigma,\rho} (P_+^{\tau,\sigma,\rho} A B)
    \end{align*}

    The latter issue is discussed in \cite{MathOF:product_type_in_simply_typed_lambda_terms}, where it is also proven that no such explicitly typed triple of combinators\fnote{As noted in \fullref{rem:product_type_equality_rules}, such a triple is called a \enquote{surjective pairing}} exist.

    We will find it convenient to have a dedicated constant term \( \synP_+ \) such that \( \synP_+ A B \) has a dedicated type --- namely, the product type \( \tau \syntimes \sigma \), which we will introduce in \fullref{def:simple_product_type}.

    \thmitem{ex:def:type_derivation_tree/disjoint} Consider the combinators \ref{eq:ex:def:beta_eta_reduction/disjoint/intro_left}, \ref{eq:ex:def:beta_eta_reduction/disjoint/intro_right} and \ref{eq:ex:def:beta_eta_reduction/disjoint/elim} from \fullref{ex:def:beta_eta_reduction/disjoint}.

    Since \( S_- \) and \( P_+ \) are \hyperref[def:lambda_term_alpha_equivalence]{\( \alpha \)-equivalent}, we conclude that they can be assigned the same types\fnote{This will be proven formally in \fullref{thm:alpha_equivalent_term_typing}.}.

    On the other hand, for
    \begin{equation*}
      S_{+L} = \qabs \synx \qabs \synf \qabs \syng \synf \synx
    \end{equation*}
    we have
    \begin{equation*}
      \begin{prooftree}
        \hypo{ \synf: \tau \synimplies \rho }
        \hypo{ \synx: \tau }
        \infer2[\ref{inf:def:arrow_type/elim}]{ \synf \synx: \rho }
        \infer1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \syng \synf \synx: (\sigma \synimplies \rho) \synimplies \rho }
        \infer[left label=\( \synf \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ \qabs \synf \qabs \syng \synf \synx: (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho \synimplies \rho) }
        \infer[left label=\( \synx \)]1[\ref{inf:def:arrow_type/intro/implicit}]{ S_{+L}: \tau \synimplies (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho }
      \end{prooftree}
    \end{equation*}

    Similarly, we can derive
    \begin{equation*}
      S_{+R}: \sigma \synimplies (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    Suppose that \( A: \tau \), \( F: \tau \synimplies \rho \) and \( G: \sigma \synimplies \rho \). Then, in order for \ref{inf:def:arrow_type/elim} to be applicable to
    \begin{equation*}
      S_- F G (S_{+L} A),
    \end{equation*}
    the combinator \( S_- \) must inhabit
    \begin{equation*}
      (\tau \synimplies \rho) \synimplies (\sigma \synimplies \rho) \synimplies ((\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho) \synimplies \delta
    \end{equation*}
    for some type \( \delta \).

    According to \fullref{ex:def:type_derivation_tree/pairs}, such a derivation is possible if \( \delta = \rho \). This type corresponds to Haskell's
    \begin{verbatim}
      either :: (a -> c) -> (b -> c) -> Either a b -> c,
    \end{verbatim}\vspace{-\baselineskip}
    as long as we identify \verb|Either a b| with
    \begin{equation*}
      (\tau \synimplies \sigma) \synimplies (\sigma \synimplies \rho) \synimplies \rho.
    \end{equation*}

    This works even with explicit typing, but the identification is not particularly apt because \verb|Either a b| must depend on \( \rho \). One solution to this is to introduce sum types, which we will do in \fullref{def:simple_sum_type}.

    As long as \( F \) and \( G \) are fixed, however, they determine \( \rho \), and we can derive
    \begin{equation*}
      S_- F G (S_{+L} A): \rho
    \end{equation*}
    and
    \begin{equation*}
      S_- F G (S_{+R} B): \rho.
    \end{equation*}
  \end{thmenum}
\end{example}
\begin{comments}
  \item Many of these examples are verified programmatically in the modules \identifier{lambda_.type_derivation.test_tree} and \identifier{lambda_.type_derivation.test_inference} in \cite{notebook:code}.
\end{comments}

\begin{remark}\label{rem:typing_style}
  \Fullref{ex:def:type_derivation_tree} highlights how the \hyperref[def:simple_type_system_style]{typing style} of a system can drastically affect its \hyperref[def:typability]{typability}. The rule \ref{inf:def:arrow_type/intro/explicit} itself demonstrates how \hyperref[con:type_annotation]{type annotations} help guide us during type derivation.

  \Fullref{thm:typed_term_habitation_uniqueness} proves that this tackles the non-uniqueness of type derivations for \hyperref[def:lambda_combinator]{combinators} shown in \fullref{ex:def:type_derivation_tree/i} --- the combinator \( \ref{eq:ex:def:lambda_term/combinator/i} = \qabs \synx \synx \) inhabits \( \tau \synimplies \tau \) for any type \( \tau \), however, when \( \tau \) is fixed, \ref{inf:def:arrow_type/intro/explicit} uniquely determines \hi{the} type of \( I^\tau = \qabs {\synx^\tau} \synx \) as \( \tau \synimplies \tau \) at the cost of introducing a distinct abstraction term for every possible annotation of the abstractor variable.

  Another possibility is to annotate every term like Church originally did in \cite{Church1940STT}. In this case type contexts become obsolete. The notation becomes much more verbose, however, and, in light of \fullref{thm:typed_term_habitation_uniqueness}, there is little gain. Compare the following typed variations of the combinator \ref{eq:ex:def:lambda_term/combinator/k}:
  \begin{equation*}
    \qabs {\synx^\tau} \qabs {\syny^\sigma} \synx
  \end{equation*}
  and
  \begin{equation*}
    (\qabs {\synx^\tau} (\qabs {\syny^\sigma} \synx^\tau)^{\sigma \synimplies \tau})^{\tau \synimplies \sigma \synimplies \tau}.
  \end{equation*}

  The second convention is referred to as \enquote{Church style typing}, for example by \cite[ch. 5]{Hindley1997BasicSTT}. Even though it is not as historically accurate, the first convention is also referred to as \enquote{Church style}, for example by \incite[ch. 4]{Mimram2020ProgramEqualsProof}. This relates to explicitly typed systems, where the rules have type annotations, however we should distinguish between the typing style of rules (i.e. explicit or implicit) and the typing style of terms (i.e. typed or untyped). Explicitly typed systems require typed terms, but not vice versa.

  As a contradistinction, implicitly typed systems are referred to by both the aforementioned authors as \enquote{Curry style} in honor of Haskell Curry for his work \cite{Curry1934FunctionalityInCombinatoryLogic}. Curry did not consider \( \muplambda \)-terms nor types, but worked with abstract combinators applied to each other in what he called \enquote{combinatory logic}. We can deduce a relation to typing systems from the following quote:
  \begin{displayquote}
    Let \( F \) denote an entity whose interpretation is such that \( FXY \) represents, in the notation of combinatory logic, the category of functions on \( X \) to \( Y \), while the formula \( \vdash FXYf \) represents the statement that \( f \) belongs to that category.
  \end{displayquote}

  Here \( f \) is merely a symbol, while \( \vdash FXYf \) translates into the type assertion \( f: X \synimplies Y \). Since the type \( X \synimplies Y \) is not attached to \( f \), the latter is also allowed to inhabit another type, which contrasts with Church's usage mentioned earlier.

  Ironically, the programming language Haskell, also named after Haskell Curry, uses type annotations and hence not Curry style typing. Unlike a true Church style type system, however, Haskell's allows not annotating terms for which the types can be inferred.
\end{remark}

\begin{proposition}\label{thm:typed_term_habitation_uniqueness}
  In the \hyperref[def:simple_type_system_style]{explicitly typed} \hyperref[def:simple_type_system]{simple type system} featuring only the arrow typing rules \ref{inf:def:arrow_type/elim} and \ref{inf:def:arrow_type/intro/explicit}, we can \hyperref[def:simple_type_derivability]{derive} at most one type for any \hyperref[def:typed_lambda_term]{typed term} from a fixed \hyperref[def:type_context]{type context}.
\end{proposition}
\begin{comments}
  \item In particular, a typed combinator can \hyperref[def:type_habitation]{inhabit} at most one type.

  \item We can also interpret this result as a statement for untyped combinators --- each of them can be typed uniquely \enquote{up to a choice of types for bound variables}.

  \item \hyperref[def:lambda_cube/term_on_type]{Polymorphic types} allow extending this to implicitly typed systems.
\end{comments}
\begin{proof}
  Let \( T \) be a tree deriving \( M: \tau \) from the type context \( \Gamma \).

  We will use \fullref{thm:induction_on_rooted_trees} on \( T \) to show that if \( T' \) derives \( M: \tau' \) from \( \Gamma \), the trees are equal and \( \tau = \tau' \):
  \begin{itemize}
    \item If \( T \) is an assumption tree, then \( M \) must be a variable, and \( \Gamma \vdash M \) only if \( \Gamma \) contains a type assertion for \( M \). Since type contexts have at most one type assertion per variable, it follows that the type \( \tau \) of \( M \) is uniquely determined.

    \item If \( T \) is an application of \ref{inf:def:arrow_type/elim}, then \( M = NK \) and \( T \) has a subtree \( T_N \) deriving \( N: \sigma \to \tau \) for some type \( \sigma \), and a subtree \( T_K \) deriving \( K: \sigma \). We suppose that the inductive hypothesis holds for \( T_N \) and \( T_K \).

    Let \( T' \) be a tree deriving \( M: \tau' \) from \( \Gamma \). Since \( M = NK \), \( T' \) must be an application tree of \ref{inf:def:arrow_type/elim}, with subtrees \( T_N' \) and \( T_K' \) deriving \( N: \sigma' \to \tau' \) and \( K: \sigma' \) from the assumptions in \( \Gamma \).

    The inductive hypothesis on \( T_N \) implies that the types \( \sigma' \to \tau' \) and \( \sigma \to \tau \) are equal, and thus so are \( \tau' \) and \( \tau \).

    \item If \( T \) is an application of \ref{inf:def:arrow_type/intro/explicit}, then \( M = \qabs {x^\sigma} N \), \( \tau = \sigma \synimplies \rho \) and \( T \) has a subtree \( S \) deriving \( N: \rho \) from \( \Gamma, x: \sigma \).

    Let \( T' \) be a tree deriving \( M: \tau' \) from \( \Gamma \). Then \( \tau' = \sigma \synimplies \rho' \) \( T' \) is an application of \ref{inf:def:arrow_type/intro/explicit}, and we have a subtree \( S' \) deriving \( N: \rho' \) from \( \Gamma, x: \sigma \).

    It is extremely important here that \( \sigma \) and \( \sigma' \) are equal, which is only possible due to the annotation of \( x \).

    The inductive hypothesis implies that \( S \) and \( S' \) are equal, and that \( \rho = \rho' \). Then also \( \tau = \tau' \).
  \end{itemize}
\end{proof}

\begin{remark}\label{rem:simply_typed_lambda_term_dependency}
  Similarly to the case of \hyperref[def:lambda_term]{untyped \( \muplambda \)-terms} in \fullref{alg:untyped_lambda_term_to_function}, each \hyperref[def:typed_lambda_term]{simply typed \( \muplambda \)-term} \( M \) has an abstractor prefix, i.e. there exist variables \( x_1, \ldots, x_n \) and types \( \tau_1, \ldots, \tau_n \) such that
  \begin{equation*}
    M = \qabs {x_1^{\tau_1}}\ldots \qabs {x_n^{\tau_n}} N
  \end{equation*}
  and \( N \) is not an abstraction.

  If we fix a \hyperref[def:abstract_type_system]{type system}, this would allow us to determine which terms inhabit which types, which in turn would allow us to treat \( M \) as a function over terms inhabiting \( \tau_1, \ldots, \tau_n \).

  If \( y \) is \hyperref[def:lambda_variable_freeness]{free variable} of \( M \), and if we know that its intended type is \( \sigma \), we might consider \( \qabs {y^\sigma} M \) instead of \( M \). We may thus, without loss of generality, suppose that \( M \) has no free variables.
\end{remark}

\paragraph{Type inference}

\begin{algorithm}[Typed term type inference]\label{alg:simply_typed_term_type_inference}
  Fix a \hyperref[def:simple_type_system_style]{explicitly typed} \hyperref[def:simple_type_system]{simple type system} and a \hyperref[def:typed_lambda_term]{typed \( \muplambda \)-term} \( M \) without constants. Fix also a \hyperref[def:type_context]{type context} \( \Gamma \) containing the free variables of \( M \). We will try (and sometimes fail) to construct a \hyperref[def:type_derivation_tree]{type derivation tree} for \( M \) recursively.

  \begin{thmenum}
    \thmitem{alg:simply_typed_combinator_type_derivation/const} If \( M \) is a constant, we halt the algorithm with no result since handling constants depends on the particular type system.

    \thmitem{alg:simply_typed_combinator_type_derivation/var} If \( M \) is a variable, we have two possibilities:
    \begin{thmenum}
      \thmitem{alg:simply_typed_combinator_type_derivation/var/assumption} If \( \Gamma \) contains an assertion \( M: \tau \) for some type \( \tau \), we use this to construct an \hyperref[def:type_derivation_tree/assumption]{assumption tree}.

      \thmitem{alg:simply_typed_combinator_type_derivation/var/no_assumption} Otherwise, we again halt the algorithm with no result since, as shown in \fullref{thm:assumptions_and_free_variables}, free variables require a choice of type.
    \end{thmenum}

    \thmitem{alg:simply_typed_combinator_type_derivation/app} If \( M = NK \), we use the algorithm on \( N \) and \( K \) with the same context to obtain derivation trees \( T_N \) and \( T_K \).

    If their types are compatible, i.e. if \( T_N \) derives \( \tau \synimplies \sigma \) for \( N \) and \( T_K \) derives \( \tau \) for \( K \), we apply \ref{inf:def:arrow_type/elim} to obtain a tree deriving \( M: \sigma \).

    \thmitem{alg:simply_typed_combinator_type_derivation/abs} Finally, if \( M = \qabs {x^\tau} N \), we use the algorithm on \( N \) with context \( \Gamma, x: \tau \) to obtain a derivation tree \( T_N \) deriving some type \( \sigma \) for \( N \).

    Then we simply apply \ref{inf:def:arrow_type/intro/explicit} to obtain a tree deriving \( M: \tau \to \sigma \).
  \end{thmenum}
\end{algorithm}
\begin{comments}
  \item Note that, unlike in \fullref{thm:typed_term_habitation_uniqueness}, we have not restricted which rules can be used, so it is possible that the obtained type is not unique.

  \item This algorithm can be found as \identifier{lambda_.arrow_types.type_inference.derive_type} in \cite{notebook:code}.
\end{comments}
