<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <link href="http://arxiv.org/api/query?search_query%3D%26id_list%3D2403.06707v1%26start%3D0%26max_results%3D1" rel="self" type="application/atom+xml"/>
  <title type="html">ArXiv Query: search_query=&amp;id_list=2403.06707v1&amp;start=0&amp;max_results=1</title>
  <id>http://arxiv.org/api/68izChECrzmPFK3SHCSyJu96kWY</id>
  <updated>2024-09-08T00:00:00-04:00</updated>
  <opensearch:totalResults xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">1</opensearch:totalResults>
  <opensearch:startIndex xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">0</opensearch:startIndex>
  <opensearch:itemsPerPage xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">1</opensearch:itemsPerPage>
  <entry>
    <id>http://arxiv.org/abs/2403.06707v1</id>
    <updated>2024-03-11T13:33:09Z</updated>
    <published>2024-03-11T13:33:09Z</published>
    <title>Deriving Dependently-Typed OOP from First Principles -- Extended Version
  with Additional Appendices</title>
    <summary>  The expression problem describes how most types can easily be extended with
new ways to produce the type or new ways to consume the type, but not both.
When abstract syntax trees are defined as an algebraic data type, for example,
they can easily be extended with new consumers, such as print or eval, but
adding a new constructor requires the modification of all existing pattern
matches. The expression problem is one way to elucidate the difference between
functional or data-oriented programs (easily extendable by new consumers) and
object-oriented programs (easily extendable by new producers). This difference
between programs which are extensible by new producers or new consumers also
exists for dependently typed programming, but with one core difference:
Dependently-typed programming almost exclusively follows the functional
programming model and not the object-oriented model, which leaves an
interesting space in the programming language landscape unexplored. In this
paper, we explore the field of dependently-typed object-oriented programming by
deriving it from first principles using the principle of duality. That is, we
do not extend an existing object-oriented formalism with dependent types in an
ad-hoc fashion, but instead start from a familiar data-oriented language and
derive its dual fragment by the systematic use of defunctionalization and
refunctionalization. Our central contribution is a dependently typed calculus
which contains two dual language fragments. We provide type- and
semantics-preserving transformations between these two language fragments:
defunctionalization and refunctionalization. We have implemented this language
and these transformations and use this implementation to explain the various
ways in which constructions in dependently typed programming can be explained
as special instances of the phenomenon of duality.
</summary>
    <author>
      <name>David Binder</name>
    </author>
    <author>
      <name>Ingo Skupin</name>
    </author>
    <author>
      <name>Tim Süberkrüb</name>
    </author>
    <author>
      <name>Klaus Ostermann</name>
    </author>
    <arxiv:doi xmlns:arxiv="http://arxiv.org/schemas/atom">10.1145/3649846</arxiv:doi>
    <link title="doi" href="http://dx.doi.org/10.1145/3649846" rel="related"/>
    <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">This extended version contains additional appendices not contained in
  the published version. The published version will be available in the ACM DL
  as part of the PACMPL issue for OOPSLA 2024</arxiv:comment>
    <link href="http://arxiv.org/abs/2403.06707v1" rel="alternate" type="text/html"/>
    <link title="pdf" href="http://arxiv.org/pdf/2403.06707v1" rel="related" type="application/pdf"/>
    <arxiv:primary_category xmlns:arxiv="http://arxiv.org/schemas/atom" term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
    <category term="cs.PL" scheme="http://arxiv.org/schemas/atom"/>
  </entry>
</feed>
