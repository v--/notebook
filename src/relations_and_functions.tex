\subsection{Relations and functions}\label{subsec:relations_and_functions}

We first define \hyperref[def:binary_relation]{binary relations}, then use them to define \hyperref[def:function]{functions}. Definitions for arbitrary Cartesian products and arbitrary relations are also given, albeit with forward references to \fullref{thm:omega_is_model_of_pa}.

\begin{definition}\label{def:binary_relation}
  Let \( A \) and \( B \) be sets and let \( R \subseteq A \times B \) be a subset of their \hyperref[def:binary_cartesian_product]{Cartesian product}.

  The nested tuple \( (R,  (A, B)) \) is called an \term{binary relation}. We say that the tuple \( (x, y) \in A \times B \) is \term{related} with respect to \( R \) when \( (x, y) \in R \). We will also later (in \fullref{def:relation}) introduce relations that are not necessarily binary but we must first define arbitrary Cartesian products.

  We introduce the following terminology:
  \begin{thmenum}[series=def:binary_relation]
    \thmitem{def:binary_relation/graph} The set \( R \) of tuples is called the \term{graph} of the relation. In case the tuple \( (A, B) \) is clear from the context, we can identify the relation \( (R, (A, B)) \) with its graph \( R \). We sometimes use the notation \( \gph(R) \) for the graph.

    \thmitem{def:binary_relation/signature} The \term{signature} of the binary relation is the tuple \( (A, B) \). Obviously this definition only makes sense if we know what the signature is, either from the context or from the definition of the relation as the nested tuple \( (R, (A, B)) \) rather than only via its graph \( R \).

    As a matter of fact, it is common to ignore the signature when defining relations --- see e.g. \cite[7]{Kelley1955} or \cite[def. 2.1]{OpenLogicFull}. If we do identify a relation only with its graph, however, some notions like \hyperref[def:binary_relation/range]{ranges} and \hyperref[def:binary_relation/image]{images} coincide despite being different and other notions like \hyperref[def:function_invertibility/surjective]{function surjectivity} make no sense.

    Furthermore, a two relations whose graphs are equal may have different signatures, which further highlights how important it is to distinguish between a relation and its graph.

    \thmitem{def:binary_relation/domain} The \term{domain} of \( R \) is the set
    \begin{equation*}
      \dom(R) \coloneqq \set{ x \in A \given \qexists {y \in B} (x, y) \in R }
    \end{equation*}
    of all members of \( A \) that belong to at least one tuple in the graph \( R \).

    \thmitem{def:binary_relation/image} The \term{image} of \( R \) is the set
    \begin{equation*}
      \img(R) \coloneqq \set{ y \in B \given \qexists {x \in A} (x, y) \in R }
    \end{equation*}
    of all members of \( Y \) that belong to at least one tuple in the graph \( R \).

    \thmitem{def:binary_relation/range} The set \( B \) is called the \term{range} or \term{codomain} of \( R \). There is no similar established terminology for \( A \).

    \thmitem{def:binary_relation/empty} The relation is \term{empty} if its graph is the empty set, i.e. if no two elements are related.

    It is important to highlight that the graphs of all empty relations are equal but two empty relations are only equal if their signatures are.

    \thmitem{def:binary_relation/inverse}\mcite[def 2.31]{OpenLogicFull} The \term{inverse relation} of \( R \) is
    \begin{equation*}
      R^{-1} \coloneqq \set{ (y, x) \given (x, y) \in R }.
    \end{equation*}

    \thmitem{def:binary_relation/restriction} The \term{restriction} of \( R \) to \( A' \subseteq A \) is the binary relation \( (R\restr_{A'}, A', A') \) is
    \begin{equation*}
      R\restr_{A'} \coloneqq R \cap (A' \times A') = \set{ (x, y) \in R \given x \in A' \T{and} y \in A' }.
    \end{equation*}

    We say that \( R \) is an \term{extension} of \( R\restr_{A'} \).

    \thmitem{def:binary_relation/diagonal} A very special relation is the \term{diagonal relation} on a set \( A \):
    \begin{equation*}
      \increment_A \coloneqq \set{ (x, x) \given x \in A }.
    \end{equation*}

    \thmitem{def:binary_relation/composition} Given two relations \( R \subseteq A \times B \) and \( T \subseteq B \times C \), we define their composition as
    \begin{equation*}
      T \bincirc R \coloneqq \set*{ (x, z) \in A \times C \given* \qexists {y \in Y} \parens[\Big]{ (x, y) \in R \T{and} (y, z) \in T } }.
    \end{equation*}
  \end{thmenum}

  Whenever \( A = B \) and \( R \) is simply a binary relation over \( A \), the following are commonly used conditions that are often as axioms to some theory:
  \begin{thmenum}[resume=def:binary_relation]
    \thmitem{def:binary_relation/reflexive} \( R \) is \term{reflexive} if \( \Delta_A \subseteq R \), i.e. if every element of \( A \) is related with itself.

    The following formula is used as an axiom for \hyperref[def:poset/nonstrict]{nonstrict partial orders} and \hyperref[def:entourage]{entourages}:
    \begin{equation}\label{eq:def:binary_relation/reflexive}
      \qforall \xi (\xi \mathbin{R} \xi).
    \end{equation}

    Note that we use \fullref{rem:first_order_formula_conventions/infix} notation in the latter case. Using either infix or prefix notation is actually a necessity since we do not actually have a concept of an ordered tuple in general (not set-based) first-order theories --- see \fullref{rem:first_order_formula_conventions/infix}.

    \thmitem{def:binary_relation/irreflexive} \( R \) is \term{irreflexive} if \( \Delta_A \cap R = \varnothing \), i.e. if no element of \( A \) is related with itself.

    The following formula is used as an axiom for \hyperref[def:poset/strict]{strict partial orders}:
    \begin{equation}\label{eq:def:binary_relation/irreflexive}
      \neg \qexists \xi (\xi \mathbin{R} \xi).
    \end{equation}

    \thmitem{def:binary_relation/symmetric} \( R \) is \term{symmetric} if \( R = R^{-1} \).

    The following formula is used as an axiom for \hyperref[def:equivalence_relation]{equivalence relations}, \hyperref[def:undirected_graph]{undirected graphs} and \hyperref[def:entourage]{entourages}:
    \begin{equation}\label{eq:def:binary_relation/symmetric}
      \xi \mathbin{R} \eta \rightarrow \eta \mathbin{R} \xi.
    \end{equation}

    \thmitem{def:binary_relation/antisymmetric} \( R \) is \term{antisymmetric} if \( R \cap R^{-1} = \Delta_X \).

    The following formula is used as an axiom for \hyperref[def:poset]{partial orders}:
    \begin{equation}\label{eq:def:binary_relation/antisymmetric}
      (\xi \mathbin{R} \eta \wedge \eta \mathbin{R} \xi) \rightarrow \xi \doteq \eta.
    \end{equation}

    \thmitem{def:binary_relation/transitive} \( R \) is \term{transitive} if \( R = R \bincirc R \).

    The following formula is used as an axiom for \hyperref[def:poset]{preorders}:
    \begin{equation}\label{eq:def:binary_relation/transitive}
      (\xi \mathbin{R} \eta \wedge \eta \mathbin{R} \zeta) \rightarrow \xi \mathbin{R} \zeta.
    \end{equation}

    \thmitem{def:binary_relation/total} \( R \) is \term{total} if any two member of \( A \) are related.

    The following formula is used as an axiom for \hyperref[def:totally_ordered_set]{nonstrict total orders}:
    \begin{equation}\label{eq:def:binary_relation/total}
      \qforall \xi \qforall \eta (\xi \mathbin{R} \eta \vee \eta \mathbin{R} \xi).
    \end{equation}

    \thmitem{def:binary_relation/trichotomic} \( R \) is \term{trichotomic} if every two elements of \( A \) are either related or equal.

    The following formula is used as an axiom for \hyperref[def:totally_ordered_set]{strict total orders}:
    \begin{equation}\label{eq:def:binary_relation/trichotomic}
      \qforall \xi \qforall \eta (\xi \mathbin{R} \eta \vee \eta \mathbin{R} \xi \vee \eta = \xi).
    \end{equation}
  \end{thmenum}
\end{definition}

\begin{example}\label{ex:relation}
  \hyperref[def:binary_relation]{Binary relations} are used in vastly different contexts:
  \begin{itemize}
    \item \hyperref[def:function]{Functions} are special binary relations.
    \item \hyperref[sec:order_theory]{Orders} are also special binary relations.
    \item \hyperref[def:directed_graph]{Directed graphs} are binary relations over finite sets.
    \item \hyperref[def:entourage]{Entourages} are binary relations in \hyperref[def:uniform_space]{uniform spaces}.
    \item Relations are equivalent to Boolean-valued functions (see \fullref{rem:boolean_valued_functions_and_predicates}) and are often used for defining semantics of predicate symbols in \hyperref[subsec:first_order_logic]{first-order logic}.
  \end{itemize}
\end{example}

\begin{definition}\label{def:derived_relations}
  Let \( R \subseteq A^2 \) be a binary relation on the set \( A \).

  \begin{thmenum}
    \thmitem{def:derived_relations/reflexive} The \term{reflexive closure} of \( R \) is
    \begin{equation*}
      \cl^R(R) \coloneqq R \cup \Delta_X.
    \end{equation*}

    \thmitem{def:derived_relations/symmetric} The \term{symmetric closure} of \( R \) is
    \begin{equation*}
      \cl^S(R) \coloneqq R \cup R^{-1}.
    \end{equation*}

    \thmitem{def:derived_relations/transitive} The \term{transitive closure} \( \cl^T(R) \) of \( R \) is the smallest (with respect to set inclusion) relation that contains \( R \) such that \( (x, y) \in R \) and \( (y, z) \in R \) together imply \( (x, z) \in \cl^T(R) \).

    The \term{transitive reduction} \( \red^T(R) \) of \( R \) is the smallest relation such that \( \cl^T(\red^T(R)) = \cl^T(R) \).

    Using natural numbers, the transitive closure can instead be defined recursively as
    \begin{equation*}
      \cl^T(R) \coloneqq \bigcup \set{ R^k \given k \in \BbbN },
    \end{equation*}
    where \( R^k \) is iterated \hyperref[def:binary_relation/composition]{composition}.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:derived_relations_characterization}
  The is reflexive (resp. symmetric or transitive) closure of a relation \( R \) is the smallest reflexive (resp. symmetric or transitive) relation that contains \( R \).
\end{proposition}
\begin{proof}
  Every other reflexive (resp. symmetric or transitive) relation contains the closure.
\end{proof}


\begin{remark}\label{rem:function_definition}
  It is not straightforward to formalize the notion of correspondence between two values. We will use the terms \term{mapping}, \term{function}, \term{transformation} and \term{operator}. We will define functions as special binary relations in \fullref{def:function}. Despite this being a standard practice, this has several drawbacks:

  \begin{itemize}
    \item There are some more mappings than the functions defined in \fullref{def:function}. For example, assigning to a set \( A \) its \hyperref[def:basic_set_operations/power_set]{power set} \( \mscrP(A) \) can be cannot be regarded as a function because its domain and range should both be the set of all sets whose existence is inconsistent with \hyperref[def:zfc]{\logic{ZFC}} by \fullref{thm:simple_foundation_theorems/no_set_contains_itself}.

    \item We often work with spaces that have some additional structure in addition to being sets. In this case, we are often only interested in maps that preserve this structure. This is the case with \hyperref[def:group/homomorphism]{group homomorphisms}, for example.

    In terms of \hyperref[def:first_order_structure]{first-order structures}, not every function is a \hyperref[def:first_order_homomorphism]{homomorphism}.

    This is a motivating example for the benefits of \hyperref[sec:category_theory]{category theory}, where the notion of \hyperref[def:category/C2]{morphism} is able to capture this additional structure.

    It is often important to consider functions that are not homomorphisms, however. For example, function spaces over \( \BbbR \) contain some very complicated functions that are not field homomorphisms, order homomorphisms nor continuous functions and thus do not aim to preserve structural properties of \( \BbbR \).

    \item Several generalizations of the standard notion of a function are often used. These include \hyperref[def:multi_valued_function]{multi-valued} and \hyperref[def:partial_function]{partial functions}. Both are not functions, strictly speaking.

    For simplicity of exposition, we take multi-valued functions as primitive notions and define single-valued functions as special cases. This is actually done in \cite[def. 2.31]{OpenLogicFull} and \cite[8]{Kelley1955} except that the corresponding authors conflate multi-valued functions and relations.

    \item Set-theoretic functions are often used in contexts where they do not refer to the intuitive notion of a mapping. Examples include \hyperref[def:cartesian_product]{Cartesian products} and \hyperref[def:indexed_family]{indexed families}.
  \end{itemize}
\end{remark}

\begin{definition}\label{def:multi_valued_function}
  A \term{multi-valued function} from \( A \) to \( B \) is simply a \hyperref[def:binary_relation]{binary relation} \( (F, (A, B)) \). For us the difference between a multi-valued function and a relation is merely in how we treat them. Multi-valued function are also called set-valued.

  As discussed in \fullref{def:binary_relation/graph}, the common practive of identifying a multi-valued function \( (F, (A, B)) \) with its \hyperref[def:binary_relation/graph]{graph} \( F \) with no regard to its \hyperref[def:binary_relation/signature]{signature} \( (A, B) \) has serious drawbacks that we wish to avoid.

  We use the more established notation \( F: A \multto B \) rather than \( (F, (A, B)) \) and call the string of symbols \( A \multto B \) the signature of \( F \) rather than the tuple \( (A, B) \).

  \begin{thmenum}[series=def:multi_valued_function]
    \thmitem{def:multi_valued_function/value} The \term{value} of \( F \) at \( x \) is
    \begin{equation*}
      F(x) \coloneqq \set{ y \in B \given (x, y) \in F }.
    \end{equation*}

    In case \( x \) is not a concrete value, then \( F(x) \) stands for the function \( F \) itself. In other words, \( F(x) \) refers to a member of \( B \) if \( x \) is a \hyperref[def:first_order_syntax/formula_bound_variables]{bound variable} and \( F(x) \) refers to the function \( F \) if \( x \) is a \hyperref[def:first_order_syntax/formula_free_variables]{free variable}.

    \thmitem{def:multi_valued_function/set_value} We also define the value of \( F \) at a subset \( A' \) of \( A \) as
    \begin{equation*}
      F(A') \coloneqq \cup \set{ F(x) \given x \in A' }.
    \end{equation*}

    This is also called the \term{action} of \( F \) on the set \( A' \) or the \term{image} of \( A' \) under \( F \). We also refer to \( F(x) \) as the image of \( x \) under \( F \) because \( F(x) = F(\set{x}) \).
  \end{thmenum}

  The following terminology is consistent with relations:
  \begin{thmenum}[resume=def:multi_valued_function]
    \thmitem{def:multi_valued_function/graph} The \term{graph} \( \gph(F) \) of \( F \) is the graph of the relation \( F \). This is consistent with \fullref{def:binary_relation/graph}.

    \thmitem{def:multi_valued_function/domain} The \term{domain} \( \dom(F) \) of \( F \) is the set of all values \( x \) for which \( F(x) \neq \varnothing \). This is consistent with \fullref{def:binary_relation/domain}.

    \thmitem{def:multi_valued_function/image} The \term{image} \( \img(F) \) is the set of all \( y \in B \) that belong to the set \( F(x) \) for at least one \( x \in A \). It is the same as the value \( F(A) \). The definition is consistent with \fullref{def:binary_relation/image}.

    \thmitem{def:multi_valued_function/range} The \term{range} \( \range(F) \) is simply the set \( B \). This is consistent with \fullref{def:binary_relation/range}.

    \thmitem{def:multi_valued_function/restriction} The \term{restriction} of \( F: A \multto B \) to \( A' \subseteq A \) is the multi-valued function \( F\restr_{A'}: A' \rightarrow B \). We say that \( F \) is an \term{extension} of \( F\restr_{A'} \). This is consistent with \fullref{def:binary_relation/restriction}.

    \thmitem{def:multi_valued_function/inverse} The \term{inverse} \( F^{-1}: B \multto A \) of a multi-valued function \( F: A \multto B \) is the multi-valued function in which assigns to every element \( y \) of the image \( \img(F) \) the set of all \( x \in A \) such that \( y \in F(x) \). This is consistent with \fullref{def:binary_relation/inverse}.

    \thmitem{def:multi_valued_function/composition} The \term{composition} \( G \bincirc F \) of two multi-valued functions \( F: A \multto B \) and \( G: B \multto C \) is the function
    \begin{equation*}
      [G \bincirc F](x) \coloneqq G(F(x)).
    \end{equation*}

    The square brackets around \( G \bincirc F \) are not a special notation but rather another pair of delimiters that looks different from parentheses for the sake of reducing visual clutter.

    This definition is consistent with \fullref{def:binary_relation/composition}.

    \thmitem{def:multi_valued_function/empty} A function \( F: A \multto B \) is \term{empty} if \( F = \varnothing \). This is consistent with \fullref{def:binary_relation/empty}.
  \end{thmenum}

  The following terminology is inconsistent with relations:
  \begin{thmenum}[resume=def:multi_valued_function]
    \thmitem{def:multi_valued_function/total} The term \term{total multi-valued function} means that \( \dom(F) = A \), that is, that \( F(x) \neq \varnothing \) for all \( x \in A \). This is very different from total binary relations as defined in \fullref{def:binary_relation/total}.

    \thmitem{def:multi_valued_function/symmetric} A function \( f: A \times A \to B \) is called \term{symmetric} if, for all \( x, y \in A \), we have \( f(x, y) = f(y, x) \).

    Symmetric functions should not be confused with symmetric relations as defined in \fullref{def:derived_relations/symmetric}.

    \thmitem{def:multi_valued_function/diagonal}\mcite[exer. 3.1.1]{Leinster2016Basic} The function corresponding to the diagonal relation \( \increment A \) as defined in \fullref{def:binary_relation/diagonal} is called the \term{identity function} on \( A \) and denoted by \( \id_A \). The \term{diagonal function} is instead defined as \( f: A \to A^2 \) is defined as \( f(x) \coloneqq (x, x) \). This is mostly used in category theory.
  \end{thmenum}

  We define some additional terminology:
  \begin{thmenum}[resume=def:multi_valued_function]
    \thmitem{def:multi_valued_function/endofunction} Functions from a set to itself (e.g. \( F: A \multto A \)) are called \term{endofunctions}.

    \thmitem{def:multi_valued_function/involution} If \( F = F^{-1} \), we say that \( F \) is an \term{involution}. See \fullref{def:set_with_involution}.

    \thmitem{def:multi_valued_function/large_preimage} For a fixed set \( B' \subseteq B \), its \term{large preimage} or simply \term{preimage} under \( F: A \to B \) is the image of \( B' \) under the inverse function \( F^{-1}: B \multto A \). For a single value \( y \in B \), we call \( F^{-1}(y) \) the \term{fiber} of \( y \) under \( F \).

    \thmitem{def:multi_valued_function/small_preimage} Analogously, we define its \term{small preimage} as
    \begin{equation*}
      F_{-1}(B') \coloneqq \set{ x \in A \colon F(x) \subseteq B' }.
    \end{equation*}

    Obviously \( F_{-1}(B') \subseteq F^{-1}(B') \).
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:multivalued_function_properties}
  \hyperref[def:multi_valued_function]{Multi-valued functions} have the following basic properties:

  \begin{thmenum}
    \thmitem{thm:multivalued_function_properties/associative} \hyperref[def:multi_valued_function/composition]{Composition} is associative. That is, for any three functions \( F: A \to B \), \( G: B \to C \) and \( H: C \to D \) we have
    \begin{equation*}
      H \bincirc [G \bincirc F] = [H \bincirc G] \bincirc F.
    \end{equation*}

    We will henceforth simply write \( H \bincirc G \bincirc F \).

    \thmitem{thm:multivalued_function_properties/composition_inverse} If \( F: A \to B \) and \( G: B \to C \) are \hyperref[def:multi_valued_function]{multi-valued functions}, then
    \begin{equation*}
      [G \bincirc F]^{-1} = F^{-1} \bincirc G^{-1}.
    \end{equation*}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:multivalued_function_properties/associative} Let \( a \in A \). Then in order for \( d \in D \) to belong to \( [[H \bincirc G] \bincirc F](a) \), there must exist values \( b \in B \) and \( c \in C \) such that \( b \in F(a) \) and \( c \in G(b) \) and \( d \in H(c) \). Clearly this is also the condition for \( d \) to belong to \( [H \bincirc [G \bincirc F]](a) \).

  \SubProofOf{thm:multivalued_function_properties/composition_inverse} Since \( G \bincirc F \) has signature \( A \to C \), clearly \( [G \bincirc F]^{-1} \) has signature \( C \to A \). Let \( c \in C \).

  \begin{itemize}
    \item If \( [G \bincirc F]^{-1}(c) \) is empty, \( c \not\in \img(G \bincirc F) \), hence either \( G^{-1}(c) \) is empty or is nonempty but disjoint from \( \img(F) \). Hence \( [F^{-1} \bincirc G^{-1}](c) \) is also empty.

    \item Suppose that \( [G \bincirc F]^{-1}(c) \) is not empty and let \( a \in [G \bincirc F]^{-1}(c) \).

    By definition, there exists \( b \in B \) and such that \( b \in F(a) \) and \( c \in G(b) \). Hence \( b \in G^{-1}(c) \) and \( a \in F^{-1}(b) \), which implies that the image of \( c \) under the composition \( F^{-1} \bincirc G^{-1} \) also contains \( a \).
  \end{itemize}

  In both cases, for every \( c \in C \) we have
  \begin{equation*}
    [G \bincirc F]^{-1}(c) = [F^{-1} \bincirc G^{-1}](c).
  \end{equation*}

  Hence the two multi-valued functions are equal.
\end{proof}

\begin{definition}\label{def:function}
  Although \hyperref[def:multi_valued_function]{multi-valued functions} are very general, they are not nearly as useful nor are not studied nearly as extensively as single-valued functions.

  The \hyperref[def:multi_valued_function]{multi-valued function} \( F: A \multto B \) is called a \term{single-valued function} if \( F(x) \) is a \hyperref[rem:singleton_sets]{singleton set} for each \( x \in A \). In this case, we write \( F: A \to B \) rather than \( F: A \multto B \).

  All terminology from \fullref{def:multi_valued_function} holds for single-valued functions.

  By convention, when both single-valued and multi-valued functions are involved, the former are denoted using lowercase letters and the latter using uppercase letters.

  Strictly speaking, the value \( f(x) \) of a single-valued function \( f: A \to B \) is a singleton set. It is common practice (e.g. in \cite[def. 3.1]{OpenLogicFull} and \cite[10]{Kelley1955}) to define the value of a single-valued function to be an element of \( B \) rather than a subset of \( B \). Unless this would be confusing, we identify \( f(x) \) with its only element due to the convention established in \fullref{rem:singleton_sets}.

  More precisely, single-valued functions satisfy the following \hyperref[rem:predicate_formula]{predicate formula}, which states that the free variable \( \chi \) is a function from \( \alpha \) to \( \beta \):
  \begin{equation*}\taglabel[\op{IsFun}]{eq:def:function/predicate}
    \ref{eq:def:function/predicate}[\chi, \alpha, \beta] \coloneqq \qforall {\xi \in \alpha} \qExists {\eta \in \beta} \underbrace{ \qexists {\zeta \in \chi} \ref{eq:def:binary_cartesian_product/pair_predicate}[\zeta, \xi, \eta] }_{\chi(\xi) = \eta}.
  \end{equation*}

  Unless otherwise noted, we will now conflate the terms \enquote{function} and \enquote{single-valued function}.

  \begin{thmenum}
    \thmitem{def:function/selection}\mcite[52]{DontchevRockafellar2014} If \( f: A \to B \) is a single-valued function, \( F: A \multto B \) is a multi-valued function and \( \gph(f) \subseteq \gph(F) \), we say that \( f \) is a \term{selection} of \( F \).

    \thmitem{def:function/set_of_functions} We denote the set of all single-valued functions from \( A \) to \( B \) by \( \fun(A, B) \). We may also use either \( \cat{Set}(A, B) \) (which is consistent with \hyperref[def:category_of_sets]{morphisms in the category of sets}) or by \( B^A \) (which is consistent with \hyperref[def:cardinal_arithmetic]{cardinal arithmetic}). We abbreviate \( \fun(A, A) \) as \( \fun(A) \)
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:function_properties}
  \hyperref[def:function]{Single-valued functions} have the following properties when regarded as \hyperref[def:multi_valued_function]{multi-valued functions}:
  \begin{thmenum}
    \thmitem{thm:function_properties/total} Single-valued functions are \hyperref[def:multi_valued_function/total]{total} as multi-valued functions. As a consequence, a multi-valued function cannot have a selection unless it is \hyperref[def:multi_valued_function/total]{total}.

    This explains why there is no established terminology for the set \( A \) analogous to \enquote{range} for \( B \) --- we rarely need to differentiate between \( A \) and \( \dom(f) \).

    \thmitem{thm:function_properties/composition} The \hyperref[def:multi_valued_function/composition]{composition} of single-valued functions is a single-valued function.

    \thmitem{thm:function_properties/preimage} The \hyperref[def:multi_valued_function/large_preimage]{large preimages} and \hyperref[def:multi_valued_function/small_preimage]{small preimages} of single-valued functions are identical. We restrict ourselves to large preimages with the notation \( f^{-1}(x) \) and refer to them simply as preimages.

    Note that preimages are multi-valued in general.
  \end{thmenum}
\end{proposition}

\begin{definition}\label{def:partial_function}
  A \hyperref[def:multi_valued_function]{Multi-valued function} that is otherwise single-valued but not necessarily \hyperref[def:multi_valued_function/total]{total} is called a \term{partial function}. That is, \( f: A \to B \) is a partial function if \( f(x) \) has at most one element for every \( x \in A \).
\end{definition}

\begin{definition}\label{def:function_invertibility}
  We introduce the following terminology for invertibility of a (single-valued) function \( f: A \to B \):
  \begin{thmenum}
    \begin{minipage}[t]{0.43\textwidth}
      \thmitem{def:function_invertibility/injective} We say that \( f \) is \term{injective} or \term{one-to-one} if any of the following equivalent conditions hold:
      \begin{thmenum}
        \thmitem{def:function_invertibility/injective/existence} For any \( y \in B \) there exists at \hi{most} one \( x \in A \) such that \( f(x) = y \).

        That is, each point in \( B \) is the image of at most one point in \( A \).
        \newline

        \thmitem{def:function_invertibility/injective/equality} For all \( x_1, x_2 \in A \), the equality \( f(x_1) = f(x_2) \) implies \( x_1 = x_2 \).

        The contrapositive of this statement is that different points in \( A \) have different images under \( f \).

        \thmitem{def:function_invertibility/injective/inverse} The inverse is a partial single-valued function.
      \end{thmenum}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.44\textwidth}
      \thmitem{def:function_invertibility/surjective} \( f \) is called \term{surjective} or \term{onto} if any of the following equivalent conditions hold:
      \newline
      \begin{thmenum}[leftmargin=0.9cm]
        \thmitem{def:function_invertibility/surjective/existence} For any \( y \in B \) there exists at \hi{least} one \( x \in A \) such that \( f(x) = y \).

        That is, each point in \( B \) is the image of at least one point in \( A \). Hence the image of \( f \) is the entire range \( B \).

        \thmitem{def:function_invertibility/surjective/equality} For all \( y_1, y_2 \in B \), the equality \( f^{-1}(y_1) = f^{-1}(y_2) \) implies \( y_1 = y_2 \).

        Without surjectivity, the above holds only for the points in the image of \( f \).

        \thmitem{def:function_invertibility/surjective/inverse} The inverse is a total multi-valued function.
      \end{thmenum}
    \end{minipage}

    \thmitem{def:function_invertibility/bijective} Finally, \( f \) is called \term{bijective} if any of the following equivalent conditions hold:
    \begin{thmenum}
      \thmitem{def:function_invertibility/bijective/direct} It is both injective and surjective.
      \thmitem{def:function_invertibility/bijective/existence} For any \( y \in B \) there exists exactly one \( x \in A \) such that \( f(x) = y \).
      \thmitem{def:function_invertibility/bijective/inverse} The inverse is a total single-valued function.
    \end{thmenum}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:function_composition_invertibility}
  The composition of injective (resp. surjective, bijective) functions is injective (resp. surjective, bijective).
\end{proposition}
\begin{proof}
  Let \( f: A \to B \) and \( g: B \to C \) be arbitrary functions and define \( h \coloneqq g \circ f: A \to C \).

  \SubProofOf[def:function_invertibility/injective/equality]{injectivity} Suppose that \( f \) and \( g \) are injective. We will use \fullref{def:function_invertibility/injective/equality}.

  Let \( x_1, x_2 \in A \) and suppose that \( h(x_1) = h(x_2) \), that is, \( g(f(x_1)) = g(f(x_2)) \). Then \( f(x_1) = f(x_2) \) since \( g \) is injective and \( x_1 = x_2 \) since \( f \) is injective.

  Since \( x_1 \) and \( x_2 \) were arbitrary, we conclude that \( h \) is also injective.

  \SubProofOf[def:function_invertibility/surjective/existence]{surjectivity} Suppose that \( f \) and \( g \) are surjective. We will use \fullref{def:function_invertibility/injective/existence}.

  Let \( z \in C \). Then there exists some \( y \in B \) such that \( g(y) = z \) because \( g \) is surjective and similarly there exists some \( x \in B \) such that \( f(x) = y \) because \( f \) is surjective. Thus \( h(x) = g(f(x)) = z \).

  Since \( z \) was arbitrary, we conclude that \( h \) is also surjective.

  \SubProofOf[def:function_invertibility/bijective/direct]{bijectivity} We have shown that if \( f \) and \( g \) are both injective or surjective, then so is \( h \). Hence if \( f \) and \( g \) are bijective, so is \( h \).
\end{proof}

\begin{definition}\label{def:indexed_family}
  We generalize both the notion of an amorphous \hyperref[rem:family_of_sets]{family of sets} and of the yet undefined \hyperref[def:sequence]{sequences}.

  Choose a set \( \mscrK \), called the \term{index set}. An \term{indexed family} is simply a function from \( \mscrK \) into some family of sets \( \mscrA \)

  This function maps every element \( k \) of \( \mscrK \) into a set \( A_k \in \mscrA \). For convenience, this family is denoted as
  \begin{equation*}
    \seq{ A_k }_{k \in \mscrK}
  \end{equation*}
  without any reference to the underlying function.

  See \fullref{rem:indexed_family_notation} for a discussion of this notation.

  For convenience we will write \( \seq{ A_k }_{k \in \mscrK} \subseteq \mscrA \) despite the indexed family actually being encoded as a very different set.

  Indexed families allow us to write \( \bigcup_{k \in \mscrK} A_k \) rather than \( \bigcup \mscrA \), for example (we assume here that the underlying function is \hyperref[def:function_invertibility/surjective]{surjective}).

  A more general framework than indexed families that also considers relations between the family's elements is given by diagrams in category theory defined in \fullref{def:categorical_diagram}.
\end{definition}

\begin{example}\label{ex:def:indexed_family}
  The following are commonly encountered \hyperref[def:indexed_family]{indexed families}:

  \begin{itemize}
    \item Every n-tuple \( (x_1, \ldots, x_n) \) is an indexed family with domain \( \mscrK = \set{ 1, \ldots, n } \). Here the ordering of \( \mscrK \) plays an important role.

    \item An important corner case is when \( \mscrK \) is the empty set. Since the only possible indexing function is then the empty function, we simply say that the resulting family is empty.

    \item In continuous stochastic processes, it is convenient to consider families of random variables \( \seq{ X_t }_{t \geq 0} \) indexed by the nonnegative real numbers \( \mscrK = \BbbR_{\geq 0} \). The indexing parameter is often denoted by \( t \geq 0 \) and interpreted as time.

    \item An \( n \times m \) \hyperref[def:array/matrix]{matrix} \( A = \set{ a_{i,j} } \) is a family of scalars indexed by the unordered set \( \mscrK = \set{ 1, \ldots, n } \times \set{ 1, \ldots, m } \). More general \hyperref[def:array]{arrays} are also indexed families.

    \item \hyperref[def:topological_net]{Topological nets} are indexed families where the domain is a \hyperref[def:directed_set]{directed set}.
  \end{itemize}
\end{example}

\begin{remark}\label{rem:indexed_family_notation}
  Since we denote \hyperref[def:binary_cartesian_product]{tuples} by \( (A, B) \), it seems conventional to denote \hyperref[def:indexed_family]{indexed families} by
  \begin{equation*}
    ( A_k )_{k \in \mscrK}
  \end{equation*}
  rather than
  \begin{equation*}
    \seq{ A_k }_{k \in \mscrK}.
  \end{equation*}

  This is actually done when we want to enumerate elements of a sequence, e.g. see \fullref{def:polynomial}.

  In general, however, we prefer the latter notation because
  \begin{equation*}
    \set[\Big]{ \log \parens[\Big]{ f^{(n)}(x_k) } }_{k=1}^\infty.
  \end{equation*}
  is both more conventional (in analysis) and more aesthetically pleasing than
  \begin{equation*}
    \parens[\Big]{ \log \parens[\Big]{ f^{(n)}(x_k) } }_{k=1}^\infty.
  \end{equation*}

  The difference may be more noticeable in simpler cases like
  \begin{balign*}
    (\sin(k))_{k \in \mscrK}
     &  &
    \{\sin(k)\}_{k \in \mscrK}.
  \end{balign*}
\end{remark}

\begin{remark}\label{rem:multi_valued_functions}
  We can represent a \hyperref[def:multi_valued_function]{multi-valued functions} \( F: A \multto B \) as the \hyperref[def:indexed_family]{indexed family} \( \set{ F(a) }_{a \in A} \). This indexed family is itself a \hyperref[def:function]{single-valued function} \( G \) from \( A \) to \( \pow(B) \). This is an alternative to our approach to define \hyperref[def:multi_valued_function]{multi-valued functions} as a basic notion. This latter approach is used, for example, in \cite[def. 2.3]{Phelps1993}. The pair \( (x, y) \in A \times B \) belongs to the relation \( F \) if and only if there exists a subset \( B' \subseteq B \) such that \( y \in B' \) and the pair \( (x, B') \) belongs to the relation \( G \).

  The downside of the latter approach is that notions such as the \hyperref[def:multi_valued_function/image]{image}, \hyperref[def:multi_valued_function/range]{range} and \hyperref[def:multi_valued_function/inverse] of the multi-valued function have a very different and much less useful meaning and notions such as \hyperref[def:multi_valued_function/endofunction]{endofunctions} cannot be defined.
\end{remark}

\begin{definition}\label{def:disjoint_union}
  The \term{disjoint union} of the \hyperref[def:indexed_family]{indexed family} \( \seq{ A_k }_{k \in \mscrK} \) of nonempty sets is
  \begin{equation*}
    \bigsqcup_{k \in \mscrK} A_k \coloneqq \set[\Big]{ (k, x) \given k \in \mscrK \T{and} x \in A_k }.
  \end{equation*}
\end{definition}

\begin{proposition}\label{thm:function_image_properties}
  \hyperref[def:multi_valued_function/set_value]{Images of sets} under \( f: A \to B \) have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:function_image_properties/monotonicity} If \( A_1 \subseteq A_2 \), then \( f(A_1) \subseteq f(A_2) \).

    \thmitem{thm:function_image_properties/union} For any \hyperref[def:indexed_family]{indexed family} \( \seq{ A_k }_{k \in \mscrK} \subseteq A \) of subsets of \( A \) we have the equality
    \begin{equation}\label{eq:thm:function_image_properties/union}
      f\parens*{ \bigcup_{k \in \mscrK} A_k } = \bigcup_{k \in \mscrK} f(A_k).
    \end{equation}

    \thmitem{thm:function_image_properties/intersection} For any indexed family \( \seq{ A_k }_{k \in \mscrK} \) of subsets of \( A \) we have the inclusion
    \begin{equation}\label{eq:thm:function_image_properties/intersection}
      f\parens*{ \bigcap_{k \in \mscrK} A_k } \subseteq \bigcap_{k \in \mscrK} f(A_k).
    \end{equation}

    Equality in \eqref{eq:thm:function_image_properties/intersection} holds if \( f \) is \hyperref[def:function_invertibility/injective]{injective}. If \( f \) is not injective, for example if both \( A \) and \( B \) are nonempty, \( A_1 \) and \( A_2 \) are disjoint subsets of \( A \) and \( f(A_1) = f(A_2) = B \), then
    \begin{equation*}
      f(A_1 \cap A_2) = f(\varnothing) = \varnothing \subsetneq f(A_1) \cap f(A_2) = B.
    \end{equation*}

    \thmitem{thm:function_image_properties/difference} For any two subsets \( A_1 \) and \( A_2 \) of \( A \) we have the inclusion
    \begin{equation}\label{eq:thm:function_image_properties/difference}
      f(A_1) \setminus f(A_2) \subseteq f(A_1 \setminus A_2).
    \end{equation}

    Equality in \eqref{eq:thm:function_image_properties/difference} holds if \( f \) is injective. If \( f \) is not injective, for example if \( A_1 \subsetneq A_2 \) but \( f(A_1) = f(A_2) \), then
    \begin{equation*}
      f(A_1) \setminus f(A_2) = \varnothing \subsetneq f(A_1 \setminus A_2).
    \end{equation*}
  \end{thmenum}

  Compare this result to the more well-behaved properties of \hyperref[thm:function_properties/preimage]{preimages} described in \fullref{thm:function_preimage_properties}.
\end{proposition}
\begin{proof}
  \SubProofOf{thm:function_image_properties/monotonicity} If \( x \in A_1 \), then \( x \in A_2 \) and hence \( f(x) \in f(A_2) \). Therefore \( f(A_1) \subseteq f(A_2) \).

  \SubProofOf{thm:function_image_properties/union} If \( x_0 \in A_{k_0} \) for some \( k_0 \in \mscrK \), clearly
  \begin{equation*}
    f(x_0) \in f(A_{k_0}) \subseteq \bigcup_{k \in \mscrK} f(A_k).
  \end{equation*}

  Therefore
  \begin{equation*}
    f\parens*{ \bigcup_{k \in \mscrK} A_k } \subseteq \bigcup_{k \in \mscrK} f(A_k).
  \end{equation*}

  Conversely, if \( y_0 \in f(A_{k_0}) \) for some \( k_0 \in \mscrK \), by \fullref{thm:function_image_properties/monotonicity} obviously
  \begin{equation*}
    y_0 \in f\parens*{ \bigcup_{k \in \mscrK} A_k }.
  \end{equation*}

  Therefore
  \begin{equation*}
    f\parens*{ \bigcup_{k \in \mscrK} A_k } \supseteq \bigcup_{k \in \mscrK} f(A_k).
  \end{equation*}

  Hence \eqref{eq:thm:function_image_properties/union} holds.

  \SubProofOf{thm:function_image_properties/intersection} If \( x_0 \) belongs to \( \bigcap_{k \in \mscrK} A_k \), then \( x_0 \) belongs to \( A_k \) for all \( k \in \mscrK \). It follows that \( f(x_0) \) belongs to \( f(A_k) \) for all \( k \in \mscrK \) and hence to their intersection. Therefore the inclusion \eqref{eq:thm:function_image_properties/intersection} holds.

  Now suppose that \( f \) is injective. Let \( y_0 \) be a point in the intersection \( \bigcap_{k \in \mscrK} f(A_k) \). We thus have \( y_0 \in f(A_k) \) for all \( k \in \mscrK \). Since \( f \) is injective, for each \( k \in \mscrK \) there exists a unique \( x_k \in A_k \) such that \( f(x_k) = y_0 \). Again because of injectivity of \( f \), all these elements are equal because \( f(x_k) = f(x_m) = y_0 \) for \( k, m \in \mscrK \). Hence \( y_0 \in f(\bigcap_{k \in \mscrK} A_k) \).

  Therefore the reverse inclusion in \eqref{eq:thm:function_image_properties/intersection} holds if \( f \) is injective.

  \SubProofOf{thm:function_image_properties/difference} If \( f(A_1) \setminus f(A_2) \) is empty, \eqref{eq:thm:function_image_properties/difference} obviously holds. Suppose that it is nonempty and let \( y_0 \in f(A_1) \setminus f(A_2) \).

  Then there exists a point \( x_0 \in A_1 \) such that \( f(x_0) = y_0 \). It cannot be that \( x_0 \in A_2 \) because otherwise \( y_0 = f(x_0) \in f(A_2) \), which would contradict our choice of \( y_0 \). Hence \( x_0 \in A_1 \setminus A_2 \) and \( y_0 \in f(A_1 \setminus A_2) \).

  Since \( y_0 \) was chosen arbitrarily, we conclude that the inclusion \eqref{eq:thm:function_image_properties/difference} holds.

  Conversely, suppose that \( f \) is injective. If \( f(A_1 \setminus A_2) \) is empty, by \eqref{eq:thm:function_image_properties/difference} the set \( f(A_1) \setminus f(A_2) \) is also empty and the converse holds.

  Now suppose that it is nonempty and let \( y_0 \in f(A_1 \setminus A_2) \). Then there exists a point \( x_0 \in A_1 \setminus A_2 \) such that \( f(x_0) = y_0 \). Furthermore, since \( f \) is injective, \( x_0 \) is the only preimage of \( y_0 \) and hence \( f(x_0) \in f(A_1) \setminus f(A_2) \), which proves the reverse inclusion in \eqref{eq:thm:function_image_properties/difference}.
\end{proof}

\begin{proposition}\label{thm:function_preimage_properties}
  Function \hyperref[thm:function_properties/preimage]{preimages} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:function_preimage_properties/monotonicity} If \( B_1 \subseteq B_2 \), then \( f^{-1}(B_1) \subseteq f^{-1}(B_2) \).

    \thmitem{thm:function_preimage_properties/union} For any \hyperref[def:indexed_family]{indexed family} \( \seq{ B_k }_{k \in \mscrK} \subseteq B \) of subsets of \( B \) we have the equality
    \begin{equation}\label{eq:thm:function_preimage_properties/union}
      f^{-1}\parens*{ \bigcup_{k \in \mscrK} B_k } = \bigcup_{k \in \mscrK} f^{-1}(B_k).
    \end{equation}

    \thmitem{thm:function_preimage_properties/intersection} For any indexed family \( \seq{ B_k }_{k \in \mscrK} \) of subsets of \( B \) we have the equality
    \begin{equation}\label{eq:thm:function_preimage_properties/intersection}
      f^{-1}\parens*{ \bigcap_{k \in \mscrK} B_k } = \bigcap_{k \in \mscrK} f^{-1}(B_k).
    \end{equation}

    \thmitem{thm:function_preimage_properties/difference} For any two subsets \( B_1 \) and \( B_2 \) of \( B \) we have the equality
    \begin{equation}\label{eq:thm:function_preimage_properties/difference}
      f^{-1}(B_1) \setminus f^{-1}(B_2) = f^{-1}(B_1 \setminus B_2).
    \end{equation}
  \end{thmenum}

  Compare this result to the less well-behaved properties of images described in \fullref{thm:function_image_properties}.
\end{proposition}
\begin{proof}
  \SubProofOf{thm:function_image_properties/monotonicity} Analogous to \fullref{thm:function_image_properties/monotonicity}.

  \SubProofOf{thm:function_image_properties/union} Analogous to \fullref{thm:function_image_properties/union}.

  \SubProofOf{thm:function_image_properties/intersection} If \( y_0 \) belongs to \( \bigcap_{k \in \mscrK} B_k \), then \( y_0 \) belongs to \( B_k \) for all \( k \in \mscrK \). It follows that \( f(y_0) \subseteq f^{-1}(B_k) \) for all \( k \in \mscrK \) and hence it is also a subset of their intersection. Therefore
  \begin{equation*}
    f^{-1} \parens*{ \bigcap_{k \in \mscrK} B_k } \subseteq \bigcap_{k \in \mscrK} f^{-1}(B_k).
  \end{equation*}

  Conversely, if \( x_0 \in \bigcap_{k \in \mscrK} f^{-1}(B_k) \), it belongs to \( f^{-1}(B_k) \) for all \( k \in \mscrK \). Clearly then \( f(x_0) \in B_k \) for all \( k \in \mscrK \) and thus \( f(x_0) \in \bigcap_{k \in \mscrK} B_k \). Hence by \fullref{thm:function_preimage_properties/monotonicity} we have
  \begin{equation*}
    f^{-1}(f(x_0))
    \subseteq
    f^{-1}\parens*{ \bigcap_{k \in \mscrK} B_k }.
  \end{equation*}

  Since \( x_0 \in f^{-1}(f(x_0)) \),
  \begin{equation*}
    x_0 \in f^{-1}\parens*{ \bigcap_{k \in \mscrK} B_k }.
  \end{equation*}

  Since \( x_0 \) was chosen arbitrarily from \( \bigcap_{k \in \mscrK} f^{-1}(B_k) \), we can conclude that
  \begin{equation*}
    \bigcap_{k \in \mscrK} f^{-1}(B_k) \in f^{-1}\parens*{ \bigcap_{k \in \mscrK} B_k }.
  \end{equation*}

  Hence \eqref{eq:thm:function_preimage_properties/intersection} holds.

  \SubProofOf{thm:function_preimage_properties/difference} If \( y_0 \in B_1 \setminus B_2 \), there exists a point \( x_1 \in B_1 \) such that \( f(x_1) = y_0 \). Aiming at a contradiction, suppose that there exists a point \( x_2 \in f^{-1}(B_2) \) such that \( f(x_2) = y_0 \). Then \( y_0 = f(x_1) = f(x_2) \) implies that \( f^{-1}(y_0) \subseteq f^{-1}(B_1) \cap f^{-1}(B_2) \). \Fullref{thm:function_preimage_properties/intersection} then in turn implies that \( f^{-1}(y_0) \subseteq f^{-1}(B_1 \cap B_2) \) and hence by \fullref{thm:function_image_properties/monotonicity}
  \begin{equation*}
    y_0 = f(f^{-1}(y_0)) \in f(f^{-1}(B_1 \cap B_2)) = B_1 \cap B_2,
  \end{equation*}
  which contradicts our choice of \( y_0 \). Since the choice of \( y_0 \in B_1 \setminus B_2 \), \( x_1 \in f^{-1}(y_0) \cap B_1 \) and \( x_2 \in f^{-1}(y_0) \cap B_2 \) was arbitrary, the obtained contradiction shows that
  \begin{equation*}
    f^{-1}(B_1 \setminus B_2) \subseteq f^{-1}(B_1) \setminus f^{-1}(B_2).
  \end{equation*}

  Conversely, we have
  \begin{equation*}
    f(f^{-1}(B_1) \setminus f^{-1}(B_2))
    \reloset {\eqref{eq:thm:function_image_properties/difference}} \subseteq
    f(f^{-1}(B_1 \setminus B_2))
    \reloset {\ref{thm:function_image_preimage_composition/image_of_preimage}} \subseteq
    B_1 \setminus B_2.
  \end{equation*}

  Hence
  \begin{equation*}
    f^{-1}(B_1) \setminus f^{-1}(B_2)
    \reloset {\ref{thm:function_image_preimage_composition/preimage_of_image}} \subseteq
    f^{-1}\parens[\Big]{ f\parens[\Big]{ f^{-1}(B_1) \setminus f^{-1}(B_2) } }
    \reloset {\eqref{thm:function_preimage_properties/monotonicity}} \subseteq
    f^{-1}(B_1 \setminus B_2).
  \end{equation*}
\end{proof}

\begin{definition}\label{def:equivalence_relation}
  A binary relation on \( A \) that is \hyperref[def:binary_relation/reflexive]{reflexive}, \hyperref[def:binary_relation/symmetric]{symmetric} and \hyperref[def:binary_relation/transitive]{transitive} is called an \term{equivalence relation}. In other words, an equivalence relation is a symmetric \hyperref[def:preordered_set]{preorder}.

  We usually denote equivalence relations by the congruence symbol \( \cong \).

  \begin{thmenum}
    \thmitem{def:equivalence_relation/coset} The \term{equivalence class} of \( x \in A \), also called its \term{coset}, is the set
    \begin{equation*}
      [x] \coloneqq \set{ y \in A \given x \cong y }
    \end{equation*}
    of all elements of \( A \) that are related to \( x \).

    \thmitem{def:equivalence_relation/quotient} The \term{quotient set} of \( A \) by \( \cong \) is the set
    \begin{equation*}
      A / {\cong} \ \coloneqq \set{ [x] \given x \in A }.
    \end{equation*}

     If we have an easy way to choose a representative from each coset, then \( A / {\cong} \) may be regarded as a subset of \( A \). In general, this is not a subset relation by only an \hyperref[def:first_order_homomorphism_invertibility/embedding]{embedding}.

    \thmitem{def:equivalence_relation/projection} The \term{canonical projection} is
    \begin{equation*}
      \begin{aligned}
        &\pi: A \to A / {\cong}  \\
        &\pi(x) \coloneqq [x].
      \end{aligned}
    \end{equation*}

    If we have a fixed \hyperref[def:choice_function]{choice function} \( c: A / {\cong} \to A \), we also define the \term{canonical embedding}
    \begin{equation*}
      \begin{aligned}
        &\iota: A / {\cong} \to A \\
        &\iota([x]) \coloneqq c(x).
      \end{aligned}
    \end{equation*}

    We sometimes have an obvious choice function, for example in \fullref{thm:polynomial_quotient_rings_equinumerous_with_module_of_polynomials}. In this case, the canonical projection may be regarded as a function from \( A \) to the subset \( c(A / {\cong}) \) of \( A \). Otherwise, the function \( \pi \) can be regarded as a \hyperref[def:multi_valued_function]{multi-valued function} from \( A \) to \( A \).
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:equality_is_smallest_equivalence_relation}
  The equality \hyperref[def:binary_relation]{relation} \( = \) is the intersection of all equivalence relations.
\end{proposition}
\begin{proof}
  It is equivalent to the \hyperref[def:binary_relation/diagonal]{diagonal relation} \( \Delta_X \). By \fullref{thm:derived_relations_characterization}, it is the smallest reflexive (resp. symmetric and transitive) relation on \( A \), i.e. the intersection of all reflexive (resp. symmetric and transitive) relations.
\end{proof}

\begin{definition}\label{def:set_partition}
  Let \( A \) be a set. A \term{cover} of \( A \) is a \hyperref[rem:family_of_sets]{family} \( \mscrA \subseteq \pow(A) \) of nonempty subsets of \( A \) such that \( A = \bigcup \mscrA \). We sometimes use the term more loosely and say that an arbitrary family of sets \( \mscrA \) is a cover of \( A \) if \( A \subseteq \bigcup \mscrA \). The two definitions are identical if we intersect each set in \( \mscrA \) with \( A \) and exclude the empty sets.

  A \term{partition} of \( A \) is a pairwise \hyperref[def:subset]{disjoint} cover. In other words, the cover \( \mscrA \) is a partition if and only if each element of \( A \) belong to exactly one set in \( \mscrA \).
\end{definition}

\begin{proposition}\label{thm:equivalence_partition}
  Fix a set \( A \). Let \( {\sim} \) be a binary relation of \( A \). The following are equivalent:
  \begin{thmenum}
    \thmitem{thm:equivalence_partition/equivalence} \( {\sim} \) is an \hyperref[def:equivalence_relation]{equivalence relation}.

    \thmitem{thm:equivalence_partition/partition} There exists a \hyperref[def:set_partition]{partition} \( \mscrA \) of \( A \) such that \( x \sim y \) if and only if they belong to the same set in the partition \( \mscrA \).

    \thmitem{thm:equivalence_partition/function} There exists a set \( B \) and a \hyperref[def:function]{function} \( f: A \to B \) such that \( f(x) = f(y) \) if and only if \( x \sim y \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \ImplicationSubProof{thm:equivalence_partition/equivalence}{thm:equivalence_partition/partition} Let \( {\sim} \) be an equivalence relation on \( A \). The quotient set \( A / {\sim} \) is a partition. Indeed:
  \begin{itemize}
    \item Every element \( x \in A \) belongs exactly one equivalence class \( [x] \) by definition.

    \item The equivalence classes are disjoint. Indeed, assume the contrary. Then there exist \( x \) and \( y \) such that \( [x] \cap [y] \neq \varnothing \) and yet \( x \not\sim y \).

    Let \( z \in [x] \cap [y] \). Then \( z \sim x \) and \( z \sim y \), thus from transitivity of \( {\sim} \) we have \( x \sim z \sim y \) and hence \( x \sim y \), which contradicts our assumption that \( x \not\sim y \).

    Hence either \( [x] = [x] \) or \( [x] \cap [y] = \varnothing \). That is, different equivalence classes are disjoint.
  \end{itemize}

  \ImplicationSubProof{thm:equivalence_partition/partition}{thm:equivalence_partition/function} Let \( \mscrA \) be a partition of \( A \) such that \( x \sim y \) if and only if they both belong to the same set in \( \mscrA \).

  Given \( x \in A \), denote by \( A_x \) the set in \( \mscrA \) which contains \( x \). Define the function
  \begin{equation*}
    \begin{aligned}
      &f: A \to \mscrA \\
      &f(x) = A_x.
    \end{aligned}
  \end{equation*}

  This function is well defined since since \( \mscrA \) is a partition, which means that \( x \) belongs to exactly one set in \( \mscrA \).

  \ImplicationSubProof{thm:equivalence_partition/function}{thm:equivalence_partition/equivalence} Follows from the fact that \( = \) is an equivalence relation.
\end{proof}

\begin{remark}\label{rem:forward_references_to_natural_numbers_zfc}
  We list below several closely related definitions, however they depend on natural numbers which we have not yet defined. We refrain from actually using these concepts until we prove \fullref{thm:omega_is_model_of_pa}.
\end{remark}

\begin{definition}\label{def:sequence}
  A \term{sequence} is an \hyperref[def:indexed_family]{indexed family} whose domain \( \mscrK \) is the set of natural numbers \( \BbbN \). As explained in \fullref{rem:peano_arithmetic_zero}, outside of \logic{PA} we usually prefer to exclude zero, hence our sequences will actually be defined only on \( \BbbN \setminus \set{ 0 } \).

  We say that \( \seq{ A_{k_m} }_{k=1}^\infty \) is a \term{subsequence} of \( \seq{ A_k }_{k=1}^\infty \) if the sequence \( \seq{ k_m }_{k=1}^\infty \) of natural numbers is strictly monotone.

  Subsequences of \( \seq{ A_k }_{k=1}^\infty \) are usually denoted by adding another index as a subscript, i.e. \( \seq{ x_{k_m} }_{k=1}^\infty \).
\end{definition}

\begin{definition}\label{def:cartesian_product}
  As promised in \fullref{rem:binary_vs_arbitrary_tuples}, we will define the Cartesian products for an arbitrary indexed family of sets.

  Let \( \seq{ A_k }_{k \in \mscrK} \) be a nonempty \hyperref[def:indexed_family]{indexed family} of sets. Their \term{Cartesian product} is
  \begin{equation}\label{eq:def:cartesian_product}
    \bigtimes_{k \in \mscrK} A_k \coloneqq \set*{ f: \mscrK \to \bigcup_{k \in \mscrK} A_k \given* \qforall{m \in \mscrK} f(m) \in A_m }.
  \end{equation}

  The definition also makes sense when any of the sets is empty because the product itself is then empty.

  Any element of the Cartesian product is called a \term{tuple}.

  If \( \mscrK \) is the set \( \set{ 1, \ldots, n } \) for some natural number \( n \), we usually write the product using \hyperref[rem:first_order_formula_conventions/infix]{infix notation}, i.e. \( A_1 \times \cdots \times A_n \) and the tuples as \( (a_1, \ldots, a_n) \). Finite tuples are sometimes called \term{finite sequences}.

  If \( n = 2 \), the notion of a general Cartesian product coincides with the notion of a \hyperref[def:binary_cartesian_product]{binary Cartesian product}. Clearly the Kuratowski pair
  \begin{equation*}
    (A, B) = \set[\Big]{ \set{ A }, \set{ A, B } }
  \end{equation*}
  is different from the generalized tuple
  \begin{equation*}
    (A, B) = \set[\Bigg]{ \set[\Big]{ \set{ 1 }, \set{ 1, A } }, \set[\Big]{ \set{ 2 }, \set{ 2, B } } }.
  \end{equation*}

  They are bijective, however, and we conflate the two notions because it is conventional to do so. We just as well conflate the products \( A \times B \times C \) and \( (A \times B) \times C \) since the binary Cartesian product is \hyperref[def:magma/associative]{associative}.
\end{definition}

\begin{definition}\label{def:relation}
  We can now use arbitrary Cartesian products to define arbitrary relations. Let \( A_1, \ldots, A_n \) be a tuple of sets and let
  \begin{equation*}
    R \subseteq A_1 \times \cdots \times A_n
  \end{equation*}
  be a subset of their \hyperref[def:cartesian_product]{Cartesian product}.

  The pair \( (R,  (A_1, \ldots, A_n)) \) is called an \( n \)-ary \term{relation}. We say that the tuple \( (x_1, \ldots, x_n) \in A_1 \times \cdots \times A_n \) is related with respect to \( R \).

  Relations are the semantical counterpart to \hyperref[def:first_order_structure/interpretation/predicate]{first-order predicates} and are equivalent to Boolean-valued functions (see \fullref{rem:boolean_valued_functions_and_predicates}).

  We generalize only the following notions from \hyperref[def:binary_relation]{binary relations}:
  \begin{thmenum}[series=def:relation]
    \thmitem{def:relation/graph} The set \( R \) of tuples is called the \term{graph} of the relation.
    \thmitem{def:relation/signature} The \term{signature} of the relation is the tuple \( (A_1, \ldots, A_n) \).
  \end{thmenum}

  We also introduce some new concepts:
  \begin{thmenum}[resume=def:relation]
    \thmitem{def:relation/arity} For some small values of \( n \), \( n \)-ary relations have established names:
    \begin{itemize}
      \item \term{Nullary} if \( n = 0 \).
      \item \term{Unary} if \( n = 1 \).
      \item \term{Binary} if \( n = 2 \).
      \item \term{Ternary} if \( n = 3 \).
    \end{itemize}

    This is not to be confused with \hyperref[def:function_arity]{function arity} --- functions are always binary relations.

    \thmitem{def:relation/single_set} If all \( A_k \) are equal to the set \( A \), we say that \( R \subseteq A^k \) is a relation \hi{on \( A \)}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:function_arguments}
  As mentioned in \fullref{def:multi_valued_function/value}, given a function \( f: A \to B \), we sometimes use the notation \( f(x) \) where \( x \) is a free variable.

  If \( A = A_1 \times \cdots \times A_n \) is a \hyperref[def:binary_cartesian_product]{finite Cartesian product} of other sets, we instead use the notation \( f(x_1, \ldots, x_n) \) and regard \( x_1, \ldots, x_n \) as free variables that have no assigned value. The number of arguments is called the function \term{arity} (not to be confused with \hyperref[def:relation/arity]{relation arity}).

  These variables are called \term{arguments} or sometimes \term{parameters}, although the latter term is a bit overloaded. This notion is somewhat informal and depends on the context since \( A \) can usually be represented as a Cartesian product in different ways and with different arities. For example, if \( A = B \times C \), we can write both \( f(a) \) and \( f(b, c) \) and the function has a different number of parameters in each case. In practice the number of arguments is usually clear from the context. We sometimes use \( \overrightarrow{a} \) when we regard \( a \) as a tuple.

  For example, in \hyperref[def:first_order_semantics]{classical first-order semantics}, to each \( n \)-ary functional symbol there corresponds an \( n \)-ary function with the unambiguous signature \( X^n \to X \).

  When working over a vector space like \( \BbbR^2 \), on the other side, depending on the context we regard \hyperref[rem:functional]{functionals} as either unary or binary functions.

  We sometimes refer to \( f \) as a \term{dependent variable} since it depends on its arguments. In this later case, we call the arguments \term{independent variables}.
\end{definition}

\begin{definition}\label{def:superposition}
  Although the terms \enquote{composition} and \enquote{superposition} are used interchangeably (for example in \cite[\textnumero 25]{19681}), \enquote{superposition} often refers to a certain generalization of \hyperref[def:multi_valued_function]{composition}{function composition}.

  If we are given the functions \( f_k: A \multto B_k, k = 1, \ldots, n \) and \( g: B_1 \times \cdots \times B_n \multto C \), their \term{superposition} \( h: A \multto C \) is
  \begin{equation*}
    h(x) \coloneqq g(f_1(x), \ldots, f_n(x)).
  \end{equation*}
\end{definition}

\begin{definition}\label{def:currying}
  Given the \hyperref[def:multi_valued_function/arity]{two-argument} function \( f: A \times B \to C \), we can define another function \( g: A \to \fun(B, C) \) as
  \begin{equation*}
    g(x) \coloneqq (y \mapsto f(x, y)).
  \end{equation*}

  This process is called \term{currying} after Haskell Curry.

  Currying is useful if we have somehow fixed a value \( x_0 \in A \), in which case we can \enquote{get rid} of one argument by introducing some shortcut for the function \( g(x_0): B \to C \) for the sake of reducing notational clutter. See \fullref{def:differentiability/first_variation} for an example of how this can be used in the wild.
\end{definition}
