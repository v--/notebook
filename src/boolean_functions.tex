\subsection{Boolean functions}\label{subsec:boolean_functions}

\begin{remark}\label{rem:metalanguage_syntax_and_semantics}
  In the context of \hyperref[subsec:language_of_propositional_logic]{propositional logic} or \hyperref[subsec:language_of_first_order_logic]{first-order logic}, the word \term{syntax} refers to actual strings of characters, e.g. \hyperref[def:propositional_syntax]{propositional formulas}, and their manipulation, e.g. \hyperref[def:propositional_substitution]{substitution} or \hyperref[def:first_order_proofs/derivability]{derivability}.

  Somewhat dually, the word \term{semantics} refers to \hyperref[def:propositional_valuation/interpretation]{propositional interpretations} and \hyperref[def:first_order_semantics/satisfiability]{first-order logic models} and their properties like \hyperref[def:propositional_semantics/satisfiability]{satisfiability} and \hyperref[def:propositional_semantics/equivalence]{semantic equivalence}. For example, the semantics of \hyperref[def:propositional_syntax]{propositional formulas} is given by \hyperref[def:boolean_function]{Boolean functions}.

  When we are concerned with syntax, we are interested in making a distinction between the \term{object language} under study, and the \term{metalanguage} which we use to write statements about the object language. This distinction is sometimes emphasized by using different logical symbols in the two languages.

  When not talking about syntax, prose is often preferred to \hyperref[def:first_order_language/quantifiers]{quantifiers} and \hyperref[def:propositional_language/connectives]{connectives} so the latter can mostly be avoided. We use \( \implies \) rather than \( \to \) and \( \iff \) rather than \( \leftrightarrow \) in the metalanguage. For example, \fullref{ex:first_order_substitution} contains actual formulas in the object language and \fullref{thm:uniform_space_local_convergence} simply uses logical symbols in the metalanguage for brevity of exposition.

  We do, however, use \( \wedge \) both as a symbol in the \hyperref[def:propositional_language]{propositional alphabet} and as an operation in \hyperref[def:binary_lattice_operations/meet]{lattices}. We do not introduce disambiguation because the usage is clear from the context.

  We only introduce a special convention regarding truth values.
  \begin{enumerate}
    \item The \( \top \) and \( \bot \) symbols represent syntactic true and false values in the \hyperref[def:propositional_language/constants]{propositional constants}.
    \item The \( T \) and \( F \) symbols represent semantic true and false values in the context of \hyperref[def:boolean_function]{Boolean functions}.
  \end{enumerate}

  We still use \( \top \) and \( \bot \) in general \hyperref[def:lattice]{lattices}, however.
\end{remark}

\begin{definition}\label{def:boolean_function}
  Fix any set \( S \) and a two-element set \( \set{ T, F } \). We interpret \( T \) as a truthy value and \( F \) as a falsy value. See \fullref{rem:metalanguage_syntax_and_semantics}.

  A function \( f: S \to \set{ T, F } \) is called \term{Boolean-valued} and a function \( f: \set{ T, F }^n \to \set{ T, F } \) is called \term{Boolean}.

  Without further context, we can assume that \( \set{ T, F } \) the \hyperref[thm:galois_field_existence]{Galois field} \( \BbbF_2 \) or any of the other equivalent Boolean algebras of two elements (see \fullref{thm:binary_boolean_algebras_are_isomorphic}). Unless noted otherwise, we identify \( 0 \) with \( F \) and \( 1 \) with \( T \).
\end{definition}

\begin{proposition}\label{thm:boolean_functions_form_boolean_algebra}
  The set of all \hyperref[def:boolean_function]{Boolean-valued functions} over any set naturally have a \hyperref[def:boolean_algebra]{Boolean algebra} structure themselves.
\end{proposition}
\begin{proof}
  Follows from \fullref{thm:functions_into_boolean_algebra_form_boolean_algebra}.
\end{proof}

\begin{definition}\label{def:boolean_closure}
  Fix a set \( \mscrB \) of Boolean functions of arbitrary arities.

  The \term{closure} \( \cl{\mscrB} \) of \( \mscrB \) is defined inductively as follows:
  \begin{itemize}
    \item If \( f \in \mscrB \), then \( f \in \cl{\mscrB} \)
    \item If \( f_k(x_1, \ldots, x_n) \in \cl{\mscrB}, k = 1, \ldots, m \) and \( g(x_1, \ldots, x_m) \in \cl{\mscrB} \), then their \hyperref[def:function/superposition]{superposition}
    \begin{equation*}
      h(x_1, \ldots, x_n) \coloneqq g(f_1(x_1, \ldots, x_n), \ldots, f_m(x_1, \ldots, x_n))
    \end{equation*}
    is also in \( \cl{\mscrB} \).
  \end{itemize}

  We say that \( \mscrB \) is \term{closed} if \( \cl{\mscrB} = \mscrB \) and \term{complete} if \( \cl{\mscrB} \) is the set of all Boolean functions of arbitrary arity.
\end{definition}

\begin{definition}\label{def:zhegalkin_polynomial}
  A \term{Zhegalkin polynomial} is a \hyperref[def:polynomial]{polynomial} in the \hyperref[thm:galois_field_existence]{Galois field} \( \BbbF_2 \).

  Due to \fullref{thm:polynomial_embedding_behavior}, we may restrict ourselves to polynomials with no powers higher than \( 1 \). For example, for binary operations, we may restrict ourselves to the Zhegalkin polynomials
  \begin{equation}\label{eq:def:zhegalkin_polynomial/binary_polynomial}
    f(x, y) = axy \oplus bx \oplus cy \oplus d,
  \end{equation}
  where \( a, b, c, d \in \BbbF_2 \), since these are exactly the polynomials that correspond to unique binary Boolean functions.

  Using this conventions, we can avoid distinguishing between polynomials and polynomial functions (see \fullref{rem:polynomials_vs_polynomial_functions}).
\end{definition}

\begin{definition}\label{def:standard_boolean_operators}
  Unlike \hyperref[def:function/single_valued]{arbitrary functions}, \hyperref[def:boolean_function]{Boolean functions} only have a small finite number of possible values that can easily be enumerated. We define the following operators:

  \begin{equation*}
    \begin{tabular}{c | c || c c | c c c c c c}
      \( x \) & \( \overline{x} \)     & \( x \) & \( y \) & \( x \vee y \)             & \( x \oplus y \)    & \( x \wedge y \)    & \( x \to y \)      & \( x \leftrightarrow y \) \\
      \hline
              & not \( x \)      &         &         & \( x \) or \( y \)         & \( x \) xor \( y \) & \( x \) and \( y \) & \( x \) implies \( y \)    & \( x \) iff \( y \)       \\
      \hline
      \( F \) & \( T \)          & \( F \) & \( F \) & \( F \)                    & \( F \)             & \( F \)             & \( T \)                    & \( T \)                   \\
      \( T \) & \( F \)          & \( F \) & \( T \) & \( F \)                    & \( T \)             & \( F \)             & \( T \)                    & \( F \)                   \\
              &                  & \( T \) & \( F \) & \( F \)                    & \( T \)             & \( F \)             & \( F \)                    & \( F \)                   \\
              &                  & \( T \) & \( T \) & \( T \)                    & \( F \)             & \( T \)             & \( T \)                    & \( T \)                   \\
      \hline
              & \( x \oplus 1 \) &         &         & \( xy \oplus x \oplus y \) & \( x \oplus y \)    & \( xy \)            & \( xy \oplus x \oplus 1 \) & \( x \oplus y \oplus 1 \)
    \end{tabular}
  \end{equation*}

  Note that \( \vee \), \( \wedge \) and \( \overline{x} \) form the \hyperref[thm:f2_is_boolean_algebra]{Boolean algebra structure} on \( \BbbF_2 \) and that \( \oplus \) and \( \wedge \) form the \hyperref[def:field]{field structure} on \( \BbbF_2 \).
\end{definition}

\begin{proposition}\label{thm:boolean_function_equivalences}
  For arbitrary variables \( x \) and \( y \) from \( \BbbF_2 \), the following equivalences hold (with comments regarding the corresponding \hyperref[def:propositional_syntax/formula]{propositional formulas}):

  \begin{propenum}
    \ilabel{thm:boolean_equivalences/contrapositive} A \hyperref[def:material_implication]{material implication} is equivalent to its \hyperref[def:material_implication/contrapositive]{contrapositive}:
    \begin{equation}\label{eq:thm:boolean_equivalences/contrapositive}
      x \to y = \neg y \to \neg x.
    \end{equation}

    \ilabel{thm:boolean_equivalences/equivalence_via_implication} \hyperref[def:propositional_language/connectives/equivalence]{Equivalence} is a \hyperref[def:propositional_language/connectives/conjunction]{conjunction} of \hyperref[def:material_implication]{implications}:
    \begin{equation}\label{eq:thm:boolean_equivalences/equivalence_via_implication}
      x \leftrightarrow y = (x \to y) \wedge (y \to x).
    \end{equation}

    \ilabel{thm:boolean_equivalences/implication_cnf} \hyperref[def:propositional_language/connectives/implication]{Implication} is a \hyperref[def:propositional_language/connectives/disjunction]{disjunction} of \hyperref[def:conjunctive_disjunctive_normal_form/literal]{literals}:
    \begin{equation}\label{eq:thm:boolean_equivalences/equivalence_cnf}
      x \to y = \neg x \vee y.
    \end{equation}

    \ilabel{thm:boolean_equivalences/equivalence_dnf} \hyperref[def:propositional_language/connectives/equivalence]{Equivalence} is a \hyperref[def:propositional_language/connectives/disjunction]{disjunction} of \hyperref[def:propositional_language/connectives/conjunction]{conjunctions}:
    \begin{equation}\label{eq:thm:boolean_equivalences/equivalence_dnf}
      x \leftrightarrow y = (x \wedge y) \vee (\neg x \wedge \neg y).
    \end{equation}

    \ilabel{thm:boolean_equivalences/equivalence_member_complement} \hyperref[def:propositional_language/connectives/equivalence]{Equivalence} equals its termwise complement:
    \begin{equation}\label{eq:thm:boolean_equivalences/equivalence_member_complement}
      \overline{x} \leftrightarrow \overline{y} = x \leftrightarrow y.
    \end{equation}

    \ilabel{thm:boolean_equivalences/equivalence_complement} The complement of \hyperref[def:propositional_language/connectives/equivalence]{equivalence} is an equivalence with one of the terms complemented:
    \begin{equation}\label{eq:thm:boolean_equivalences/equivalence_complement}
      \overline{x \leftrightarrow y} = \neg x \leftrightarrow y = x \leftrightarrow \neg y.
    \end{equation}
  \end{propenum}
\end{proposition}
\begin{proof}
  The proofs follow directly from the table in \fullref{def:standard_boolean_operators}.
\end{proof}

\begin{definition}\label{def:boolean_functions_in_f2}
  Fix a \hyperref[def:boolean_function]{Boolean function} \( f(x_1, \ldots, x_n) \) in the \hyperref[thm:galois_field_existence]{Galois field} \( \BbbF_2 \),

  \begin{defenum}
    \ilabel{def:boolean_function_in_f2/dual} Its \term{dual function} is
    \begin{equation*}
      \overline{f}(x_1, \ldots, x_n) \coloneqq \overline{f(\overline{x_1}, \ldots, \overline{x_n})}.
    \end{equation*}

    \ilabel{def:boolean_functions_in_f2/self_dual} \( f \) is \term{self-dual} if it is its own \hyperref[def:boolean_function_in_f2/dual]{dual}.

    \ilabel{def:boolean_functions_in_f2/truth_preserving} \( f \) is \term{truth-preserving} if \( f(1, \ldots, 1) = 1 \).

    \ilabel{def:boolean_functions_in_f2/falsity_preserving} \( f \) is \term{falsity-preserving} if \( f(0, \ldots, 0) = 0 \).

    \ilabel{def:boolean_functions_in_f2/monotone} \( f \) is \term{monotone} if, for any two tuples of arguments \( x_1, \ldots, x_n \in \BbbF_2^n \) and \( y_1, \ldots, y_n \in \BbbF_2^n \), the inequalities \( x_k \leq y_k \) for all \( k = 1, \ldots, n \) imply that
    \begin{equation*}
      f(x_1, \ldots, x_n) \leq f(y_1, \ldots, y_n).
    \end{equation*}

    \ilabel{def:boolean_functions_in_f2/linear} \( f \) is \term{linear} if its \hyperref[def:zhegalkin_polynomial]{Zhegalkin polynomial} is linear, i.e. has only monomials of degree \( 0 \) or \( 1 \). In the case of binary Boolean functions, this means that the coefficient \( a \) in \eqref{eq:def:zhegalkin_polynomial/binary_polynomial} is zero.
  \end{defenum}
\end{definition}

\begin{remark}\label{rem:propositional_connectives_ambiguity}
  We use the same symbols \( \set{ \vee, \wedge, \to, \leftrightarrow } \) for the syntactic \hyperref[def:propositional_language/connectives]{propositional connectives} in \fullref{subsec:language_of_propositional_logic} and the set of \hyperref[def:standard_boolean_operators]{Boolean operators}. This does not cause confusion because it is clear from the context which one is meant. This ambiguity can be resolved by introducing distinct notations for the two, however the variety of topics in this document leaves no room for unconventional notation.
\end{remark}

\begin{theorem}[Post's completeness theorem]\label{thm:posts_completeness_theorem}\mcite{Pelletier1990}
  A set \( \mscrB \) is a \hyperref[def:boolean_closure]{complete set of Boolean functions} if and only if all of the following conditions are satisfied:
  \begin{propenum}
    \ilabel{thm:posts_completeness_theorem/truth_preserving} \( \mscrB \) contains a function that is not \hyperref[def:boolean_functions_in_f2/truth_preserving]{truth-preserving}.
    \ilabel{thm:posts_completeness_theorem/falsity_preserving} \( \mscrB \) contains a function that is not \hyperref[def:boolean_functions_in_f2/falsity_preserving]{falsity-preserving}.
    \ilabel{thm:posts_completeness_theorem/self_dual} \( \mscrB \) contains a function that is not \hyperref[def:boolean_functions_in_f2/self_dual]{self-dual}.
    \ilabel{thm:posts_completeness_theorem/monotone} \( \mscrB \) contains a function that is not \hyperref[def:boolean_functions_in_f2/monotone]{monotone}.
    \ilabel{thm:posts_completeness_theorem/linear} \( \mscrB \) contains a function that is not \hyperref[def:boolean_functions_in_f2/linear]{linear}.
  \end{propenum}
\end{theorem}

\begin{example}\label{ex:posts_completeness_theorem}
  We give examples of complete sets of Boolean functions in \( \BbbF_2 \).

  \begin{exenum}
    \ilabel{ex:posts_completeness_theorem/and_or} The archetypic example of a complete set of Boolean functions is the triple \( \vee, \wedge, \neg \) that forms the Boolean algebra structure on \( \BbbF_2 \).

    We verify that the conditions of \fullref{thm:posts_completeness_theorem} are satisfied:
    \begin{RefList}
      \iref{thm:posts_completeness_theorem/truth_preserving} \( \neg \) is not truth-preserving.
      \iref{thm:posts_completeness_theorem/falsity_preserving} \( \neg \) is not falsity-preserving.
      \iref{thm:posts_completeness_theorem/self_dual} Neither \( \vee \) and \( \wedge \) are self-dual. In fact, by \hyperref[thm:de_morgans_laws]{De Morgan's laws}, \( \wedge \) is the dual of \( \vee \) and vice versa.
      \iref{thm:posts_completeness_theorem/monotone} \( \neg \) is not monotone.
      \iref{thm:posts_completeness_theorem/linear} Neither \( \vee \) nor \( \wedge \) are linear.
    \end{RefList}

    Thus \( \set{ \wedge, \vee, \neg } \) is indeed a complete set of Boolean functions. Note that having both \( \vee \) and \( \wedge \) is redundant and we usually include both for symmetry. The sets \( \set{ \wedge, \neg } \) and \( \set{ \vee, \neg } \) are both complete.

    \ilabel{ex:posts_completeness_theorem/nand} We can go even further and have a single binary Boolean function generate all others. We will use the function
    \begin{equation}\label{eq:ex:posts_completeness_theorem/nand}
      x \uparrow y \coloneqq \neg(x \wedge y) = xy \oplus 1.
    \end{equation}

    This operation is called \term{Sheffer's stroke} or \term{nand} (\enquote{not and}).

    By fixing \( y = 1 \), we obtain \( x \uparrow 1 = \neg x \). Since \( \neg \) is self-dual, we also have \( \wedge = \neg(x \uparrow y) \). By reducing the case to \fullref{ex:posts_completeness_theorem/nand}, we conclude that the singleton set \( \set{ \uparrow } \) is a complete set of Boolean operations.

    \ilabel{ex:posts_completeness_theorem/implies_neg} Another commonly used complete family is \( \set{ \to, \neg } \).
    We verify that the conditions of \fullref{thm:posts_completeness_theorem} are satisfied:
    \begin{RefList}
      \iref{thm:posts_completeness_theorem/truth_preserving} \( \neg \) is not truth-preserving.
      \iref{thm:posts_completeness_theorem/falsity_preserving} \( \to \) is not falsity-preserving because \( F \to F = T \).
      \iref{thm:posts_completeness_theorem/self_dual} \( \to \) is not self-dual because \( \overline{\overline{x} \to \overline{y}} = y \to x \neq x \to y \).
      \iref{thm:posts_completeness_theorem/monotone} \( \to \) is not monotone because \( F \to T = F \).
      \iref{thm:posts_completeness_theorem/linear} \( \to \) is not linear.
    \end{RefList}

    \ilabel{ex:posts_completeness_theorem/implies_bot} Given the family \( \set{ \to, F } \), we can define
    \begin{equation}
      \neg x \coloneqq (x \to F),
    \end{equation}
    which shows that \( \set{ \to, F } \) is also a complete family.
  \end{exenum}
\end{example}
