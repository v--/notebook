\subsection{First-order satisfiability}\label{subsec:first_order_satisfiability}

\begin{definition}\label{def:first_order_substitution}
  As in \hyperref[subsec:propositional_logic]{propositional logic}, we sometimes want to perform substitution, however we have different types of syntactic objects (terms and formulas) which have different substitution rules. The notion of free and bound variables further complicates us --- see for example the problems outlined in \fullref{rem:first_order_substitution_renaming_justification}. In particular, this means that an analogous to \fullref{thm:propositional_substitution_equivalence} theorem cannot longer justify substitution as it is done in \fullref{alg:perfect_cnf} --- we can have weaker statements as in \fullref{thm:propositional_substitution_equivalence} that implicitly rely on variable renaming in order to hold. This implies that it is of no practical use to define substitution of a first-order subformula inside another formula as it is done in \fullref{def:propositional_substitution}. Instead, we concert ourselves with substituting variables --- propositional variables with first-order formulas and first-order variables with first-order terms. Furthermore, since this does not complicate us, we allow substituting arbitrary terms rather than only first-order variables.

  While substituting a propositional variable is the syntactic analog to applying \hyperref[def:boolean_function]{Boolean functions} to different variables or propositional constants, substituting a first-order variable can express applying \hyperref[def:function]{arbitrary functions} to different first-order variables or arbitrary constants. For example, in a suitable language, we can apply \( \log(x) \) to the constant \( e \) by substituting \( x \) with \( e \) to obtain the ground term \( \log(e) \).

  As in \fullref{def:propositional_substitution}, we define different kinds of (single) \term{substitution} in more generality that in e.g. \cite[def. 15.25]{OpenLogicFull}. Where applicable, \term{simultaneous substitution} is defined via the same trick as in \fullref{def:propositional_substitution}.

  \begin{thmenum}
    \thmitem{def:first_order_substitution/propositional} Let \( \varphi \) be a \hyperref[def:propositional_syntax/formula]{propositional formula} with variables \( \boldop{Var}(\varphi) = \set{ P_1, \ldots, P_n } \). For brevity, denote \( V \coloneqq \boldop{Var}(\varphi) \). Let \( \Theta = \set{ \theta_1, \ldots, \theta_n } \) be a set of \hyperref[def:first_order_syntax/formula]{first-order formulas}.

    It does not make sense to replace a single propositional variable by a single formula. Furthermore, a first-order formula \( \theta_k \) cannot possibly contain any of the propositional variables \( P_1, \ldots, P_n \). This allows us to introduce a simplification of the simultaneous substitution based on \eqref{eq:def:propositional_substitution/single} as
    \begin{equation}\label{eq:def:first_order_substitution/propositional}
      \varphi[V \mapsto \Theta] \coloneqq \begin{cases}
        \varphi,                                                    &\varphi \in \set{ \top, \bot } \\
        \theta_k,                                                   &\varphi = \theta_k \T{for some} k = 1, \ldots, n \\
        \neg \psi[V \mapsto \Theta],                                &\varphi = \neg \psi \\
        \psi_1[V \mapsto \Theta] \bincirc \psi_2[V \mapsto \Theta], &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma.
      \end{cases}
    \end{equation}

    As in \fullref{def:propositional_substitution}, it is not strictly necessary for any of the variables to belong to \( \boldop{Var}(\varphi) \).

    \thmitem{def:first_order_substitution/term_in_term} We define the substitution of the \hyperref[def:first_order_syntax/term]{first-order term} \( \kappa \) with \( \mu \) in the term \( \tau \) as
    \begin{equation}\label{eq:def:first_order_substitution/term_in_term}
      \tau[\kappa \mapsto \mu] \coloneqq \begin{cases}
        \mu,                                                               &\tau = \kappa, \\
        \tau,                                                              &\tau \neq \kappa \T{and} \tau \in \boldop{Var}, \\
        f(\tau_1[\kappa \mapsto \mu], \ldots, \tau_n[\kappa \mapsto \mu]), &\tau \neq \kappa \T{and} \tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    It is not strictly necessary for \( \kappa \) to be a \hyperref[def:first_order_syntax/subterm]{subterm} of \( \tau \).

    \thmitem{def:first_order_substitution/term_in_formula} This case is more complicated. We define the substitution of the term \( \kappa \) with the term \( \mu \) in the first-order formula \( \varphi \) as
    \begin{equation}\label{eq:def:first_order_substitution/term_in_formula}
      \varphi[\kappa \mapsto \mu] \coloneqq \begin{cases}
        \varphi,                                                           &\varphi \in \set{ \top, \bot }, \\
        p(\tau_1[\kappa \mapsto \mu], \ldots, \tau_n[\kappa \mapsto \mu]), &\varphi = p(\tau_1, \ldots, \tau_n), \\
        \tau_1[\kappa \mapsto \mu] \doteq \tau_2[\kappa \mapsto \mu],      &\varphi = \tau_1 \doteq \tau_2, \\
        \neg \psi[\kappa \mapsto \mu],                                     &\varphi = \neg \psi, \\
        \psi_1[\kappa \mapsto \mu] \bincirc \psi_2[\xi \mapsto \mu],       &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma, \\
        (\dagger),                                                         &\varphi = \quantifier{Q}{\xi} \psi, Q \in \set{ \forall, \exists },
      \end{cases}
    \end{equation}
    where
    \begin{empheq}[left=(\dagger) \coloneqq \empheqlbrace]{align}
      &\varphi,                                                                        && \xi \in \boldop{Var}(\kappa), \label{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial} \\
      &\quantifier{Q}{\xi} \parens[\Big]{\psi[\kappa \mapsto \mu]},                    && \xi \not\in \boldop{Var}(\kappa) \cup \boldop{Var}(\mu), \label{eq:def:first_order_substitution/term_in_formula/quantifiers/direct} \\
      &\quantifier{Q}{\eta} \parens[\Big]{\psi[\xi \mapsto \eta][\kappa \mapsto \mu]}, && \xi \not\in \boldop{Var}(\kappa) \T{and} \xi \in \boldop{Var}(\mu) \T{and} &\label{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming} \\
                                                                                      &&& \eta \not\in \boldop{Var}(\kappa) \cup \boldop{Var}(\mu) \cup \boldop{Var}(\psi). \nonumber
    \end{empheq}

    In \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}, we chose a new variable \( \eta \). We implicitly assume that there exist enough variables in the language, so that we can find \( \eta \) that satisfies the condition. In order to fully avoid nondeterminism in the choice of \( \eta \), we can pick a well-ordering on the set \( \boldop{Var} \) and always choose \( \eta \) to be the smallest variable not present in \( \varphi \). This rule is called \term{renaming of the bound variables} \( \xi \) to \( \eta \) and is done to mitigate capturing as described in \fullref{rem:first_order_substitution_renaming_justification/capturing}.

    We could avoid the rule for renaming (as it is done in \cite[def. 15.25]{OpenLogicFull}), however renaming both free and bound variables is natural and is often done in practice. For example, consider the \hyperref[def:peano_arithmetic]{Peano arithmetic} formula \enquote{there exists \( n \) such that \( nm \) is even}. Note that the bound variable \( n \) is renamed to \( k \) and the free variable \( m \) to \( n \) in the larger formula \enquote{for every \( n \) there exists \( k \) such that \( kn \) is even}.

    The rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial} may seem redundant, but when doing inductive proofs (e.g. the proof of \fullref{thm:renaming_assignment_compatibility}), we usually need to separately consider the cases where \( \xi \in \boldop{Var}(\kappa) \) and \( \xi \not\in \boldop{Var}(\kappa) \setminus \boldop{Var}(\mu) \) and the rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct} being trivial simplifies the proofs.

    See \fullref{rem:first_order_substitution_parentheses} regarding the additional parentheses in \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}.

    See \fullref{ex:first_order_substitution} for examples of applying the different quantifier rules.
  \end{thmenum}
\end{definition}

\begin{remark}\label{rem:first_order_substitution_renaming_justification}
  The renaming rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming} is designed to mitigate the following two problems (compared to \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}):

  \begin{thmenum}
    \thmitem{rem:first_order_substitution_renaming_justification/capturing} Renaming mitigates \enquote{capturing} free variables as in
    \begin{equation*}
      \parens[\Big]{ \qforall \eta p(\xi, \eta) }[\xi \mapsto \eta] = \qforall \eta p(\eta, \eta)
    \end{equation*}
    by instead producing, up to a choice of new variables, the formula
    \begin{equation*}
      \parens[\Big]{ \qforall \eta p(\xi, \eta) }[\xi \mapsto \eta] = \qforall \zeta p(\eta, \zeta).
    \end{equation*}

    \thmitem{rem:first_order_substitution_renaming_justification/colliding} Renaming mitigates \enquote{colliding} multiple bound variables as in
    \begin{equation*}
      \parens[\Big]{ \qforall \xi \qforall \eta p(\xi, \eta) }[\xi \mapsto \eta] = \qforall \xi \qforall \eta p(\eta, \eta)
    \end{equation*}
    by instead producing, up to a choice of new variables, the formula
    \begin{equation*}
      \parens[\Big]{ \qforall \xi \qforall \eta p(\xi, \eta) }[\xi \mapsto \eta] = \qforall \zeta \qforall \sigma p(\zeta, \sigma).
    \end{equation*}
  \end{thmenum}
\end{remark}

\begin{remark}\label{rem:first_order_substitution_parentheses}
  When performing \hyperref[def:propositional_substitution]{substitution}, it is sometimes convenient to add additional parentheses to avoid ambiguity. For example, while parentheses around quantifier expressions are not necessary by the syntax of first-order logic, adding such parentheses helps avoid the ambiguity in
  \begin{equation*}
    \qforall \xi p(\xi, \eta) [\eta \mapsto \zeta].
  \end{equation*}

  Instead, we either write
  \begin{equation*}
    \parens[\Big]{ \qforall \xi p(\xi, \eta) } [\eta \mapsto \zeta]
  \end{equation*}
  or
  \begin{equation*}
    \qforall \xi \parens[\Big]{ p(\xi, \eta)[\eta \mapsto \zeta] }.
  \end{equation*}

  This convention is only part of the metasyntax and the parentheses are not part of the syntax of the formulas themselves.
\end{remark}

\begin{example}\label{ex:first_order_substitution}
  The following term substitutions should justify the distinct cases in \eqref{eq:def:first_order_substitution/term_in_formula}:
  \begin{thmenum}
    \thmitem{ex:first_order_substitution/1} The trivial case without actual substitution:
    \begin{align*}
      &\phantom{{}={}}
      \parens[\Big]{\qforall \xi p(\xi, \eta)}[\xi \mapsto \eta]
      = \\ &=
      \parens[\Big]{\qforall \xi p(\xi, \eta)}[\xi \mapsto \eta]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}} = \\ &=
      \qforall \xi p(\xi, \eta).
    \end{align*}

    \Fullref{ex:first_order_substitution/5} demonstrates that this does not work for nested substitution.

    \thmitem{ex:first_order_substitution/2} A simple substitution without renaming:
    \begin{align*}
      &\phantom{{}={}}
      \parens[\Big]{\qforall \xi p(\xi, \eta)}[\eta \mapsto \zeta]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}} = \\ &=
      \qforall \xi \parens[\Big]{p(\xi, \eta)[\eta \mapsto \zeta]}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \qforall \xi p(\xi, \zeta).
    \end{align*}

    \thmitem{ex:first_order_substitution/3} A simple renaming without actual substitution:
    \begin{align*}
      &\phantom{{}={}}
      \parens[\Big]{\qforall \xi p(\xi, \eta)}[\eta \mapsto \xi]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \qforall \zeta \parens[\Big]{p(\xi, \eta)[\xi \mapsto \zeta][\eta \mapsto \xi]}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \qforall \zeta p(\zeta, \xi).
    \end{align*}

    \thmitem{ex:first_order_substitution/4} \Fullref{ex:first_order_substitution/3}, but with \( \mu \) in \eqref{eq:def:first_order_substitution/term_in_formula} containing \( \xi \) indirectly:
    \begin{align*}
      &\phantom{{}={}}
      \parens[\Big]{\qforall \xi p(\xi, \eta)}[\eta \mapsto f(\xi)]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \qforall \zeta \parens[\Big]{p(\xi, \eta)[\xi \mapsto \zeta][\eta \mapsto f(\xi)]}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \qforall \zeta p(\zeta, f(\xi)).
    \end{align*}

    \thmitem{ex:first_order_substitution/5} Only renaming with multiple quantifiers which shows the limitations of \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}:
    \begin{align*}
      &\phantom{{}={}}
      \parens[\Big]{\qforall \eta \qexists \xi p(\xi, \eta)}[\xi \mapsto \eta]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \qforall \zeta \parens*{ \parens[\Big]{ \qforall \xi p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta]}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \qforall \zeta \parens*{ \parens[\Big]{ \qforall \xi p(\xi, \zeta) }[\xi \mapsto \eta]}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}} = \\ &=
      \qforall \zeta \qforall \xi p(\xi, \zeta).
    \end{align*}

    \thmitem{ex:first_order_substitution/6} Both renaming and substitution with multiple quantifiers:
    \begin{align*}
      &\phantom{{}={}}
      \parens[\Big]{ \qforall \eta (p(\xi, \eta) \vee \qforall \xi p(\xi, \eta)) }[\xi \mapsto \eta]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \qforall \zeta \parens*{ \parens[\Big]{ p(\xi, \eta) \vee \qexists \xi p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta] }
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \qforall \zeta \parens*{ p(\eta, \zeta) \vee \parens[\Big]{ \qexists \xi p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta] }
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}} = \\ &=
      \qforall \zeta \parens*{ p(\eta, \zeta) \vee \parens[\Big]{ \qexists \xi p(\xi, \zeta) }[\xi \mapsto \eta] }
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}} = \\ &=
      \parens[\Big]{ \qforall \zeta p(\eta, \zeta) } \vee \parens[\Big]{ \qexists \xi p(\xi, \zeta) }.
    \end{align*}

    \thmitem{ex:first_order_substitution/7} Substitution of more general terms than variables with renaming of term's variables:
    \begin{align*}
      &\phantom{{}={}}
      \parens*{\qforall \xi p(\xi, \eta, f(\eta))}[f(\eta) \mapsto g(\eta, \xi)]
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \qforall \zeta \parens[\Big]{p(\xi, \eta, f(\eta))[\xi \mapsto \zeta][f(\eta) \mapsto g(\eta, \xi)]}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \qforall \zeta p(\zeta, \eta, g(\eta, \xi)).
    \end{align*}
  \end{thmenum}
\end{example}

\begin{proposition}\label{thm:renaming_assignment_compatibility}
  We will show how \hyperref[rem:first_order_substitution_renaming_justification]{syntactic renaming} is compatible with a certain \enquote{semantic renaming}.

  Fix a \hyperref[def:first_order_syntax]{first-order language} \( \mscrL \), a \hyperref[def:first_order_structure]{structure} \( \mscrX = (X, I) \) on \( \mscrL \) and a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) in \( \mscrX \).

  \begin{thmenum}
    \thmitem{thm:renaming_assignment_compatibility/terms} For any term \( \tau \) and any two variables \( \xi \) and \( \eta \), we have
    \begin{equation}\label{eq:thm:renaming_assignment_compatibility/terms}
      \tau\Bracks{v_{\xi \mapsto \eta}}
      =
      \parens[\Big]{ \tau[\xi \mapsto \eta] }\Bracks{v}.
    \end{equation}

    \thmitem{thm:renaming_assignment_compatibility/formulas} For any formula \( \varphi \), any variable \( \xi \) and any other variable \( \eta \) not in \( \boldop{Var}(\varphi) \) we have
    \begin{equation}\label{eq:thm:renaming_assignment_compatibility/formulas}
      \varphi\Bracks{v_{\xi \mapsto \eta}}
      =
      \parens[\Big]{ \varphi[\xi \mapsto \eta] }\Bracks{v}.
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  In both cases, we use structural induction on the definition of the substitution.

  \SubProofOf{thm:renaming_assignment_compatibility/terms}

  \begin{itemize}
    \item If \( \tau = \xi \), then
    \begin{equation*}
      \tau[\xi \mapsto \eta] = \xi[\xi \mapsto \eta] = \eta
    \end{equation*}
    and \eqref{eq:thm:renaming_assignment_compatibility/terms} follows directly.

    \item If \( \tau \) is a variable and \( \tau \neq \xi \), then
    \begin{equation*}
      \tau[\xi \mapsto \eta] = \tau
    \end{equation*}
    and \eqref{eq:thm:renaming_assignment_compatibility/terms} again holds trivially.

    \item If \( \tau = f(\tau_1, \ldots, \tau_n) \) and if the inductive hypothesis holds for \( \tau_1, \ldots, \tau_n \), then
    \begin{balign*}
      \parens[\Big]{ \tau[\xi \mapsto \eta] }\Bracks{v}
      &=
      \parens[\Big]{ f(\tau_1[\xi \mapsto \eta], \ldots, \tau_n[\xi \mapsto \eta]) }\Bracks{v}
      = \\ &=
      I(f) \parens[\Bigg]{ \parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Bracks{v}, \ldots, \parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Bracks{v} }
      \reloset {\T{ind.}} = \\ &=
      I(f) \parens[\Big]{ \tau_1\Bracks{v_{\xi \mapsto \eta}}, \ldots, \tau_n\Bracks{v_{\xi \mapsto \eta}} }
      = \\ &=
      \parens[\Big]{ f(\tau_1, \ldots, \tau_n) }\Bracks{v_{\xi \mapsto \eta}}
      = \\ &=
      \tau\Bracks{v_{\xi \mapsto \eta}}.
    \end{balign*}
  \end{itemize}

  In all cases, \eqref{eq:thm:renaming_assignment_compatibility/terms} holds.

  \SubProofOf{thm:renaming_assignment_compatibility/formulas}
  \hfill
  \begin{itemize}
    \item If \( \varphi \in \set{ \top, \bot } \), then \( \varphi \) has no subterms and thus \eqref{eq:thm:renaming_assignment_compatibility/formulas} holds vacuously.

    \item If \( \varphi = p(\tau_1, \ldots, \tau_n) \), then since \eqref{eq:thm:renaming_assignment_compatibility/terms} holds for all \( \tau_k \), we have
    \begin{equation*}
      \parens[\Big]{ \tau_k[\xi \mapsto \eta] }\Bracks{v} = \tau_k\Bracks{v_{\xi \mapsto \eta}}
    \end{equation*}
    and thus
    \begin{equation*}
      I(p)\parens[\Big]{ \parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Bracks{v}, \ldots, \parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Bracks{v} }
      \reloset {\T{ind.}} =
      I(p)\parens[\Big]{ \tau_1\Bracks{v_{\xi \mapsto \eta}}, \ldots, \tau_n\Bracks{v_{\xi \mapsto \eta}} }.
    \end{equation*}

    Therefore,
    \begin{balign*}
      \parens[\Big]{ \varphi[\xi \mapsto \eta] }\Bracks{v}
      &=
      \parens[\Big]{ p(\tau_1[\xi \mapsto \eta], \ldots, \tau_n[\xi \mapsto \eta]) }\Bracks{v}
      = \\ &=
      \parens[\Big]{ p(\tau_1, \ldots, \tau_n) }\Bracks{v_{\xi \mapsto \eta}}
      = \\ &=
      \varphi\Bracks{v_{\xi \mapsto \eta}}.
    \end{balign*}

    \item The case \( \varphi = \tau_1 \doteq \tau_2 \) is proved analogously.

    \item The cases \( \varphi = \neg \psi \) and \( \varphi = \psi_1 \bincirc \psi_2 \) are proved in an straightforward manner.

    \item Let \( \varphi = \qforall \zeta \psi \), where the inductive hypothesis holds for \( \psi \). We consider three cases
    \begin{itemize}
      \item Suppose that \( \zeta = \xi \). By definition, we have
      \begin{equation*}
        \varphi[\xi \mapsto \eta]
        =
        \varphi,
      \end{equation*}
      hence \eqref{eq:thm:renaming_assignment_compatibility/formulas} holds trivially.

      \item Suppose that \( \zeta \neq \xi \). It follows that
      \begin{equation*}
        \varphi[\xi \mapsto \eta]
        =
        \qforall \zeta \parens[\Big]{ \psi[\xi \mapsto \eta] }.
      \end{equation*}

      \begin{itemize}
        \item If \( \parens[\Big]{\varphi[\xi \mapsto \eta]}\Bracks{v} = T \), by definition of \hyperref[def:first_order_valuation/formula_valuation]{quantifier formula valuation}, for any \( x \in X \) we have
        \begin{equation}\label{eq:thm:renaming_assignment_compatibility/formulas/true_modified_assignment}
          \parens[\Bigg]{\underbrace{\qforall \zeta \parens[\Big]{ \psi[\xi \mapsto \eta] }}_{\varphi[\xi \mapsto \eta]} }\Bracks{v}
          =
          \parens[\Big]{\psi[\xi \mapsto \eta]}\Bracks{v_{\zeta \mapsto x}}
          =
          T.
        \end{equation}

        On the other hand, by the inductive hypothesis,
        \begin{equation*}
          \parens[\Big]{ \psi[\xi \mapsto \eta] }\Bracks{v} = \psi\Bracks{v_{\xi \mapsto \eta}}
        \end{equation*}
        and, as a special case, for any \( x \in X \),
        \begin{equation}\label{eq:thm:renaming_assignment_compatibility/formulas/ind_hyp_modified_assignment}
          \parens[\Big]{ \psi[\xi \mapsto \eta] }\Bracks{v_{\zeta \mapsto x}} = \psi\Bracks{v_{\xi \mapsto \eta, \zeta \mapsto x}}.
        \end{equation}

        Combining \eqref{eq:thm:renaming_assignment_compatibility/formulas/true_modified_assignment} and \eqref{eq:thm:renaming_assignment_compatibility/formulas/ind_hyp_modified_assignment}, we obtain
        \begin{equation*}
          \parens[\Big]{ \varphi[\xi \mapsto \eta] }\Bracks{v}
          =
          \parens[\Big]{ \psi[\xi \mapsto \eta] }\Bracks{v_{\zeta \mapsto x}}
          =
          \underbrace{\psi\Bracks{v_{\xi \mapsto \eta, \zeta \mapsto x}}}_{T \T*{for all} x \in X}
          =
          \varphi\Bracks{v_{\xi \mapsto \eta}},
        \end{equation*}
        which proves the case.

        \item If \( \parens[\Big]{\varphi[\xi \mapsto \eta]}\Bracks{v} = F \), then there exists \( x \in X \) such that
        \begin{equation*}
          \parens[\Big]{\psi[\xi \mapsto \eta]}\Bracks{v_{\zeta \mapsto x}} = F.
        \end{equation*}

        Since \eqref{eq:thm:renaming_assignment_compatibility/formulas/ind_hyp_modified_assignment} holds by the inductive hypothesis, we have
        \begin{equation*}
          \psi\Bracks{v_{\xi \mapsto \eta, \zeta \mapsto x}} = F
        \end{equation*}
        for the same \( x \).

        It follows that \( \varphi\Bracks{v_{\xi \mapsto \eta}} = F \), which proves the case.
      \end{itemize}
    \end{itemize}

    \item We can prove the case \( \varphi = \qexists \zeta \psi \) using double negation on the previous case.
  \end{itemize}

  In all cases, \eqref{eq:thm:renaming_assignment_compatibility/formulas} holds.
\end{proof}

\begin{proposition}\label{thm:first_order_substitution_equivalence}
  Analogously to \fullref{thm:propositional_substitution_equivalence}, we will show that all substitutions defined in \fullref{def:first_order_substitution} types of substitution preserve the corresponding \hyperref[def:first_order_semantics]{semantics}.

  By induction, this proposition also holds for \hyperref[def:propositional_substitution/simultaneous]{simultaneous substitution}.

  Fix a \hyperref[def:first_order_structure]{structure} \( \mscrX = (X, I) \) and a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \).

  \begin{thmenum}
    \thmitem{thm:first_order_substitution_equivalence/propositional} As in \fullref{def:first_order_substitution/propositional}, let \( \varphi \) be a \hyperref[def:propositional_syntax/formula]{propositional formula} with variables \( {V = \set{ P_1, \ldots, P_n }} \) and let \( \Theta = \set{ \theta_1, \ldots, \theta_n } \) be a set of \hyperref[def:first_order_syntax/formula]{first-order formulas}.

    Furthermore, let \( J \) be a \hyperref[def:propositional_valuation/interpretation]{propositional interpretation} such that, for all \( k = 1, \ldots, n \),
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/propositional/compatibility}
      P_k\Bracks{J} = \theta_k\Bracks{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/propositional}
      \parens[\Big]{ \varphi[V \mapsto \Theta] }\Bracks{v} = \varphi \Bracks{J}.
    \end{equation}

    In particular, \( \vDash \varphi \) in the sense of \fullref{def:propositional_semantics/tautology} implies \( \vDash \varphi[V \mapsto \Theta] \) in the sense of \fullref{def:first_order_semantics/tautology}.

    \thmitem{thm:first_order_substitution_equivalence/term_in_term} Let \( \tau \) be a \hyperref[def:first_order_syntax/term]{first-order term} and let \( \kappa \) be a \hyperref[def:first_order_syntax/subterm]{subterm} of \( \tau \). Let \( \mu \) be another term such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_term/compatibility}
      \mu\Bracks{v} = \kappa\Bracks{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_term}
      \tau[\kappa \mapsto \mu]\Bracks{v} = \tau\Bracks{v}.
    \end{equation}

    \thmitem{thm:first_order_substitution_equivalence/term_in_formula} Let \( \varphi \) be a \hyperref[def:first_order_syntax/formula]{first-order formula} and let \( \kappa \) be a \hyperref[def:first_order_syntax/formula_terms]{term of \( \varphi \)}. Let \( \mu \) be another term such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula/compatibility}
      \mu\Bracks{v} = \kappa\Bracks{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula}
      \varphi[\kappa \mapsto \mu]\Bracks{v} = \varphi\Bracks{v}.
    \end{equation}
  \end{thmenum}
\end{proposition}
\begin{proof}
  In all cases, we use structural induction by the definition of the substitution. The inductive hypothesis for a formula is that the proposition holds for arbitrary substitutions and valuations.

  \SubProofOf{thm:first_order_substitution_equivalence/propositional} Let \( \varphi \) be a propositional formula.
  \begin{itemize}
    \item If \( \varphi \in \set{ \top, \bot } \), no substitution is performed and thus \eqref{eq:thm:first_order_substitution_equivalence/propositional} holds trivially.

    \item If \( \varphi = P_k \) for some \( k = 1, \ldots, n \), then follows \eqref{eq:thm:first_order_substitution_equivalence/propositional} from \eqref{eq:thm:first_order_substitution_equivalence/propositional/compatibility}.

    \item If \( \varphi = \neg \psi \) and if the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \parens[\Big]{ \psi[V \mapsto \Theta] }\Bracks{v}
      =
      \overline{\parens[\Big]{ \psi[V \mapsto \Theta] }\Bracks{v}}
      \reloset {\T{ind.}} =
      \overline{\psi \Bracks{J}}
      =
      \varphi \Bracks{J}.
    \end{equation*}

    \item If \( \varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma \) and if the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), then
    \begin{equation*}
      \parens[\Big]{ \psi[V \mapsto \Theta] }\Bracks{v}
      =
      \parens[\Big]{ \psi_1[V \mapsto \Theta] }\Bracks{v} \bincirc \parens[\Big]{ \psi_2[V \mapsto \Theta] }\Bracks{v}
      \reloset {\T{ind.}} =
      \psi_1 \Bracks{J} \bincirc \psi_2\Bracks{J}
      =
      \varphi\Bracks{J}.
    \end{equation*}
  \end{itemize}

  In all cases, \eqref{eq:thm:first_order_substitution_equivalence/propositional} holds.

  \SubProofOf{thm:first_order_substitution_equivalence/term_in_term} The proof is identical to that of \fullref{thm:renaming_assignment_compatibility/terms}.

  \SubProofOf{thm:first_order_substitution_equivalence/term_in_formula} The proof is identical to that of \fullref{thm:renaming_assignment_compatibility/formulas} except for the special cases where \hyperref[rem:first_order_substitution_renaming_justification]{renaming} occurs, i.e. \( \varphi = \qforall \xi \psi \) and \( \varphi = \qexists \xi \psi \), where
  \begin{itemize}
    \item \( \xi \in \boldop{Free}(\mu) \).
    \item \( \eta \not\in \boldop{Var}(\kappa) \cup \boldop{Var}(\mu) \cup \boldop{Var}(\psi) \).
    \item The inductive hypothesis holds for \( \psi \).
  \end{itemize}

  We will only show the case \( \varphi = \qforall \xi \psi \) since the existential case is handled similarly.

  Since \( \xi \in \boldop{Free}(\mu) \), we have
  \begin{equation*}
    \varphi[\kappa \mapsto \mu]
    =
    \qforall \eta \parens[\Big]{ \psi[\xi \mapsto \eta][\kappa \mapsto \mu] },
  \end{equation*}
  which does not allow us to use the inductive hypothesis directly.

  We proceed to prove the statement by nested induction on the number of quantifiers. We have already shown the case of \( 0 \) quantifiers. Suppose that the statement holds for all formulas with strictly less than \( n \) quantifiers and suppose that \( \varphi \) has exactly \( n \) quantifiers.

  Furthermore, for formulas with \( n \) quantifiers with \( \forall \) as the outermost one, the non-renaming cases \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial} and \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct} hold. Therefore, since \( \eta \not\in \boldop{Free}(\mu) \),
  \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula/nested_induction}
    \begin{aligned}
      &\phantom{{}={}}
      \varphi[\kappa \mapsto \mu]\Bracks{v}
      = \\ &=
      \parens[\Bigg]{\qforall \eta \parens[\Big]{ \psi[\xi \mapsto \eta][\kappa \mapsto \mu] }}\Bracks{v}
      \reloset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}} = \\ &=
      \parens[\Bigg]{ \parens*{ \qforall \eta \parens[\Big]{ \psi[\xi \mapsto \eta] } }[\kappa \mapsto \mu] }\Bracks{v}
      \reloset {\T{ind.}} = \\ &=
      \parens[\Bigg]{\qforall \eta \parens[\Big]{ \psi[\xi \mapsto \eta] } }\Bracks{v},
    \end{aligned}
  \end{equation}
  where we have implicitly used that \( \psi \) has \( n - 1 \) quantifiers.

  On the other hand, due to \fullref{thm:renaming_assignment_compatibility/formulas},
  \begin{equation*}
    \parens[\Big]{ \psi[\xi \mapsto \eta] }\Bracks{v} = \psi\Bracks{v_{\xi \mapsto \eta}}
  \end{equation*}
  and, in particular, for any \( x \in X \),
  \begin{equation*}
    \parens[\Big]{ \psi[\xi \mapsto \eta] }\Bracks{v_{\eta \mapsto x}}
    =
    \psi\Bracks{v_{\xi \mapsto \eta,\eta \mapsto x}}
    =
    \psi\Bracks{v_{\xi \mapsto x}},
  \end{equation*}
  where the last equality holds because \( \eta \not\in \boldop{Var}(\psi) \).

  Hence,
  \begin{equation*}
    \underbrace{ \parens[\Bigg]{\qforall \eta \parens[\Big]{ \psi[\xi \mapsto \eta] } }\Bracks{v} }_{\varphi[\xi \mapsto \eta]\Bracks{v}}
    =
    \underbrace{ \parens[\Big]{\qforall \xi \psi }\Bracks{v_{\xi \mapsto \eta}} }_{\varphi\Bracks{v_{\xi \mapsto \eta}}}.
  \end{equation*}

  This proves \eqref{eq:thm:first_order_substitution_equivalence/term_in_formula}.
\end{proof}

\begin{remark}\label{rem:predicate_formula}
  As explained in \fullref{rem:first_order_formula_conventions/necessary_signature}, we avoid adding to a language more predicates than necessary. For this reason, we sometimes use \term{predicate formulas}. For example, if \( \leq \) is a \hyperref[def:partially_ordered_set/theory]{partial order} symbol and we want to have a predicate for whether \( \xi \) is the \hyperref[def:partially_ordered_set_extremal_points/top_and_bottom]{bottom element}, we can define the formula
  \begin{equation}\taglabel[\op{IsBottom}]{rem:predicate_formula/bottom}
    \ref{rem:predicate_formula/bottom}[\xi] \coloneqq \qforall \eta (\xi \leq \eta).
  \end{equation}

  Note that \( [\xi] \) is only a notational convenience for highlighting which variables are free, the actual formula is named \( \op{IsBottom} \). This is consistent with \fullref{rem:first_order_formula_valuation_without_variable_assignment} which allows us to write \( \op{IsBottom}[\eta] \) rather than \( \op{IsBottom}[\xi \mapsto \eta] \) to verify if \( \eta \) is a bottom element
\end{remark}

\begin{proposition}\label{thm:first_order_quantifiers_are_dual}
  For any formula \( \varphi \) and any variable \( \xi \) over \( \mscrL \), we have the following equivalences:
  \begin{align}
    \neg \qforall \xi \varphi &\gleichstark \qexists \xi \neg \varphi \label{eq:thm:first_order_quantifiers_are_dual/negation_of_universal} \\
    \neg \qexists \xi \varphi &\gleichstark \qforall \xi \neg \varphi \label{eq:thm:first_order_quantifiers_are_dual/negation_of_existential}
  \end{align}
\end{proposition}
\begin{proof}
  The two equivalences are connected using \hyperref[thm:boolean_equivalences/double_negation]{double negation}. We will only prove \eqref{eq:thm:first_order_quantifiers_are_dual/negation_of_universal}.

  Let \( \mscrX = (X, I) \) be a structure over \( \mscrL \) and let \( v \) be a variable assignment. Then
  \begin{align*}
    (\neg \qforall \xi \varphi)\Bracks{v}
    &=
    \overline{(\qforall \xi \varphi)\Bracks{v}}
    = \\ &=
    \overline{\bigwedge\set{ \varphi\Bracks{v_{\xi \mapsto x}} \given x \in X }}
    \reloset {\eqref{eq:thm:de_morgans_laws/complement_of_meet}} = \\ &=
    \bigvee\set{ \overline{\varphi\Bracks{v_{\xi \mapsto x}}} \given x \in X }
    = \\ &=
    \bigvee\set{ (\neg \varphi)\Bracks{v_{\xi \mapsto x}} \given x \in X }
    = \\ &=
    (\qexists \xi \neg \varphi)\Bracks{v}.
  \end{align*}
\end{proof}

\begin{proposition}\label{thm:implicit_universal_quantification}
  For any formula \( \varphi \) and any variable \( \xi \) over \( \mscrL \), the formulas \( \varphi \) and \( \qforall \xi \varphi \) are \hyperref[def:first_order_semantics/equivalence]{semantically equivalent}.

  This allows us to skip quantifiers when writing formulas without changing their validity. Given a formula \( \varphi \) with free variables \( \xi_1, \ldots, \xi_n \), we call
  \begin{equation*}
    \qforall {\xi_1} \cdots \qforall {\xi_n} \varphi
  \end{equation*}
  its \term{universal closure} and say that \( \varphi \) itself is \term{implicitly universally quantified}. Universal closures of quantifierless formulas are called \term{universal formulas}.

  See \fullref{ex:def:first_order_natural_deduction_system/eigenvariables/invalid_universal_closure} for how this fails for derivability.
\end{proposition}
\begin{proof}
  Let \( \mscrX = (X, I) \) be a structure that satisfies \( \varphi \). Let \( v \) be a variable assignment in \( \mscrX \). Then for any \( x \in X \), the modified variable assignment \( v_{\xi \mapsto x} \) also satisfies \( \varphi \), i.e.
  \begin{equation*}
    \varphi\Bracks{v} = \varphi\Bracks{v_{\xi \mapsto x}} = T.
  \end{equation*}

  Thus, \( \mscrX \) is also a model for \( \qforall \xi \varphi \).

  Conversely, suppose that \( \mscrX \) satisfies \( \qforall \xi \varphi \) and \( v \) is any variable assignment. Then
  \begin{equation*}
    \varphi\Bracks{v_{\xi \mapsto x}} = T
  \end{equation*}
  for any \( x \), including \( x \coloneqq v(\xi) \). Thus,
  \begin{equation*}
    \varphi\Bracks{v_{\xi \mapsto v(\xi)}} = \varphi\Bracks{v} = T.
  \end{equation*}

  Therefore, \( \mscrX \) is also a model for \( \varphi \).
\end{proof}

\begin{proposition}\label{thm:quantifier_satisfiability}
  Let \( \mscrL \) be a first-order language, \( \varphi \) be a formula, \( \xi \) be any variable and \( \tau \) be a \hyperref[def:first_order_syntax/ground_term]{ground term} in \( \mscrL \). The following hold:

  \begin{thmenum}
    \thmitem{thm:quantifier_satisfiability/universal} \( \qforall \xi \varphi \vDash \varphi[\xi \mapsto \tau] \),

    \thmitem{thm:quantifier_satisfiability/existential} \( \varphi[\xi \mapsto \tau] \vDash \qexists \xi \varphi \).
  \end{thmenum}

  See also \fullref{def:first_order_natural_deduction_system/terms} for inference rules corresponding to this proposition.
\end{proposition}
\begin{proof}
  The proof is very straightforward, but the technical details make it look a bit more complicated.

  First note that if the formulas on the left are unsatisfiable, the proof is trivial. Hence, we will assume that they are satisfiable.

  \SubProofOf{thm:quantifier_satisfiability/universal} From \fullref{thm:implicit_universal_quantification} it follows that \( \qforall \xi \varphi \vDash \varphi \). If \( \xi \) is not free in \( \varphi \), then \( \varphi[\xi \mapsto \tau] = \varphi \) and the proof is finished. Suppose that \( \xi \) is free in \( \varphi \).

  Let \( \mscrX = (X, I) \) be a model of \( \qforall \xi \varphi \). Let \( v \) be a variable assignment in \( \mscrX \) and let \( t \coloneqq \tau\Bracks{v} \). To avoid the case where \( \xi \in \boldop{Var}(\tau) \), we replace it with \( \eta \) that is not a variable in neither \( \tau \) nor \( \varphi \). Then
  \begin{align*}
    \varphi[\xi \mapsto \tau]\Bracks{v}
    &=
    \varphi[\xi \mapsto \eta][\eta \mapsto \tau]\Bracks{v}
    = \\ &=
    \varphi[\xi \mapsto \eta][\eta \mapsto \tau]\Bracks{v_{\eta \mapsto t}}
    \reloset {\ref{thm:first_order_substitution_equivalence/term_in_formula}} = \\ &=
    \varphi[\xi \mapsto \eta]\Bracks{v_{\eta \mapsto t}}
    \reloset {\ref{thm:renaming_assignment_compatibility/formulas}} = \\ &=
    \varphi\Bracks{v_{\xi \mapsto \eta, \eta \mapsto t}}
    = \\ &=
    \varphi\Bracks{v_{\xi \mapsto t}}.
  \end{align*}

  Since \( (\qforall \xi \varphi)\Bracks{v} = T \), by definition of valuation of \( \forall \) we have
  \begin{equation*}
    \varphi\Bracks{v_{\xi \mapsto t}} = T.
  \end{equation*}

  Therefore, \( \varphi[\xi \mapsto \tau]\Bracks{v} = T \) and, since \( v \) was chosen arbitrarily, we have \( \mscrX \vDash \varphi[\xi \mapsto \tau] \).

  \SubProofOf{thm:quantifier_satisfiability/existential} For any model \( \mscrX = (X, I) \) of \( \varphi \), any assignment \( v \) satisfies \( \varphi[\xi \mapsto \tau] \). Thus, \( \varphi\Bracks{v_{\xi \mapsto t}} = T \) for \( t \coloneqq \tau\Bracks{v} \) and hence \( v \) satisfies \( \qexists \xi \varphi \). Therefore, \( \mscrX \) is also a model of \( \qexists \xi \varphi \).
\end{proof}

\begin{proposition}\label{thm:existential_quantifier_removal}
  Let \( \varphi \) be a formula in the language \( \mscrL \). If \( \tau = c \) for some constant \( c \) that does not occur in \( \varphi \), the formulas \( \varphi[\xi \mapsto c] \) and \( \qexists \xi \varphi \) are equisatisfiable.

  If there is no such constant in \( \mscrL \), we can instead define the extension \( \widetilde \mscrL \) of \( \mscrL \) by adjoining a new constant \( c \).

  This general procedure of creating a new extension language in order to obtain an equisatisfiable formula without the outer quantifier is called \term{existential quantifier elimination}.
\end{proposition}
\begin{proof}
  \Fullref{thm:quantifier_satisfiability/existential} implies that \( \qexists \xi \varphi \vDash \varphi[\xi \mapsto c] \), which is even stronger than the statement that if \( \qexists \xi \varphi \) is satisfiable, so it \( \varphi[\xi \mapsto c] \).

  For the other direction, suppose that \( \mscrX = (X, I) \) satisfies \( \qexists \xi \varphi \). Fix a variable assignment \( v \). Then there exists a value \( x \) such that
  \begin{equation}\label{eq:thm:quantifier_satisfiability/existential/existence_modified_assignment}
    \varphi\Bracks{v_{\xi \mapsto x}} = T.
  \end{equation}

  Define the interpretation
  \begin{equation*}
    \widetilde I (a) \coloneqq \begin{cases}
      x, &a = c, \\
      a, &a \in \boldop{Func}, \\
      a, &a \in \boldop{Pred}
    \end{cases}
  \end{equation*}
  as \( I \) modified at \( c \), so that \( c\Bracks{v} = x \). It remains to show that the structure \( (X, \widetilde I) \) is a model of \( \varphi[\xi \mapsto \tau] \). Since the new structure has the same domain, \( v \) is a variable assignment in this new structure. Nevertheless, we will denote it by \( \widetilde v \) in order to distinguish between valuations in the two structures.

  Since \( \xi\Bracks{v} = c\Bracks{v} = x \), from \fullref{thm:first_order_substitution_equivalence/term_in_formula} it follows that
  \begin{equation*}
    \varphi[\xi \mapsto c]\Bracks{v} = \varphi\Bracks{v_{\xi \mapsto x}} \reloset{\eqref{eq:thm:quantifier_satisfiability/existential/existence_modified_assignment}} = T.
  \end{equation*}

  Since the above holds for any assignment \( v \), the structure \( (X, \widetilde I) \) is a model of \( \varphi[\xi \mapsto c] \).
\end{proof}

\begin{theorem}[First-order semantic deduction theorem]\label{thm:semantic_deduction_theorem}\mcite[thm. 16.29]{OpenLogicFull}
  Let \( \Gamma \) be a set of formulas over some first-order language, let \( \psi \) be an arbitrary formula and let \( \varphi \) be a \hyperref[def:first_order_syntax/ground_formula]{closed formula}.

  Then the entailment \( \Gamma, \varphi \vDash \psi \) holds if and only if \( \Gamma \vDash \varphi \to \psi \) holds.

  See \fullref{rem:deduction_with_free_variables} for the importance of the condition that \( \varphi \) is a closed formula.

  Due to \fullref{rem:propositional_logic_as_first_order_logic}, this theorem also holds for propositional formulas.

  Compare this result with \fullref{thm:syntactic_deduction_theorem}.
\end{theorem}
\begin{proof}
  \SufficiencySubProof Let \( \Gamma, \varphi \vDash \psi \) and let \( \mscrX = (X, I) \) be a model for \( \Gamma \).

  \begin{itemize}
    \item If \( \mscrX \vDash \varphi \), then \( \mscrX \vDash \Gamma \cup \set{ \varphi } \) and from our assumption we conclude \( \mscrX \vDash \psi \). Hence, for any variable assignment \( v \) we have
    \begin{equation*}
      (\varphi \rightarrow \psi)\Bracks{v}
      =
      (\varphi\Bracks{v} \rightarrow \psi\Bracks{v})
      =
      (T \rightarrow T)
      =
      T.
    \end{equation*}

    \item If \( \mscrX \not\vDash \varphi \), then, since \( \varphi \) is closed and the valuation \( \varphi\Bracks{v} \) does not depend on the variable assignment \( v \), for any \( v \) we have
    \begin{equation}\label{eq:thm:semantic_deduction_theorem/closedness_condition}
      (\varphi \rightarrow \psi)\Bracks{v}
      =
      (\varphi\Bracks{v} \rightarrow \psi\Bracks{v})
      =
      (F \rightarrow \psi\Bracks{v})
      =
      T.
    \end{equation}

  \end{itemize}

  In both cases we conclude that \( \mscrX \vDash \varphi \rightarrow \psi \). Therefore, \( \Gamma \vDash \varphi \rightarrow \psi \).

  \NecessitySubProof Let \( \Gamma \vDash \varphi \rightarrow \psi \) and let \( \mscrX = (X, I) \) be a model for \( \Gamma \cup \set{ \varphi } \). Let \( v \) be an arbitrary assignment in \( \mscrX \).

  Obviously \( \mscrX \vDash \Gamma \) and \( \mscrX \vDash \varphi \). We thus have \( (\varphi \rightarrow \psi)\Bracks{v} = T \) and \( \varphi\Bracks{v} = T \), which only leaves \( \psi\Bracks{v} = T \) as a possible option.

  Hence, \( \mscrX \vDash \psi \) and, consequently, \( \Gamma \cup \set{ \varphi } \vDash \psi \).
\end{proof}

\begin{remark}\label{rem:deduction_with_free_variables}
  In order to highlight the importance of closed formulas in certain theorems, we will take a close look at the proof of \fullref{thm:semantic_deduction_theorem}.

  Note that \eqref{eq:thm:semantic_deduction_theorem/closedness_condition} only holds because the formula \( \varphi \) is closed. If it were not closed, we could only conclude that there exists a variable assignment \( v_0 \) such that \( \varphi\Bracks{v_0} = F \). Clearly then \( (\varphi \rightarrow \psi)\Bracks{v_0} = T \). But there may exist another assignment \( v \) such that \( \varphi\Bracks{v} = T \) and \( \psi\Bracks{v} = F \), which would imply that \( \mscrX \not\vDash \varphi \rightarrow \psi \).
\end{remark}
