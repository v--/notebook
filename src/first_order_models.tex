\subsection{First-order models}\label{subsec:first_order_models}

Much of \fullref{subsec:first_order_logic} is dedicated to semantic equivalences between logical formulas, which are formulated and proved using \hyperref[def:first_order_structure]{structures}. This section is dedicated to the study of structures themselves and relations between them. While model theory is a wide topic, for the purposes of this document we are only interested in the following questions:

\begin{itemize}
  \item Which subsets of a structure form a \hyperref[def:first_order_substructure]{substructure}?

  This is answered by \fullref{def:first_order_substructure} and by \fullref{def:first_order_generated_substructure}. Vacuously, if the language contains no functional symbols, by \fullref{thm:first_order_substructure_properties/no_functions} every subset of a structure is a substructure. Such is the case with \hyperref[def:set]{sets} themselves, with \hyperref[def:poset]{partially ordered sets} or with \hyperref[def:metric_space]{metric} and \hyperref[def:topological_space]{topological spaces}.

  \Fullref{thm:substructures_form_complete_lattice} shows that the set of all substructures of a structure is worth studying in itself.

  \item Given a model of some set \( \Gamma \) of formulas, which substructures and \hyperref[def:first_order_homomorphism]{homomorphic} images of the model are again models of \( \Gamma \)?

  This is answered by \fullref{thm:positive_formulas_preserved_under_homomorphism}, \fullref{thm:arbitrary_formulas_preserved_under_isomorphisms} and \fullref{thm:functions_over_model_form_model}.
\end{itemize}

\begin{definition}\label{def:first_order_substructure}
  Let \( \mscrX = (X, I) \) be a structure for the language \( \mscrL \) and let \( Y \subseteq X \). We say that \( \mscrY = (Y, I) \) is a \term{substructure} of \( \mscrX \) if it satisfies any of the following equivalent conditions:

  \begin{thmenum}
    \thmitem{def:first_order_substructure/deductive} If \( Y \) is closed under function application, that is, for any functional symbol \( f \) in \( \mscrL \) with arity \( n \), we have \( I(f)(Y^n) \subseteq Y \).

    \thmitem{def:first_order_substructure/inductive} \( \mscrY \) is a \hyperref[def:fixed_point]{fixed point} of the operator
    \begin{equation}\label{eq:def:first_order_substructure/inductive/operator}
      \begin{aligned}
        &T: \pow(X) \to \pow(X) \\
        &T(A) \coloneqq A \cup \set*{ x \in X \given \qexists{f \in \boldop{Fun}} \qexists{x_1, \ldots, x_{\#f} \in A} f\Bracks{x_1, \ldots, x_{\#f}} = x },
      \end{aligned}
    \end{equation}
    which enlarges \( A \) with the union of all image of \( A \) under functions of the language \( \mscrL \).

    Note that the formula inside \eqref{eq:def:first_order_substructure/inductive/operator} is in the metalanguage despite using syntax similar to first-order logic formulas.
  \end{thmenum}
\end{definition}
\begin{proof}
  By definition of \( T \), \( Y \) if a fixed point if and only if
  \begin{equation*}
    \set*{ x \in X \given \qexists{f \in \boldop{Fun}} \qexists{x_1, \ldots, x_{\#f} \in A} f\Bracks{x_1, \ldots, x_{\#f}} = x } \subseteq Y.
  \end{equation*}

  This condition is clearly satisfied if \( B \) satisfies \fullref{def:first_order_substructure/deductive}.

  If, instead \( Y \) is a fixed point of \( T \), for the \( n \)-ary functional symbol \( f \in \boldop{Fun} \) and for any tuple \( x_1, \ldots, x_n \), the value \( I(f)(x_1, \ldots, x_n) \) belongs to \( Y \). Therefore \fullref{def:first_order_substructure/deductive} is satisfied.
\end{proof}

\begin{example}\label{ex:def:first_order_substructure/vector_space}
  The classic definition for a subset \( U \) of a \hyperref[def:vector_space]{vector space} \( \mscrV \) being a vector subspace is that \( U \) is closed under \hyperref[def:linear_combination]{linear combinations}. Linear combinations are simply finite \hyperref[def:multi_valued_function/superposition]{superpositions} of addition and scalar multiplication in \( \mscrV \). So this condition ensures that \( U \) is closed under application of the functional symbols corresponding to addition and scalar multiplication.
\end{example}

\begin{proposition}\label{thm:first_order_substructure_properties}
  Fix a language \( \mscrL \). The \hyperref[def:first_order_substructure]{first order substructures} of a structure \( \mscrX = (X, I) \) have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:first_order_substructure_properties/no_functions} If \( \mscrL \) has no functional symbols, then \( (Y, I) \) is a substructure where \( Y \) is any subset of \( X \).

    \thmitem{thm:first_order_substructure_properties/intersection} Let \( \{ (Y_k, I) \}_{k \in \mscrK} \) be a family of substructures of \( \mscrX \). Then their \term{intersection structure} \( \parens*{\bigcap_{k \in \mscrK} Y_k, I} \) is again a substructure of \( \mscrX \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:first_order_substructure_properties/no_functions} Both conditions in \fullref{def:first_order_substructure} are vacuously satisfied if there are no functional symbols in \( \mscrL \).

  \SubProofOf{thm:first_order_substructure_properties/intersection} For any functional symbol \( f \) in \( \mscrL \) with arity \( n \), we have
  \begin{equation*}
    I(f)\parens*{\parens*{\bigcap_{\smash{k \in \mscrK}} Y_k}^n}
    \reloset {\ref{thm:function_image_properties/intersection}} \subseteq
    \bigcap_{k \in \mscrK} I(f)(Y_k^n) \subseteq \bigcap_{k \in \mscrK} \mscrY_k.
  \end{equation*}

  Therefore \( \parens*{\bigcap_{k \in \mscrK} Y_k, I} \) is indeed a substructure of \( \mscrX \).
\end{proof}

\begin{definition}\label{def:first_order_generated_substructure}
  Let \( \mscrX = (X, I) \) be a structure over \( \mscrL \) and let \( A \subseteq X \) be any set. The set \( A \) is said to \term[bg=поражда,ru=порождает]{generate} or \term{induce} the substructure \( \mscrY = (Y, I) \) if it satisfies any of the equivalent statements:
  \begin{thmenum}
    \thmitem{def:first_order_generated_substructure/smallest} Out of all substructures of \( \mscrX \) whose domain contains \( A \), the domain \( \mscrY \) is the smallest with respect to \hyperref[def:subset]{set inclusion}.

    \thmitem{def:first_order_generated_substructure/intersection} \( \mscrY \) is the intersection structure of all substructures of \( \mscrX \) that contain \( A \).
  \end{thmenum}
\end{definition}
\begin{proof}
  Let \( \{ (Y_k, I) \}_{k \in \mscrK} \) be the family of all substructures of \( \mscrX \) whose domains contain \( A \). Fix one of these substructures, say \( (Y_{k_0}, I) \).

  We have the obvious inclusion
  \begin{equation*}
    \bigcap_{k \in \mscrK} Y_k \subseteq Y_{k_0}.
  \end{equation*}

  The reverse inclusion holds if and only if \( Y_{k_0} \) is contained in each one of domains \( Y_k \) for \( k \in \mscrK \). In other words, \( Y_{k_0} \) is the smallest of the domains \( \set{ Y_k }_{k \in \mscrK} \) with respect to set inclusion if and only if \( Y_{k_0} \) equals their intersection.
\end{proof}

\begin{example}\label{ex:def:first_order_generated_substructure}
  Common examples of generated substructures are the \hyperref[def:linear_span]{linear span} and the \hyperref[def:generated_ring_ideal]{generated ring ideals}.
\end{example}

\begin{remark}\label{rem:induction}
  \Fullref{def:first_order_substructure} highlights an important aspect of logic. It actually provides two definitions (that are not equivalent in general):
  \begin{itemize}
    \item \Fullref{def:first_order_substructure/deductive} defines a substructure of \( \mscrX = (X, I) \) to be \( \mscrY = (Y, I) \), where \( Y \) is any subset of \( X \) that satisfies certain conditions. Given a subset \( Y \) of \( X \), we this definition allows us to deduce if \( (Y, I) \) is a substructure or not.

    We say that this definition is \term{deductive}. \Fullref{thm:first_order_semantic_deduction_theorem} and \fullref{thm:propositional_syntactic_deduction_theorem} allow us to connect deduction in the object language with deduction in the metalanguage so we can mechanize this substructure validation by introducing it as a unary predicate symbol in the object language.

    \item \Fullref{def:first_order_substructure/inductive} instead provides a procedure for building a substructure given a subset of the domain \( X \) of \( \mscrX \) by having explicit rules for which additional related elements from \( X \) we need to add in order to obtain the corresponding generated substructure --- see \fullref{def:first_order_generated_substructure} and \fullref{ex:def:first_order_generated_substructure}.

    We say that this definition is \term{inductive}. Rather than using it for verifying whether a subset forms a substructure or not, we can instead use it for generating substructures. In \hyperref[def:zfc]{\logic{ZFC}}, we can even add a unary function to the object language for obtaining the generated substructure of a set (which set in this case will be an individual member of a model of \logic{ZFC} rather than a subset of the model).
  \end{itemize}

  The ambient domain \( X \) used for the inductive definition only guarantees that the result is well-defined but the operator \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial} is not the only one that is useful for definitions. In fact, any monotone operator on the \hyperref[thm:boolean_algebra_of_subsets]{Boolean algebra of subsets} of \( X \) has a least fixed point due to \fullref{thm:knaster_tarski_theorem}.

  For example, provided that \( X \) is a large enough to be a superset of the \hyperref[thm:smallest_inductive_set_existence]{smallest inductive set \( \omega \)}, the set \( \omega \) itself can be defined as the smallest fixed point of the operator
  \begin{equation*}
    T(A) \coloneqq \set{ \varnothing } \cup \set{ S(x) \given x \in A },
  \end{equation*}
  where \( S \) is the \hyperref[def:basic_set_operations/successor]{set successor operator}.

  This general procedure for constructing in stages an object that satisfies certain conditions is called \term{structural induction} or simply \term{induction}. The number of steps required by the procedure may not be finite (as in the example with \( \omega \)) or may not even be countable, which further encourages us to think of induction as a general procedure rather than an algorithm that works in discrete steps.

  Rather than constructing objects, we can also use inductive reasoning for proofs. In this context, the procedure for constructing objects is sometimes called recursion. We introduce specific axiom schemas representing induction --- \ref{def:peano_arithmetic/PA3} on \hyperref[def:set_of_natural_numbers]{natural numbers}, \fullref{thm:well_ordered_induction} on \hyperref[def:well_ordered_set]{well-ordered sets} and \fullref{thm:transfinite_induction} on \hyperref[def:ordinal]{ordinals}. These are formulated entirely within the object language and are, within the \hyperref[def:first_order_derivation_system]{first-order derivation system}, a useful way to introduce universal quantification where deductive derivations are more difficult or even nonexistent.
\end{remark}

\begin{proposition}\label{thm:substructures_form_complete_lattice}
  Fix a structure \( \mscrX = (X, I) \) for the language \( \mscrL \).

  The set of all substructures of a \( \mscrX \) forms a complete lattice with respect to set inclusion of domains. It is isomorphic to a complete \hyperref[def:semilattice/submodel]{sublattice} of the Boolean algebra \( \pow(X) \) described in \fullref{thm:boolean_algebra_of_subsets}.

  Explicitly:
  \begin{thmenum}
    \thmitem{thm:substructures_form_complete_lattice/join} The \hyperref[def:semilattice/join]{join} of the family of substructures with domains \( \set{ (Y_k, I) }_{k \in \mscrK} \) is the \hyperref[def:first_order_generated_substructure]{generated substructure} of the set \( \bigcup_{k \in \mscrK} Y_k \).

    \thmitem{thm:substructures_form_complete_lattice/top} The \hyperref[def:poset_extremal_points/top_and_bottom]{top element} is the substructure \( \mscrX \) itself. Any substructures that are different from \( \mscrX \) are called \term{proper}.

    \thmitem{thm:substructures_form_complete_lattice/meet} The \hyperref[def:semilattice/meet]{meet} of the family of substructures \( \set{ (Y_k, I) }_{k \in \mscrK} \) is simply the \hyperref[thm:first_order_substructure_properties/intersection]{intersection structure} of the family.

    \thmitem{thm:substructures_form_complete_lattice/bottom} The \hyperref[def:poset_extremal_points/top_and_bottom]{bottom element} of this lattice is the intersection of all substructures. This is called the \term{trivial substructure}. As a matter of fact, because the trivial substructures for any two structures are isomorphic, we refer to them collectively as the \term{trivial structure} because trivial substructures tend to be isomorphic.

    Note that the empty set is not allowed to be the domain of a structure by definition (see \fullref{rem:empty_models}). Nevertheless, for the sake of having a bottom element we allow structures with empty domains in this lattice.

    The trivial substructure usually (but not necessarily) consists only of the constants of \( \mscrL \) --- for example, the \hyperref[def:group/trivial]{trivial group} \( \set{ e } \) or the \hyperref[def:semilattice/trivial]{trivial bounded lattice} \( \set{ \top, \bot } \).
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:substructures_form_complete_lattice/join} Let \( (Y, I) \) be the generated substructure of the set \( A \coloneqq \bigcup_{k \in \mscrK} \mscrY_k \). From \fullref{def:first_order_generated_substructure/smallest} it follows that out of the domains of all substructures of \( \mscrX \), \( Y \) is the smallest that contains \( A \) and hence the smallest that contains \( Y_k \) for all \( k \in \mscrK \). Therefore it is indeed the supremum of the family \( \set{ (Y_k, I) }_{k \in \mscrK} \) with respect to set inclusion of domains.

  \SubProofOf{thm:substructures_form_complete_lattice/top} Since \( \mscrX \) is a substructure of itself, it is not only the supremum of the entire lattice but actually the maximum.

  \SubProofOf{thm:substructures_form_complete_lattice/meet} The domain of the intersection structure of the family \( \set{ (Y_k, I) }_{k \in \mscrK} \) of substructures of \( \mscrX \) is obviously the infimum of the family since its domain are the infimum in the Boolean algebra \( \pow(X) \) (see \fullref{thm:boolean_algebra_of_subsets}).

  \SubProofOf{thm:substructures_form_complete_lattice/bottom} It trivially follows from \fullref{thm:substructures_form_complete_lattice/meet} that the bottom element is the intersection of all substructures of \( \mscrX \).
\end{proof}

\begin{definition}\label{def:first_order_homomorphism}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, I) \) be structures over a common language. We say that the \hyperref[def:function]{function} \( h: X \to Y \) is a \term{homomorphism} between \( \mscrX \) and \( \mscrY \) if it preserves all functions and relations. Explicitly:
  \begin{thmenum}
    \thmitem{def:first_order_homomorphism/functions} For any functional symbol \( f \in \boldop{Fun} \) of arity \( n \) and any tuple \( x_1, \ldots, x_n \in X \) we have
    \begin{equation*}
      h\parens[\Big]{ I_\mscrX(f)(x_1, \ldots, x_n) } = I_\mscrY(f) \parens[\Big]{ h(x_1), \ldots, h(x_n) }
    \end{equation*}

    \thmitem{def:first_order_homomorphism/predicates} For any predicate symbol \( p \in \boldop{Pred} \) of arity \( n \) and any \( x_1, \ldots, x_n \in X \),
    \begin{equation*}
      I_\mscrX(p) (x_1, \ldots, x_n) = T \T{implies} I_\mscrY(p) \parens[\Big]{ h(x_1), \ldots, h(x_n) } = T.
    \end{equation*}
  \end{thmenum}
\end{definition}

\begin{remark}\label{rem:first_order_strong_homomorphism}
  Homomorphisms as they are defined in \fullref{def:first_order_homomorphism} are sometimes called \term{weak homomorphisms}. Under weak homomorphisms, it is possible that \( I_\mscrX(p) (x_1, \ldots, x_n) = F \) and yet \( I_\mscrY(p) \parens[\Big]{ h(x_1), \ldots, h(x_n) } = T \).

  Logicians sometimes define \term{strong homomorphisms} where they replace \fullref{def:first_order_homomorphism/predicates} with the stronger condition
  \begin{equation*}
    I_\mscrX(p) (x_1, \ldots, x_n) = I_\mscrY(p) \parens[\Big]{ h(x_1), \ldots, h(x_n) }.
  \end{equation*}

  This condition seems much more natural at first but it is less useful in practice. For example, \hyperref[def:preordered_set/homomorphism]{order homomorphisms} and \hyperref[def:graph_homomorphism]{graph homomorphisms} are both weak homomorphisms and these are the most used definitions of homomorphisms in languages with predicate symbols. For this reason, we avoid studying strong homomorphisms and only mention them in a few remarks.
\end{remark}

\begin{proposition}\label{thm:first_order_homomorphism_properties}
  \hyperref[def:first_order_homomorphism]{First-order structure homomorphisms} have the following basic properties:
  \begin{thmenum}
    \thmitem{thm:first_order_homomorphism_properties/substructure} If \( \mscrX = (X, I) \) is a structure and \( \mscrY = (Y, I) \) is a \hyperref[def:first_order_substructure]{substructure} of \( \mscrX \), then the \term{canonical embedding} function
    \begin{equation}\label{thm:first_order_homomorphism_properties/substructure/canonical_embedding}
      \begin{aligned}
        &\iota: Y \to X \\
        &\iota(y) \coloneqq y
      \end{aligned}
    \end{equation}
    is indeed a \hyperref[def:first_order_homomorphism_invertibility/projection]{homomorphism} (and thus an embedding in the sense of \fullref{def:first_order_homomorphism_invertibility}).

    \thmitem{thm:first_order_homomorphism_properties/preserves_substructures} If \( \mscrX = (X, I_\mscrX) \) and \( \mscrY = (Y, I_\mscrY) \) are structures and \( h: X \to Y \) is a (weak) homomorphism, then the \hyperref[def:multi_valued_function/image]{image} \( h(\mscrX) \coloneqq (h(X), I_\mscrY) \) is a substructure of \( \mscrY \).

    \thmitem{thm:first_order_homomorphism_properties/composition} The \hyperref[def:multi_valued_function/composition]{composition} of two homomorphisms is again a homomorphism.

    \thmitem{thm:first_order_homomorphism_properties/term_valuation} Fix a homomorphism \( h: X \to Y \) and a term \( \tau \). For any variable assignments \( v_\mscrX \) and \( v_\mscrY \) such that \( v_\mscrY(\xi) = h(v_\mscrX(\xi)) \) for all \( \xi \in \boldop{Var}(\tau) \), we have
    \begin{equation*}
      h(\tau\Bracks{v_\mscrX}) = \tau\Bracks{v_\mscrY}.
    \end{equation*}
  \end{thmenum}
\end{proposition}
\begin{proof}
  \SubProofOf{thm:first_order_homomorphism_properties/substructure} The interpretation in the substructure \( \mscrY \) is the \hyperref[def:multi_valued_function/restriction]{restriction} \( I\restr_\mscrY \) of \( I \) to \( \mscrY \) which simply restricts the domain of any predicate and function is indeed an interpretation in \( \mscrY \). Thus \( (Y, I\restr_\mscrY) \) is a structure.

  Conditions \fullref{def:first_order_homomorphism/functions} and \fullref{def:first_order_homomorphism/predicates} are both satisfied since the interpretation of any function and predicate is restricted to \( \mscrY \). Thus \( \iota \) is a homomorphism.

  \SubProofOf{thm:first_order_homomorphism_properties/preserves_substructures} To prove that \( (f(X), I_\mscrY) \) is a substructure of \( \mscrY \), we will show that \fullref{def:first_order_substructure/deductive} holds.

  Indeed, due to \fullref{def:first_order_homomorphism/functions}, for any \( n \)-ary functional symbol and any tuple \( {x_1, \ldots, x_n \in X} \), we have that
  \begin{equation*}
    I_\mscrY(f) \parens[\Big]{ h(x_1), \ldots, f(x_n) }
    \reloset {\ref{def:first_order_homomorphism/functions}} =
    h\parens[\Big]{ I_\mscrX(f)(x_1, \ldots, x_n) }
    \reloset {\ref{def:first_order_substructure/deductive}} \in
    h(X).
  \end{equation*}

  \SubProofOf{thm:first_order_homomorphism_properties/composition} Let \( h: \mscrX \mapsto \mscrY \) and \( l: \mscrY \mapsto \mscrZ \) both be homomorphisms.

  \begin{itemize}
    \item \Fullref{def:first_order_homomorphism/functions} is satisfied because for any \( n \)-ary functional symbol \( f \) and any tuple \( x_1, \ldots, x_n \in X \),
    \begin{align*}
      &\phantom{{}={}}
      (l \bincirc h) \parens[\Big]{ I_\mscrX(f)(x_1, \ldots, x_n) }
      \reloset {\ref{def:first_order_homomorphism/functions}} = \\ &=
      l\parens[\Big]{ I_\mscrY(f) \parens[\Big]{ h(x_1), \ldots, h(x_n) } }
      \reloset {\ref{def:first_order_homomorphism/functions}} = \\ &=
      I_{\mscrZ}(f) \parens[\Big]{ (l \bincirc h)(x_1), \ldots, (l \bincirc h)(x_n) }.
    \end{align*}

    \item \Fullref{def:first_order_homomorphism/predicates} is satisfied because for any \( n \)-ary predicate symbol \( p \) and any tuple \( x_1, \ldots, x_n \in X \),
    \begin{align*}
      &\phantom{{}={}}
      I_\mscrX(p) (x_1, \ldots, x_n)
      \reloset {\ref{def:first_order_homomorphism/predicates}} = \\ &=
      I_\mscrY(p) \parens[\Big]{ h(x_1), \ldots, h(x_n) }
      \reloset {\ref{def:first_order_homomorphism/predicates}} = \\ &=
      I_{\mscrZ}(p) \parens[\Big]{ (l \bincirc h)(x_1), \ldots, (l \bincirc h)(x_n) }.
    \end{align*}
  \end{itemize}

  \SubProofOf{thm:first_order_homomorphism_properties/term_valuation} We use induction on the structure of \( \tau \). If \( \tau \) is a variable, the statement is obvious from the compatibility condition for \( v_\mscrX \) and \( v_\mscrY \). If \( \tau = f(\kappa_1, \ldots, \kappa_m) \), then
  \begin{align*}
    \tau\Bracks{v_\mscrY}
    &=
    I(f) \parens[\Big]{ \kappa_1\Bracks{v_\mscrY}, \ldots, \kappa_m\Bracks{v_\mscrY} }
    = \\ &=
    I(f) \parens[\Big]{ h(\kappa_1\Bracks{v_\mscrX}), \ldots, h(\kappa_m\Bracks{v_\mscrX}) }
    \reloset {\ref{def:first_order_homomorphism/functions}} = \\ &=
    h\parens[\Big]{ I(f) \parens[\Big]{ \kappa_1\Bracks{v_\mscrX}, \ldots, \kappa_m\Bracks{v_\mscrX} } }
    = \\ &=
    h(\tau\Bracks{v_\mscrX}).
  \end{align*}
\end{proof}

\begin{definition}\label{def:first_order_homomorphism_invertibility}
  In connection with \fullref{def:function_invertibility} and \fullref{def:morphism_invertibility}, we introduce the following terminology for homomorphisms:
  \begin{thmenum}
    \thmitem{def:first_order_homomorphism_invertibility/embedding} An \term{embedding}, also called a \term{monomorphism}, is an \hyperref[def:function_invertibility/injection]{injective} homomorphism. We sometimes use the categorical notation \( f: A \hookrightarrow B \).

    \thmitem{def:first_order_homomorphism_invertibility/projection} Dually, a \term{projection}, also called an \term{epimorphism}, is an \hyperref[def:function_invertibility/surjection]{surjective} homomorphism. We sometimes use the categorical notation \( f: A \twoheadrightarrow B \).

    \thmitem{def:first_order_homomorphism_invertibility/isomorphism} An \term{isomorphism} is a \hyperref[def:function_invertibility/bijection]{bijective} homomorphism.

    \thmitem{def:first_order_homomorphism_invertibility/endomorphism} An \term{endomorphism} is a homomorphism that is also an \hyperref[def:multi_valued_function/endofunction]{endofunction}.

    \thmitem{def:first_order_homomorphism_invertibility/automorphism} A homomorphism that is both an endomorphism and an isomorphism is called an \term{automorphism}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:positive_formula}
  We say that a \hyperref[def:propositional_syntax/formula]{propositional formula} \( \varphi \) is \term{positive} if it contains only \hyperref[def:conjunctive_disjunctive_normal_form/literal]{positive literals} and the propositional constants \hyperref[def:propositional_language/constants/verum]{top \( \top \)} and \hyperref[def:propositional_language/constants/falsum]{bottom \( \bot \)} connected using \hyperref[def:propositional_language/connectives/conjunction]{conjunction \( \wedge \)} and \hyperref[def:propositional_language/connectives/disjunction]{disjunction \( \vee \)}.

  The point of positive formulas is to avoid \hyperref[def:propositional_language/negation]{negation \( \neg \)}. This definition is not equivalent to \hyperref[def:positive_implicational_propositional_derivation_system]{positive implicational formulas} where \( \rightarrow \) is the only connective. We avoid adding \( \rightarrow \) because that would allow us, assuming classical logic, to derive negation using \fullref{thm:boolean_equivalences/negation_bottom}.

  Positive formulas are used in \fullref{thm:positive_formulas_preserved_under_homomorphism}, which fails to hold for some non-positive formulas (see \fullref{ex:monoid_cancellation_not_preserved_by_homomorphism}).

  When dealing with first-order logic, we simply use \hyperref[thm:first_order_substitution_equivalence/propositional]{substitution} to replace propositional variables with atomic formulas. This way we obtain positive first-order formulas with \hyperref[thm:implicit_universal_quantification]{implicit universal quantification}. Of course, we can always add explicit universal quantifiers but we avoid existential quantifiers because of \fullref{thm:first_order_quantifiers_are_dual}.
\end{definition}

\begin{proposition}\label{thm:positive_formulas_preserved_under_homomorphism}
  Let \( \mscrX = (X, I) \) and \( \mscrY = (Y, I) \) be structures over a common language \( \mscrL \) and let \( h: X \to Y \) be a \hyperref[def:first_order_homomorphism]{homomorphism} between them. Take \( \Gamma \) to be a nonempty set of \hyperref[def:positive_formula]{positive formulas}.

  Then \( h \) preserves models of \( \Gamma \). That is, if \( \mscrX \vDash \Gamma \) then \( (h(X), I_\mscrY) \vDash \Gamma \).
\end{proposition}
\begin{proof}
  Let \( v \) a variable assignment in \( \mscrY \). Let \( v_\mscrX: \boldop{Var} \to X \) be an assignment such that for any variable \( \xi \) we have
  \begin{equation*}
    v_\mscrX(\xi) \in h^{-1}(v_\mscrY(\xi)).
  \end{equation*}

  At least one such assignment exists due to \fullref{def:zfc/choice}. If \( h \) is injective, this assignment is unique.

  We will show that
  \begin{equation}\label{thm:positive_formulas_preserved_under_homomorphism/ind_hyp_x}
    \mscrX \vDash_{v_\mscrX} \varphi
  \end{equation}
  implies
  \begin{equation}\label{thm:positive_formulas_preserved_under_homomorphism/ind_hyp_y}
    (h(X), I_\mscrY) \vDash_{v_\mscrY} \varphi.
  \end{equation}

  We assume \eqref{thm:positive_formulas_preserved_under_homomorphism/ind_hyp_x} for \( \varphi \) and we use induction on the structure of \( \varphi \) to prove \eqref{thm:positive_formulas_preserved_under_homomorphism/ind_hyp_y}, starting with different \hyperref[def:first_order_syntax/atomic_formula]{atomic formulas}:
  \begin{itemize}
    \item The constant \( \top \) is vacuously preserved by homomorphisms because it does not depend on the interpretation or variable assignment.

    \item Suppose that \( \varphi = (\tau_1 \doteq \tau_2) \). We have \( \tau_1\Bracks{v_\mscrX} = \tau_2\Bracks{v_\mscrX} \) and hence \( h(\tau_1\Bracks{v_\mscrX}) = h(\tau_2\Bracks{v_\mscrX}) \) and
    \begin{equation*}
      \tau_1\Bracks{v_\mscrY}
      \reloset {\ref{thm:first_order_homomorphism_properties/term_valuation}} =
      h(\tau_1\Bracks{v_\mscrX})
      =
      h(\tau_2\Bracks{v_\mscrX})
      \reloset {\ref{thm:first_order_homomorphism_properties/term_valuation}} =
      \tau_2\Bracks{v_\mscrY}.
    \end{equation*}

    \item Suppose that \( \varphi \) is the predicate formula \( p(\tau_1, \ldots, \tau_n) \). By assumption for every variable assignment in \( \mscrX \) and, in particular, for any \( v_\mscrX \),
    \begin{equation*}
      \mscrX \vDash_{v_\mscrX} p(\tau_1, \ldots, \tau_n),
    \end{equation*}
    then
    \begin{equation}\label{eq:thm:positive_formulas_preserved_under_homomorphism/predicates/x}
      I_\mscrX(p) \parens[\Big]{ \tau_1\Bracks{v_\mscrX}, \ldots, \tau_n\Bracks{v_\mscrX} } = T.
    \end{equation}

    By definition of homomorphism, we have
    \begin{equation}\label{eq:thm:positive_formulas_preserved_under_homomorphism/predicates/y}
      I_\mscrY(p) \parens[\Big]{ h(\tau_1\Bracks{v_\mscrX}), \ldots, h(\tau_n\Bracks{v_\mscrX}) } = T.
    \end{equation}

    Now
    \begin{equation*}
      (h(X), I_\mscrY) \vDash_{v_\mscrY} p(\tau_1, \ldots, \tau_n),
    \end{equation*}
    follows from \fullref{thm:first_order_homomorphism_properties/term_valuation}.

    If \( h \) is a \hyperref[rem:first_order_strong_homomorphism]{strong homomorphism}, then the converse also holds, i.e. \eqref{eq:thm:positive_formulas_preserved_under_homomorphism/predicates/x} follows from \eqref{eq:thm:positive_formulas_preserved_under_homomorphism/predicates/y}. See \fullref{thm:arbitrary_formulas_preserved_under_isomorphisms} for an application of this converse.

    \item Suppose that \( \varphi = \psi_1 \wedge \psi_2 \) and that the inductive hypothesis holds for \( \psi_1 \) and \( \psi_2 \).

    Since \( \varphi\Bracks{v_\mscrX} = T \) by assumption, by definition of valuation of conjunction we have
    \begin{equation*}
      \psi_1\Bracks{v_\mscrX}
      =
      \psi_2\Bracks{v_\mscrX}
      =
      T.
    \end{equation*}

    This allows us to apply the inductive hypothesis to obtain
    \begin{equation*}
      \psi_1\Bracks{v_\mscrY}
      =
      \psi_2\Bracks{v_\mscrY}
      =
      T.
    \end{equation*}
    and conclude that
    \begin{equation*}
      \varphi\Bracks{v_\mscrY}
      =
      \psi_1\Bracks{v_\mscrY} \wedge \psi_2\Bracks{v_\mscrY}
      =
      T \wedge T
      =
      T.
    \end{equation*}

    \item Suppose that \( \varphi = \psi_1 \vee \psi_2 \) and that the inductive hypothesis holds for \( \psi_1 \) and \( \psi_2 \).

    Since the formula \( \varphi \) is valid in \( \mscrX \), at least one of \( \psi_1 \) or \( \psi_2 \) is valid under \( v_\mscrX \). For different \( v_\mscrX \) the valuation pair \( (\psi_1\Bracks{v_\mscrX}, \psi_2\Bracks{v_\mscrX}) \) may be different but will always have at least one \( T \) value.

    The inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \) and therefore \( (\psi_1\Bracks{v_\mscrY}, \psi_2\Bracks{v_\mscrY}) \) also contains at least one \( T \) value.

    This allows us to conclude that
    \begin{equation*}
      \varphi\Bracks{v_\mscrY}
      =
      \psi_1\Bracks{v_\mscrY} \vee \psi_2\Bracks{v_\mscrY}
      =
      T.
    \end{equation*}

    \item To see how this proof fails for conditionals, consider \( \varphi = (\psi_1 \rightarrow \psi_2) \). Then \( \varphi\Bracks{v_\mscrX} = T \) implies either \( \psi_1\Bracks{v_\mscrX} = F \) or \( \psi_1\Bracks{v_\mscrX} = \psi_2\Bracks{v_\mscrX} = T \).

    If \( \psi_1\Bracks{v_\mscrX} = \psi_2\Bracks{v_\mscrX} = F \), we have \( \varphi\Bracks{v_\mscrX} = T \) but we cannot conclude that \( \varphi\Bracks{v_\mscrY} = T \) because that would require the \hyperref[def:material_implication/inverse]{inverse} of the inductive hypothesis to hold for \( \psi_1 \) and \( \psi_2 \).

    See \fullref{ex:monoid_cancellation_not_preserved_by_homomorphism} for an example where a conditional is not preserved by a homomorphism.
  \end{itemize}

  Since \( v \) was chosen arbitrarily, we conclude that
  \begin{equation*}
    (h(X), I_\mscrY) \vDash \varphi.
  \end{equation*}
\end{proof}

\begin{corollary}\label{thm:substructure_is_model}
  If \( \Gamma \) is a set of positive formulas, any \hyperref[def:first_order_substructure]{substructure} of a model of \( \Gamma \) is again a model of \( \Gamma \).
\end{corollary}
\begin{proof}
  Follows from \fullref{thm:first_order_homomorphism_properties/substructure} and \fullref{thm:positive_formulas_preserved_under_homomorphism}.
\end{proof}

\begin{proposition}\label{thm:arbitrary_formulas_preserved_under_isomorphisms}\mcite[thm. 25.9]{OpenLogicFull}
  If \( \mscrX = (X, I_\mscrX) \) is a model of \( \Gamma \) and if \( h: X \to Y \) is a embedding from \( \mscrX \) to \( \mscrY = (Y, I_\mscrY) \), then \( (h(X), I_\mscrY) \) is also a model of \( \Gamma \).

  We say that embeddings preserve arbitrary formulas.

  If \( (h(X), I_\mscrY) \) is a model of \( \Gamma \), then \( \mscrX \) is also a model if \( h \) is a \hyperref[rem:first_order_strong_homomorphism]{strong homomorphism}.

  We say that strong embeddings reflect arbitrary formulas.
\end{proposition}
\begin{proof}
  The proof simply extends the induction in the proof of \fullref{thm:arbitrary_formulas_preserved_under_isomorphisms} to
  \begin{equation*}
    \varphi\Bracks{v_\mscrY} = \varphi\Bracks{v_\mscrY}
  \end{equation*}
  which allows us to use the usual induction on the negation and all connectives and quantifiers.

  The result regarding strong homomorphisms is shown in the note about \eqref{eq:thm:positive_formulas_preserved_under_homomorphism/predicates/x} following from \eqref{eq:thm:positive_formulas_preserved_under_homomorphism/predicates/y} under strong homomorphisms.
\end{proof}

\begin{proposition}\label{thm:functions_over_model_form_model}
  Let \( \Gamma \) to be a nonempty set of \hyperref[def:positive_formula]{positive formulas}. Let \( \mscrX \) be a model of \( \Gamma \) and let \( S \) be any nonempty set. Consider the set \( Y \coloneqq \fun(S, \mscrX) \) of \hyperref[def:function]{all set functions} from \( S \) to \( X \).

  Define the function \( \iota: X \mapsto Y \) by sending each \( x \in X \) to the corresponding constant function in \( Y \).

  Define the interpretation \( I_\mscrY \) as follows:
  \begin{itemize}
    \item For each \( n \)-ary functional symbol \( f \) in \( \mscrL \), define the interpretation of the functions \( k_1, \ldots, k_n \) componentwise as
    \begin{equation*}
      \begin{aligned}
        &I_\mscrY(f): Y^n \to Y \\
        &I_\mscrY(f) \parens[\Big]{ k_1, \ldots, k_n } \coloneqq \parens[\Big]{ s \mapsto I(f) \parens[\Big]{ k_1(s), \ldots, k_n(s) } }.
      \end{aligned}
    \end{equation*}

    \item For each \( n \)-ary predicate symbol \( p \) in \( \mscrL \), define \( I_\mscrY(p) \subseteq Y^n \) via
    \begin{equation*}
      \begin{aligned}
        &I_\mscrY(p): Y^n \to \set{ T, F } \\
        &I_\mscrY(p) \parens[\Big]{ k_1, \ldots, k_n } \coloneqq \bigwedge \set[\Big]{ I(p) \parens[\Big]{ k_1(s), \ldots, k_n(s) } \given* s \in S }.
      \end{aligned}
    \end{equation*}

    That is, \( I_\mscrY(p) (k_1, \ldots, k_n) = T \) if and only if \( I(p) (k_1(s), \ldots, k_n(s)) = T \) simultaneously for all \( s \in S \).
  \end{itemize}

  Then the structure \( \mscrY = (Y, I_\mscrY) \) is also a model of \( \Gamma \) and \( \iota: \mscrX \to \mscrY \) is an embedding.
\end{proposition}
\begin{proof}
  It is obvious that \( \mscrY \) is a structure and that \( \iota \) is an embedding. We will prove using induction on the structure of a formula \( \varphi \) that \( \mscrX \vDash \varphi \) implies \( \mscrY \vDash \varphi \).

  Let \( v_\mscrY \) be a variable assignment in \( \mscrY \).

  Suppose that \( \mscrX \vDash \varphi \). We use induction on the structure of \( \varphi \) to show that \( \varphi\Bracks{v_\mscrY} = T \).
  \begin{itemize}
    \item If \( \varphi \) is a propositional constant, its value does not depend on \( v_\mscrY \) and thus \( \varphi\Bracks{v_\mscrY} = \varphi\Bracks{v_\mscrX} \).

    \item If \( \varphi = (\tau_1 \doteq \tau_2) \), then \( \tau_1\Bracks{v_\mscrX} = \tau_2\Bracks{v_\mscrX} \) for all assignments \( v_\mscrX \) in \( \mscrX \), hence for any \( s \in S \) we have \( \parens[\Big]{\tau_1\Bracks{v_\mscrY}}(s) = \parens[\Big]{\tau_2\Bracks{v_\mscrY}}(s) \) since both sides of the equality here are elements of \( \mscrX \).

    \item Analogously, if \( \varphi = p(\tau_1, \ldots, \tau_n) \), then
    \begin{equation*}
      I_\mscrY(p) \parens[\Big]{ k_1, \ldots, k_n }
      =
      \bigwedge \set[\Big]{ I(p) \parens[\Big]{ k_1(s), \ldots, k_n(s) } \given* s \in S }
      =
      \bigwedge \set{ T \given s \in S }
      =
      T.
    \end{equation*}

    \item Analogous to the proof of \fullref{thm:positive_formulas_preserved_under_homomorphism}, conjunction and disjunction formulas that are valid in \( \mscrX \) are valid in \( \mscrY \) while conditional formulas may fail to be valid. See \fullref{ex:thm:functions_over_model_of_positive_formulas_form_model} for examples where this proposition fails.
  \end{itemize}
\end{proof}

\begin{example}\label{ex:thm:functions_over_model_of_positive_formulas_form_model}
  While the statement of \fullref{thm:functions_over_model_form_model} may be a little cryptic, a few examples show that it is actually obvious.
  \begin{itemize}
    \item \hyperref[def:boolean_function]{Boolean functions} have their values in the Boolean algebra \( \set{ T, F } \). Let \( S \) be the set of all tuples of values in \( \set{ T, F }^n \) for arbitrary \( n \). That is,
    \begin{equation*}
      S \coloneqq \bigcup_{n \geq 1} \set{ T, F }^n.
    \end{equation*}

    Then from \fullref{thm:functions_over_model_form_model} it follows that the set \( B = \fun(S, \set{ T, F }) \) of all Boolean functions of arbitrary arities is again a Boolean algebra. See \fullref{thm:lindenmaum_tarski_algebra_of_full_propositional_logic/bijection} for further discussion.

    \item If \( \mscrR \) is a ring and \( S \) is any set, then \( \fun(S, \mscrR) \) is again a ring with componentwise operations --- see \fullref{thm:functions_over_ring_form_algebra}.

    This is useful in functional analysis where we study real-valued and complex-valued functions over arbitrary sets.

    \item If \( \BbbK \) is a field, then in general \( \fun(S, \BbbK) \) is not a field. The simplest example are the real-valued real functions --- \( \sin(x) \) has no multiplicative inverse since \( \sfrac 1 {\sin(x)} \) is not defined for \( x = 2k\pi, k = 1, 2, \ldots \). We can form a \hyperref[def:field_of_fractions]{field of fractions} but in general fields of fractions over function rings no longer correspond to functions --- they are purely algebraic constructions, just like \hyperref[def:formal_power_series]{formal power series}.

    This happens because the definition of a field and, more generally, of a division ring (see \fullref{def:semiring/division_ring}), has a non-positive axiom --- it requires every nonzero element to have a multiplicative inverse, which can be described formally as
    \begin{equation*}
      \qforall \xi \parens[\Big]{ (\xi \doteq 0) \vee \qexists \eta (\xi \cdot \eta \doteq 1) }.
    \end{equation*}

    As discussed in \fullref{def:positive_formula}, a formula with an existential quantifier may fail to be positive.
  \end{itemize}
\end{example}
