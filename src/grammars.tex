\subsection{Grammars}\label{subsec:grammars}

\begin{definition}\label{def:grammar}\MarginCite[def. 2.2]{Sipser2013}
  Let \( \Cal{A} \) be some \hyperref[def:language/alphabet]{alphabet} and \( V, \Sigma \subseteq \Cal{A} \) be nonempty disjoint subsets of \( \Cal{A} \).

  \begin{DefEnum}
    \ILabel{def:grammar/variables} We call elements of \( V \) \Def{variables} or \Def{non-terminals}.

    \ILabel{def:grammar/terminals} We call elements of elements of \( \Sigma \) \Def{terminals}.

    \ILabel{def:grammar/start} We assume that a special \Def{start symbol} \( S \in V \) is fixed.

    \ILabel{def:grammar/production_rules} We define a binary \hyperref[def:relation]{relation} \( \to \) of \Def{production rules} over \( (V \cup \Sigma)^* \), that is, rules are \enquote{transformations} that define how a language is \enquote{generated} starting from \( S \in V \) (see \fullref{def:grammar_derivation} and \fullref{ex:def:grammar/arithmetic}). By convention, we treat uppercase symbols as variables and lowercase symbols as terminals. See, for example, \fullref{remark:backus_naur_form}. When speaking about general grammars, however, we usually use the letters \( u \), \( v \) and \( w \) to denote words (that may contain variables) rather than terminals.

    \ILabel{def:grammar/terminal_rules} Rules of the form \( u \to \sigma \), where \( \sigma \in \Sigma \), are called \Def{terminal rules}. Note that \( u \) here is a word and not a terminal.

    \ILabel{def:grammar/grammar} The tuple \( G \coloneqq (V, \Sigma, \to, S) \) is called a \Def{formal grammar}.

    \ILabel{def:grammar/context_free} If every production rule has only a single variable for a source, i.e. if for every rule \( u \to v \) we have \( u = A \) for some \( A \in V \), we say that the grammar is \Def{context-free}.
  \end{DefEnum}
\end{definition}

\begin{remark}\label{remark:backus_naur_form}
  In practice, specifying a \hyperref[def:grammar/context_free]{context-free grammar} as
  \begin{AlignedEquation}\label{eq:remark:backus_naur_form/long_rule_list}
    &A \to a, \\
    &A \to b, \\
    &A \to AC, \\
    &C \to c,
  \end{AlignedEquation}
  or even via the shorthand notation
  \begin{AlignedEquation}\label{eq:remark:backus_naur_form/short_rule_list}
    &A \to a \mid b \mid AC, \\
    &C \to c, \\
  \end{AlignedEquation}
  quickly becomes cumbersome.

  When dealing with more complicated languages like \hyperref[def:first_order_language/grammar]{first-order formulas}, and especially when dealing with programming languages (e.g. the Python grammar that can be found in \cite{Python:39_grammar}), it is more convenient to use alternative notation like the \Def{Backus-Naur form (BNF)}. It is a metasyntax, i.e. a syntax for describing language syntax.

  Compared to \eqref{eq:remark:backus_naur_form/long_rule_list}, the main differences are:
  \begin{enumerate}
    \item Variables are denoted by \( \langle \) words enclosed in angle brackets \( \rangle \) so that we can name variables using more than one symbol.
    \item Terminals are denoted using \enquote{quotes}. In human-readable rich text documents like this one, it is sometimes possible to use different fonts and so instead of \enquote{quotes} we specify terminals using an \texttt{upright monospaced font}.
    \item Free-text rules can be specified using a normal font. This is also only used in human-readable rich text documents, however this usage is justified because such rules are only beneficial for human understanding and not for machine parsing.
    \item The symbol \( :\coloneqq \) is used instead of \( \to \) for specifying transition rules.
    \item Different rules with the same source are concatenated as in \eqref{eq:remark:backus_naur_form/short_rule_list}.
  \end{enumerate}

  For example, \eqref{eq:remark:backus_naur_form/long_rule_list} becomes
  \begin{bnf*}
    \bnfprod{A} {\bnfts{a} \bnfor \bnfts{b} \bnfor \bnfpn{A} \bnfpn{C}} \\
    \bnfprod{C} {\bnfts{c}}
  \end{bnf*}
\end{remark}

\begin{definition}\label{def:grammar_derivation}\MarginCite[page 104 \\ page 108]{Sipser2013}
  Fix a \hyperref[def:grammar]{formal grammar} \( G = (V, \Sigma, \to, S) \). Note that all lowercase symbols in this definitions are words rather than terminals.

  \begin{DefEnum}
    \ILabel{def:grammar_derivation/yields} Fix a \hyperref[def:language/word]{word} \( pvs \). If \( u \to v \) is a production rule, we say that \( pvs \) \Def{yields} the word \( pws \) and write
    \begin{equation*}
      pvs \Rightarrow pws.
    \end{equation*}

    \ILabel{def:grammar_derivation/derivation} We say that \( u \) \Def{derives} \( v \) and write \( u \Rightarrow v \) if there exists a finite sequence of words \( u_1, \ldots, u_n \) such that
    \begin{equation*}
      u \Rightarrow u_1 \Rightarrow \ldots \Rightarrow u_n \Rightarrow v.
    \end{equation*}

    The sequence \( u, u_1, \ldots, u_n, v \) is called a \Def{derivation} of \( v \) from \( u \).

    \ILabel{def:grammar_derivation/leftmost_rightmost_derivation} If on every step of the derivation the leftmost (resp. rightmost) variable is replaced, we say that it is a \Def{leftmost} (resp. \Def{rightmost}) derivation.

    \ILabel{def:grammar_derivation/grammar_language} Define the \Def{language} of the grammar to be
    \begin{equation*}
      \Cal{L}(G) \coloneqq \{ w \in \Sigma^* \colon S \Rightarrow w \},
    \end{equation*}
    that is, all words that can be derived from \( S \) and contains only terminals.

    We also say that strings in \( \Cal{L}(G) \) are \Def{generated} by the grammar \( G \).

    \ILabel{def:grammar_derivation/ambiguity}\MarginCite[def. 2.7]{Sipser2013}We say that the word \( w \) can be derived \Def{unambiguously} if there exists a unique leftmost derivation from \( S \). Otherwise we say that \( w \) is generated \Def{ambiguously} and that the grammar itself is \Def{ambiguous}.
  \end{DefEnum}
\end{definition}

\begin{example}\label{ex:def:grammar/arithmetic}
  We will define a grammar for addition on \hyperref[def:natural_numbers]{natural numbers}. Note that we only consider the number in \( \BN \) only as symbols, not as the numbers themselves.

  Let \( V \coloneqq \{ A \} \) and \( \Sigma \coloneqq \BN \cup \{ +, (, ) \} \). Define the grammar
  \begin{AlignedEquation}\label{eq:ex:context_free_grammar/real_arithmetic/grammar}
    &A \to n,                 && n \in \BN \\
    &A \to (A + A)            &&
  \end{AlignedEquation}

  Choose the starting symbol to be the only symbol \( A \) in \( V \). Then the grammar can produce the arithmetic expression \( ((1 + 2) + 3) \) by applying the rules
  \begin{equation*}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
      input metapost/graphs;

      v1 := thelabel("$A$", origin);
      v2 := thelabel("$(A + A)$", (0, -1) scaled u);
      v3 := thelabel("$3$", (1, -2) scaled u);
      v4 := thelabel("$(A + A)$", (-1, -2) scaled u);
      v5 := thelabel("$1$", (-2, -3) scaled u);
      v6 := thelabel("$2$", (0, -3) scaled u);

      a1 := straight_arc(v1, v2);
      a2 := straight_arc(v2, v3);
      a3 := straight_arc(v2, v4);
      a4 := straight_arc(v4, v5);
      a5 := straight_arc(v4, v6);

      draw_vertices(v);
      draw_arcs(a);

      label.lft("$A \to (A + A$)", straight_arc_midpoint of a1);
      label.urt("$A \to 3$", straight_arc_midpoint of a2);
      label.ulft("$A \to (A + A)$", straight_arc_midpoint of a3);
      label.ulft("$A \to 1$", straight_arc_midpoint of a4);
      label.urt("$A \to 2$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
  \end{equation*}

  Note that the grammar is unambiguous because of the parentheses. If we omit the parentheses, it will no longer be unambiguous since \( 1 + 2 + 3 \) can be derived by both
  \begin{equation*}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
      input metapost/graphs;

      v1 := thelabel("$A$", origin);
      v2 := thelabel("$A + A$", (0, -1) scaled u);
      v3 := thelabel("$1$", (-1, -2) scaled u);
      v4 := thelabel("$A + A$", (1, -2) scaled u);
      v5 := thelabel("$2$", (0, -3) scaled u);
      v6 := thelabel("$3$", (2, -3) scaled u);

      a1 := straight_arc(v1, v2);
      a2 := straight_arc(v2, v3);
      a3 := straight_arc(v2, v4);
      a4 := straight_arc(v4, v5);
      a5 := straight_arc(v4, v6);

      draw_vertices(v);
      draw_arcs(a);

      label.lft("$A \to A + A$", straight_arc_midpoint of a1);
      label.ulft("$A \to 1$", straight_arc_midpoint of a2);
      label.urt("$A \to A + A$", straight_arc_midpoint of a3);
      label.ulft("$A \to 2$", straight_arc_midpoint of a4);
      label.urt("$A \to 3$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
    \hspace{1cm}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
      input metapost/graphs;

      v1 := thelabel("$A$", origin);
      v2 := thelabel("$A + A$", (0, -1) scaled u);
      v3 := thelabel("$3$", (1, -2) scaled u);
      v4 := thelabel("$A + A$", (-1, -2) scaled u);
      v5 := thelabel("$1$", (-2, -3) scaled u);
      v6 := thelabel("$2$", (0, -3) scaled u);

      a1 := straight_arc(v1, v2);
      a2 := straight_arc(v2, v3);
      a3 := straight_arc(v2, v4);
      a4 := straight_arc(v4, v5);
      a5 := straight_arc(v4, v6);

      draw_vertices(v);
      draw_arcs(a);

      label.lft("$A \to A + A$", straight_arc_midpoint of a1);
      label.urt("$A \to 3$", straight_arc_midpoint of a2);
      label.ulft("$A \to A + A$", straight_arc_midpoint of a3);
      label.ulft("$A \to 1$", straight_arc_midpoint of a4);
      label.urt("$A \to 2$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
  \end{equation*}
\end{example}
\begin{proof}
  We will show that \( G \) is unambiguous. Let \( w \) be a word in \( \Cal{L}(G) \). We explicitly build the derivation of \( w \) by induction\IND on \( \Len(w) \):
  \begin{itemize}
    \item If \( \Len(w) = 1 \), then \( w = n \in \BN \) and the word has been generated by the single rule \( A \to n \).

    \item Assume that \( w \) is unambiguously derived for \( \Len(w) < m + 2 \) and let \( \Len(w) = m + 2 \), then \( w \) is necessarily enclosed in parentheses. Let \( w = ( \sigma_0 \ldots \sigma_m ) \) be the symbols of \( w \). Because of the parentheses, the only possibility for \( \sigma_0 \ldots \sigma_m \) is that it consists of two words in \( \Cal{L}(G) \) with an addition symbol \( + \) between them. Let \( k \) be the index of the operator, that is, the index such that \( \sigma_1 \ldots \sigma_{k-1} \) and \( \sigma_{k+1} \ldots \sigma_m \) both belong to \( \Cal{L}(G) \). Furthermore, by inductive hypothesis, both \( \sigma_1 \ldots \sigma_{k-1} \) and \( \sigma_{k+1} \ldots \sigma_m \) are unambiguously derived. Therefore \( w \) is also unambiguously derived.
  \end{itemize}
\end{proof}
