\subsection{Language of propositional logic}\label{subsec:propositional_logic}

\begin{remark}\label{rem:propositional_language_is_alphabet}
  The \hyperref[def:propositional_language]{language of propositional logic} is, strictly speaking, an \hyperref[def:language/alphabet]{alphabet} rather than a \hyperref[def:language/language]{language}. Nonetheless, this is the established terminology.
\end{remark}

\begin{definition}\label{def:propositional_language}\mcite\cite[102]{OpenLogic20201202}
  The \term{language of propositional logic} consists of:

  \begin{thmenum}
    \ilabel{def:propositional_language/prop} A nonempty at most \hyperref[rem:cardinals/countable]{countable} set \( \bfop{Prop} \) of \term{propositional variables}.

    \ilabel{def:propositional_language/constants} Two \term{propositional constants} (also known as \term{truth values}):
    \begin{thmenum}
      \ilabel{def:propositional_language/constants/top} \term{top} \( \top \)
      \ilabel{def:propositional_language/constants/bottom} \term{bottom} \( \bot \) (also known as \term{falsum})
    \end{thmenum}

    \ilabel{def:propositional_language/negation} \term{Negation} \( \neg \)
    \ilabel{def:propositional_language/connectives} The set \( \Sigma \) of \term{propositional connectives}, namely
    \begin{thmenum}
      \ilabel{def:propositional_language/connectives/conjunction} \term{conjunction} \( \wedge \) (also known as \hyperref[def:standard_boolean_operators]{\term{and}} or \hyperref[def:lattice_operations]{\term{meet}})
      \ilabel{def:propositional_language/connectives/disjunction} \term{disjunction} \( \vee \) (also known as \hyperref[def:standard_boolean_operators]{\term{or}} or \hyperref[def:lattice_operations]{\term{join}})
      \ilabel{def:propositional_language/connectives/implication} \term{(material) implication} \( \to \) (see \fullref{def:material_implication})
      \ilabel{def:propositional_language/connectives/equivalence} \term{(material) equivalence} \( \leftrightarrow \)
    \end{thmenum}

    \ilabel{def:propositional_language/parentheses} Parentheses \( ( \) and \( ) \) for defining the order of operations unambiguously (see \fullref{rem:propositional_formula_parentheses}).
  \end{thmenum}

  \Fullref{rem:smaller_propositional_language} shows we can actually utilize a smaller propositional language without losing any of its semantics.
\end{definition}

\begin{definition}\label{def:propositional_syntax}
  The following related definitions constitute what is called the \term{syntax of propositional logic}.

  \begin{thmenum}
    \ilabel{def:propositional_syntax/grammar} Consider the following \hyperref[def:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}   {P \in \bfop{Prop}} \\
      \bnfprod{connective} {\circ \in \Sigma} \\
      \bnfprod{formula}    {\bnfpn{variable} \bnfor} \\
      \bnfmore             {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore             {\bnfts{\( \neg \)} \bnfpn{formula} \bnfor} \\
      \bnfmore             {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)}}
    \end{bnf*}

    Note that \( \bfop{Prop} \) may be infinite, in which case the grammars may have infinitely many rules. If needed, we can circumvent this by introducing an appropriate naming convention for variables, analogously to \fullref{ex:natural_arithmetic_grammar/backus_naur_form}.

    We will be using the conventions in \fullref{rem:propositional_formula_parentheses}.

    \ilabel{def:propositional_syntax/formula} The set of \term{propositional formulas} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{formula} \) as a starting rule.

    The grammar of propositional formulas is unambiguous by \fullref{thm:propositional_formulas_are_unambiguous}.

    \ilabel{def:propositional_syntax/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \term{subformula} of \( \varphi \).

    \ilabel{def:propositional_syntax/variables} For each formula \( \varphi \), we inductively\IND define its \term{variables} to be elements of the set
    \begin{equation}\label{eq:def:propositional_syntax/varables}
      \bfop{Var}(\varphi) \coloneqq \begin{cases}
        \varnothing,                              &\varphi \in \set{ \top, \bot }                     \\
        \set{ P },                                  &\varphi = P \in \bfop{Prop}                      \\
        \bfop{Var}(\psi),                         &\varphi = \neg \psi                              \\
        \bfop{Var}(\psi) \cup \bfop{Var}(\theta), &\varphi = (\psi \circ \theta), \circ \in \Sigma.
      \end{cases}
    \end{equation}

    Note that \( \bfop{Var}(\varphi) \) can naturally be totally ordered by the position of the first occurrence of a variable.
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The grammar of \hyperref[def:propositional_syntax/formula]{propositional formulas} is \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is analogous to \fullref{ex:natural_arithmetic_grammar/derivation}.
\end{proof}

\begin{remark}\label{rem:propositional_formula_parentheses}
  We use the following two conventions regarding parentheses:
  \begin{thmenum}
    \ilabel{rem:propositional_formula_parentheses/outermost} We may skip the outermost parentheses in formulas with top-level \hyperref[def:propositional_language/connectives]{connectives}, e.g. we may write \( P \wedge Q \) rather than \( (P \wedge Q) \).

    \ilabel{rem:propositional_formula_parentheses/associative} Because of the associativity of \( \wedge \) and \( \vee \) (see \fullref{def:propositional_formula_induced_function} and \fullref{def:standard_boolean_operators}), we may skip the parentheses in chains like
    \begin{equation*}
      ( \ldots ((P_1 \wedge P_2) \wedge P_3) \wedge \ldots \wedge P_{n-1} ) \wedge P_n.
    \end{equation*}
    and instead write
    \begin{equation*}
      P_1 \wedge P_2 \wedge \ldots \wedge P_{n-1} \wedge P_n.
    \end{equation*}
  \end{thmenum}

  These are only notations shortcuts in the \hyperref[rem:metalanguage_syntax_and_semantics]{metalanguage} and the formulas themselves (as abstract mathematical objects) are still assumed to contain parentheses to avoid syntactic ambiguity (see \fullref{thm:propositional_formulas_are_unambiguous}).
\end{remark}

\begin{definition}\label{def:material_implication}
  We call the connective \hyperref[def:propositional_language/connectives/implication]{\( \to \)} \term{material implications} or simply \term{implication}. This distinguishes it from logical implication, which relates to the metatheoretic concept of \hyperref[def:propositional_semantics/entailment]{entailment} (see \cite{MathSE:material_vs_logical_implication}). Theorems in mathematics usually have the form \( P \to Q \).

  \begin{thmenum}
    \ilabel{def:material_implication/sufficient_condition} \( P \) is a \term{sufficient condition} for \( Q \).

    \ilabel{def:material_implication/necessary_condition} \( Q \) is a \term{necessary condition} for \( P \).

    \ilabel{def:material_implication/antecedent} \( P \) the \term{antecedent} of \( \varphi \).

    \ilabel{def:material_implication/consequent} \( Q \) the \term{consequent} of \( \varphi \).

    \ilabel{def:material_implication/inverse} The formula \( \neg P \to \neg Q \) is the \term{inverse} of \( \varphi \).

    \ilabel{def:material_implication/converse} The formula \( Q \to P \) is the \term{converse} of \( \varphi \).

    \ilabel{def:material_implication/contrapositive} The formula \( \neg Q \to \neg P \) is the \term{contrapositive} of \( \varphi \). It is \hyperref[def:propositional_semantics/equivalence]{equivalent} to the original formula by \fullref{thm:boolean_equivalences/contrapositive}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:propositional_valuation}
  \hfill
  \begin{thmenum}
    \ilabel{def:propositional_valuation/interpretation} A \term{propositional interpretation} is a function \( I: \bfop{Prop} \to \set{ T, F } \). See \fullref{def:boolean_function} and \fullref{rem:metalanguage_syntax_and_semantics} for remarks regarding the \hyperref[def:boolean_algebra]{Boolean algebra} \( \set{ T, F } \) and the \hyperref[def:standard_boolean_operators]{standard Boolean operators}.

    \ilabel{def:propositional_valuation/formula_valuation} Given an interpretation \( I \), we define the \term{valuation} of a formula \( \varphi \) inductively\IND as
    \begin{equation}\label{eq:def:propositional_valuation/formula_interpretation}
      \varphi\Bracks{I} \coloneqq \begin{cases}
        T,                               &\varphi = \top \\
        F,                               &\varphi = \bot \\
        I(P),                            &\varphi = P \in \bfop{Prop} \\
        \overline{\psi\Bracks{I}},                &\varphi = \neg \psi \\
        \psi\Bracks{I} \circ \theta\Bracks{I}, &\varphi = \psi \circ \theta, \circ \in \Sigma.
      \end{cases}
    \end{equation}
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:propositional_formula_induced_function}
  Let \( \varphi \) be a propositional formula and let \( \bfop{Var}(\varphi) = \set{ P_1, \ldots, P_n } \) be an ordering of the free variables of \( \varphi \). We define the \hyperref[def:boolean_function]{Boolean function}
  \begin{alignedeq}\label{eq:def:propositional_formula_induced_function}
    &\fun_\varphi: \set{ T, F }^n \to \set{ T, F } \\
    &\fun_\varphi(x_1, \ldots, x_n) \coloneqq \varphi\Bracks{I},
  \end{alignedeq}
  where \( I \) is any interpretation such that
  \begin{equation*}
    I(P_k) = x_k, k = 1, \ldots, n.
  \end{equation*}
\end{definition}

\begin{definition}\label{def:propositional_semantics}\mcite\cite[def. 7.14]{OpenLogic20201202}
  We now define \term{semantical} properties of propositional formulas. Because of the connection with \hyperref[def:boolean_function]{Boolean functions} given in \fullref{def:propositional_formula_induced_function}, we also formulate some of the properties using Boolean functions.

  \begin{thmenum}
    \ilabel{def:propositional_semantics/satisfiability} Given an interpretation \( I \) and a set \( \Gamma \) of formulas, we say that \( I \) \term{satisfies} \( \Gamma \) if, for every formula \( \gamma \in \Gamma \) we have \( \gamma\Bracks{I} = T \).

    We also say that \( I \) is a \term{model} of \( \Gamma \) and write \( I \vDash \Gamma \).

    If \( \Gamma = \set{ \gamma_1, \ldots, \gamma_n } \) is a finite ordered set, we use the shorthand \( I \vDash \gamma_1, \ldots, \gamma_n \) rather than \( I \vDash \set{ \gamma_1, \ldots, \gamma_n } \). In particular, if \( \Gamma = \set{ \varphi } \) we write \( I \vDash \varphi \).

    Note that every interpretation vacuously satisfies the empty set \( \Gamma = \varnothing \) of formulas.

    We say that \( \Gamma \) is \term{satisfiable} if there exists a model for \( \Gamma \).

    \ilabel{def:propositional_semantics/entailment} We say that the set of formulas \( \Gamma \) \term{entails} the set of formulas \( \Delta \) and write \( \Gamma \vDash \Delta \) if either of the following hold:
    \begin{itemize}
      \ilabel{def:propositional_semantics/entailment/direct} Every model of \( \Gamma \) is also a model of \( \Delta \).
      \ilabel{def:propositional_semantics/entailment/functional} The following \hyperref[def:function/preimage]{preimage} inclusion holds:
      \begin{equation*}
        \bigcap_{\gamma \in \Gamma} \fun_\gamma^{-1}(T) \subseteq \bigcap_{\delta \in \Delta} \fun_\delta^{-1}(T).
      \end{equation*}
    \end{itemize}

    \ilabel{def:propositional_semantics/tautology} The formula \( \varphi \) is a \term{tautology} if either:
    \begin{itemize}
      \ilabel{def:propositional_semantics/tautology/direct} Every interpretation satisfies \( \varphi \).
      \ilabel{def:propositional_semantics/tautology/entailment} The empty set \( \Gamma = \varnothing \) of formulas entails \( \varphi \), i.e. \( \vDash \varphi \).
      \ilabel{def:propositional_semantics/tautology/functional} The function \( \fun_\varphi \) is canonically true.
    \end{itemize}

    We also say that \( \varphi \) is \term{valid}.

    \ilabel{def:propositional_semantics/contradiction} Dually, \( \varphi \) is a \term{contradiction} if either:
    \begin{itemize}
      \ilabel{def:propositional_semantics/contradiction/direct} No interpretation satisfies \( \varphi \).
      \ilabel{def:propositional_semantics/contradiction/entailment} The formula \( \varphi \) entails \( \Gamma = \varnothing \), i.e. \( \varphi \vDash \).
      \ilabel{def:propositional_semantics/contradiction/functional} The function \( \fun_\varphi \) is canonically false.
    \end{itemize}

    \ilabel{def:propositional_semantics/equivalence} We say that \( \varphi \) and \( \psi \) are \term{semantically equivalent} and write \( \varphi \gleichstark \psi \) if either:
    \begin{itemize}
      \ilabel{def:propositional_semantics/equivalence/direct} We have \( \varphi\Bracks{I} = \psi\Bracks{I} \) for every interpretation \( I \).
      \ilabel{def:propositional_semantics/equivalence/entailment} Both \( \varphi \vDash \psi \) and \( \psi \vDash \varphi \).
      \ilabel{def:propositional_semantics/equivalence/functional} We have \( \fun_\varphi = \fun_\psi \) for the induced functions.
    \end{itemize}
  \end{thmenum}
\end{definition}

\begin{theorem}\label{thm:propositional_formula_cosets_are_boolean_functions}
  We give an explicit connection between \hyperref[def:propositional_syntax/formula]{propositional formulas} and \hyperref[def:boolean_function]{Boolean functions}.

  \begin{thmenum}
    \ilabel{thm:propositional_formula_cosets_are_boolean_functions/equivalence} The \hyperref[def:propositional_semantics/equivalence]{semantic equivalence} \( \gleichstark \) is an equivalence relation on the set of all propositional formulas.

    \ilabel{thm:propositional_formula_cosets_are_boolean_functions/bijection} The \hyperref[def:equivalence_relation/quotient]{quotient set} of all propositional formulas by \( \gleichstark \) is bijective with the set of all \hyperref[def:boolean_function]{Boolean functions} of arbitrary arity.

    \ilabel{thm:propositional_formula_cosets_are_boolean_functions/boolean_algebra} The quotient set of all propositional formulas by \( \gleichstark \) forms a \hyperref[def:boolean_algebra]{Boolean algebra} with the following:
    \begin{reflist}
      \iref{def:binary_lattice_operations/join} Finite joins are given by \hyperref[def:propositional_language/connectives/disjunction]{disjunctions \( \vee \)}.
      \iref{def:binary_lattice_operations/meet} Finite meets are given by \hyperref[def:propositional_language/connectives/conjunction]{conjunctions \( \wedge \)}.
      \iref{def:lattice/top} The top is the equivalence class \( [\top] \) of \hyperref[def:propositional_semantics/tautology]{tautologies}.
      \iref{def:lattice/bottom} The bottom is the equivalence class \( [\bot] \) of \hyperref[def:propositional_semantics/contradiction]{contradictions}.
      \iref{def:boolean_algebra} The complement of the coset \( [\varphi] \) is the \hyperref[def:propositional_language/negation]{negation} coset \( [\neg \varphi] \).
    \end{reflist}
  \end{thmenum}
\end{theorem}
\begin{proof}
  \SubProofOf{thm:propositional_formula_cosets_are_boolean_functions/equivalence} Follows from the equivalent definitions in \fullref{def:equivalence_relation}.

  \SubProofOf{thm:propositional_formula_cosets_are_boolean_functions/bijection} Follows from the equivalent definitions in \fullref{def:propositional_semantics/equivalence}.

  \SubProofOf{thm:propositional_formula_cosets_are_boolean_functions/boolean_algebra} Follows from \fullref{thm:propositional_formula_cosets_are_boolean_functions/bijection} and \fullref{thm:boolean_functions_form_boolean_algebra}.
\end{proof}

\begin{definition}\label{def:propositional_substitution}
  We sometimes want to replace a propositional variable with another variable or even with a formula. It does not pose any difficulty to extend this definition beyond replacing a variable like it is usually done (e.g. \cite[def. 7.8]{OpenLogic20201202}). Not only that, we can then use this mechanism to define complicated rewriting rules as in \fullref{alg:conjunctive_normal_form_reduction} and have semantic equivalence automatically follow from \fullref{thm:propositional_substitution_equivalence}.

  \begin{thmenum}
    \ilabel{def:propositional_substitution/single} We define the \term{substitution} of the propositional formula \( \psi \) with \( \rho \) in \( \varphi \) as
    \begin{equation}\label{eq:def:propositional_substitution/single}
      \varphi[\theta \mapsto \rho] \coloneqq \begin{cases}
        \rho,                                                          &\varphi = \theta \\
        \varphi,                                                       &\varphi \neq \theta \T{and} \varphi \in \set{ \top, \bot } \cup \bfop{Prop} \\
        \neg \psi[\theta \mapsto \rho],                                &\varphi \neq \theta \T{and} \varphi = \neg \psi \\
        \psi_1[\theta \mapsto \rho] \circ \psi_2[\theta \mapsto \rho], &\varphi \neq \theta \T{and} \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma.
      \end{cases}
    \end{equation}

    \ilabel{def:propositional_substitution/simultaneous} We will now define \term{simultaneous substitution} of \( \theta_1, \ldots, \theta_n \) with \( \rho_1, \ldots, \rho_n \). We wish to avoid the case where \( \theta_k \) is a subformula of \( \rho_{k-1} \) and it accidentally gets replaced during \( \varphi[\theta_{k-1} \mapsto \rho_{k-1}][\theta_k \mapsto \rho_k] \).

    Define
    \begin{equation*}
      \cat{Bound} \coloneqq \bfop{Var}(\rho_1) \cup \ldots \cup \bfop{Var}(\rho_n).
    \end{equation*}
    and, for each variable \( P_k \) in \( \cat{Bound} \), pick a variable \( Q_k \) from \( \bfop{Prop} \setminus \bfop{Bound} \). Let \( m \) be the \hyperref[def:cardinal]{cardinality} of \( \bfop{Bound} \). The simultaneous substitution can now be defined as
    \begin{align*}
      \varphi[\theta_1 \mapsto \rho_1, \ldots, \theta_n \mapsto \rho_n] \coloneqq \varphi
      [\theta_1 \mapsto \rho_1[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      \vdots \hspace{3cm} \\
      [\theta_n \mapsto \rho_n[P_1 \mapsto Q_1, \ldots, P_m \mapsto Q_m]] \\
      [Q_1 \mapsto P_1, \ldots, Q_m \mapsto P_m].
    \end{align*}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:propositional_substitution_equivalence}
  If \( \theta \) is a subformula of \( \varphi \) and if \( \theta \gleichstark \rho \), then
  \begin{equation}\label{eq:thm:propositional_substitution_equivalence}
    \varphi[\theta \mapsto \rho] \gleichstark \varphi.
  \end{equation}

  By induction, this also holds for \hyperref[def:propositional_substitution/simultaneous]{simultaneous substitution}.
\end{proposition}
\begin{proof}
  We use structural induction\IND on \( \varphi \):

  \begin{itemize}
    \item If \( \varphi = \theta \), then \( \varphi[\theta \mapsto \rho] = \rho \) and, by definition,
    \begin{equation*}
      \varphi = \theta \gleichstark \rho = \varphi[\theta \mapsto \rho].
    \end{equation*}

    \item If \( \varphi \in \set{ \top, \bot } \cup \bfop{Prop} \), then \( \varphi[\theta \mapsto \rho] = \varphi \) and \eqref{eq:thm:propositional_substitution_equivalence} again holds trivially.

    \item If \( \varphi = \neg \rho \) and if the inductive conjecture holds for \( \rho \), then \( \varphi[\theta \mapsto \rho] = \neg \psi[\theta \mapsto \rho] \). For any interpretation \( I \),
    \begin{equation*}
      \parens[\Big]{ \varphi[\theta \mapsto \rho] }\Bracks{I}
      =
      \overline{\parens[\Big]{ \psi[\theta \mapsto \rho] }\Bracks{I}}
      \overset {\IndHyp} =
      \overline{\psi\Bracks{I}}
      =
      \varphi\Bracks{I}.
    \end{equation*}

    Therefore \eqref{eq:thm:propositional_substitution_equivalence} holds in this case.

    \item If \( \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma \) and if the inductive conjecture holds for both \( \psi_1 \) and \( \psi_2 \), then for any interpretation \( I \),
    \begin{equation*}
      \parens[\Big]{ \varphi[\theta \mapsto \rho] }\Bracks{I}
      =
      \parens[\Big]{ \psi_1[\theta \mapsto \rho] }\Bracks{I} \circ \parens[\Big]{ \psi_2[\theta \mapsto \rho] }\Bracks{I}
      \overset {\IndHyp} =
      \psi_1\Bracks{I} \circ \psi_2\Bracks{I}
      =
      \varphi\Bracks{I}.
    \end{equation*}

    Therefore \eqref{eq:thm:propositional_substitution_equivalence} holds in this case also.
  \end{itemize}

  We have verified that \eqref{eq:thm:propositional_substitution_equivalence} holds in all cases.
\end{proof}

\begin{remark}\label{rem:smaller_propositional_language}
  For \hyperref[def:propositional_semantics]{semantical} concepts, it is immaterial which element of an equivalence class we consider. \hyperref[def:boolean_closure]{Complete sets of Boolean operations} allow us to represent each formula using a strict subset of the \hyperref[def:propositional_language/constants]{propositional constants}, \hyperref[def:propositional_language/negation]{negation} and \hyperref[def:propositional_language/connectives]{connectives}. \Fullref{ex:posts_completeness_theorem} shows some concrete commonly used complete sets of Boolean operations. This is useful in certain syntactic manipulations, however it is also useful in \hyperref[def:propositional_semantics/satisfiability]{satisfiability} proofs that rely on \hyperref[rem:induction]{structural induction} because it allows us to consider less cases in the induction.

  See the \hyperref[def:conjunctive_disjunctive_normal_form]{conjunctive normal form} for a concrete example.
\end{remark}

\begin{definition}\label{def:conjunctive_disjunctive_normal_form}
  \hfill
  \begin{thmenum}
    \ilabel{def:conjunctive_disjunctive_normal_form/literal} A \term{literal} is either a propositional variable \( L = P \) or a negation \( L = \neg P \) of a propositional variable.

    \ilabel{def:conjunctive_disjunctive_normal_form/normal_form} A propositional formula \( \varphi \) is in \term{conjunctive normal form} (resp. \term{disjunctive normal form}) if \( \varphi \) is a finite conjunction of disjunctions (resp. finite disjunction of conjunctions) of literals. That is, if \( \varphi \) is in conjunctive normal form, it has the form
    \begin{equation*}
      (L_{1,1} \vee \ldots \vee L_{1,n_1}) \wedge \cdots \wedge (L_{k,1} \vee \ldots \vee L_{k,n_k}).
    \end{equation*}

    \ilabel{def:conjunctive_disjunctive_normal_form/conjunct_disjunct} A \term{disjunct} (resp. a \term{conjunct}) is a set of literals, the difference between the two being the context in which they are used. To each formula in conjunctive normal form there corresponds a set of disjuncts and to each formula in disjunctive normal form there corresponds a set of conjuncts.
  \end{thmenum}
\end{definition}

\begin{algorithm}\label{alg:conjunctive_normal_form_reduction}
  Let \( \varphi \) be any formula. We explicitly derive a formula in conjunctive normal form that is \hyperref[def:propositional_semantics/equivalence]{semantically equivalent} to \( \varphi \). In a software implementation, we can easily construct an efficient recursive procedure based on the following steps.

  \begin{thmenum}
    \ilabel{alg:conjunctive_normal_form_reduction/constants} Pick any variable \( P \) and substitute
    \begin{align*}
      \top \T{with} P \vee \neg P, && \bot \T{with} P \wedge \neg P
    \end{align*}
    to get rid of the \hyperref[def:propositional_language/constants]{propositional constants}.

    \ilabel{alg:conjunctive_normal_form_reduction/iff} For any subformulas \( \psi \) and \( \theta \) of \( \varphi \), perform the substitution
    \begin{equation*}
      \psi \leftrightarrow \theta \T{with} (\psi \to \theta) \wedge (\theta \to \psi)
    \end{equation*}
    to get rid of \hyperref[def:propositional_language/connectives/equivalence]{equivalence connectives}. Semantic equivalence with \( \varphi \) is then justified by \fullref{thm:boolean_equivalences/equivalence_via_implication}.

    \ilabel{alg:conjunctive_normal_form_reduction/implies} For any subformulas \( \psi \) and \( \theta \) of \( \varphi \), perform the substitution
    \begin{equation*}
      \psi \to \theta \T{with} \neg \psi \vee \theta.
    \end{equation*}
    to get rid of \hyperref[def:propositional_language/connectives/implication]{implications}. Equivalence with \( \varphi \) is justified by \fullref{thm:boolean_equivalences/implication_cnf}.

    \ilabel{alg:conjunctive_normal_form_reduction/de_morgan} For any subformulas \( \psi \) and \( \theta \) of \( \varphi \), use \fullref{thm:de_morgans_laws} to justify the substitution
    \begin{align*}
      \neg(\psi \vee \theta) \T{with} \neg \psi \wedge \neg \theta
      &&
      \neg(\psi \wedge \theta) \T{with} \neg \psi \vee \neg \theta.
    \end{align*}

    In order to ensure that \hyperref[def:propositional_language/negation]{negation} is only present before propositional variables, repeat \ref{alg:conjunctive_normal_form_reduction/de_morgan} until nothing is substituted anymore.

    \ilabel{alg:conjunctive_normal_form_reduction/double_negation} For any variable \( P \) of \( \varphi \), use \fullref{thm:boolean_algebra_properties/double_complement} to justify the substitution
    \begin{equation*}
      \neg \neg P \T{with} P.
    \end{equation*}

    \ilabel{alg:conjunctive_normal_form_reduction/distributivity} Finally, for any subformulas \( \psi \), \( \theta \) and \( \rho \) of \( \varphi \), use \hyperref[eq:def:distributive_lattice/distributivity]{distributivity} of \( \wedge \) over \( \vee \) to justify the substitution
    \begin{equation*}
      \psi \vee (\theta \wedge \rho) \T{with} (\psi \vee \theta) \wedge (\theta \vee \rho).
    \end{equation*}

    In order to ensure that conjunction is always one level higher than disjunction, repeat \ref{alg:conjunctive_normal_form_reduction/distributivity} until nothing is substituted anymore.
  \end{thmenum}

  The resulting formula is in conjunctive normal form. By \fullref{thm:propositional_substitution_equivalence}, it is equivalent to \( \varphi \).
\end{algorithm}
