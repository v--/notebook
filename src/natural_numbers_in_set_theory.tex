\subsection{Natural numbers in set theory}\label{subsec:natural_numbers_in_set_theory}

\begin{theorem}[Recursion theorem]\label{thm:omega_recursion}\mcite[73]{Enderton1977Sets}
  Let \( A \) be a nonempty set. Suppose that we are given some member \( a_0 \) of \( A \) and some function \( F: A \to A \). Then there exists a unique function \( f: \omega \to A \) such that
  \begin{itemize}
    \item \( f(\varnothing) = a_0 \).
    \item For every \( n \in \omega \) we have \( f(\op{succ}(n)) = F(f(n)) \).
  \end{itemize}

  Note that \( f \) is actually a \hyperref[def:sequence]{sequence}. We have not yet defined natural numbers within \logic{ZFC}, however, and this theorem is important for being able to do so. So we avoid talking about sequences to avoid circularity.
\end{theorem}
\begin{proof}
  Let \( G \subseteq \pow(\omega \times A) \) be the set of all \hyperref[def:partial_function]{partial single-valued functions} \( g: \omega \to A \) such that
  \begin{itemize}
    \item If \( g \) is defined at \( \varnothing \), then \( g(\varnothing) = a_0 \).
    \item For every \( n \in \omega \), if \( g \) is defined at \( \op{succ}(n) \), then \( g \) is also defined at \( n \) and
    \begin{equation*}
      g(\op{succ}(n)) = F(f(n)).
    \end{equation*}
  \end{itemize}

  Clearly \( G \) is nonempty because the function \( \set{ (\varnothing, a_0) } \) belongs to \( G \).

  The conditions imposed on the functions in \( G \) ensure that every function is defined in some \hyperref[def:poset_interval/ray]{initial segment} of the natural numbers. A more obvious approach is to require \( g \) to be defined at \( \op{succ}(n) \) if it is defined at \( n \), however we are trying to prove that such a function exists in the first place.

  Define \( f \coloneqq \bigcup G \). At this point \( f \) is a \hyperref[def:multi_valued_function]{multi-valued function}. We must now show that \( f \) has all the properties that we want.

  \SubProofOf[def:multi_valued_function/total]{totality} First, we will show that \( f \) is total. Clearly \( \varnothing \in \dom f \).

  Now fix \( n \in \dom f \) and let \( g \) be a function defined at \( n \).

  \begin{itemize}
    \item If \( g \) is defined at \( \op{succ}(n) \) also, this directly proves that \( \op{succ}(n) \in \dom f \).
    \item If \( g \) is not defined at \( \op{succ}(n) \), consider
    \begin{equation*}
      \widehat g \coloneqq g \cup \set{ (\op{succ}(n), F(g(n)) }.
    \end{equation*}

    The function \( \widehat g \) is again single-valued and it belongs to \( G \), hence \( \op{succ}(n) \in \dom f \).
  \end{itemize}

  We have now shown that \( \dom f \) is an inductive set and since it is contained in the smallest inductive set, it must coincide with it. On other words, \( f: \omega \multto A \) is total.

  \SubProofOf[def:function]{single-valuedness} Now that we know that \( f \) is total, we will prove that it is single-valued and thus is a function in the usual sense of the term.

  Denote by \( S \subseteq \omega \) the set for which \( f \) is single-valued. Clearly \( \varnothing \in S \).

  Now suppose that \( n \in S \) for some \( S \). Since \( f \) is total, there exist at least one partial function in \( G \) that is defined at \( \op{succ}(n) \), from which it follows that it is also defined at \( n \). Let \( g \) and \( h \) be such functions.

  Then
  \begin{equation*}
    g(\op{succ}(n)) = F(g(n)) = F(f(n)) = F(h(n)) = h(\op{succ}(n)),
  \end{equation*}
  hence \( g \) and \( h \) coincide at \( \op{succ}(n) \), which in turn implies that \( \op{succ}(n) \in S \).

  Thus \( S \) is inductive and since \( S \subseteq \omega \), it follows that \( S = \omega \) and that \( f \) is single-valued.

  \SubProofOf[def:function]{uniqueness} Now that it is clear that \( f \) satisfies the theorem, we must verify that it is unique.

  Suppose that \( f_1 \) and \( f_2 \) both satisfy the theorem and let
  \begin{equation*}
    H \coloneqq \set{ n \in \omega \given f_1(n) = f_2(n) }.
  \end{equation*}

  Clearly \( \varnothing \in H \). Fix some \( n \neq \varnothing \) and suppose that \( n \in H \). Then
  \begin{equation*}
    f_2(\op{succ}(n)) = F(f_1(n)) = F(f_2(n)) = f_2(\op{succ}(n)),
  \end{equation*}
  hence \( \op{succ}(n) \in H \).

  Therefore \( H \) is inductive and \( H = \omega \), which in turn implies that \( f_1 = f_2 \). So there is at most one function that satisfies the theorem and we have already shown that \( f \) is such a function.
\end{proof}

\begin{example}\label{ex:thm:omega_recursion}
  \Fullref{thm:omega_recursion} may not seem very powerful at first glance but we should note that we have put no restrictions on \( A \) except for it being nonempty. Let \( A = \pow(\omega \times \omega) \), i.e. the set of all relations over \( \omega \).

  \begin{thmenum}
    \thmitem{ex:thm:omega_recursion/omega_addition} Define
    \begin{equation*}
      \begin{aligned}
        &F: A \to A \\
        &F(R) \coloneqq R \cup \set{ (n, \op{succ}(m), \op{succ}(k)) \given (n, m, k) \in R }
      \end{aligned}
    \end{equation*}

    Now we use the initial point \( a_0 = (\omega, \varnothing, \omega) \) to construct a binary function \( \oplus \) that is used in \fullref{thm:omega_is_model_of_pa} to define natural number addition.

    \thmitem{ex:thm:omega_recursion/omega_multiplication} Similarly, we define natural number multiplication \( \odot \) using
    \begin{equation*}
      \begin{aligned}
        &F: A \to A \\
        &F(R) \coloneqq R \cup \set{ (n, \op{succ}(m), k \oplus n) \given (n, m, k) \in R }
      \end{aligned}
    \end{equation*}
    and \( a_0 = (\omega, \varnothing, \varnothing) \).
  \end{thmenum}
\end{example}

\begin{theorem}\label{thm:omega_is_model_of_pa}
  The \hyperref[thm:smallest_inductive_set_existence]{smallest inductive set \( \omega \)} is a model of \hyperref[def:peano_arithmetic]{Peano arithmetic} with the following interpretation:
  \begin{thmenum}
    \thmitem{thm:omega_is_model_of_pa/zero} \hyperref[def:peano_arithmetic/zero]{Zero} is interpreted as \( \varnothing \).

    \thmitem{thm:omega_is_model_of_pa/succ} The \hyperref[def:peano_arithmetic/succ]{successor} operation \( s \) is interpreted as \( \op{succ} \).

    \thmitem{thm:omega_is_model_of_pa/plus} \hyperref[def:peano_arithmetic/plus]{Addition} is interpreted by the \( \oplus \) function given in \fullref{ex:thm:omega_recursion/omega_addition}.

    \thmitem{thm:omega_is_model_of_pa/mult} Similarly, \hyperref[def:peano_arithmetic/mult]{multiplication} is interpreted by \( \odot \) from \fullref{ex:thm:omega_recursion/omega_multiplication}.
  \end{thmenum}
\end{theorem}
\begin{proof}
  \SubProofOf{eq:def:peano_arithmetic/PA1} Let \( n, m \in \omega \) and suppose that \( \op{succ}(n) = \op{succ}(m) \).

  Aiming at a contradiction, suppose that \( n \neq m \). Then \( n \in \op{succ}(m) = m \cup \set{ m } \) and since \( n \neq m \) it is only possible that \( n \in m \). We can analogously prove, however, that \( m \in n \). This mutual containment contradicts \fullref{thm:simple_foundation_theorems/no_mutual_containment}.

  Therefore \( n = m \).

  \SubProofOf{eq:def:peano_arithmetic/PA2} Suppose that \( \varnothing \) has a predecessor \( n \in \omega \). Then
  \begin{equation*}
    \varnothing = \op{succ}(n) = n \cup \set{ n },
  \end{equation*}
  which implies that \( n \in \varnothing \). But this is contradicts the \hyperref[def:empty_set]{definition of \( \varnothing \)}.

  Therefore \( \varnothing \) has no predecessor.

  \SubProofOf{eq:def:peano_arithmetic/PA3} We have already shown in \fullref{thm:omega_induction} that the induction schema \eqref{eq:def:peano_arithmetic/PA3} is satisfied by \( \omega \).

  \SubProofOf{eq:def:peano_arithmetic/PA4} The starting condition, i.e. \( a_0 \), in \fullref{thm:omega_is_model_of_pa/plus} implies that \( n \oplus 0 = n \) for all \( n \in \omega \).

  \SubProofOf{eq:def:peano_arithmetic/PA5} The iteration function \( F \) in \fullref{thm:omega_is_model_of_pa/plus} implies that \( n \oplus \op{succ}(m) = \op{succ}(n \oplus m) \) for all \( n, m \in \omega \).

  \SubProofOf{eq:def:peano_arithmetic/PA6} Handled analogously to \( \oplus \).

  \SubProofOf{eq:def:peano_arithmetic/PA7} Handled analogously to \( \oplus \).
\end{proof}

\begin{remark}\label{rem:natural_number_availability_zfc}
  Thanks to \fullref{thm:omega_is_model_of_pa}, we now have at our disposal the toolkit of the \hyperref[def:natural_numbers]{natural numbers} described in \fullref{subsec:natural_numbers}.

  We will now list some important definition that we have postponed because natural numbers were not yet available.
\end{remark}

\begin{definition}\label{def:sequence}
  A \term{sequence} is an \hyperref[def:indexed_family]{indexed family} whose domain \( \mscrK \) is the set of natural numbers \( \BbbN \). As explained in \fullref{rem:peano_arithmetic_zero}, outside of \logic{PA} we usually prefer to exclude zero, hence our sequences will actually be defined only on \( \BbbN \setminus \set{ 0 } \).

  We say that \( \seq{ A_{k_m} }_{k=1}^\infty \) is a \term{subsequence} of \( \seq{ A_k }_{k=1}^\infty \) if the sequence \( \seq{ k_m }_{k=1}^\infty \) of natural numbers is strictly monotone.

  Subsequences of \( \seq{ A_k }_{k=1}^\infty \) are usually denoted by adding another index as a subscript, i.e. \( \seq{ x_{k_m} }_{k=1}^\infty \).
\end{definition}

\begin{definition}\label{def:cartesian_product}
  As promised in \fullref{rem:binary_vs_arbitrary_tuples}, we will define the Cartesian products for an arbitrary indexed family of sets.

  Let \( \seq{ A_k }_{k \in \mscrK} \) be a nonempty \hyperref[def:indexed_family]{indexed family} of sets. Their \term{Cartesian product} is
  \begin{equation}\label{eq:def:cartesian_product}
    \bigtimes_{k \in \mscrK} A_k \coloneqq \set*{ f: \mscrK \to \bigcup_{k \in \mscrK} A_k \given* \qforall{m \in \mscrK} f(m) \in A_m }.
  \end{equation}

  The definition also makes sense when any of the sets is empty because the product itself is then empty.

  Any element of the Cartesian product is called a \term{tuple}.

  If \( \mscrK \) is the set \( \set{ 1, \ldots, n } \) for some natural number \( n \), we usually write the product using \hyperref[rem:first_order_formula_conventions/infix]{infix notation}, i.e. \( A_1 \times \cdots \times A_n \) and the tuples as \( (a_1, \ldots, a_n) \). Finite tuples are sometimes called \term{finite sequences}.

  If \( n = 2 \), the notion of a general Cartesian product coincides with the notion of a \hyperref[def:binary_cartesian_product]{binary Cartesian product}. Clearly the Kuratowski pair
  \begin{equation*}
    (A, B) = \set[\Big]{ \set{ A }, \set{ A, B } }
  \end{equation*}
  is different from the generalized tuple
  \begin{equation*}
    (A, B) = \set[\Bigg]{ \set[\Big]{ \set{ 1 }, \set{ 1, A } }, \set[\Big]{ \set{ 2 }, \set{ 2, B } } }.
  \end{equation*}

  They are bijective, however, and we conflate the two notions because it is conventional to do so. We just as well conflate the products \( A \times B \times C \) and \( (A \times B) \times C \) since the binary Cartesian product is \hyperref[def:magma/associative]{associative}.
\end{definition}

\begin{definition}\label{def:relation}
  We can now use arbitrary Cartesian products to define arbitrary relations. Let \( A_1, \ldots, A_n \) be a tuple of sets and let
  \begin{equation*}
    R \subseteq A_1 \times \cdots \times A_n
  \end{equation*}
  be a subset of their \hyperref[def:cartesian_product]{Cartesian product}.

  The pair \( (R,  (A_1, \ldots, A_n)) \) is called an \( n \)-ary \term{relation}. We say that the tuple \( (x_1, \ldots, x_n) \in A_1 \times \cdots \times A_n \) is related with respect to \( R \).

  Relations are the semantical counterpart to \hyperref[def:first_order_structure/interpretation/predicate]{first-order predicates} and are equivalent to Boolean-valued functions (see \fullref{rem:boolean_valued_functions_and_predicates}).

  We generalize only the following notions from \hyperref[def:binary_relation]{binary relations}:
  \begin{thmenum}[series=def:relation]
    \thmitem{def:relation/graph} The set \( R \) of tuples is called the \term{graph} of the relation.
    \thmitem{def:relation/signature} The \term{signature} of the relation is the tuple \( (A_1, \ldots, A_n) \).
  \end{thmenum}

  We also introduce some new concepts:
  \begin{thmenum}[resume=def:relation]
    \thmitem{def:relation/arity} For some small values of \( n \), \( n \)-ary relations have established names:
    \begin{itemize}
      \item \term{Nullary} if \( n = 0 \).
      \item \term{Unary} if \( n = 1 \).
      \item \term{Binary} if \( n = 2 \).
      \item \term{Ternary} if \( n = 3 \).
    \end{itemize}

    This is not to be confused with \hyperref[def:function_arity]{function arity} --- functions are always binary relations.

    \thmitem{def:relation/single_set} If all \( A_k \) are equal to the set \( A \), we say that \( R \subseteq A^k \) is a relation \hi{on \( A \)}.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:function_arguments}
  As mentioned in \fullref{def:multi_valued_function/value}, given a function \( f: A \to B \), we sometimes use the notation \( f(x) \) where \( x \) is a free variable.

  If \( A = A_1 \times \cdots \times A_n \) is a \hyperref[def:binary_cartesian_product]{finite Cartesian product} of other sets, we instead use the notation \( f(x_1, \ldots, x_n) \) and regard \( x_1, \ldots, x_n \) as free variables that have no assigned value. The number of arguments is called the function \term{arity} (not to be confused with \hyperref[def:relation/arity]{relation arity}).

  These variables are called \term{arguments} or sometimes \term{parameters}, although the latter term is a bit overloaded. This notion is somewhat informal and depends on the context since \( A \) can usually be represented as a Cartesian product in different ways and with different arities. For example, if \( A = B \times C \), we can write both \( f(a) \) and \( f(b, c) \) and the function has a different number of parameters in each case. In practice the number of arguments is usually clear from the context. We sometimes use \( \overrightarrow{a} \) when we regard \( a \) as a tuple.

  For example, in \hyperref[def:first_order_semantics]{classical first-order semantics}, to each \( n \)-ary functional symbol there corresponds an \( n \)-ary function with the unambiguous signature \( X^n \to X \).

  When working over a vector space like \( \BbbR^2 \), on the other side, depending on the context we regard \hyperref[rem:functional]{functionals} as either unary or binary functions.

  We sometimes refer to \( f \) as a \term{dependent variable} since it depends on its arguments. In this later case, we call the arguments \term{independent variables}.
\end{definition}

\begin{definition}\label{def:superposition}
  Although the terms \enquote{composition} and \enquote{superposition} are used interchangeably (for example in \cite[\textnumero 25]{Фихтенгольц1968Том1}), \enquote{superposition} often refers to a certain generalization of \hyperref[def:multi_valued_function]{composition}{function composition}.

  If we are given the functions \( f_k: A \multto B_k, k = 1, \ldots, n \) and \( g: B_1 \times \cdots \times B_n \multto C \), their \term{superposition} \( h: A \multto C \) is
  \begin{equation*}
    h(x) \coloneqq g(f_1(x), \ldots, f_n(x)).
  \end{equation*}
\end{definition}

\begin{definition}\label{def:currying}
  Given the \hyperref[def:multi_valued_function/arity]{two-argument} function \( f: A \times B \to C \), we can define another function \( g: A \to \fun(B, C) \) as
  \begin{equation*}
    g(x) \coloneqq (y \mapsto f(x, y)).
  \end{equation*}

  This process is called \term{currying} after Haskell Curry.

  Currying is useful if we have somehow fixed a value \( x_0 \in A \), in which case we can \enquote{get rid} of one argument by introducing some shortcut for the function \( g(x_0): B \to C \) for the sake of reducing notational clutter. See \fullref{def:differentiability/first_variation} for an example of how this can be used in the wild.
\end{definition}
