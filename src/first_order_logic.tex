\subsection{First-order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_logic_alphabet}\MarginCite[187]{OpenLogic20201202}
  The idea of first-order predicate logic is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universum. Unlike in \hyperref[subsec:propositional_logic]{propositional logic}, there are many first-order logic languages.

  The alphabet for a \Def{first-order predicate logic \hyperref[def:language]{language}} \( \CL \) extends that of \hyperref[subsec:propositional_logic]{propositional logic} and consists of two types of symbols.

  \begin{description}
    \item[Logical symbols]\mbox{}
    \begin{DefEnum}[series=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/propositional} The entirety of the \hyperref[subsec:propositional_logic]{propositional logic alphabet}.

      \ILabel{def:first_order_logic_alphabet/var} A countable alphabet of variables \( \Bold{Var} \), usually denoted by \( \xi_1, \xi_2, \ldots \) or \( \xi, \eta, \zeta \).

      \ILabel{def:first_order_logic_alphabet/quantifiers} The quantifiers \( Q = \Set{ \forall, \exists } \):
      \begin{DefEnum}
        \ILabel{def:first_order_logic_alphabet/quantifiers/universal} The \Def{universal quantifier} \( \forall \).
        \ILabel{def:first_order_logic_alphabet/quantifiers/existential} The \Def{existential quantifier} \( \exists \).
        \ILabel{def:first_order_logic_alphabet/quantifiers/dot} The dot \( \centerdot \) for separating a quantifier from its formula. The dot itself is not itself a quantifier. This is not formally necessary and we use it only for readability.
      \end{DefEnum}

      \ILabel{def:first_order_logic_alphabet/equality} Optionally, an equality symbol \( \doteq \). See \fullref{remark:first_order_equality}.
    \end{DefEnum}

    \item[Non-logical symbols]\mbox{}
    \begin{DefEnum}[resume=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/func} A set of functional symbols, \( \Bold{Fun} \), whose elements are usually denoted by \( f_1, f_2, \ldots \) or \( f, g, h \) or by symbols lie \( \oplus \), in which case we use infix notation. Each functional symbol has an associated natural number called its \Def{arity}, denoted by \( \# f \). Functional symbols with a zero arity are called \Def{constants}.

      \ILabel{def:first_order_logic_alphabet/pred} A set of predicate symbols, \( \Bold{Pred} \), whose elements are usually denoted by \( p_1, p_2, \ldots \) or by symbols like \( \leq \), in which case we use infix notation. Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \Def{propositional variables}.
    \end{DefEnum}
  \end{description}
\end{definition}

\begin{definition}\label{def:first_order_language}\mbox{}
  \begin{DefEnum}
    \ILabel{def:first_order_language/grammar} Consider the following \hyperref[def:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}        {v \in \Bold{Var}} \\
      \bnfprod{connective}      {\circ \in \Sigma} \\
      \bnfprod{quantifier}      {\bnfts{\( \forall \)} \bnfor \bnfts{\( \exists \)}} \\
      \bnfprod{unary function}  {f \in \Bold{Fun}, \#f = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary function}  {f \in \Bold{Fun}, \#f = n \text{ (separate rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{unary predicate} {p \in \Bold{Pred}, \#p = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary predicate} {p \in \Bold{Pred}, \#p = n \text{ (separate rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{term}            {\bnfpn{variable} \bnfor} \\
      \bnfmore                  {\bnfpn{unary function} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary function} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{atomic formula}  {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{\( \doteq \)} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{unary predicate} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary predicate} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{formula}         {\bnfpn{atomic formula} \bnfor} \\
      \bnfmore                  {\bnfts{\neg} \bnfpn{formula} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{quantifier} \bnfsp \bnfpn{variable} \bnfsp \bnfts{\( \centerdot \)} \bnfsp \bnfpn{formula}}
    \end{bnf*}

    In practice, we usually only have functions or predicates of specific arities. Note that we can have infinitely many functions but only finitely many different arities. The \hyperref[remark:theory_of_left_monoid_actions]{theory of monoid actions} is an example of a first-order language with infinitely many unary functional symbols, one constant and one binary functional symbol.

    If we need the grammars to have a finite set of rules, except for having only finitely many different arities, we need to introduce appropriate naming conventions for variables, functions and predicates, analogously to \fullref{ex:natural_arithmetic_grammar/backus_naur_form}.

    We will be using the conventions in \fullref{remark:propositional_formula_parentheses} by extending it for outer parentheses around equality formulas.

    \ILabel{def:first_order_language/term}\MarginCite[189]{OpenLogic20201202}The set \( \CT \) of \Def{terms} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{term} \) as a starting rule.

    The grammar of first-order terms is unambiguous by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    \ILabel{def:first_order_language/subterm} If \( \tau \) and \( \kappa \) are terms and \( \kappa \) is a \hyperref[def:language/subword]{subword} of \( \tau \), we say that \( \kappa \) is a \Def{subterm} of \( \tau \).

    \ILabel{def:first_order_language/term_variables} For each term \( \tau \), we define its variables as
    \begin{equation}\label{eq:def:first_order_language/term_variables}
      \Bold{Var}(\tau) \coloneqq \begin{cases}
        \xi,                                                    &\tau = \xi \in \Bold{Var},        \\
        \Bold{Var}(\tau_1) \cup \ldots \cup \Bold{Var}(\tau_n), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    As in \fullref{def:propositional_language/variables}, \( \Bold{Var} \) is ordered by the position of the first occurrence of a variable.

    \ILabel{def:first_order_language/formula} The set \( \CF \) of \Def{formulas} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{formula} \) as a starting rule.

    The \Def{atomic formulas} are the ones generated from \( \bnfpn{atomic formula} \).

    The grammar of first-order formulas is unambiguous by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    See \fullref{ex:first_order_substitution} for examples of formulas.

    \ILabel{def:first_order_language/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \Def{subformula} of \( \varphi \).

    \ILabel{def:first_order_language/formula_terms} If \( \varphi \) is a formula, if \( \tau \) is a term and if \( \tau \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \tau \) is a \Def{term} of \( \varphi \).

    \ILabel{def:first_order_language/formula_free_variables} The \Def{free variables} of a formula are defined as
    \begin{equation}\label{eq:def:first_order_language/formula_free_variables}
      \Bold{Free}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                            &\varphi \in \Set{ \top, \bot } \\
        \Bold{Var}(\tau_1) \cup \ldots \cup \Bold{Var}(\tau_n), &\varphi = p(\tau_1, \ldots, \tau_n) \\
        \Bold{Var}(\tau_1) \cup \Bold{Var}(\tau_2),             &\varphi = \tau_1 \doteq \tau_2, \\
        \Bold{Free}(\psi),                                      &\varphi = \neg \psi, \\
        \Bold{Free}(\psi_1) \cup \Bold{Free}(\psi_2),           &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \Bold{Free}(\psi) \setminus \{ \xi \},                  &\varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists }
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_language/formula_bound_variables} Dually, the \Def{bound variables} of a formula are defined as
    \begin{equation}\label{eq:def:first_order_language/formula_bound_variables}
      \Bold{Bound}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                    &\varphi \text{ is atomic}, \\
        \Bold{Bound}(\psi),                             &\varphi = \neg \psi, \\
        \Bold{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2), &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \Bold{Bound}(\psi) \cup \{ \xi \},              &\varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists }.
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_language/formula_variables} Finally, the set of all variables of a formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_language/formula_variables}
      \Bold{Var}(\varphi) \coloneqq \Bold{Free}(\varphi) \cup \Bold{Bound}(\varphi).
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{proposition}\label{thm:first_order_terms_and_formulas_are_unambiguous}
  The grammars of \hyperref[def:first_order_language/term]{first-order terms} and of \hyperref[def:first_order_language/formula]{first-order formulas} are \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \fullref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{definition}\label{def:first_order_structure}\MarginCite[def. 14.27]{OpenLogic20201202}
  Fix a first-order logic language \( \CL \). A \Def{structure} \( \CA \) for \( \CL \) is a pair \( (A, I) \), where

  \begin{DefEnum}
    \ILabel{def:first_order_structure/set} \( A \) is a nonempty set called the \Def{universum} of \( \CA \).

    \ILabel{def:first_order_structure/interpretation} \( I \) is a \hyperref[def:function]{map} called the \Def{interpretation} of \( \CA \) that we define partially as
    \begin{DefEnum}
      \ILabel{def:first_order_structure/interpretation/equality} The interpretation \( I(\doteq) \) of the equality is a \hyperref[def:binary_relation]{binary relation} on \( A \).

      \ILabel{def:first_order_structure/interpretation/function} For every \( n \)-ary function symbol \( f \), its interpretation is a \hyperref[def:function]{function} of type \( I(f): A^n \to A \).

      \ILabel{def:first_order_structure/interpretation/predicate} For every \( n \)-ary predicate \( p \), its interpretation is a an n-ary \hyperref[def:relation]{relation} \( I(p) \subseteq A^n \). This relation corresponds to all tuples of values that satisfy the predicate within the structure.
    \end{DefEnum}
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_valuation}
  Fix a structure \( \CA = (A, I) \) for a first-order logic language \( \CL \).

  \begin{DefEnum}
    \ILabel{def:first_order_valuation/variable_assignment} A \Def{variable assignment} for the variables of \( \CL \) is any function \( v: \Bold{Var} \to A \) (loosely similar to \hyperref[def:propositional_valuation/interpretation]{propositional interpretations}).

    \ILabel{def:first_order_valuation/modified_assignment} For every variable \( \xi \) and every universum element \( a \in A \) we also define the \Def{modified assignment} at \( \xi \) with \( a \):
    \begin{equation*}
      v_a^\xi(\eta) \coloneqq \begin{cases}
        a,    &\eta = \xi, \\
        v(\eta), &\eta \neq \xi.
      \end{cases}
    \end{equation*}

    Inductively\IND,
    \begin{equation*}
      v_{a_1, \ldots, a_n}^{\xi_1, \ldots, \xi_n}(\eta) \coloneqq ((v_{a_1}^{\xi_1})_{a_2}^{\xi_2})\cdots_{a_n}^{\xi_n}(\eta).
    \end{equation*}

    \ILabel{def:first_order_valuation/term_valuation} The \Def{valuation} of a term \( \tau \) is a value in the universum \( A \) given by
    \begin{equation}\label{eq:def:first_order_valuation/term_valuation}
      \tau\Val{v} \coloneqq \begin{cases}
        v(\xi),                                     &\tau = \xi \in \Bold{Var}, \\
        I(f)(\tau_1\Val{v}, \ldots, \tau_n\Val{v}), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_valuation/formula_valuation} The \Def{valuation} of a formula \( \varphi \) is a Boolean value (see \fullref{def:propositional_valuation}) given by
    \begin{equation}\label{eq:def:first_order_valuation/formula_valuation}
      \varphi\Val{v} \coloneqq \begin{cases}
        T,                                                         &\varphi = \top, \\
        F,                                                         &\varphi = \bot, \\
        (\tau_1\Val{v}, \tau_2\Val{v}) \in I(\doteq),              &\varphi = \tau_1 \doteq \tau_2, \\
        (\tau_1\Val{v}, \ldots, \tau_n\Val{v}) \in I(p),           &\varphi = p(\tau_1, \ldots, \tau_n), \\
        \Ol{\psi\Val{v}},                                          &\varphi = \neg \psi, \\
        \psi_1\Val{v} \circ \psi_2\Val{v},                         &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        T \T{iff} \psi[v_a^\xi] = T \T{for every} a \in A,         &\varphi = \forall \xi \psi, \\
        T \T{iff there exists} a \in A \T{s.t.} \psi[v_a^\xi] = T, &\varphi = \exists \xi \psi.
      \end{cases}
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_semantics}\MarginCite[208]{OpenLogic20201202}
  Fix a first-order logic language \( \CL \). We introduce notions analogous to \hyperref[def:propositional_semantics]{propositional semantics}:
  \begin{DefEnum}
    \ILabel{def:propositional_model/satisfiability} Given a \hyperref[def:first_order_structure]{structure} \( \CA = (A, I) \), a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) and a set \( \Gamma \) of \hyperref[def:first_order_language/formula]{first order formulas}, we say that the variable assignment \( v \) \Def{satisfies} \( \Gamma \) and we write \( \CA \vDash_v \Gamma \) if, for every formula \( \gamma \in \Gamma \) we have \( \gamma\Val{v} = T \).

    If every variable assignment in \( \CA \) satisfies \( \Gamma \), we say that \( \CA \) itself satisfies \( \Gamma \) or that \( \CA \) is a \Def{model} of \( \Gamma \) and write \( \CA \vDash \Gamma \).

    Analogously to \fullref{def:propositional_semantics/satisfiability}, we say that \( \Gamma \) is satisfiable if there exists a model for \( \Gamma \).

    \ILabel{def:propositional_model/entailment} We say that the set of formulas \( \Gamma \) \Def{entails} the set of formulas \( \Delta \) and write \( \Gamma \vDash \Delta \) if every model of \( \Gamma \) is also a model of \( \Delta \).

    \ILabel{def:propositional_model/tautology} The formula \( \varphi \) is a \Def{tautology} if every structure is a model of \( \varphi \).

    \ILabel{def:propositional_model/contradiction} Dually, \( \varphi \) is a \Def{contradiction} is no structure is a model of \( \varphi \).

    \ILabel{def:propositional_model/equivalence} We say that \( \varphi \) and \( \psi \) are \Def{semantically equivalent} and write \( \varphi \Sequiv \psi \) if both \( \varphi \vDash \psi \) and \( \psi \vDash \varphi \).
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_substitution}
  We define different kinds of (single) \Def{substitution} in as much generality as possible. Where applicable, \Def{simultaneous substitution} is defined via the same trick as in \fullref{def:propositional_substitution}.

  \begin{DefEnum}
    \ILabel{def:first_order_substitution/predicate} Let \( \varphi \) be a \hyperref[def:propositional_language/formula]{propositional formula} with variables \( \Bold{Var}(\varphi) = \Set{ P_1, \ldots, P_n } \). For brevity, denote \( V \coloneqq \Bold{Var}(\varphi) \). Let \( \Rho = \Set{ \rho_1, \ldots, \rho_n } \) be a set of \hyperref[def:first_order_language/formula]{first order formulas}.

    It does not make sense to replace a single propositional variable by a single formula. Furthermore, a first-order formula \( \rho_k \) cannot possibly contain any of the propositional variables \( P_1, \ldots, P_n \). We introduce a simplification of the simultaneous substitution based on \eqref{eq:def:propositional_substitution/single} as
    \begin{equation}\label{eq:def:first_order_substitution/predicate}
      \varphi[V \mapsto \Rho] \coloneqq \begin{cases}
        \varphi,                                             &\varphi \in \Set{ \top, \bot } \\
        \rho_k,                                              &\varphi = \rho_k \T{for some} k = 1, \ldots, n \\
        \neg \psi[V \mapsto \Rho],                           &\varphi = \neg \psi \\
        \psi_1[V \mapsto \Rho] \circ \psi_2[V \mapsto \Rho], &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma.
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_substitution/term_in_term} The substitution of the \hyperref[def:first_order_language/term]{first order term} \( \kappa \) with \( \mu \) in the term \( \tau \) is
    \begin{equation}\label{eq:def:first_order_substitution/term_in_term}
      \tau[\kappa \mapsto \mu] \coloneqq \begin{cases}
        \mu,                                                               &\tau = \kappa, \\
        \tau,                                                              &\tau \neq \kappa \T{and} \tau \in \Bold{Var}, \\
        f(\tau_1[\kappa \mapsto \mu], \ldots, \tau_n[\kappa \mapsto \mu]), &\tau \neq \kappa \T{and} \tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_substitution/term_in_formula} The substitution of the term \( \kappa \) with the term \( \mu \) in the first order formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_substitution/term_in_formula}
      \varphi[\kappa \mapsto \mu] \coloneqq \begin{cases}
        \varphi,                                                           &\varphi \in \Set{ \top, \bot }, \\
        p(\tau_1[\kappa \mapsto \mu], \ldots, \tau_n[\kappa \mapsto \mu]), &\varphi = p(\tau_1, \ldots, \tau_n), \\
        \tau_1[\kappa \mapsto \mu] \doteq \tau_2[\kappa \mapsto \mu],      &\varphi = \tau_1 \doteq \tau_2, \\
        \neg \psi[\kappa \mapsto \mu],                                     &\varphi = \neg \psi, \\
        \psi_1[\kappa \mapsto \mu] \circ \psi_2[\xi \mapsto \mu],          &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        (\Ast),                                                            &\varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists },
      \end{cases}
    \end{equation}
    where
    \begin{equation}\label{eq:def:first_order_substitution/term_in_formula/quantifiers}
      (\Ast) = \begin{cases}
        \varphi,                                                                     &\xi \in \Bold{Var}(\kappa), \\
        Q \xi \centerdot \Parens[\Big]{\psi[\kappa \mapsto \mu]},                    &\xi \not\in \Bold{Var}(\kappa) \cup \Bold{Var}(\mu), \\
        Q \eta \centerdot \Parens[\Big]{\psi[\xi \mapsto \eta][\kappa \mapsto \mu]}, &\xi \not\in \Bold{Var}(\kappa) \T{and} \xi \in \Bold{Var}(\mu) \T{and} \\
                                                                                     &\eta \not\in \Bold{Var}(\kappa) \cup \Bold{Var}(\mu) \cup \Bold{Var}(\psi).
      \end{cases}
    \end{equation}

    We implicitly assume that there exist enough variables in the language so that we can find \( \eta \) that satisfies the condition. See \fullref{ex:first_order_substitution} for examples of applying the different quantifier rules.

    The first rule may seem redundant but when doing inductive proofs, we usually need to separately consider the cases where \( \xi \in \Bold{Var}(\kappa) \) and \( \xi \not\in \Bold{Var}(\kappa) \setminus \Bold{Var}(\mu) \) and the first case being trivial simplifies the proofs.

    The third rule in \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers} is called \Def{renaming of the bound variables} \( \xi \) to \( \eta \) and is done to mitigate capturing as described in \fullref{remark:first_order_substitution_renaming_justification/capturing}.

    See \fullref{remark:first_order_substitution_parentheses} regarding the additional parentheses in \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers}.

    \ILabel{def:first_order_substitution/formula_in_formula} The substitution of the \hyperref[def:first_order_language/formula]{first order formula} \( \theta \) with the first order formula \( \rho \) in the first order formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_substitution/formula_in_formula}
      \varphi[\theta \mapsto \rho] \coloneqq \begin{cases}
        \rho,                                                       &\varphi = \theta, \\
        \varphi,                                                    &\varphi \neq \theta \T{and} \varphi \text{ is atomic}, \\
        \neg \psi[\theta \mapsto \rho],                             &\varphi \neq \theta \T{and} \varphi = \neg \psi, \\
        \psi_1[\theta \mapsto \rho] \circ \psi_2[\xi \mapsto \rho], &\varphi \neq \theta \T{and} \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        (\Ast),                                                     &\varphi \neq \theta \T{and} \varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists },
      \end{cases}
    \end{equation}
    where
    \begin{equation}\label{eq:def:first_order_substitution/formula_in_formula/quantifiers}
      (\Ast) = \begin{cases}
        \varphi,                                                                      &\xi \in \Bold{Free}(\theta), \\
        Q \xi \centerdot \Parens[\Big]{\psi[\theta \mapsto \rho]},                    &\xi \not\in \Bold{Free}(\theta) \cup \Bold{Free}(\rho), \\
        Q \eta \centerdot \Parens[\Big]{\psi[\xi \mapsto \eta][\theta \mapsto \rho]}, &\xi \not\in \Bold{Free}(\theta) \T{and} \xi \in \Bold{Free}(\rho) \T{and} \\
                                                                                      &\eta \not\in \Bold{Free}(\theta) \cup \Bold{Free}(\rho) \cup \Bold{Var}(\psi).
      \end{cases}
    \end{equation}

    The only difference in the substitutions \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers} and \eqref{eq:def:first_order_substitution/formula_in_formula/quantifiers} is that the first deals with terms and the second deals with formulas.
  \end{DefEnum}
\end{definition}

\begin{remark}\label{remark:first_order_substitution_renaming_justification}
  The rules in \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers} and \eqref{eq:def:first_order_substitution/formula_in_formula/quantifiers} are designed to mitigate the following two problems:

  \begin{RemEnum}
    \ILabel{remark:first_order_substitution_renaming_justification/capturing} Renaming mitigates \enquote{capturing} free variables as in
    \begin{equation*}
      \Parens[\Big]{ \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \eta \centerdot p(\eta, \eta)
    \end{equation*}
    by instead doing.
    \begin{equation*}
      \Parens[\Big]{ \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \zeta \centerdot p(\eta, \zeta).
    \end{equation*}

    Capturing happens when \( \xi \in \Bold{Free}(\rho) \) in \( \varphi[\theta \mapsto \rho] \) (or analogously for terms).

    \ILabel{remark:first_order_substitution_renaming_justification/colliding} Renaming mitigates \enquote{colliding} multiple bound variables as in
    \begin{equation*}
      \Parens[\Big]{ \forall \xi \centerdot \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \xi \centerdot \forall \eta \centerdot p(\eta, \eta)
    \end{equation*}
    by instead giving
    \begin{equation*}
      \Parens[\Big]{ \forall \xi \centerdot \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \zeta \centerdot \forall t \centerdot p(\zeta, t).
    \end{equation*}
  \end{RemEnum}
\end{remark}

\begin{remark}\label{remark:first_order_substitution_parentheses}
  When performing \hyperref[def:propositional_substitution]{substitution}, it is sometimes convenient to add additional parentheses to avoid ambiguity. For example, while parentheses around quantifier expressions are not necessary by the syntax of first-order logic, adding such parentheses helps avoid the ambiguity in
  \begin{equation*}
    \forall \xi \centerdot p(\xi, \eta) [\eta \mapsto \zeta].
  \end{equation*}

  Instead, we either write
  \begin{equation*}
    \Parens[\Big]{ \forall \xi \centerdot p(\xi, \eta) } [\eta \mapsto \zeta]
  \end{equation*}
  or
  \begin{equation*}
    \forall \xi \centerdot \Parens[\Big]{ p(\xi, \eta)[\eta \mapsto \zeta] }.
  \end{equation*}

  This convention is only part of the metasyntax and does not interfere with the syntax of the formulas themselves.
\end{remark}

\begin{example}\label{ex:first_order_substitution}
  The following term substitutions should justify the distinct cases in \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers}:
  \begin{ExEnum}
    \ILabel{ex:first_order_substitution/1} A simple substitution without renaming:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\eta \mapsto \zeta]
      = \\ &=
      \forall \xi \centerdot \Parens[\Big]{p(\xi, \eta)[\eta \mapsto \zeta]}
      = \\ &=
      \forall \xi \centerdot p(\eta, \zeta).
    \end{align*}

    \ILabel{ex:first_order_substitution/2} A simple renaming without actual substitution:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\xi \mapsto \eta]
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{p(\xi, \eta)[\xi \mapsto \zeta][\xi \mapsto \eta]}
      = \\ &=
      \forall \zeta \centerdot p(\zeta, \eta).
    \end{align*}

    We might have defined \( \varphi[\kappa \mapsto \mu] \) in \eqref{eq:def:first_order_substitution/term_in_formula} to be \( \varphi \) if \( \xi \in \Bold{Var}(\kappa) \) and this would have leaved this exact formula unchanged. \Fullref{ex:first_order_substitution/4}, however, demonstates that this definition would not have worked for nested substitution. Since the substituted formula is equivalent to the original one, we leave the definition as it is.

    \ILabel{ex:first_order_substitution/3} \Fullref{ex:first_order_substitution/2} but with both \( \kappa \) and \( \mu \) containing \( \xi \):
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\xi \mapsto f(\xi)]
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{p(\xi, \eta)[\xi \mapsto \zeta][\xi \mapsto f(\xi)]}
      = \\ &=
      \forall \zeta \centerdot p(\zeta, \eta).
    \end{align*}

    \ILabel{ex:first_order_substitution/4} Only renaming with multiple quantifiers (analogous to \fullref{ex:first_order_substitution/2}):
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \eta \centerdot \forall \xi \centerdot p(\xi, \eta))}[\xi \mapsto \eta]
      = \\ &=
      \forall \zeta \Parens[\Big]{(\forall \xi \centerdot p(\xi, \eta))[\eta \mapsto \zeta][\xi \mapsto \eta]}
      = \\ &=
      \forall \zeta \forall t \centerdot p(\xi, \zeta)[\xi \mapsto t][\xi \mapsto \eta]
      = \\ &=
      \forall \zeta \forall t \centerdot p(t, \zeta).
    \end{align*}

    \ILabel{ex:first_order_substitution/5} Both renaming and substitution with multiple quantifiers:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{ \forall \eta \centerdot (p(\xi, \eta) \vee \forall \xi \centerdot p(\xi, \eta)) }[\xi \mapsto \eta]
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ p(\xi, \eta) \vee \forall \xi \centerdot p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta]
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ p(\eta, \zeta) \vee \Parens[\Big]{ \forall \xi \centerdot p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta] }
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ p(\eta, \zeta) \vee \Parens[\Big]{ \forall t \centerdot p(\xi, \zeta) }[\xi \mapsto t][\xi \mapsto \eta] }
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ p(\eta, \zeta) \vee \forall t \centerdot p(t, \zeta) }.
    \end{align*}

    \ILabel{ex:first_order_substitution/6} Substitution of arbitrary terms rather than only variables:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta, f(\eta))}[f(\eta) \mapsto g(\eta, \xi)]
      = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{p(\xi, \eta, f(\eta))[\xi \mapsto \zeta][f(\eta) \mapsto g(\eta, \xi)]}
      = \\ &=
      \forall \zeta \centerdot p(\zeta, \eta, g(\eta, \xi)).
    \end{align*}
  \end{ExEnum}
\end{example}

\begin{proposition}\label{thm:swapping_assignment_compatibility}
  We will show how \hyperref[remark:first_order_substitution_renaming_justification]{syntactic renaming} is compatible with a certain \enquote{semantic renaming}.

  Fix a \hyperref[def:first_order_language]{first order language} \( \CL \), a \hyperref[def:first_order_structure]{structure} \( \CA = (A, I) \) on \( \CL \) and a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) in \( \CA \). For any variables \( \xi \) and \( \eta \), define the \enquote{swapping} assignment
  \begin{equation}\label{eq:thm:swapping_assignment_compatibility/swapping_assignment}
    v_\eta^\xi(\zeta) \coloneqq \begin{cases}
      v(\eta), \zeta = \xi, \\
      v(\xi), \zeta = \eta, \\
      v(\zeta), \text{otherwise}.
    \end{cases}
  \end{equation}

  \begin{PropEnum}
    \ILabel{thm:swapping_assignment_compatibility/terms} For any term \( \tau \) and any two variables \( \xi \) and \( \eta \), we have
    \begin{equation}\label{eq:thm:swapping_assignment_compatibility/terms}
      \tau\Val{v}
      =
      \Parens[\Big]{ \tau[\xi \mapsto \eta] }\Val{v_\eta^\xi}.
    \end{equation}

    \ILabel{thm:swapping_assignment_compatibility/formulas} If \( \eta \not\in \Bold{Var}(\varphi) \cup \Bold{Var}(\mu) \), for \( Q \in \Set{ \forall, \exists } \) and any \( \xi \) we have
    \begin{equation}\label{eq:thm:swapping_assignment_compatibility/formulas}
      \Parens[\Big]{ Q \xi \centerdot \psi }\Val{v}
      =
      \Parens[\Big]{ Q \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }\Val{v_\eta^\xi}.
    \end{equation}
  \end{PropEnum}
\end{proposition}
\begin{proof}
  In both cases, we use structural induction on the definition of the substitution\IND.

  \SubProofOf{thm:swapping_assignment_compatibility/terms}\mbox{}
  \begin{itemize}
    \item If \( \tau = \xi \), then
    \begin{equation*}
      \tau[\xi \mapsto \eta] = \xi[\xi \mapsto \eta] = \xi
    \end{equation*}
    and \eqref{eq:thm:swapping_assignment_compatibility/terms} follows directly.

    \item If \( \tau \) is a variable and \( \tau \neq \xi \), then
    \begin{equation*}
      \tau[\xi \mapsto \eta] = \tau
    \end{equation*}
    and \eqref{eq:thm:swapping_assignment_compatibility/terms} again holds trivially.

    \item If \( \tau = f(\tau_1, \ldots, \tau_n) \) and if the inductive hypothesis holds for \( \tau_1, \ldots, \tau_n \), then
    \begin{BreakableAlign*}
      \Parens[\Big]{ \tau[\xi \mapsto \eta] }\Val{v_\eta^\xi}
      &=
      \Parens[\Big]{ f(\tau_1[\xi \mapsto \eta], \ldots, \tau_n[\xi \mapsto \eta]) }\Val{v_\eta^\xi}
      = \\ &=
      I(f) \Parens[\Bigg]{ \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v_\eta^\xi}, \ldots, \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v_\eta^\xi} }
      \overset {\IndHyp} = \\ &=
      I(f) \Parens[\Big]{ \tau_1\Val{v}, \ldots, \tau_n\Val{v} }
      = \\ &=
      \Parens[\Big]{ f(\tau_1, \ldots, \tau_n) }\Val{v}
      = \\ &=
      \tau\Val{v}.
    \end{BreakableAlign*}
  \end{itemize}

  In all cases, \eqref{eq:thm:swapping_assignment_compatibility/terms} holds.

  \SubProofOf{thm:swapping_assignment_compatibility/formulas}\mbox{}
  \begin{itemize}
    \item If \( \varphi \in \Set{ \top, \bot } \), then \( \varphi \) has no subterms and thus \eqref{eq:thm:swapping_assignment_compatibility/formulas} holds vacuously.

    \item If \( \varphi = p(\tau_1, \ldots, \tau_n) \), then by \eqref{eq:thm:swapping_assignment_compatibility/terms} for all \( \tau_k \) we have
    \begin{equation*}
      \Parens[\Big]{ \tau_k[\xi \mapsto \eta] }\Val{v_\eta^\xi} = \tau_k\Val{v}
    \end{equation*}
    and thus
    \begin{equation*}
      \Parens[\Big]{ \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v_\eta^\xi}, \ldots, \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v_\eta^\xi} }
      \overset {\IndHyp} =
      \Parens[\Big]{ \tau_1\Val{v}, \ldots, \tau_n\Val{v} }.
    \end{equation*}

    Therefore
    \begin{BreakableAlign*}
      \Parens[\Big]{ \varphi[\xi \mapsto \eta] }\Val{v_\eta^\xi}
      &=
      \Parens[\Big]{ p(\tau_1[\xi \mapsto \eta], \ldots, \tau_n[\xi \mapsto \eta]) }\Val{v_\eta^\xi}
      = \\ &=
      \Parens[\Big]{ p(\tau_1, \ldots, \tau_n) }\Val{v}
      = \\ &=
      \tau\Val{v}.
    \end{BreakableAlign*}

    \item The case \( \varphi = \tau_1 \doteq \tau_2 \) is proved analogously.

    \item The case \( \varphi = \neg \psi \) is obvious because it is a simple recursion.

    \item The case \( \varphi = \psi_1 \circ \psi_2 \) is also simple recursion.

    \item Let \( \varphi = \forall \zeta \centerdot \psi \), where the inductive hypothesis holds for \( \psi \). We consider three cases
    \begin{itemize}
      \item Assume that \( \xi = \zeta \). By definition, we have
      \begin{equation*}
        \varphi[\xi \mapsto \eta]
        =
        \varphi,
      \end{equation*}
      hence \eqref{thm:swapping_assignment_compatibility/formulas} holds trivially.

      \item Assume that \( \zeta \not\in \Set{ \xi, \eta } \). In our case,
      \begin{equation*}
        \varphi[\xi \mapsto \eta]
        =
        \forall \zeta \Parens[\Big]{ \psi[\xi \mapsto \eta] }.
      \end{equation*}

      \begin{itemize}
        \item If \( \Parens[\Big]{\varphi[\xi \mapsto \eta]}\Val{v_\eta^\xi} = T \), by definition of \hyperref[def:first_order_valuation/formula_valuation]{quantifier formula valuation}, for any \( a \in A \) we have
        \begin{equation}\label{eq:thm:swapping_assignment_compatibility/formulas/true_modified_assignment}
          \Parens[\Big]{\forall \zeta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] }}\Val{v_\eta^\xi}
          =
          \Parens[\Big]{\psi[\xi \mapsto \eta]}\Val{v_{\eta,a}^{\xi,\zeta}}
          =
          T.
        \end{equation}

        By the inductive hypothesis,
        \begin{equation*}
          \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_\eta^\xi} = \psi\Val{v}
        \end{equation*}
        and, as a special case, for any \( a \in A \),
        \begin{equation}\label{eq:thm:swapping_assignment_compatibility/formulas/ind_hyp_modified_assignment}
          \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_{\eta,a}^{\xi,\zeta}} = \psi\Val{v_a^\zeta}.
        \end{equation}

        Combining \eqref{eq:thm:swapping_assignment_compatibility/formulas/true_modified_assignment} and \eqref{eq:thm:swapping_assignment_compatibility/formulas/ind_hyp_modified_assignment}, we obtain
        \begin{equation*}
          \Parens[\Big]{ \varphi[\xi \mapsto \eta] }\Val{v_\eta^\xi}
          =
          \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_{\eta,a}^{\xi,\zeta}}
          =
          \underbrace{\psi\Val{v_a^\zeta}}_{T \T{for all} a \in A}
          =
          \varphi\Val{v},
        \end{equation*}
        which proves the case.

        \item If \( \Parens[\Big]{\varphi[\xi \mapsto \eta]}\Val{v_\eta^\xi} = F \), then there exists \( a \in A \) such that
        \begin{equation*}
          \Parens[\Big]{\psi[\xi \mapsto \eta]}\Val{v_{\eta,a}^{\xi,\zeta}} = F.
        \end{equation*}

        Since \eqref{eq:thm:swapping_assignment_compatibility/formulas/ind_hyp_modified_assignment} holds by the inductive hypothesis, then
        \begin{equation*}
          \psi\Val{v_a^\zeta} = F
        \end{equation*}
        for the same \( a \).

        It follows that \( \varphi\Val{v} = F \), which proves the case.
      \end{itemize}

      \item We have \( \eta \neq \zeta \) by the assumption \( \eta \not\in \Bold{Var}(\varphi) \cup \Bold{Var}(\mu) \). Hence this case holds vacuously.
    \end{itemize}

    \item The case \( \varphi = \exists \zeta \centerdot \psi \) is identical except that \( a \) is nor arbitrary. We can also obtain it by double negation.
  \end{itemize}

  In all cases, \eqref{eq:thm:swapping_assignment_compatibility/formulas} holds.
\end{proof}

\begin{proposition}\label{thm:first_order_substitution_equivalence}
  Analogously to \fullref{thm:propositional_substitution_equivalence}, we will show that all defined in \fullref{def:first_order_substitution} types of substitution preserve the corresponding \hyperref[def:first_order_semantics]{semantics}.

  Fix a \hyperref[def:first_order_structure]{structure} \( \CA = (A, I) \) and a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \).

  \begin{PropEnum}
    \ILabel{thm:first_order_substitution_equivalence/predicate} As in \fullref{def:first_order_substitution/predicate}, let \( \varphi \) be a \hyperref[def:propositional_language/formula]{propositional formula} with variables \( {V = \Set{ P_1, \ldots, P_n }} \) and let \( \Rho = \Set{ \rho_1, \ldots, \rho_n } \) be a set of \hyperref[def:first_order_language/formula]{first order formulas}.

    Furthermore, let \( J \) be a \hyperref[def:propositional_valuation/interpretation]{propositional interpretation} such that, for all \( k = 1, \ldots, n \),
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/propositional/compatibility}
      P_k\Val{J} = \rho_k\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/propositional}
      \Parens[\Big]{ \varphi[V \mapsto \Rho] }\Val{v} = \varphi \Val{J}.
    \end{equation}

    In particular, \( \vDash \varphi \) (in the sense of \fullref{def:propositional_semantics/tautology}) implies \( \vDash \varphi[V \mapsto \Rho] \) (in the sense of \fullref{def:first_order_semantics/tautology}).

    \ILabel{thm:first_order_substitution_equivalence/term_in_term} Let \( \tau \) be a \hyperref[def:first_order_language/term]{first order term} and let \( \kappa \) be a \hyperref[def:first_order_language/subterm]{subterm} of \( \tau \). Let \( \mu \) be another term such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_term/compatibility}
      \mu\Val{v} = \kappa\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_term}
      \Parens[\Big]{ \tau[\kappa \mapsto \mu] }\Val{v} = \tau\Val{v}.
    \end{equation}

    \ILabel{thm:first_order_substitution_equivalence/term_in_formula} Let \( \varphi \) be a \hyperref[def:first_order_language/formula]{first order formula} and let \( \kappa \) be a \hyperref[def:first_order_language/formula_terms]{term of \( \varphi \)}. Let \( \mu \) be another term such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula/compatibility}
      \mu\Val{v} = \kappa\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula}
      \Parens[\Big]{ \varphi[\kappa \mapsto \mu] }\Val{v} = \varphi\Val{v}.
    \end{equation}

    \ILabel{thm:first_order_substitution_equivalence/formula_in_formula} Let \( \varphi \) be a \hyperref[def:first_order_language/formula]{first order formula} and let \( \theta \) be a \hyperref[def:first_order_language/subformula]{subformula of \( \varphi \)}. Let \( \rho \) be another formula such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/formula_in_formula/compatibility}
      \theta\Val{v} = \rho\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/formula_in_formula}
      \Parens[\Big]{ \varphi[\theta \mapsto \rho] }\Val{v} = \varphi\Val{v}.
    \end{equation}

    In particular, \( \theta \Sequiv \rho \) implies \( \varphi[\theta \mapsto \rho] \Sequiv \varphi \).
  \end{PropEnum}
\end{proposition}
\begin{proof}
  In all cases, we use structural induction by the definition of the substitution\IND. The inductive hypothesis for a formula is that the proposition holds for arbitrary substitutions and valuations.

  \SubProofOf{thm:first_order_substitution_equivalence/predicate} Since \( \varphi \) is a propositional formula, we have fewer cases:
  \begin{itemize}
    \item If \( \varphi \in \Set{ \top, \bot } \), no substitution is performed and thus \eqref{eq:thm:first_order_substitution_equivalence/propositional} holds trivially.

    \item If \( \varphi = P_k \) for some \( k = 1, \ldots, n \), then follows \eqref{eq:thm:first_order_substitution_equivalence/propositional} from \eqref{eq:thm:first_order_substitution_equivalence/propositional/compatibility}.

    \item If \( \varphi = \neg \psi \) and if the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Parens[\Big]{ \psi[V \mapsto \Rho] }\Val{v}
      =
      \Ol{\Parens[\Big]{ \psi[V \mapsto \Rho] }\Val{v}}
      \overset {\IndHyp} =
      \Ol{\psi \Val{J}}
      =
      \varphi \Val{J}.
    \end{equation*}

    \item If \( \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma \) and if the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), then
    \begin{equation*}
      \Parens[\Big]{ \psi[V \mapsto \Rho] }\Val{v}
      =
      \Parens[\Big]{ \psi_1[\theta \mapsto \rho] }\Val{v} \circ \Parens[\Big]{ \psi_2[\theta \mapsto \rho] }\Val{v}
      \overset {\IndHyp} =
      \psi_1 \Val{J} \circ \psi_2\Val{J}
      =
      \varphi\Val{J}.
    \end{equation*}
  \end{itemize}

  In all cases, \eqref{eq:thm:first_order_substitution_equivalence/propositional} holds.

  \SubProofOf{thm:first_order_substitution_equivalence/term_in_term} The proof is identical to \fullref{thm:swapping_assignment_compatibility/terms}.

  \SubProofOf{thm:first_order_substitution_equivalence/term_in_formula} The proof is identical to \fullref{thm:swapping_assignment_compatibility/formulas} except for the special case \( \varphi = Q \xi \centerdot \psi \), where \( Q \in \Set{ \forall, \exists } \), the inductive hypothesis holds for \( \psi \) and \( \xi \in \Bold{Free}(\mu) \).

  We will only show the case \( Q = \forall \) since the other one is analogous.

  Since \( \xi \in \Bold{Free}(\mu) \), we have
  \begin{equation*}
    \varphi[\kappa \mapsto \mu]
    =
    \forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta][\kappa \mapsto \mu] },
  \end{equation*}
  which does not allow us to use the inductive hypothesis directly.

  We proceed to prove the statement by nested induction\IND on the number of quantifiers. We have already shown the case of \( 0 \) quantifiers. Suppose that the statement holds for all formulas with strictly less than \( n \) quantifiers and suppose that \( \varphi \) has exactly \( n \) quantifiers.

  Furthermore, for formulas with \( n \) quantifiers, we have shown all the other cases (for \( Q = \forall \)). Therefore, since \( \eta \not\in \Bold{Free}(\mu) \),
  \begin{equation*}
    \Parens[\Bigg]{ \Parens[\Big]{ \forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }[\kappa \mapsto \mu] }\Val{v}
    =
    \Parens[\Bigg]{\forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }\Val{v},
  \end{equation*}
  where we have implicitly used that \( \psi \) has \( n - 1 \) quantifiers.

  Fix \( a \in A \). By \fullref{thm:swapping_assignment_compatibility/formulas},
  \begin{equation*}
    \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_a^\eta} = \psi\Val{v_{\eta,a}^{\xi,\eta}}.
  \end{equation*}

  Hence
  \begin{equation*}
    \Parens[\Bigg]{\forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }\Val{v}
    =
    \Parens[\Big]{\forall \xi \centerdot \psi }\Val{v_\eta^\xi}.
  \end{equation*}

  Therefore \eqref{eq:thm:first_order_substitution_equivalence/term_in_formula} holds.

  \SubProofOf{thm:first_order_substitution_equivalence/formula_in_formula} The proof is analogous to that of \fullref{thm:first_order_substitution_equivalence/term_in_formula}.
\end{proof}
