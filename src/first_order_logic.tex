\subsection{First-order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_language}\mcite[sec. 15.2]{OpenLogicFull}
  The idea of first-order predicate logic (we will omit \enquote{predicate} and only refer to \enquote{first-order logic}) is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universe. Unlike in \hyperref[subsec:propositional_logic]{propositional logic}, there are different first-order logic languages.

  The alphabet for a \term{first-order logic \hyperref[def:language]{language}} \( \mscrL \) extends that of \hyperref[subsec:propositional_logic]{propositional logic} and consists of two types of symbols (note that \fullref{rem:propositional_language_is_alphabet} holds here also).

  \begin{description}
    \item[Logical symbols]
    \hfill
    \begin{thmenum}[series=def:first_order_language]
      \thmitem{def:first_order_language/propositional} The entirety of the \hyperref[subsec:propositional_logic]{propositional logic language} except for the \hyperref[def:propositional_language/prop]{propositional variables}.

      \thmitem{def:first_order_language/var} A nonempty at most \hyperref[rem:cardinals/countably_infinite]{countable} alphabet of \term{individual variables} \( \boldop{Var} \), usually denoted by small Greek letters \( \xi_1, \xi_2, \ldots \) or \( \xi, \eta, \zeta \) --- see \fullref{rem:mathematical_logic_conventions/variable_symbols}.

      \thmitem{def:first_order_language/quantifiers} The quantifiers \( Q = \set{ \forall, \exists } \):
      \begin{thmenum}
        \thmitem{def:first_order_language/quantifiers/universal} The \term{universal quantifier} \( \forall \).
        \thmitem{def:first_order_language/quantifiers/existential} The \term{existential quantifier} \( \exists \).
        \thmitem{def:first_order_language/quantifiers/dot} The dot \( . \) for separating a quantifier from its formula.
      \end{thmenum}

      The dot is not itself a quantifier and is not formally necessary --- we use it only for readability.

      \thmitem{def:first_order_language/equality} A symbol for \term{formal equality} \( \doteq \). Equality is sometimes omitted by logicians but examples of first-order languages without formal equality are obscure.
    \end{thmenum}

    \item[Non-logical symbols]
    \hfill
    \begin{thmenum}[resume=def:first_order_language]
      \thmitem{def:first_order_language/func} A set of functional symbols, \( \boldop{Fun} \), whose elements are usually denoted by \( f_1, f_2, \ldots \) or \( f, g \) or by symbols like \( \otimes \). In the latter case we usually use infix notation (see \fullref{rem:first_order_formula_conventions/infix}). Each functional symbol has an associated natural number called its \term{arity}, denoted by \( \# f \). Functional symbols with a zero arity are called \term{constants}.

      \thmitem{def:first_order_language/pred} A set of predicate symbols, \( \boldop{Pred} \), whose elements are usually denoted by \( p_1, p_2, \ldots \) or by symbols like \( \leq \). Again, in the latter case we use infix notation. Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \term{propositional variables}.
    \end{thmenum}
  \end{description}

  The logical symbols are common for all first-order languages. Thus first-order languages differ by their non-logical symbols. The collection of functional and predicate symbols of a language are sometimes called its \term{signature}.
\end{definition}

\begin{definition}\label{def:first_order_syntax}
  Similarly to the \hyperref[def:propositional_syntax]{syntax of propositional logic}, we define the \term{syntax} of a fixed first-order language \( \mscrL \).

  \begin{thmenum}
    \thmitem{def:first_order_syntax/grammar_schema} Consider the following \hyperref[def:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}        {v \in \boldop{Var}} \\
      \bnfprod{connective}      {\bincirc \in \Sigma} \\
      \bnfprod{quantifier}      {\bnfts{\( \forall \)} \bnfor \bnfts{\( \exists \)}} \\
      \bnfprod{unary function}  {f \in \boldop{Fun}, \#f = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary function}  {f \in \boldop{Fun}, \#f = n \text{ (standalone rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{unary predicate} {p \in \boldop{Pred}, \#p = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary predicate} {p \in \boldop{Pred}, \#p = n \text{ (standalone rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{term}            {\bnfpn{variable} \bnfor} \\
      \bnfmore                  {\bnfpn{unary function} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary function} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{atomic formula}  {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{\( \doteq \)} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{unary predicate} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary predicate} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{formula}         {\bnfpn{atomic formula} \bnfor} \\
      \bnfmore                  {\bnfts{\( \neg \)} \bnfpn{formula} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{quantifier} \bnfsp \bnfpn{variable} \bnfsp \bnfts{.} \bnfsp \bnfpn{formula}}
    \end{bnf*}

    In practice, we usually only have functions and predicates of specific arities. Note that we can have infinitely many functions but only finitely many different arities. The \hyperref[rem:theory_of_left_monoid_actions]{theory of monoid actions} is an example of a first-order language with infinitely many unary functional symbols, one constant and one binary functional symbol.

    If we need the grammars to have a finite set of rules, except for having only finitely many different arities, we need to introduce appropriate naming conventions for variables, functions and predicates, analogously to the \hyperref[def:propositional_syntax/grammar_schema]{grammar schema of propositional logic}.

    We use the conventions in \fullref{rem:propositional_formula_parentheses} regarding parentheses by extending them wherever appropriate.

    In order to simplify notation, we also use the conventions in \fullref{rem:first_order_formula_conventions}.

    \thmitem{def:first_order_syntax/term} The set \( \boldop{Term} \) of \term{terms} in \( \mscrL \) is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{term} \) as a starting rule.

    The grammar of first-order terms is unambiguous due to \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    \thmitem{def:first_order_syntax/subterm} If \( \tau \) and \( \kappa \) are terms and \( \kappa \) is a \hyperref[def:language/subword]{subword} of \( \tau \), we say that \( \kappa \) is a \term{subterm} of \( \tau \).

    \thmitem{def:first_order_syntax/term_variables} For each term \( \tau \), we define its variables as
    \begin{equation}\label{eq:def:first_order_syntax/term_variables}
      \boldop{Var}(\tau) \coloneqq \begin{cases}
        \xi,                                                        &\tau = \xi \in \boldop{Var}, \\
        \boldop{Var}(\tau_1) \cup \ldots \cup \boldop{Var}(\tau_n), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    As in \fullref{def:propositional_syntax/variables}, \( \boldop{Var} \) is ordered by the position of the first occurrence of a variable.

    \thmitem{def:first_order_syntax/ground_term} A term \( \tau \) is called a \term{ground term} if \( \boldop{Var}(\tau) = \varnothing \). Ground terms are also called \term{closed terms}.

    \thmitem{def:first_order_syntax/atomic_formula} The set \( \boldop{Atom} \) of \term{atomic formulas} in \( \mscrL \) is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{atomic formula} \) as a starting rule.

    \thmitem{def:first_order_syntax/formula} The set \( \boldop{Form} \) of \term{formulas} in \( \mscrL \) is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{formula} \) as a starting rule.

    The \term{atomic formulas} are the ones generated from \( \bnfpn{atomic formula} \).

    The grammar of first-order formulas is unambiguous as shown by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    See \fullref{ex:first_order_substitution} for examples of first-order formulas.

    \thmitem{def:first_order_syntax/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \term{subformula} of \( \varphi \).

    \thmitem{def:first_order_syntax/formula_terms} If \( \varphi \) is a formula, if \( \tau \) is a term and if \( \tau \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \tau \) is a \term{term} of \( \varphi \).

    \thmitem{def:first_order_syntax/formula_free_variables} The \term{free variables} of a formula are defined as
    \begin{equation}\label{eq:def:first_order_syntax/formula_free_variables}
      \boldop{Free}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                                &\varphi \in \set{ \top, \bot } \\
        \boldop{Var}(\tau_1) \cup \ldots \cup \boldop{Var}(\tau_n), &\varphi = p(\tau_1, \ldots, \tau_n) \\
        \boldop{Var}(\tau_1) \cup \boldop{Var}(\tau_2),             &\varphi = \tau_1 \doteq \tau_2, \\
        \boldop{Free}(\psi),                                        &\varphi = \neg \psi, \\
        \boldop{Free}(\psi_1) \cup \boldop{Free}(\psi_2),           &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma, \\
        \boldop{Free}(\psi) \setminus \set{ \xi },                  &\varphi = \quantifier{Q}{\xi} \psi, Q \in \set{ \forall, \exists }
      \end{cases}
    \end{equation}

    \thmitem{def:first_order_syntax/ground_formula} A formula \( \varphi \) is called a \term{ground formula} if \( \boldop{Free}(\varphi) = \varnothing \). Ground formulas are also called \term{closed formulas} or \term{sentences} (unlike in propositional logic where all formulas are called sentences --- see \fullref{def:propositional_syntax/formula}).

    We will not restrict our attention only to closed formulas and we will even rely on implicit quantification as mentioned in \fullref{rem:mathematical_logic_conventions/quantification}. That being said, certain important theorems like \fullref{thm:first_order_semantic_deduction_theorem} and \fullref{thm:first_order_syntactic_deduction_theorem} require some of the formulas to be closed.

    \thmitem{def:first_order_syntax/formula_bound_variables} Dually, the \term{bound variables} of a formula are defined as
    \begin{equation}\label{eq:def:first_order_syntax/formula_bound_variables}
      \boldop{Bound}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                        &\varphi \text{ is atomic}, \\
        \boldop{Bound}(\psi),                               &\varphi = \neg \psi, \\
        \boldop{Bound}(\psi_1) \cup \boldop{Bound}(\psi_2), &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma, \\
        \boldop{Bound}(\psi) \cup \set{ \xi },              &\varphi = \quantifier{Q}{\xi} \psi, Q \in \set{ \forall, \exists }.
      \end{cases}
    \end{equation}

    \thmitem{def:first_order_syntax/formula_variables} Finally, the set of all variables of a formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_syntax/formula_variables}
      \boldop{Var}(\varphi) \coloneqq \boldop{Free}(\varphi) \cup \boldop{Bound}(\varphi).
    \end{equation}
  \end{thmenum}
\end{definition}

\begin{proposition}\label{thm:first_order_terms_and_formulas_are_unambiguous}
  The grammars of \hyperref[def:first_order_syntax/term]{first-order terms} and of \hyperref[def:first_order_syntax/formula]{first-order formulas} are \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar in spirit to \fullref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{remark}\label{rem:first_order_formula_conventions}
  In order to simplify exposition, we use the following conventions
  \begin{thmenum}
    \thmitem{rem:first_order_formula_conventions/infix} Binary functional symbols are often written using \term{infix notation}, i.e.
    \begin{equation*}
      \zeta \doteq \xi + \eta
    \end{equation*}
    rather than the \term{prefix notation}
    \begin{equation*}
      \zeta \doteq +(\xi, \eta).
    \end{equation*}

    This also applies to predicates --- we write \( \xi ~ \eta \) rather than \( ~(\xi, \eta) \).

    \thmitem{rem:first_order_formula_conventions/negation} Negation of an infix binary predicate symbol \( ~ \) can be written more simply as
    \begin{equation*}
      \xi \not~ \eta
    \end{equation*}
    rather than
    \begin{equation*}
      \not(\xi ~ \eta).
    \end{equation*}

    \thmitem{rem:first_order_formula_conventions/relativization}\mcite{LeanFOL} If \( \sim \) is a binary predicate, to further shorten notation, we write
    \begin{equation*}
      \qforall {\xi \sim \eta} \varphi
    \end{equation*}
    as a shorthand for
    \begin{equation*}
      \qforall \xi (\xi \sim \eta \rightarrow \varphi)
    \end{equation*}
    and
    \begin{equation*}
      \qexists {\xi \sim \eta} \varphi
    \end{equation*}
    as a shorthand for
    \begin{equation*}
      \qexists \xi (\xi \sim \eta \wedge \varphi).
    \end{equation*}

    This is called \term{relativization} of the quantifier and is immensely useful when working with heterogeneous objects or even in \hyperref[sec:set_theory]{set theory}.

    \thmitem{rem:first_order_formula_conventions/exists_unique} We sometimes want to specify not only existence but also uniqueness. This is the case in \eqref{eq:def:zfc/choice}, for example. It is conventional to write
    \begin{equation*}
      \qExists \xi \varphi
    \end{equation*}
    as a shorthand for
    \begin{equation*}
      \qexists \xi \parens[\Big]{ \varphi \wedge (\qforall \eta \varphi[\xi \mapsto \eta] \doteq \varphi) }.
    \end{equation*}

    \thmitem{rem:first_order_formula_conventions/necessary_signature} We only add to the language itself the functional and predicate symbols that are necessary for our desired axioms --- see \fullref{def:first_order_theory}. We can define additional functions and predicates in terms of these but we avoid using them as much as possible when writing formulas in the object language. For example, we avoid adding the functional symbols \hyperref[thm:order_type_existence]{\( \ord(A) \)} and \hyperref[def:cardinal]{\( \card(A) \)} or even \hyperref[def:basic_set_operations/union]{\( \cup \)} and \hyperref[def:basic_set_operations/intersection]{\( \cap \)} to \hyperref[def:zfc]{\logic{ZFC}}.

    If needed, we can consider these new functions and predicates to be abbreviations for more verbose terms and formulas as described in \fullref{rem:predicate_formula}.
  \end{thmenum}

  As for \fullref{rem:propositional_formula_parentheses}, both of these conventions exist only in the metalanguage and the formulas themselves are assumed to have the former form within the object language.
\end{remark}

\begin{definition}\label{def:first_order_structure}\mcite[def. 16.1]{OpenLogicFull}
  Fix a first-order logic language \( \mscrL \). A \term{structure} for \( \mscrL \) is a pair \( \mscrX = (X, I) \), where
  \begin{thmenum}
    \thmitem{def:first_order_structure/set} \( X \) is a nonempty set called the \term{domain} or \term{universe} of the structure \( \mscrX \). See \fullref{rem:empty_models}.

    \thmitem{def:first_order_structure/interpretation} The \term{interpretation} \( I \) of the structure \( \mscrX \) is a \hyperref[def:function]{function} that is defined on the signature of \( \mscrL \) and satisfies the following conditions:
    \begin{thmenum}
      \thmitem{def:first_order_structure/interpretation/function} For every \( n \)-ary function symbol \( f \), its interpretation is a \hyperref[def:function]{function} with signature \( I(f): X^n \to X \).

      \thmitem{def:first_order_structure/interpretation/predicate} For every \( n \)-ary predicate \( p \), its interpretation is a an n-ary \hyperref[def:boolean_function]{Boolean-valued function} with signature \( I(p): X^n \to \set{ T, F } \). A tuple \( (x_1, \ldots, x_n) \) satisfies \( p \) if \( p(x_1, \ldots, x_n) = T \).

      It is conventional to define the interpretation of a predicate to be a \hyperref[def:relation]{relation} \( I(p) \subseteq X^n \) (see e.g. \mcite[def. 16.1]{OpenLogicFull}), however it is more convenient for us to work with Boolean-valued functions. The two approaches are equivalent as explained in \fullref{rem:boolean_valued_functions_and_predicates}.
    \end{thmenum}
  \end{thmenum}

  Unlike in the rest of this document, when dealing with first-order structures, it is important to distinguish between the structure \( \mscrX \) as a pair and its domain \( X \) as a set. See \fullref{rem:first_order_model_notation}.
\end{definition}

\begin{remark}\label{rem:empty_models}
   If we allow for the domain of a structure to be empty, we would have to reformulate a lot of important theorems (e.g. see the proof of \fullref{thm:renaming_assignment_compatibility/formulas}), which would complicate compatibility between semantics and \hyperref[def:proof_derivation_system]{derivation systems}.

   See \fullref{thm:substructures_form_complete_lattice/bottom} for a context where empty sets are justified as domains of first-order structures.
\end{remark}

\begin{definition}\label{def:first_order_valuation}
  Fix a structure \( \mscrX = (X, I) \) for a first-order logic language \( \mscrL \).

  \begin{thmenum}
    \thmitem{def:first_order_valuation/variable_assignment}\mcite[def. 16.7]{OpenLogicFull} A \term{variable assignment} for the variables of \( \mscrL \) is any function \( v: \boldop{Var} \to X \) (loosely similar to \hyperref[def:propositional_valuation/interpretation]{propositional interpretations}).

    \thmitem{def:first_order_valuation/modified_assignment} For every variable \( \xi \) and every domain element \( x \in X \) we also define the \term{modified assignment} at \( \xi \) with \( x \):
    \begin{equation*}
      v_{\xi \mapsto x}(\zeta) \coloneqq \begin{cases}
        x,        &\zeta = \xi, \\
        v(\zeta), &\zeta \neq \xi.
      \end{cases}
    \end{equation*}

    We can also modify the value at \( \xi \) with another variable, e.g.
    \begin{equation*}
      v_{\xi \mapsto \eta}(\zeta) \coloneqq \begin{cases}
        v(\eta),  &\zeta = \xi, \\
        v(\zeta), &\zeta \neq \xi.
      \end{cases}
    \end{equation*}

    Inductively,
    \begin{equation*}
      v_{\xi_1 \mapsto x_1, \ldots, \xi_n \mapsto x_n}(\eta) \coloneqq ((\ldots(v_{\xi_1 \mapsto x_1})\ldots)_{\xi_n \mapsto x_n})(\eta).
    \end{equation*}

    Except for semantics of quantification, these are also used in other places like \fullref{thm:renaming_assignment_compatibility} and \fullref{rem:first_order_formula_valuation_without_variable_assignment}.

    \thmitem{def:first_order_valuation/term_valuation}\mcite[def. 16.8]{OpenLogicFull} The \term{valuation} of a term \( \tau \) is a value in the domain \( X \) given by
    \begin{equation}\label{eq:def:first_order_valuation/term_valuation}
      \tau\Bracks{v} \coloneqq \begin{cases}
        v(\xi),                                           &\tau = \xi \in \boldop{Var}, \\
        I(f)(\tau_1\Bracks{v}, \ldots, \tau_n\Bracks{v}), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    \thmitem{def:first_order_valuation/formula_valuation}\mcite[def. 16.11]{OpenLogicFull} We extend the classical propositional valuations from \fullref{def:propositional_valuation}. The (classical) \term{valuation} of a formula \( \varphi \) is a \hyperref[def:boolean_value]{Boolean value} given by
    \begin{equation}\label{eq:def:first_order_valuation/formula_valuation}
      \varphi\Bracks{v} \coloneqq \begin{cases}
        T,                                                              &\varphi = \top, \\
        F,                                                              &\varphi = \bot, \\
        \tau_1\Bracks{v} = \tau_2\Bracks{v},                            &\varphi = \tau_1 \doteq \tau_2, \\
        I(p)(\tau_1\Bracks{v}, \ldots, \tau_n\Bracks{v}),               &\varphi = p(\tau_1, \ldots, \tau_n), \\
        \overline{\psi\Bracks{v}},                                      &\varphi = \neg \psi, \\
        \psi_1\Bracks{v} \bincirc \psi_2\Bracks{v},                     &\varphi = \psi_1 \bincirc \psi_2, \bincirc \in \Sigma, \\
        \bigvee\set{ \psi\Bracks{v_{\xi \mapsto x}} \given x \in X },   &\varphi = \qforall \xi \psi, \\
        \bigwedge\set{ \psi\Bracks{v_{\xi \mapsto x}} \given x \in X }, &\varphi = \qexists \xi \psi.
      \end{cases}
    \end{equation}

    The rules for evaluating constants, negations and connectives are a direct extension of the \hyperref[def:propositional_valuation/formula_valuation]{rules for propositional logic}.

    It is important that the domain is nonempty because \( \bigwedge\varnothing = T \), which directly contradicts our intent of defining \( \exists \) as a quantifier for existence.
  \end{thmenum}
\end{definition}

\begin{definition}\label{def:first_order_definability}
  Fix a \hyperref[def:first_order_syntax]{first-order language} \( \mscrL \) and a \hyperref[def:first_order_structure]{structure} \( \mscrX = (X, I) \) on \( \mscrL \).

  We say that the set \( A \subseteq X^n \) is \term{definable} using the \hyperref[def:first_order_syntax]{formula} \( \varphi \) if, assuming \( {\boldop{Free}(\varphi) \subseteq \set{ \xi_1, \ldots, \xi_n }} \), we have
  \begin{equation*}
    \varphi\Bracks{\xi_1 \mapsto x_1, \ldots, \xi_n \mapsto x_n} = T \T{if and only if} (x_1, \ldots, x_n) \in A.
  \end{equation*}
\end{definition}

\begin{definition}\label{def:first_order_equation}
  A \term{first-order equation} is a formula of the form
  \begin{equation}\label{eq:def:first_order_equation}
    f(\xi_1, \ldots, \xi_n) \doteq g(\xi_1, \ldots, \xi_n),
  \end{equation}
  where both \( f(\xi_1, \ldots, \xi_n) \) and \( g(\xi_1, \ldots, \xi_n) \) are functional symbols with the same free variables.

  Given a structure \( \mscrX = (X, I) \), we call the elements of the set defined by this formula \term{solutions}. That is, we say that the tuple \( (x_1, \ldots, x_n) \) is a solution to the equation \eqref{eq:def:first_order_equation} if
  \begin{equation*}
    f\Bracks{x_1, \ldots, x_n} = g\Bracks{x_1, \ldots, x_n}.
  \end{equation*}

  We can actually replace \( f \) and \( g \) with more general terms \( \tau \) and \( \sigma \), in which case the equation becomes \( (\tau \doteq \sigma) \) and is satisfied if
  \begin{equation*}
    \tau\Bracks{x_1, \ldots, x_n} = \sigma\Bracks{x_1, \ldots, x_n}.
  \end{equation*}
\end{definition}

\begin{example}\label{ex:equations}
  A remarkable portion of mathematics concerns the study of different types of equations (even though they are not generally restricted to \hyperref[def:first_order_equation]{equations in first-order logic}). The reason for this is that equations provide a simple way to specify rich semantic structure using simple syntactic objects.

  \begin{itemize}
    \item Matrix theory can be regarded as the study of linear equations. See \fullref{subsec:matrices}.
    \item Differential equations is aptly named since it studies equations in functional spaces concerning functions and their derivatives. See \fullref{sec:diffeq}.
    \item Roots of generalized derivatives are studied in optimization. See \fullref{sec:nonsmooth_analysis}.
    \item Diophantine equations are studied in number theory. See \fullref{subsec:integers}.
    \item Fixed points of functions are studied in different branches of mathematics. See \fullref{thm:banach_fixed_point_theorem} or \fullref{thm:knaster_tarski_theorem}.
    \item Affine varieties, which are sets of roots of polynomials, are studied in algebraic geometry. See \fullref{subsec:affine_varieties}.
  \end{itemize}
\end{example}

\begin{definition}\label{def:first_order_semantics}
  Fix a first-order logic language \( \mscrL \). We introduce notions analogous to \hyperref[def:propositional_semantics]{propositional semantics}:
  \begin{thmenum}
    \thmitem{def:first_order_semantics/satisfiability}\mcite[def. 16.11]{OpenLogicFull} Given a \hyperref[def:first_order_structure]{structure} \( \mscrX = (X, I) \), a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) and a set \( \Gamma \) of \hyperref[def:first_order_syntax/formula]{first-order formulas}, we say that the variable assignment \( v \) \term{satisfies} \( \Gamma \) and we write \( \mscrX \vDash_v \Gamma \) if, for every formula \( \gamma \in \Gamma \) we have \( \gamma\Bracks{v} = T \).

    If every variable assignment in \( \mscrX \) satisfies \( \Gamma \), we say that \( \mscrX \) itself satisfies \( \Gamma \) or that \( \mscrX \) is a \term{model} of \( \Gamma \) and write \( \mscrX \vDash \Gamma \) (or simply \( \mscrX \vDash \Gamma \) if the interpretation is clear from the context).

    Analogously to \fullref{def:propositional_semantics/satisfiability}, we say that \( \Gamma \) is satisfiable if there exists a model for \( \Gamma \).

    \thmitem{def:first_order_semantics/entailment} We say that the set of formulas \( \Gamma \) \term{entails} the set of formulas \( \Delta \) and write \( \Gamma \vDash \Delta \) if every model of \( \Gamma \) is also a model of \( \Delta \).

    \thmitem{def:first_order_semantics/tautology} The formula \( \varphi \) is a \term{tautology} if every structure is a model of \( \varphi \).

    \thmitem{def:first_order_semantics/contradiction} Dually, \( \varphi \) is a \term{contradiction} is no structure is a model of \( \varphi \).

    \thmitem{def:first_order_semantics/equivalence} As in the simplest case with \hyperref[def:propositional_semantics/equivalence]{propositional semantical equivalence}, we say that \( \Gamma \) and \( \Delta \) are \term{semantically equivalent} and write \( \Gamma \gleichstark \Delta \) if both \( \Gamma \vDash \Delta \) and \( \Delta \vDash \Gamma \).

    \thmitem{def:first_order_semantics/equisatisfiability} Again as in the simplest case with \hyperref[def:propositional_semantics/equisatisfiability]{propositional equisatisfiability}, we say that the sets of formulas \( \Gamma \) and \( \Delta \) are \term{equisatisfiable} when it holds that \( \Gamma \) is satisfiable if and only if \( \Delta \) is satisfiable.

    \Fullref{thm:quantifier_satisfiability/existential} provides an important example of equisatisfiable formulas that are not equivalent.
  \end{thmenum}
\end{definition}

\begin{remark}\label{rem:propositional_logic_as_first_order_logic}
  It is now clear that the \hyperref[subsec:propositional_logic]{propositional logic language} can be regarded as a degenerate first-order logic language with no at most countably many predicate symbols, all of arity \( 0 \), and no functional symbols. Thus first-order logic is indeed an extension of propositional logic.
\end{remark}

\begin{remark}\label{rem:first_order_model_notation}
  In first-order logic, \hyperref[def:first_order_semantics/satisfiability]{models} are defined as pairs \( \mscrX = (X, I) \). Each area of mathematics has its own conventions and models are usually specified as simply as possible without being unambiguous (and sometimes even beyond ambiguity).

  A popular convention is to use compatible letters like we did with \( X \) and \( \mscrX \) or \( G \) and \( \mscrG \), where the structure itself is named using calligraphic letters while the domain is named using the corresponding capital letter in normal font. This only works very simple cases where we can say \enquote{Let \( \mscrP = (P, \leq) \) be a \hyperref[def:poset]{poset}}. In the case of Banach lattices, for example, this becomes \( \mscrX = (X, \BbbK, +, \norm \placeholder, \vee, \wedge) \), which is quite cumbersome.

  Consider another example. In the sense of first-order structures, the language of the \hyperref[def:group/theory]{theory of groups} has a signature consisting of three functional symbols and no predicate symbols. Specifying a structure for this language is thus the same as specifying a quadruple \( \mscrG = (G, e, (\placeholder)^{-1}, \cdot) \). We usually identify the group \( \mscrG \) as a tuple with its domain \( G \) and even go as far as to say \enquote{Let \( (\mscrG, \cdot) \) be a group}. This is technically wrong but it is both convenient and conventional. Furthermore, the rest of the definition of the group can easily be inferred. In case of ambiguity, the simplest disambiguation is to use lower indices with the name of the structure, e.g. \( +_\mscrG \) and \( +_\mscrH \) may be the addition operation in different abelian groups.
\end{remark}
