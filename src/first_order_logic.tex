\subsection{First-order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_logic_alphabet}\MarginCite[187]{OpenLogic20201202}
  The idea of first-order predicate logic is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universum. Unlike in \hyperref[subsec:propositional_logic]{propositional logic}, there are many first-order logic languages.

  The alphabet for a \Def{first-order predicate logic \hyperref[def:language]{language}} \( \CL \) extends that of \hyperref[subsec:propositional_logic]{propositional logic} and consists of two types of symbols.

  \begin{description}
    \item[Logical symbols]\mbox{}
    \begin{DefEnum}[series=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/propositional} The entirety of the \hyperref[subsec:propositional_logic]{propositional logic alphabet}.

      \ILabel{def:first_order_logic_alphabet/var} A countable alphabet of variables \( \Bold{Var} \), usually denoted by \( \xi_0, \xi_1, \ldots \) or \( \xi, \eta, \zeta \).

      \ILabel{def:first_order_logic_alphabet/quantifiers} Two quantifiers \( Q = \{ \forall, \exists \} \):
      \begin{DefEnum}
        \ILabel{def:first_order_logic_alphabet/quantifiers/universal} The \Def{universal quantifier} \( \forall \).
        \ILabel{def:first_order_logic_alphabet/quantifiers/existential} Then \Def{existential quantifier} \( \exists \).
      \end{DefEnum}

      \ILabel{def:first_order_logic_alphabet/equality} Optionally, an equality symbol \( \doteq \). See \fullref{remark:first_order_equality}.
    \end{DefEnum}

    \item[Non-logical symbols]\mbox{}
    \begin{DefEnum}[resume=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/func} A set of functional symbols, \( \Bold{Fun} \), whose elements are usually denoted by \( f_0, f_1, \ldots \) or \( f, g, h \). Each functional symbol has an associated natural number called its \Def{arity}, denoted by \( \# f \). Functional symbols with a zero arity are called \Def{constants}.

      \ILabel{def:first_order_logic_alphabet/pred} A set of predicate symbols, \( \Bold{Pred} \), whose elements are usually denoted by \( p_0, p_1, \ldots \) or by symbols like \( \oplus \) or \( \circ \). Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \Def{propositional variables}.
    \end{DefEnum}
  \end{description}
\end{definition}

\begin{definition}\label{def:first_order_language}\mbox{}
  \begin{DefEnum}
    \ILabel{def:first_order_language/grammar} Consider the following \hyperref[def:grammar]{grammar}:
    \begin{bnf*}
      \bnfprod{variable}        {v \in \Bold{Var}} \\
      \bnfprod{connective}      {\circ \in \Sigma} \\
      \bnfprod{quantifier}      {\bnfts{\( \forall \)} \bnfor \bnfts{\( \exists \)}} \\
      \bnfprod{n-ary function}  {f \in \Bold{Fun}, \#f = n \text{ (separate rule for each \( n \))}} \\
      \bnfprod{n-ary predicate} {p \in \Bold{Pred}, \#p = n \text{ (separate rule for each \( n \))}} \\
      \bnfprod{term}            {\bnfpn{variable} \bnfor} \\
      \bnfmore                  {\bnfpn{unary function} \bnfts{(} \bnfpn{term} \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary function} \underbrace{\bnfts{(} \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfts{)}}_{n \Ttimes} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{atomic formula}  {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore                  {(\bnfpn{term} \bnfsp \bnfts{\( \doteq \)} \bnfsp \bnfpn{term}) \bnfor} \\
      \bnfmore                  {\bnfpn{unary predicate} \bnfts{(} \bnfpn{term} \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary predicate} \underbrace{\bnfts{(} \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfts{)}}_{n \Ttimes} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{formula}         {\bnfpn{atomic formula} \bnfor} \\
      \bnfmore                  {\bnfts{\neg} \bnfpn{formula} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{quantifier} \bnfsp \bnfpn{variable} \bnfsp \bnfpn{formula}}
    \end{bnf*}
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_term}\MarginCite[189]{OpenLogic20201202}
  Given a first-order logic language \( \CL \), the set \( \Cal{T} \) of terms is defined inductively as
  \begin{DefEnum}
    \ILabel{def:first_order_term/var} Each variable is a term.
    \ILabel{def:first_order_term/func} If \( \tau_1, \ldots, \tau_n \) are terms and \( f \) is a functional symbol with arity \( n \), then the following word is also a term:
    \begin{equation*}
      f(\tau_1, \ldots, \tau_n).
    \end{equation*}
  \end{DefEnum}

  In particular, constants are terms.

  Furthermore, the grammar of first-order terms is unambiguous (see \fullref{thm:first_order_formulas_are_unambiguous}).

  For each term \( \tau \), we define its variables as
  \begin{BreakableAlign*}
    \Bold{Free}(\tau) \coloneqq \begin{cases}
      \xi,                                                      & \tau = \xi \in \Bold{Var},        \\
      \Bold{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), & \tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
  \end{BreakableAlign*}
\end{definition}

\begin{definition}\label{def:propositional_language}\label{def:first_order_formula}\MarginCite[189]{OpenLogic20201202}
  We now define the propositional formulas themselves.

  \begin{DefEnum}
    \ILabel{def:propositional_language/language} The set of \Def{propositional formulas} \( \CF_B \) is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by the grammar
    \begin{bnf*}
      \bnfprod{property}   {p \in \Bold{Prop}} \\
      \bnfprod{connective} {\circ \in \Sigma} \\
      \bnfprod{formula}    {\bnfpn{property} \bnfor} \\
      \bnfmore             {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore             {\bnfts{\neg} \bnfpn{formula}} \\
      \bnfmore             {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)}}
    \end{bnf*}

    This grammar is unambiguous by \fullref{thm:propositional_formulas_are_unambiguous}.

    \ILabel{def:propositional_language/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \Def{subformula} of \( \varphi \).

    \ILabel{def:propositional_language/variables} For each formula \( \varphi \), we inductively\IND define its \Def{variables} to be elements of the set
    \begin{equation}\label{def:propositional_language/var}
      \Bold{Var}(\varphi) \coloneqq \begin{cases}
        \varnothing,                              & \varphi \in \{ \top, \bot \}                     \\
        \{ P \},                                  & \varphi = P \in \Bold{Prop}                      \\
        \Bold{Var}(\psi),                         & \varphi = \neg \psi                              \\
        \Bold{Var}(\psi) \cup \Bold{Var}(\theta), & \varphi = (\psi \circ \theta), \circ \in \Sigma.
      \end{cases}
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{definition}
  Given a first-order logic language \( \CL \), we define the set of atomic formulas inductively as
  \begin{itemize}
    \ILabel{def:first_order_formula/atomic/const} Both \( \top \) and \( \bot \) are atomic formulas.
    \ILabel{def:first_order_formula/atomic/pred} If \( p \) is an n-ary predicate symbol and if \( \tau_1, \ldots, \tau_n \) are terms, then \( p(\tau_1, \ldots, \tau_n) \) is an atomic formula.
    \ILabel{def:first_order_formula/atomic/eq} If \( \CL \) has an equality symbol and if \( \tau_1, \tau_2 \) are terms, then \( (\tau_1 \doteq \tau_2) \) is an atomic formula.
  \end{itemize}

  The set \( \Cal{F} \) of first-order formulas is then defined as
  \begin{itemize}
    \ILabel{def:first_order_formula/atomic} All atomic formulas are formulas.
    \ILabel{def:first_order_formula/neg} If \( \varphi \) is a formula, its negation \( \neg \varphi \) is also a formula.
    \ILabel{def:first_order_formula/connectives} If \( \varphi \) and \( \psi \) are formulas, then \( (\varphi \circ \psi), \circ \in \Sigma \) (see \fullref{def:first_order_logic_alphabet/propositional}), are also formulas.
    \ILabel{def:first_order_formula/quant} If \( \varphi \) is a formula and \( \xi \) is a variable, then \( Q \xi \varphi, Q \in  \) (see \fullref{def:first_order_logic_alphabet/quantifiers}), are also formulas.
  \end{itemize}

  Furthermore, the grammar of first-order formulas is unambiguous (see \fullref{thm:first_order_formulas_are_unambiguous}).

  For each formula \( \varphi \), we define its free and bound variables as
  \begin{equation}\label{def:first_order_formula/free}
    \Bold{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                              & \varphi \in \{ \top, \bot \}                       \\
      \Bold{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), & \varphi = p(\tau_1, \ldots, \tau_n)                \\
      \Bold{Free}(\tau_1) \cup \Bold{Free}(\tau_2),             & \varphi = (\tau_1 \doteq \tau_2),                  \\
      \Bold{Free}(\psi),                                        & \varphi = \neg \psi,                               \\
      \Bold{Free}(\psi_1) \cup \Bold{Free}(\psi_2),             & \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma,   \\
      \Bold{Free}(\psi) \setminus \{ \xi \},                    & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}
    \end{cases}
  \end{equation}
  and
  \begin{equation}\label{def:first_order_formula/bound}
    \Cat{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                   & \varphi \in \{ \top, \bot \}                        \\
      \varnothing,                                   & \varphi = p(\tau_1, \ldots, \tau_n)                 \\
      \varnothing,                                   & \varphi = (\tau_1 \doteq \tau_2),                   \\
      \Cat{Bound}(\psi),                             & \varphi = \neg \psi,                                \\
      \Cat{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2), & \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma,    \\
      \Cat{Bound}(\psi) \cup \{ \xi \},              & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}.
    \end{cases}
  \end{equation}

  A formula is called \Def{closed} if it has no bound variables.

  If a formula \( \varphi \) has free variables \( \Bold{Free}(\varphi) = \{ \xi_1, \ldots, \xi_n \} \), we write it as
  \begin{equation*}
    \varphi(\xi_1, \ldots, \xi_n).
  \end{equation*}

  This highlights that formulas with free variables can act as predicates, however their \hyperref[def:first_order_model]{semantics} are completely determined by the actual predicates.
\end{definition}

\begin{proposition}\label{thm:first_order_formulas_are_unambiguous}
  The \hyperref[def:grammar]{grammar}
  \begin{AlignedEquation}\label{eq:thm:first_order_formulas_are_unambiguous/grammar}
    &\Theta \to v,                                          && v \in \Bold{Var}                                                \\
    &\tau \to \Theta,                                       &&                                                                 \\
    &\tau \to f(\tau, \ldots, \tau),                        && f \in \Bold{Fun} \text{ is an } n-\text{ary functional symbol} \\
    &\Phi \to \top \;|\; \bot                               &&                                                                 \\
    &\Phi \to p(\tau, \ldots, \tau),                        && p \in \Bold{Pred} \text{ is an } n-\text{ary predicate symbol}  \\
    &\Phi \to (\tau \doteq \tau)                            &&                                                                 \\
    &\Phi \to \neg \Phi                                     &&                                                                 \\
    &\Phi \to (\Phi \circ \Phi),                            && \circ \in \Sigma                                                \\
    &\Phi \to \forall \Theta \Phi \;|\; \exists \Theta \Phi &&                                                                 \\
  \end{AlignedEquation}
  of \hyperref[def:first_order_term]{first-order terms} and \hyperref[def:first_order_formula]{formulas} is \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \fullref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{definition}\label{def:first_order_substition}
  Let \( \varphi \) be a first-order formula with a free variable \( \eta \) and \( \rho \) be a term. We define the \Def{substitions}
  \begin{BreakableAlign*}
    \tau[\eta \to \rho]    & \coloneqq \begin{cases}
      \rho,                                                    & \tau = \eta,                                    \\
      \xi,                                                     & \tau = \xi \in \Bold{Var} \setminus \{ \eta \}, \\
      f(\tau_1[\eta \to \rho], \ldots, \tau_n[\eta \to \rho]), & \tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
    \\
    \varphi[\eta \to \rho] & \coloneqq \begin{cases}
      \varphi,                                                 & \varphi \in \{ \top, \bot \}                                                       \\
      p(\tau_1[\eta \to \rho], \ldots, \tau_n[\eta \to \rho]), & \varphi = p(\tau_1, \ldots, \tau_n)                                                \\
      (\tau_1[\eta \to \rho] \doteq \tau_2[\eta \to \rho]),    & \varphi = (\tau_1 \doteq \tau_2),                                                  \\
      \neg \psi[\eta \to \rho],                                & \varphi = \neg \psi,                                                               \\
      \psi_1[\eta \to \rho] \circ \psi_2[\xi \to \rho],        & \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma,                                   \\
      Q \xi \psi[\eta \to \rho],                               & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}, \xi \not\in \Bold{Free}(\rho), \\
      Q \xi \psi[\eta \to \rho[\xi \to \zeta]],                & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}, \xi \in \Bold{Free}(\rho)
    \end{cases}
  \end{BreakableAlign*}
  where in the last step \( \zeta \in \Bold{Var} \setminus \Bold{Free}(\rho) \).

  We define \Def{simultaneous substition of \( \eta_1, \ldots, \eta_n \) with \( \rho_1, \ldots, \rho_n \)} analogously to \fullref{def:propositional_substition}.
\end{definition}
