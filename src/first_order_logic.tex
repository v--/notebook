\subsection{First-order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_logic_alphabet}\MarginCite[187]{OpenLogic20201202}
  The idea of first-order predicate logic is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universum. Unlike in \hyperref[subsec:propositional_logic]{propositional logic}, there are different first-order logic languages.

  The alphabet for a \Def{first-order predicate logic \hyperref[def:language]{language}} \( \CL \) extends that of \hyperref[subsec:propositional_logic]{propositional logic} and consists of two types of symbols.

  \begin{description}
    \item[Logical symbols]\mbox{}
    \begin{DefEnum}[series=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/propositional} The entirety of the \hyperref[subsec:propositional_logic]{propositional logic alphabet}.

      \ILabel{def:first_order_logic_alphabet/var} A countable alphabet of variables \( \Bold{Var} \), usually denoted by \( \xi_1, \xi_2, \ldots \) or \( \xi, \eta, \zeta \).

      \ILabel{def:first_order_logic_alphabet/quantifiers} The quantifiers \( Q = \Set{ \forall, \exists } \):
      \begin{DefEnum}
        \ILabel{def:first_order_logic_alphabet/quantifiers/universal} The \Def{universal quantifier} \( \forall \).
        \ILabel{def:first_order_logic_alphabet/quantifiers/existential} The \Def{existential quantifier} \( \exists \).
        \ILabel{def:first_order_logic_alphabet/quantifiers/dot} The dot \( \centerdot \) for separating a quantifier from its formula. The dot itself is not itself a quantifier. This is not formally necessary and we use it only for readability.
      \end{DefEnum}

      \ILabel{def:first_order_logic_alphabet/equality} Optionally, an equality symbol \( \doteq \). See \fullref{rem:first_order_equality}.
    \end{DefEnum}

    \item[Non-logical symbols]\mbox{}
    \begin{DefEnum}[resume=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/func} A set of functional symbols, \( \Bold{Fun} \), whose elements are usually denoted by \( f_1, f_2, \ldots \) or \( f, g, h \) or by symbols lie \( \oplus \), in which case we use infix notation. Each functional symbol has an associated natural number called its \Def{arity}, denoted by \( \# f \). Functional symbols with a zero arity are called \Def{constants}.

      \ILabel{def:first_order_logic_alphabet/pred} A set of predicate symbols, \( \Bold{Pred} \), whose elements are usually denoted by \( p_1, p_2, \ldots \) or by symbols like \( \leq \), in which case we use infix notation. Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \Def{propositional variables}.
    \end{DefEnum}
  \end{description}

  The logical symbols, with the exception of formal equality, are common for all first-order languages. Thus first-order languages differ by their non-logical symbols. The collection of functional and predicate symbols of a language are sometimes called its \Def{signature}.
\end{definition}

\begin{definition}\label{def:first_order_language}\mbox{}
  \begin{DefEnum}
    \ILabel{def:first_order_language/grammar} Consider the following \hyperref[def:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}        {v \in \Bold{Var}} \\
      \bnfprod{connective}      {\circ \in \Sigma} \\
      \bnfprod{quantifier}      {\bnfts{\( \forall \)} \bnfor \bnfts{\( \exists \)}} \\
      \bnfprod{unary function}  {f \in \Bold{Fun}, \#f = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary function}  {f \in \Bold{Fun}, \#f = n \text{ (separate rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{unary predicate} {p \in \Bold{Pred}, \#p = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary predicate} {p \in \Bold{Pred}, \#p = n \text{ (separate rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{term}            {\bnfpn{variable} \bnfor} \\
      \bnfmore                  {\bnfpn{unary function} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary function} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{atomic formula}  {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{\( \doteq \)} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{unary predicate} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary predicate} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{formula}         {\bnfpn{atomic formula} \bnfor} \\
      \bnfmore                  {\bnfts{\neg} \bnfpn{formula} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{quantifier} \bnfsp \bnfpn{variable} \bnfsp \bnfts{\( \centerdot \)} \bnfsp \bnfpn{formula}}
    \end{bnf*}

    In practice, we usually only have functions or predicates of specific arities. Note that we can have infinitely many functions but only finitely many different arities. The \hyperref[rem:theory_of_left_monoid_actions]{theory of monoid actions} is an example of a first-order language with infinitely many unary functional symbols, one constant and one binary functional symbol.

    If we need the grammars to have a finite set of rules, except for having only finitely many different arities, we need to introduce appropriate naming conventions for variables, functions and predicates, analogously to \fullref{ex:natural_arithmetic_grammar/backus_naur_form}.

    We will be using the conventions in \fullref{rem:propositional_formula_parentheses} by extending it for outer parentheses around equality formulas.

    \ILabel{def:first_order_language/term}\MarginCite[189]{OpenLogic20201202}The set \( \CT \) of \Def{terms} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{term} \) as a starting rule.

    The grammar of first-order terms is unambiguous by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    \ILabel{def:first_order_language/subterm} If \( \tau \) and \( \kappa \) are terms and \( \kappa \) is a \hyperref[def:language/subword]{subword} of \( \tau \), we say that \( \kappa \) is a \Def{subterm} of \( \tau \).

    \ILabel{def:first_order_language/term_variables} For each term \( \tau \), we define its variables as
    \begin{equation}\label{eq:def:first_order_language/term_variables}
      \Bold{Var}(\tau) \coloneqq \begin{cases}
        \xi,                                                    &\tau = \xi \in \Bold{Var},        \\
        \Bold{Var}(\tau_1) \cup \ldots \cup \Bold{Var}(\tau_n), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    As in \fullref{def:propositional_language/variables}, \( \Bold{Var} \) is ordered by the position of the first occurrence of a variable.

    \ILabel{def:first_order_language/formula} The set \( \CF \) of \Def{formulas} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{formula} \) as a starting rule.

    The \Def{atomic formulas} are the ones generated from \( \bnfpn{atomic formula} \).

    The grammar of first-order formulas is unambiguous by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    See \fullref{ex:first_order_substitution} for examples of formulas.

    \ILabel{def:first_order_language/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \Def{subformula} of \( \varphi \).

    \ILabel{def:first_order_language/formula_terms} If \( \varphi \) is a formula, if \( \tau \) is a term and if \( \tau \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \tau \) is a \Def{term} of \( \varphi \).

    \ILabel{def:first_order_language/formula_free_variables} The \Def{free variables} of a formula are defined as
    \begin{equation}\label{eq:def:first_order_language/formula_free_variables}
      \Bold{Free}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                            &\varphi \in \Set{ \top, \bot } \\
        \Bold{Var}(\tau_1) \cup \ldots \cup \Bold{Var}(\tau_n), &\varphi = p(\tau_1, \ldots, \tau_n) \\
        \Bold{Var}(\tau_1) \cup \Bold{Var}(\tau_2),             &\varphi = \tau_1 \doteq \tau_2, \\
        \Bold{Free}(\psi),                                      &\varphi = \neg \psi, \\
        \Bold{Free}(\psi_1) \cup \Bold{Free}(\psi_2),           &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \Bold{Free}(\psi) \setminus \Set{ \xi },                  &\varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists }
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_language/formula_bound_variables} Dually, the \Def{bound variables} of a formula are defined as
    \begin{equation}\label{eq:def:first_order_language/formula_bound_variables}
      \Bold{Bound}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                    &\varphi \text{ is atomic}, \\
        \Bold{Bound}(\psi),                             &\varphi = \neg \psi, \\
        \Bold{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2), &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \Bold{Bound}(\psi) \cup \Set{ \xi },              &\varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists }.
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_language/formula_variables} Finally, the set of all variables of a formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_language/formula_variables}
      \Bold{Var}(\varphi) \coloneqq \Bold{Free}(\varphi) \cup \Bold{Bound}(\varphi).
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{proposition}\label{thm:first_order_terms_and_formulas_are_unambiguous}
  The grammars of \hyperref[def:first_order_language/term]{first-order terms} and of \hyperref[def:first_order_language/formula]{first-order formulas} are \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \fullref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{definition}\label{def:first_order_structure}\MarginCite[def. 14.27]{OpenLogic20201202}
  Fix a first-order logic language \( \CL \). A \Def{structure} \( \CX \) for \( \CL \) is a pair \( (X, I) \), where

  \begin{DefEnum}
    \ILabel{def:first_order_structure/set} \( X \) is a nonempty set called the \Def{universum} of \( \CX \).

    \ILabel{def:first_order_structure/interpretation} \( I \) is a \hyperref[def:function]{map} called the \Def{interpretation} of \( \CX \) that we define partially as
    \begin{DefEnum}
      \ILabel{def:first_order_structure/interpretation/equality} The interpretation \( I(\doteq) \) of the equality is a \hyperref[def:binary_relation]{binary relation} on \( X \).

      \ILabel{def:first_order_structure/interpretation/function} For every \( n \)-ary function symbol \( f \), its interpretation is a \hyperref[def:function]{function} of type \( I(f): X^n \to X \).

      \ILabel{def:first_order_structure/interpretation/predicate} For every \( n \)-ary predicate \( p \), its interpretation is a an n-ary \hyperref[def:relation]{relation} \( I(p) \subseteq X^n \). This relation corresponds to all tuples of values that satisfy the predicate within the structure.
    \end{DefEnum}
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_valuation}
  Fix a structure \( \CX = (X, I) \) for a first-order logic language \( \CL \).

  \begin{DefEnum}
    \ILabel{def:first_order_valuation/variable_assignment} A \Def{variable assignment} for the variables of \( \CL \) is any function \( v: \Bold{Var} \to X \) (loosely similar to \hyperref[def:propositional_valuation/interpretation]{propositional interpretations}).

    \ILabel{def:first_order_valuation/modified_assignment} For every variable \( \xi \) and every universum element \( x \in X \) we also define the \Def{modified assignment} at \( \xi \) with \( x \):
    \begin{equation*}
      v_x^\xi(\eta) \coloneqq \begin{cases}
        x,    &\eta = \xi, \\
        v(\eta), &\eta \neq \xi.
      \end{cases}
    \end{equation*}

    Inductively\IND,
    \begin{equation*}
      v_{x_1, \ldots, x_n}^{\xi_1, \ldots, \xi_n}(\eta) \coloneqq ((v_{x_1}^{\xi_1})_{x_2}^{\xi_2})\cdots_{x_n}^{\xi_n}(\eta).
    \end{equation*}

    \ILabel{def:first_order_valuation/term_valuation} The \Def{valuation} of a term \( \tau \) is a value in the universum \( X \) given by
    \begin{equation}\label{eq:def:first_order_valuation/term_valuation}
      \tau\Val{v} \coloneqq \begin{cases}
        v(\xi),                                     &\tau = \xi \in \Bold{Var}, \\
        I(f)(\tau_1\Val{v}, \ldots, \tau_n\Val{v}), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_valuation/formula_valuation} The \Def{valuation} of a formula \( \varphi \) is a Boolean value (see \fullref{def:propositional_valuation}) given by
    \begin{equation}\label{eq:def:first_order_valuation/formula_valuation}
      \varphi\Val{v} \coloneqq \begin{cases}
        T,                                                         &\varphi = \top, \\
        F,                                                         &\varphi = \bot, \\
        (\tau_1\Val{v}, \tau_2\Val{v}) \in I(\doteq),              &\varphi = \tau_1 \doteq \tau_2, \\
        (\tau_1\Val{v}, \ldots, \tau_n\Val{v}) \in I(p),           &\varphi = p(\tau_1, \ldots, \tau_n), \\
        \Ol{\psi\Val{v}},                                          &\varphi = \neg \psi, \\
        \psi_1\Val{v} \circ \psi_2\Val{v},                         &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        T \T{iff} \psi[v_x^\xi] = T \T{for every} x \in X,         &\varphi = \forall \xi \centerdot \psi, \\
        T \T{iff there exists} x \in X \T{s.t.} \psi[v_x^\xi] = T, &\varphi = \exists \xi \centerdot \psi.
      \end{cases}
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_semantics}\MarginCite[208]{OpenLogic20201202}
  Fix a first-order logic language \( \CL \). We introduce notions analogous to \hyperref[def:propositional_semantics]{propositional semantics}:
  \begin{DefEnum}
    \ILabel{def:first_order_semantics/satisfiability} Given a \hyperref[def:first_order_structure]{structure} \( \CX = (X, I) \), a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) and a set \( \Gamma \) of \hyperref[def:first_order_language/formula]{first order formulas}, we say that the variable assignment \( v \) \Def{satisfies} \( \Gamma \) and we write \( \CX \vDash_v \Gamma \) if, for every formula \( \gamma \in \Gamma \) we have \( \gamma\Val{v} = T \).

    If every variable assignment in \( \CX \) satisfies \( \Gamma \), we say that \( \CX \) itself satisfies \( \Gamma \) or that \( \CX \) is a \Def{model} of \( \Gamma \) and write \( \CX \vDash \Gamma \).

    Analogously to \fullref{def:propositional_semantics/satisfiability}, we say that \( \Gamma \) is satisfiable if there exists a model for \( \Gamma \).

    \ILabel{def:first_order_semantics/entailment} We say that the set of formulas \( \Gamma \) \Def{entails} the set of formulas \( \Delta \) and write \( \Gamma \vDash \Delta \) if every model of \( \Gamma \) is also a model of \( \Delta \).

    \ILabel{def:first_order_semantics/tautology} The formula \( \varphi \) is a \Def{tautology} if every structure is a model of \( \varphi \).

    \ILabel{def:first_order_semantics/contradiction} Dually, \( \varphi \) is a \Def{contradiction} is no structure is a model of \( \varphi \).

    \ILabel{def:first_order_semantics/equivalence} We say that \( \varphi \) and \( \psi \) are \Def{semantically equivalent} and write \( \varphi \Sequiv \psi \) if both \( \varphi \vDash \psi \) and \( \psi \vDash \varphi \).
  \end{DefEnum}
\end{definition}

\begin{definition}\label{def:first_order_substitution}
  As in \hyperref[subsec:propositional_logic]{propositional logic}, we sometimes want to perform substitution. What complicates us is that there are both terms and formulas that can be substituted and different approaches are suitable for different cases. As in \fullref{def:propositional_substitution}, we define different kinds of (single) \Def{substitution} in more generality that in e.g. \cite[def. 14.25]{OpenLogic20201202}. Where applicable, \Def{simultaneous substitution} is defined via the same trick as in \fullref{def:propositional_substitution}.

  \begin{DefEnum}
    \ILabel{def:first_order_substitution/predicate} Let \( \varphi \) be a \hyperref[def:propositional_language/formula]{propositional formula} with variables \( \Bold{Var}(\varphi) = \Set{ P_1, \ldots, P_n } \). For brevity, denote \( V \coloneqq \Bold{Var}(\varphi) \). Let \( \Rho = \Set{ \rho_1, \ldots, \rho_n } \) be a set of \hyperref[def:first_order_language/formula]{first order formulas}.

    It does not make sense to replace a single propositional variable by a single formula. Furthermore, a first-order formula \( \rho_k \) cannot possibly contain any of the propositional variables \( P_1, \ldots, P_n \). We introduce a simplification of the simultaneous substitution based on \eqref{eq:def:propositional_substitution/single} as
    \begin{equation}\label{eq:def:first_order_substitution/predicate}
      \varphi[V \mapsto \Rho] \coloneqq \begin{cases}
        \varphi,                                             &\varphi \in \Set{ \top, \bot } \\
        \rho_k,                                              &\varphi = \rho_k \T{for some} k = 1, \ldots, n \\
        \neg \psi[V \mapsto \Rho],                           &\varphi = \neg \psi \\
        \psi_1[V \mapsto \Rho] \circ \psi_2[V \mapsto \Rho], &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma.
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_substitution/term_in_term} The substitution of the \hyperref[def:first_order_language/term]{first order term} \( \kappa \) with \( \mu \) in the term \( \tau \) is
    \begin{equation}\label{eq:def:first_order_substitution/term_in_term}
      \tau[\kappa \mapsto \mu] \coloneqq \begin{cases}
        \mu,                                                               &\tau = \kappa, \\
        \tau,                                                              &\tau \neq \kappa \T{and} \tau \in \Bold{Var}, \\
        f(\tau_1[\kappa \mapsto \mu], \ldots, \tau_n[\kappa \mapsto \mu]), &\tau \neq \kappa \T{and} \tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_substitution/term_in_formula} This is the only complicated case. The substitution of the term \( \kappa \) with the term \( \mu \) in the first order formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_substitution/term_in_formula}
      \varphi[\kappa \mapsto \mu] \coloneqq \begin{cases}
        \varphi,                                                           &\varphi \in \Set{ \top, \bot }, \\
        p(\tau_1[\kappa \mapsto \mu], \ldots, \tau_n[\kappa \mapsto \mu]), &\varphi = p(\tau_1, \ldots, \tau_n), \\
        \tau_1[\kappa \mapsto \mu] \doteq \tau_2[\kappa \mapsto \mu],      &\varphi = \tau_1 \doteq \tau_2, \\
        \neg \psi[\kappa \mapsto \mu],                                     &\varphi = \neg \psi, \\
        \psi_1[\kappa \mapsto \mu] \circ \psi_2[\xi \mapsto \mu],          &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        (\Ast),                                                            &\varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists },
      \end{cases}
    \end{equation}
    where \( (\Ast) \) is defined piecewise as
    \begin{align}
      &\varphi                                                                     &&\T{if} \xi \in \Bold{Var}(\kappa), \label{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial} \\
      &Q \xi \centerdot \Parens[\Big]{\psi[\kappa \mapsto \mu]}                    &&\T{if} \xi \not\in \Bold{Var}(\kappa) \cup \Bold{Var}(\mu), \label{eq:def:first_order_substitution/term_in_formula/quantifiers/direct} \\
      &Q \eta \centerdot \Parens[\Big]{\psi[\xi \mapsto \eta][\kappa \mapsto \mu]} &&\T{if} \xi \not\in \Bold{Var}(\kappa) \T{and} \xi \in \Bold{Var}(\mu) \T{and} \label{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming} \\
                                                                                   &&&\phantom{\T{if}} \eta \not\in \Bold{Var}(\kappa) \cup \Bold{Var}(\mu) \cup \Bold{Var}(\psi). \nonumber
    \end{align}

    In \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}, we chose a new variable \( \eta \). We implicitly assume that there exist enough variables in the language so that we can find \( \eta \) that satisfies the condition. We can alternatively define substitution solely via \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct} (as it is done in \cite[def. 14.25]{OpenLogic20201202}), however that requires us to only define substitution in certain special cases. We prefer the same substitution operation to be defined for all formulas and terms, which requires a more elaborate definition and some nondeterminism in the choice of \( \eta \). In practice, if we with to avoid this nondeterminism, we can enforce non-overlapping variables.

    The rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial} may seem redundant but when doing inductive proofs (e.g. the proof of \fullref{thm:swapping_assignment_compatibility}), we usually need to separately consider the cases where \( \xi \in \Bold{Var}(\kappa) \) and \( \xi \not\in \Bold{Var}(\kappa) \setminus \Bold{Var}(\mu) \) and the rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct} being trivial simplifies the proofs.

    The rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming} is called \Def{renaming of the bound variables} \( \xi \) to \( \eta \) and is done to mitigate capturing as described in \fullref{rem:first_order_substitution_renaming_justification/capturing}.

    See \fullref{rem:first_order_substitution_parentheses} regarding the additional parentheses in \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}.

    See \fullref{ex:first_order_substitution} for examples of applying the different quantifier rules.

    \ILabel{def:first_order_substitution/formula_in_formula} We purposely define substitution of first order formulas in analogy with \hyperref[def:propositional_substitution/single]{propositional formula substitution} rather than \hyperref[def:first_order_substitution/term_in_formula]{first-order term substitution in formulas}. Substitution of subformulas in first-order formulas is not even defined in \cite{OpenLogic20201202}. The purpose of this substitution, for us, is to replace subformulas as in \fullref{alg:conjunctive_normal_form_reduction} and the elaborate rules of \fullref{def:first_order_substitution/term_in_formula} would interfere with this.

    The substitution of the \hyperref[def:first_order_language/formula]{first order formula} \( \theta \) with the first order formula \( \rho \) in the first order formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_substitution/formula_in_formula}
      \varphi[\theta \mapsto \rho] \coloneqq \begin{cases}
        \rho,                                                       &\varphi = \theta, \\
        \varphi,                                                    &\varphi \neq \theta \T{and} \varphi \text{ is atomic}, \\
        \neg \psi[\theta \mapsto \rho],                             &\varphi \neq \theta \T{and} \varphi = \neg \psi, \\
        \psi_1[\theta \mapsto \rho] \circ \psi_2[\xi \mapsto \rho], &\varphi \neq \theta \T{and} \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        Q \xi \centerdot \Parens[\Big]{\psi[\theta \mapsto \rho]},  &\varphi \neq \theta \T{and} \varphi = Q \xi \centerdot \psi, Q \in \Set{ \forall, \exists }
      \end{cases}
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{remark}\label{rem:first_order_substitution_renaming_justification}
  The renaming rule \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming} is designed to mitigate the following two problems (compared to \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}):

  \begin{RemEnum}
    \ILabel{rem:first_order_substitution_renaming_justification/capturing} Renaming mitigates \enquote{capturing} free variables as in
    \begin{equation*}
      \Parens[\Big]{ \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \eta \centerdot p(\eta, \eta)
    \end{equation*}
    by instead doing.
    \begin{equation*}
      \Parens[\Big]{ \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \zeta \centerdot p(\eta, \zeta).
    \end{equation*}

    \ILabel{rem:first_order_substitution_renaming_justification/colliding} Renaming mitigates \enquote{colliding} multiple bound variables as in
    \begin{equation*}
      \Parens[\Big]{ \forall \xi \centerdot \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \xi \centerdot \forall \eta \centerdot p(\eta, \eta)
    \end{equation*}
    by instead giving
    \begin{equation*}
      \Parens[\Big]{ \forall \xi \centerdot \forall \eta \centerdot p(\xi, \eta) }[\xi \mapsto \eta] = \forall \zeta \centerdot \forall \sigma \centerdot p(\zeta, \sigma).
    \end{equation*}
  \end{RemEnum}
\end{remark}

\begin{remark}\label{rem:first_order_substitution_parentheses}
  When performing \hyperref[def:propositional_substitution]{substitution}, it is sometimes convenient to add additional parentheses to avoid ambiguity. For example, while parentheses around quantifier expressions are not necessary by the syntax of first-order logic, adding such parentheses helps avoid the ambiguity in
  \begin{equation*}
    \forall \xi \centerdot p(\xi, \eta) [\eta \mapsto \zeta].
  \end{equation*}

  Instead, we either write
  \begin{equation*}
    \Parens[\Big]{ \forall \xi \centerdot p(\xi, \eta) } [\eta \mapsto \zeta]
  \end{equation*}
  or
  \begin{equation*}
    \forall \xi \centerdot \Parens[\Big]{ p(\xi, \eta)[\eta \mapsto \zeta] }.
  \end{equation*}

  This convention is only part of the metasyntax and does not interfere with the syntax of the formulas themselves.
\end{remark}

\begin{example}\label{ex:first_order_substitution}
  The following term substitutions should justify the distinct cases in \eqref{eq:def:first_order_substitution/term_in_formula}:
  \begin{ExEnum}
    \ILabel{ex:first_order_substitution/1} The trivial case without actual substitution:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\xi \mapsto \eta]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}} = \\ &=
      \forall \xi \centerdot p(\xi, \eta).
    \end{align*}

    \Fullref{ex:first_order_substitution/5} demonstrates that this does not work for nested substitution.

    \ILabel{ex:first_order_substitution/2} A simple substitution without renaming:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\eta \mapsto \zeta]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}} = \\ &=
      \forall \xi \centerdot \Parens[\Big]{p(\xi, \eta)[\eta \mapsto \zeta]}
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \forall \xi \centerdot p(\xi, \zeta).
    \end{align*}

    \ILabel{ex:first_order_substitution/3} A simple renaming without actual substitution:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\eta \mapsto \xi]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{p(\xi, \eta)[\xi \mapsto \zeta][\eta \mapsto \xi]}
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \forall \zeta \centerdot p(\zeta, \xi).
    \end{align*}

    \ILabel{ex:first_order_substitution/4} \Fullref{ex:first_order_substitution/3} but with \( \mu \) in \eqref{eq:def:first_order_substitution/term_in_formula} containing \( \xi \) indirectly:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta)}[\eta \mapsto f(\xi)]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{p(\xi, \eta)[\xi \mapsto \zeta][\eta \mapsto f(\xi)]}
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \forall \zeta \centerdot p(\zeta, f(\xi)).
    \end{align*}

    \ILabel{ex:first_order_substitution/5} Only renaming with multiple quantifiers which shows the limitations of \eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \eta \centerdot \forall \xi \centerdot p(\xi, \eta)}[\xi \mapsto \eta]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ \Parens[\Big]{ \forall \xi \centerdot p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta]}
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ \Parens[\Big]{ \forall \xi \centerdot p(\xi, \zeta) }[\xi \mapsto \eta]}
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}} = \\ &=
      \forall \zeta \centerdot \forall \xi \centerdot p(\xi, \zeta).
    \end{align*}

    \ILabel{ex:first_order_substitution/6} Both renaming and substitution with multiple quantifiers:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{ \forall \eta \centerdot (p(\xi, \eta) \vee \forall \xi \centerdot p(\xi, \eta)) }[\xi \mapsto \eta]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ \Parens[\Big]{ p(\xi, \eta) \vee \forall \xi \centerdot p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta] }
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ p(\eta, \zeta) \vee \Parens[\Big]{ \forall \xi \centerdot p(\xi, \eta) }[\eta \mapsto \zeta][\xi \mapsto \eta] }
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/direct}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{ p(\eta, \zeta) \vee \Parens[\Big]{ \forall \xi \centerdot p(\xi, \zeta) }[\xi \mapsto \eta] }
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/trivial}} = \\ &=
      \forall \zeta \centerdot p(\eta, \zeta) \vee \forall \xi \centerdot p(\xi, \zeta).
    \end{align*}

    \ILabel{ex:first_order_substitution/7} Substitution of more general terms than variables with renaming of term's variables:
    \begin{align*}
      &{}\phantom{=}{}
      \Parens[\Big]{\forall \xi \centerdot p(\xi, \eta, f(\eta))}[f(\eta) \mapsto g(\eta, \xi)]
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula/quantifiers/renaming}} = \\ &=
      \forall \zeta \centerdot \Parens[\Big]{p(\xi, \eta, f(\eta))[\xi \mapsto \zeta][f(\eta) \mapsto g(\eta, \xi)]}
      \overset {\eqref{eq:def:first_order_substitution/term_in_formula}} = \\ &=
      \forall \zeta \centerdot p(\zeta, \eta, g(\eta, \xi)).
    \end{align*}
  \end{ExEnum}
\end{example}

\begin{proposition}\label{thm:swapping_assignment_compatibility}
  We will show how \hyperref[rem:first_order_substitution_renaming_justification]{syntactic renaming} is compatible with a certain \enquote{semantic renaming}.

  Fix a \hyperref[def:first_order_language]{first-order language} \( \CL \), a \hyperref[def:first_order_structure]{structure} \( \CX = (X, I) \) on \( \CL \) and a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \) in \( \CX \). For any variables \( \xi \) and \( \eta \), define the \enquote{swapping} assignment
  \begin{equation}\label{eq:thm:swapping_assignment_compatibility/swapping_assignment}
    v_\eta^\xi(\zeta) \coloneqq \begin{cases}
      v(\eta), \zeta = \xi, \\
      v(\xi), \zeta = \eta, \\
      v(\zeta), \text{otherwise}.
    \end{cases}
  \end{equation}

  \begin{PropEnum}
    \ILabel{thm:swapping_assignment_compatibility/terms} For any term \( \tau \) and any two variables \( \xi \) and \( \eta \), we have
    \begin{equation}\label{eq:thm:swapping_assignment_compatibility/terms}
      \tau\Val{v_\eta^\xi}
      =
      \Parens[\Big]{ \tau[\xi \mapsto \eta] }\Val{v}.
    \end{equation}

    \ILabel{thm:swapping_assignment_compatibility/formulas} For any formula \( \varphi \), any \( \eta \not\in \Bold{Var}(\varphi) \cup \Bold{Var}(\mu) \) and any variable \( \xi \) we have
    \begin{equation}\label{eq:thm:swapping_assignment_compatibility/formulas}
      \varphi\Val{v_\eta^\xi}
      =
      \Parens[\Big]{ \varphi[\xi \mapsto \eta] }\Val{v}.
    \end{equation}
  \end{PropEnum}
\end{proposition}
\begin{proof}
  In both cases, we use structural induction on the definition of the substitution\IND.

  \SubProofOf{thm:swapping_assignment_compatibility/terms}\mbox{}
  \begin{itemize}
    \item If \( \tau = \xi \), then
    \begin{equation*}
      \tau[\xi \mapsto \eta] = \xi[\xi \mapsto \eta] = \eta
    \end{equation*}
    and \eqref{eq:thm:swapping_assignment_compatibility/terms} follows directly.

    \item If \( \tau \) is a variable and \( \tau \neq \xi \), then
    \begin{equation*}
      \tau[\xi \mapsto \eta] = \tau
    \end{equation*}
    and \eqref{eq:thm:swapping_assignment_compatibility/terms} again holds trivially.

    \item If \( \tau = f(\tau_1, \ldots, \tau_n) \) and if the inductive hypothesis holds for \( \tau_1, \ldots, \tau_n \), then
    \begin{BreakableAlign*}
      \Parens[\Big]{ \tau[\xi \mapsto \eta] }\Val{v}
      &=
      \Parens[\Big]{ f(\tau_1[\xi \mapsto \eta], \ldots, \tau_n[\xi \mapsto \eta]) }\Val{v}
      = \\ &=
      I(f) \Parens[\Bigg]{ \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v}, \ldots, \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v} }
      \overset {\IndHyp} = \\ &=
      I(f) \Parens[\Big]{ \tau_1\Val{v_\eta^\xi}, \ldots, \tau_n\Val{v_\eta^\xi} }
      = \\ &=
      \Parens[\Big]{ f(\tau_1, \ldots, \tau_n) }\Val{v_\eta^\xi}
      = \\ &=
      \tau\Val{v_\eta^\xi}.
    \end{BreakableAlign*}
  \end{itemize}

  In all cases, \eqref{eq:thm:swapping_assignment_compatibility/terms} holds.

  \SubProofOf{thm:swapping_assignment_compatibility/formulas}\mbox{}
  \begin{itemize}
    \item If \( \varphi \in \Set{ \top, \bot } \), then \( \varphi \) has no subterms and thus \eqref{eq:thm:swapping_assignment_compatibility/formulas} holds vacuously.

    \item If \( \varphi = p(\tau_1, \ldots, \tau_n) \), then by \eqref{eq:thm:swapping_assignment_compatibility/terms} for all \( \tau_k \) we have
    \begin{equation*}
      \Parens[\Big]{ \tau_k[\xi \mapsto \eta] }\Val{v} = \tau_k\Val{v_\eta^\xi}
    \end{equation*}
    and thus
    \begin{equation*}
      I(p)\Parens[\Big]{ \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v}, \ldots, \Parens[\Big]{ \tau_1[\xi \mapsto \eta] }\Val{v} }
      \overset {\IndHyp} =
      I(p)\Parens[\Big]{ \tau_1\Val{v_\eta^\xi}, \ldots, \tau_n\Val{v_\eta^\xi} }.
    \end{equation*}

    Therefore
    \begin{BreakableAlign*}
      \Parens[\Big]{ \varphi[\xi \mapsto \eta] }\Val{v}
      &=
      \Parens[\Big]{ p(\tau_1[\xi \mapsto \eta], \ldots, \tau_n[\xi \mapsto \eta]) }\Val{v}
      = \\ &=
      \Parens[\Big]{ p(\tau_1, \ldots, \tau_n) }\Val{v_\eta^\xi}
      = \\ &=
      \tau\Val{v_\eta^\xi}.
    \end{BreakableAlign*}

    \item The case \( \varphi = \tau_1 \doteq \tau_2 \) is proved analogously.

    \item The case \( \varphi = \neg \psi \) is obvious because it is a simple recursion.

    \item The case \( \varphi = \psi_1 \circ \psi_2 \) is also simple recursion.

    \item Let \( \varphi = \forall \zeta \centerdot \psi \), where the inductive hypothesis holds for \( \psi \). We consider three cases
    \begin{itemize}
      \item Assume that \( \xi = \zeta \). By definition, we have
      \begin{equation*}
        \varphi[\xi \mapsto \eta]
        =
        \varphi,
      \end{equation*}
      hence \eqref{thm:swapping_assignment_compatibility/formulas} holds trivially.

      \item Assume that \( \zeta \not\in \Set{ \xi, \eta } \). It follows that
      \begin{equation*}
        \varphi[\xi \mapsto \eta]
        =
        \forall \zeta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] }.
      \end{equation*}

      \begin{itemize}
        \item If \( \Parens[\Big]{\varphi[\xi \mapsto \eta]}\Val{v} = T \), by definition of \hyperref[def:first_order_valuation/formula_valuation]{quantifier formula valuation}, for any \( x \in X \) we have
        \begin{equation}\label{eq:thm:swapping_assignment_compatibility/formulas/true_modified_assignment}
          \Parens[\Big]{\forall \zeta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] }}\Val{v}
          =
          \Parens[\Big]{\psi[\xi \mapsto \eta]}\Val{v_x^\zeta}
          =
          T.
        \end{equation}

        On the other hand, by the inductive hypothesis,
        \begin{equation*}
          \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v} = \psi\Val{v_\eta^\xi}
        \end{equation*}
        and, as a special case, for any \( x \in X \),
        \begin{equation}\label{eq:thm:swapping_assignment_compatibility/formulas/ind_hyp_modified_assignment}
          \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_x^\zeta} = \psi\Val{v_{\eta,x}^{\xi,\zeta}}.
        \end{equation}

        Combining \eqref{eq:thm:swapping_assignment_compatibility/formulas/true_modified_assignment} and \eqref{eq:thm:swapping_assignment_compatibility/formulas/ind_hyp_modified_assignment}, we obtain
        \begin{equation*}
          \Parens[\Big]{ \varphi[\xi \mapsto \eta] }\Val{v}
          =
          \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_x^\zeta}
          =
          \underbrace{\psi\Val{v_{\eta,x}^{\xi,\zeta}}}_{T \T{for all} x \in X}
          =
          \varphi\Val{v_\eta^\xi},
        \end{equation*}
        which proves the case.

        \item If \( \Parens[\Big]{\varphi[\xi \mapsto \eta]}\Val{v} = F \), then there exists \( x \in X \) such that
        \begin{equation*}
          \Parens[\Big]{\psi[\xi \mapsto \eta]}\Val{v_x^\zeta} = F.
        \end{equation*}

        Since \eqref{eq:thm:swapping_assignment_compatibility/formulas/ind_hyp_modified_assignment} holds by the inductive hypothesis, we have
        \begin{equation*}
          \psi\Val{v_{\eta,x}^{\xi,\zeta}} = F
        \end{equation*}
        for the same \( x \).

        It follows that \( \varphi\Val{v_\eta^\xi} = F \), which proves the case.
      \end{itemize}

      \item This case holds vacuously because it is impossible to reach it - we have \( \eta \neq \zeta \) by the assumption \( \eta \not\in \Bold{Var}(\varphi) \cup \Bold{Var}(\mu) \).
    \end{itemize}

    \item We can prove the case \( \varphi = \exists \zeta \centerdot \psi \) using double negation on the previous case.
  \end{itemize}

  In all cases, \eqref{eq:thm:swapping_assignment_compatibility/formulas} holds.
\end{proof}

\begin{proposition}\label{thm:first_order_substitution_equivalence}
  Analogously to \fullref{thm:propositional_substitution_equivalence}, we will show that all defined in \fullref{def:first_order_substitution} types of substitution preserve the corresponding \hyperref[def:first_order_semantics]{semantics}.

  By induction, this proposition also holds for \hyperref[def:propositional_substitution/simultaneous]{simultaneous substitution}.

  Fix a \hyperref[def:first_order_structure]{structure} \( \CX = (X, I) \) and a \hyperref[def:first_order_valuation/variable_assignment]{variable assignment} \( v \).

  \begin{PropEnum}
    \ILabel{thm:first_order_substitution_equivalence/predicate} As in \fullref{def:first_order_substitution/predicate}, let \( \varphi \) be a \hyperref[def:propositional_language/formula]{propositional formula} with variables \( {V = \Set{ P_1, \ldots, P_n }} \) and let \( \Rho = \Set{ \rho_1, \ldots, \rho_n } \) be a set of \hyperref[def:first_order_language/formula]{first order formulas}.

    Furthermore, let \( J \) be a \hyperref[def:propositional_valuation/interpretation]{propositional interpretation} such that, for all \( k = 1, \ldots, n \),
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/propositional/compatibility}
      P_k\Val{J} = \rho_k\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/propositional}
      \Parens[\Big]{ \varphi[V \mapsto \Rho] }\Val{v} = \varphi \Val{J}.
    \end{equation}

    In particular, \( \vDash \varphi \) (in the sense of \fullref{def:propositional_semantics/tautology}) implies \( \vDash \varphi[V \mapsto \Rho] \) (in the sense of \fullref{def:first_order_semantics/tautology}).

    \ILabel{thm:first_order_substitution_equivalence/term_in_term} Let \( \tau \) be a \hyperref[def:first_order_language/term]{first order term} and let \( \kappa \) be a \hyperref[def:first_order_language/subterm]{subterm} of \( \tau \). Let \( \mu \) be another term such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_term/compatibility}
      \mu\Val{v} = \kappa\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_term}
      \Parens[\Big]{ \tau[\kappa \mapsto \mu] }\Val{v} = \tau\Val{v}.
    \end{equation}

    \ILabel{thm:first_order_substitution_equivalence/term_in_formula} Let \( \varphi \) be a \hyperref[def:first_order_language/formula]{first order formula} and let \( \kappa \) be a \hyperref[def:first_order_language/formula_terms]{term of \( \varphi \)}. Let \( \mu \) be another term such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula/compatibility}
      \mu\Val{v} = \kappa\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula}
      \Parens[\Big]{ \varphi[\kappa \mapsto \mu] }\Val{v} = \varphi\Val{v}.
    \end{equation}

    \ILabel{thm:first_order_substitution_equivalence/formula_in_formula} Let \( \varphi \) be a \hyperref[def:first_order_language/formula]{first order formula} and let \( \theta \) be a \hyperref[def:first_order_language/subformula]{subformula of \( \varphi \)}. Let \( \rho \) be another formula such that
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/formula_in_formula/compatibility}
      \theta\Val{v} = \rho\Val{v}.
    \end{equation}

    Then
    \begin{equation}\label{eq:thm:first_order_substitution_equivalence/formula_in_formula}
      \Parens[\Big]{ \varphi[\theta \mapsto \rho] }\Val{v} = \varphi\Val{v}.
    \end{equation}

    In particular, \( \theta \Sequiv \rho \) implies \( \varphi[\theta \mapsto \rho] \Sequiv \varphi \).
  \end{PropEnum}
\end{proposition}
\begin{proof}
  In all cases, we use structural induction by the definition of the substitution\IND. The inductive hypothesis for a formula is that the proposition holds for arbitrary substitutions and valuations.

  \SubProofOf{thm:first_order_substitution_equivalence/predicate} Let \( \varphi \) be a propositional formula.
  \begin{itemize}
    \item If \( \varphi \in \Set{ \top, \bot } \), no substitution is performed and thus \eqref{eq:thm:first_order_substitution_equivalence/propositional} holds trivially.

    \item If \( \varphi = P_k \) for some \( k = 1, \ldots, n \), then follows \eqref{eq:thm:first_order_substitution_equivalence/propositional} from \eqref{eq:thm:first_order_substitution_equivalence/propositional/compatibility}.

    \item If \( \varphi = \neg \psi \) and if the inductive hypothesis holds for \( \psi \), then
    \begin{equation*}
      \Parens[\Big]{ \psi[V \mapsto \Rho] }\Val{v}
      =
      \Ol{\Parens[\Big]{ \psi[V \mapsto \Rho] }\Val{v}}
      \overset {\IndHyp} =
      \Ol{\psi \Val{J}}
      =
      \varphi \Val{J}.
    \end{equation*}

    \item If \( \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma \) and if the inductive hypothesis holds for both \( \psi_1 \) and \( \psi_2 \), then
    \begin{equation*}
      \Parens[\Big]{ \psi[V \mapsto \Rho] }\Val{v}
      =
      \Parens[\Big]{ \psi_1[\theta \mapsto \rho] }\Val{v} \circ \Parens[\Big]{ \psi_2[\theta \mapsto \rho] }\Val{v}
      \overset {\IndHyp} =
      \psi_1 \Val{J} \circ \psi_2\Val{J}
      =
      \varphi\Val{J}.
    \end{equation*}
  \end{itemize}

  In all cases, \eqref{eq:thm:first_order_substitution_equivalence/propositional} holds.

  \SubProofOf{thm:first_order_substitution_equivalence/term_in_term} The proof is identical to that of \fullref{thm:swapping_assignment_compatibility/terms}.

  \SubProofOf{thm:first_order_substitution_equivalence/term_in_formula} The proof is identical to that of \fullref{thm:swapping_assignment_compatibility/formulas} except for the special case \( \varphi = Q \xi \centerdot \psi \), where \( Q \in \Set{ \forall, \exists } \), the inductive hypothesis holds for \( \psi \) and \( \xi \in \Bold{Free}(\mu) \).

  We will only show the case \( Q = \forall \) since the case \( Q = \exists \) is handled similarly.

  Since \( \xi \in \Bold{Free}(\mu) \), we have
  \begin{equation*}
    \varphi[\kappa \mapsto \mu]
    =
    \forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta][\kappa \mapsto \mu] },
  \end{equation*}
  which does not allow us to use the inductive hypothesis directly.

  We proceed to prove the statement by nested induction\IND on the number of quantifiers. We have already shown the case of \( 0 \) quantifiers. Suppose that the statement holds for all formulas with strictly less than \( n \) quantifiers and suppose that \( \varphi \) has exactly \( n \) quantifiers.

  Furthermore, for formulas with \( n \) quantifiers, we have shown all the other cases (for \( Q = \forall \)). Therefore, since \( \eta \not\in \Bold{Free}(\mu) \),
  \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula/nested_induction}
    \Parens[\Bigg]{ \Parens[\Big]{ \forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }[\kappa \mapsto \mu] }\Val{v}
    =
    \Parens[\Bigg]{\forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }\Val{v},
  \end{equation}
  where we have implicitly used that \( \psi \) has \( n - 1 \) quantifiers.

  On the other hand, by \fullref{thm:swapping_assignment_compatibility/formulas},
  \begin{equation*}
    \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v} = \psi\Val{v_\eta^\xi}
  \end{equation*}
  and, in particular, for any \( x \in X \),
  \begin{equation*}
    \Parens[\Big]{ \psi[\xi \mapsto \eta] }\Val{v_x^\eta} = \psi\Val{v_{\eta,x}^{\xi,\eta}}
  \end{equation*}

  Hence
  \begin{equation}\label{eq:thm:first_order_substitution_equivalence/term_in_formula/modified_assignment}
    \Parens[\Bigg]{\forall \eta \centerdot \Parens[\Big]{ \psi[\xi \mapsto \eta] } }\Val{v}
    =
    \Parens[\Big]{\forall \xi \centerdot \psi }\Val{v_\eta^\xi}.
  \end{equation}

  Now \eqref{eq:thm:first_order_substitution_equivalence/term_in_formula} follows from \eqref{eq:thm:first_order_substitution_equivalence/term_in_formula/nested_induction} and \eqref{eq:thm:first_order_substitution_equivalence/term_in_formula/modified_assignment}.

  \SubProofOf{thm:first_order_substitution_equivalence/formula_in_formula} The proof is analogous to that of \fullref{thm:first_order_substitution_equivalence/predicate}.
\end{proof}
