\subsection{First-order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_logic_language}\MarginCite[187]{OpenLogic20201202}
  The idea of first-order predicate logic is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universum. Unlike in \hyperref[subsec:propositional_logic]{propositional logic}, there are many first-order logic languages.

  The alphabet for a \Def{first-order predicate logic \hyperref[def:language]{language}} \( \CL \) extends that of \hyperref[subsec:propositional_logic]{propositional logic} and consists of two types of symbols.

  \begin{description}
    \item[Logical symbols]\mbox{}
    \begin{DefEnum}[series=def:first_order_logic_language]
      \ILabel{def:first_order_logic_language/propositional} The entirety of the \hyperref[subsec:propositional_logic]{propositional logic alphabet}.

      \ILabel{def:first_order_logic_language/var} A countable alphabet of variables \( \Bold{Var} \), usually denoted by \( \xi_0, \xi_1, \ldots \) or \( \xi, \eta, \zeta \).

      \ILabel{def:first_order_logic_language/quantifiers} Two quantifiers \( Q = \{ \forall, \exists \} \):
      \begin{DefEnum}
        \ILabel{def:first_order_logic_language/quantifiers/universal} The \Def{universal quantifier} \( \forall \).
        \ILabel{def:first_order_logic_language/quantifiers/existential} Then \Def{existential quantifier} \( \exists \).
      \end{DefEnum}

      \ILabel{def:first_order_logic_language/equality} Optionally, an equality symbol \( \doteq \). See \fullref{remark:first_order_equality}.
    \end{DefEnum}

    \item[Non-logical symbols]\mbox{}
    \begin{DefEnum}[resume=def:first_order_logic_language]
      \ILabel{def:first_order_logic_language/func} A set of functional symbols, \( \Bold{Func} \), whose elements are usually denoted by \( f_0, f_1, \ldots \) or \( f, g, h \). Each functional symbol has an associated natural number called its \Def{arity}, denoted by \( \# f \). Functional symbols with a zero arity are called \Def{constants}.

      \ILabel{def:first_order_logic_language/pred} A set of predicate symbols, \( \Bold{Pred} \), whose elements are usually denoted by \( p_0, p_1, \ldots \) or by symbols like \( \oplus \) or \( \circ \). Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \Def{propositional variables}.
    \end{DefEnum}
  \end{description}
\end{definition}

\begin{example}\label{ex:first_order_languages}
  Examples of first-order logic languages include
  \begin{itemize}
    \item \Fullref{def:peano_arithmetic} defines the Peano arithmetic
    \item \Fullref{def:algebraic_theory} defines different algebraic theories
  \end{itemize}
\end{example}

\begin{definition}\label{def:first_order_term}\MarginCite[189]{OpenLogic20201202}
  Given a first-order logic language \( \CL \), the set \( \Cal{T} \) of terms is defined inductively as
  \begin{DefEnum}
    \ILabel{def:first_order_term/var} Each variable is a term.
    \ILabel{def:first_order_term/func} If \( \tau_1, \ldots, \tau_n \) are terms and \( f \) is a functional symbol with arity \( n \), then the following word is also a term:
    \begin{equation*}
      f(\tau_1, \ldots, \tau_n).
    \end{equation*}
  \end{DefEnum}

  In particular, constants are terms.

  Furthermore, the grammar of first-order terms is unambiguous (see \fullref{thm:first_order_formulas_are_unambiguous}).

  For each term \( \tau \), we define its variables as
  \begin{BreakableAlign*}
    \Bold{Free}(\tau) \coloneqq \begin{cases}
      \xi,                                                      & \tau = \xi \in \Bold{Var},        \\
      \Bold{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), & \tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
  \end{BreakableAlign*}
\end{definition}

\begin{definition}\label{def:first_order_formula}\MarginCite[189]{OpenLogic20201202}
  Given a first-order logic language \( \CL \), we define the set of atomic formulas inductively as
  \begin{itemize}
    \ILabel{def:first_order_formula/atomic/const} Both \( \top \) and \( \bot \) are atomic formulas.
    \ILabel{def:first_order_formula/atomic/pred} If \( p \) is an n-ary predicate symbol and if \( \tau_1, \ldots, \tau_n \) are terms, then \( p(\tau_1, \ldots, \tau_n) \) is an atomic formula.
    \ILabel{def:first_order_formula/atomic/eq} If \( \CL \) has an equality symbol and if \( \tau_1, \tau_2 \) are terms, then \( (\tau_1 \doteq \tau_2) \) is an atomic formula.
  \end{itemize}

  The set \( \Cal{F} \) of first-order formulas is then defined as
  \begin{itemize}
    \ILabel{def:first_order_formula/atomic} All atomic formulas are formulas.
    \ILabel{def:first_order_formula/neg} If \( \varphi \) is a formula, its negation \( \neg \varphi \) is also a formula.
    \ILabel{def:first_order_formula/connectives} If \( \varphi \) and \( \psi \) are formulas, then \( (\varphi \circ \psi), \circ \in \Sigma \) (see \fullref{def:first_order_logic_language/propositional}), are also formulas.
    \ILabel{def:first_order_formula/quant} If \( \varphi \) is a formula and \( \xi \) is a variable, then \( Q \xi \varphi, Q \in  \) (see \fullref{def:first_order_logic_language/quantifiers}), are also formulas.
  \end{itemize}

  Furthermore, the grammar of first-order formulas is unambiguous (see \fullref{thm:first_order_formulas_are_unambiguous}).

  For each formula \( \varphi \), we define its free and bound variables as
  \begin{equation}\label{def:first_order_formula/free}
    \Bold{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                              & \varphi \in \{ \top, \bot \}                       \\
      \Bold{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), & \varphi = p(\tau_1, \ldots, \tau_n)                \\
      \Bold{Free}(\tau_1) \cup \Bold{Free}(\tau_2),             & \varphi = (\tau_1 \doteq \tau_2),                  \\
      \Bold{Free}(\psi),                                        & \varphi = \neg \psi,                               \\
      \Bold{Free}(\psi_1) \cup \Bold{Free}(\psi_2),             & \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma,   \\
      \Bold{Free}(\psi) \setminus \{ \xi \},                    & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}
    \end{cases}
  \end{equation}
  and
  \begin{equation}\label{def:first_order_formula/bound}
    \Cat{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                   & \varphi \in \{ \top, \bot \}                        \\
      \varnothing,                                   & \varphi = p(\tau_1, \ldots, \tau_n)                 \\
      \varnothing,                                   & \varphi = (\tau_1 \doteq \tau_2),                   \\
      \Cat{Bound}(\psi),                             & \varphi = \neg \psi,                                \\
      \Cat{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2), & \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma,    \\
      \Cat{Bound}(\psi) \cup \{ \xi \},              & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}.
    \end{cases}
  \end{equation}

  A formula is called \Def{closed} if it has no bound variables.

  If a formula \( \varphi \) has free variables \( \Bold{Free}(\varphi) = \{ \xi_1, \ldots, \xi_n \} \), we write it as
  \begin{equation*}
    \varphi(\xi_1, \ldots, \xi_n).
  \end{equation*}

  This highlights that formulas with free variables can act as predicates, however their \hyperref[def:first_order_model]{semantics} are completely determined by the actual predicates.
\end{definition}

\begin{proposition}\label{thm:first_order_formulas_are_unambiguous}
  The \hyperref[def:grammar]{grammar}
  \begin{AlignedEquation}\label{eq:thm:first_order_formulas_are_unambiguous/grammar}
    &\Theta \to v,                                          && v \in \Bold{Var}                                                \\
    &\tau \to \Theta,                                       &&                                                                 \\
    &\tau \to f(\tau, \ldots, \tau),                        && f \in \Bold{Func} \text{ is an } n-\text{ary functional symbol} \\
    &\Phi \to \top \;|\; \bot                               &&                                                                 \\
    &\Phi \to p(\tau, \ldots, \tau),                        && p \in \Bold{Pred} \text{ is an } n-\text{ary predicate symbol}  \\
    &\Phi \to (\tau \doteq \tau)                            &&                                                                 \\
    &\Phi \to \neg \Phi                                     &&                                                                 \\
    &\Phi \to (\Phi \circ \Phi),                            && \circ \in \Sigma                                                \\
    &\Phi \to \forall \Theta \Phi \;|\; \exists \Theta \Phi &&                                                                 \\
  \end{AlignedEquation}
  of \hyperref[def:first_order_term]{first-order terms} and \hyperref[def:first_order_formula]{formulas} is \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \fullref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{definition}\label{def:first_order_substition}
  Let \( \varphi \) be a first-order formula with a free variable \( \eta \) and \( \rho \) be a term. We define the \Def{substitions}
  \begin{BreakableAlign*}
    \tau[\eta \to \rho]    & \coloneqq \begin{cases}
      \rho,                                                    & \tau = \eta,                                    \\
      \xi,                                                     & \tau = \xi \in \Bold{Var} \setminus \{ \eta \}, \\
      f(\tau_1[\eta \to \rho], \ldots, \tau_n[\eta \to \rho]), & \tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
    \\
    \varphi[\eta \to \rho] & \coloneqq \begin{cases}
      \varphi,                                                 & \varphi \in \{ \top, \bot \}                                                       \\
      p(\tau_1[\eta \to \rho], \ldots, \tau_n[\eta \to \rho]), & \varphi = p(\tau_1, \ldots, \tau_n)                                                \\
      (\tau_1[\eta \to \rho] \doteq \tau_2[\eta \to \rho]),    & \varphi = (\tau_1 \doteq \tau_2),                                                  \\
      \neg \psi[\eta \to \rho],                                & \varphi = \neg \psi,                                                               \\
      \psi_1[\eta \to \rho] \circ \psi_2[\xi \to \rho],        & \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma,                                   \\
      Q \xi \psi[\eta \to \rho],                               & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}, \xi \not\in \Bold{Free}(\rho), \\
      Q \xi \psi[\eta \to \rho[\xi \to \zeta]],                & \varphi = Q \xi \psi, Q \in \{ \forall, \exists \}, \xi \in \Bold{Free}(\rho)
    \end{cases}
  \end{BreakableAlign*}
  where in the last step \( \zeta \in \Bold{Var} \setminus \Bold{Free}(\rho) \).

  We define \Def{simultaneous substition of \( \eta_1, \ldots, \eta_n \) with \( \rho_1, \ldots, \rho_n \)} analogously to \fullref{def:propositional_substition}.
\end{definition}
