\subsection{First-order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_logic_alphabet}\MarginCite[187]{OpenLogic20201202}
  The idea of first-order predicate logic is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universum. Unlike in \hyperref[subsec:propositional_logic]{propositional logic}, there are many first-order logic languages.

  The alphabet for a \Def{first-order predicate logic \hyperref[def:language]{language}} \( \CL \) extends that of \hyperref[subsec:propositional_logic]{propositional logic} and consists of two types of symbols.

  \begin{description}
    \item[Logical symbols]\mbox{}
    \begin{DefEnum}[series=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/propositional} The entirety of the \hyperref[subsec:propositional_logic]{propositional logic alphabet}.

      \ILabel{def:first_order_logic_alphabet/var} A countable alphabet of variables \( \Bold{Var} \), usually denoted by \( \xi_1, \xi_2, \ldots \) or \( \xi, \eta, \zeta \).

      \ILabel{def:first_order_logic_alphabet/quantifiers} Two quantifiers \( Q = \{ \forall, \exists \} \):
      \begin{DefEnum}
        \ILabel{def:first_order_logic_alphabet/quantifiers/universal} The \Def{universal quantifier} \( \forall \).
        \ILabel{def:first_order_logic_alphabet/quantifiers/existential} Then \Def{existential quantifier} \( \exists \).
      \end{DefEnum}

      \ILabel{def:first_order_logic_alphabet/equality} Optionally, an equality symbol \( \doteq \). See \fullref{remark:first_order_equality}.
    \end{DefEnum}

    \item[Non-logical symbols]\mbox{}
    \begin{DefEnum}[resume=def:first_order_logic_alphabet]
      \ILabel{def:first_order_logic_alphabet/func} A set of functional symbols, \( \Bold{Fun} \), whose elements are usually denoted by \( f_1, f_2, \ldots \) or \( f, g, h \) or by symbols lie \( \oplus \), in which case we use infix notation. Each functional symbol has an associated natural number called its \Def{arity}, denoted by \( \# f \). Functional symbols with a zero arity are called \Def{constants}.

      \ILabel{def:first_order_logic_alphabet/pred} A set of predicate symbols, \( \Bold{Pred} \), whose elements are usually denoted by \( p_1, p_2, \ldots \) or by symbols like \( \leq \), in which case we use infix notation. Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \Def{propositional variables}.
    \end{DefEnum}
  \end{description}
\end{definition}

\begin{definition}\label{def:first_order_language}\mbox{}
  \begin{DefEnum}
    \ILabel{def:first_order_language/grammar} Consider the following \hyperref[def:backus_naur_form]{grammar schema}:
    \begin{bnf*}
      \bnfprod{variable}        {v \in \Bold{Var}} \\
      \bnfprod{connective}      {\circ \in \Sigma} \\
      \bnfprod{quantifier}      {\bnfts{\( \forall \)} \bnfor \bnfts{\( \exists \)}} \\
      \bnfprod{unary function}  {f \in \Bold{Fun}, \#f = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary function}  {f \in \Bold{Fun}, \#f = n \text{ (separate rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{unary predicate} {p \in \Bold{Pred}, \#p = 1} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{n-ary predicate} {p \in \Bold{Pred}, \#p = n \text{ (separate rule for each \( n \))}} \\
      \bnfmore                  {\vdots} \\
      \bnfprod{term}            {\bnfpn{variable} \bnfor} \\
      \bnfmore                  {\bnfpn{unary function} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary function} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{atomic formula}  {\bnfts{\( \top \)} \bnfor \bnfts{\( \bot \)} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{\( \doteq \)} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{unary predicate} \bnfsp \bnfts{(} \bnfsp \bnfpn{term} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfmore                  {\bnfpn{n-ary predicate} \bnfsp \underbrace{\bnfts{(} \bnfsp \bnfpn{term} \bnfts{,} \bnfsk \bnfts{,} \bnfpn{term} \bnfsp \bnfts{)}}_{n \text{ terms}} \bnfor} \\
      \bnfmore                  {\hspace{3cm} \vdots} \\
      \bnfprod{formula}         {\bnfpn{atomic formula} \bnfor} \\
      \bnfmore                  {\bnfts{\neg} \bnfpn{formula} \bnfor} \\
      \bnfmore                  {\bnfts{(} \bnfsp \bnfpn{formula} \bnfsp \bnfpn{connective} \bnfsp \bnfpn{formula} \bnfsp \bnfts{)} \bnfor} \\
      \bnfmore                  {\bnfpn{quantifier} \bnfsp \bnfpn{variable} \bnfsp \bnfpn{formula}}
    \end{bnf*}

    In practice, we usually only have functions or predicates of specific arities. Note that we can have infinitely many functions but only finitely many different arities. The \hyperref[remark:theory_of_left_monoid_actions]{theory of monoid actions} is an example of a first-order language with infinitely many unary functional symbols, one constant and one binary functional symbol.

    If we need the grammars to have a finite set of rules, except for having only finitely many different arities, we need to introduce appropriate naming conventions for variables, functions and predicates, analogously to \fullref{ex:natural_arithmetic_grammar/backus_naur_form}.

    \ILabel{def:first_order_language/term}\MarginCite[189]{OpenLogic20201202}The set \( \CT \) of \Def{terms} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{term} \) as a starting rule.

    The grammar of first-order terms is unambiguous by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    \ILabel{def:first_order_language/subterm} If \( \tau \) and \( \kappa \) are terms and \( \kappa \) is a \hyperref[def:language/subword]{subword} of \( \tau \), we say that \( \kappa \) is a \Def{subterm} of \( \tau \).

    \ILabel{def:first_order_language/term_variables} For each term \( \tau \), we define its variables as
    \begin{equation*}
      \Bold{Var}(\tau) \coloneqq \begin{cases}
        \xi,                                                    &\tau = \xi \in \Bold{Var},        \\
        \Bold{Var}(\tau_1) \cup \ldots \cup \Bold{Var}(\tau_n), &\tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation*}

    \ILabel{def:first_order_language/formula} The set \( \CF \) of \Def{formulas} is the language \hyperref[def:grammar_derivation/grammar_language]{generated} by this grammar schema with \( \bnfpn{formula} \) as a starting rule.

    The \Def{atomic formulas} are the ones generated from \( \bnfpn{atomic formula} \).

    The grammar of first-order formulas is unambiguous by \fullref{thm:first_order_terms_and_formulas_are_unambiguous}.

    We use the convention from \fullref{remark:propositional_formula_parentheses}.

    \ILabel{def:first_order_language/subformula} If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a \hyperref[def:language/subword]{subword} of \( \varphi \), we say that \( \psi \) is a \Def{subformula} of \( \varphi \).

    \ILabel{def:first_order_language/formula_free_variables} The \Def{free variables} of a formula are defined inductively as
    \begin{equation}\label{eq:def:first_order_language/formula_free_variables}
      \Bold{Free}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                            &\varphi \in \{ \top, \bot \} \\
        \Bold{Var}(\tau_1) \cup \ldots \cup \Bold{Var}(\tau_n), &\varphi = p(\tau_1, \ldots, \tau_n) \\
        \Bold{Var}(\tau_1) \cup \Bold{Var}(\tau_2),             &\varphi = (\tau_1 \doteq \tau_2), \\
        \Bold{Free}(\psi),                                      &\varphi = \neg \psi, \\
        \Bold{Free}(\psi_1) \cup \Bold{Free}(\psi_2),           &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \Bold{Free}(\psi) \setminus \{ \xi \},                  &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \}
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_language/formula_bound_variables} Dually, the \Def{bound variables} of a formula are defined inductively as
    \begin{equation}\label{eq:def:first_order_language/formula_bound_variables}
      \Cat{Bound}(\varphi) \coloneqq \begin{cases}
        \varnothing,                                   &\varphi \in \{ \top, \bot \} \\
        \varnothing,                                   &\varphi = p(\tau_1, \ldots, \tau_n) \\
        \varnothing,                                   &\varphi = (\tau_1 \doteq \tau_2), \\
        \Cat{Bound}(\psi),                             &\varphi = \neg \psi, \\
        \Cat{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2), &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \Cat{Bound}(\psi) \cup \{ \xi \},              &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \}.
      \end{cases}
    \end{equation}
  \end{DefEnum}
\end{definition}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The grammars of \hyperref[def:propositional_language/term]{first-order terms} and of \hyperref[def:propositional_language/formula]{first-order formulas} are \hyperref[def:grammar_derivation/ambiguity]{unambiguous}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \fullref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{definition}\label{def:first_order_substition}
  We define different kinds of (singular) \Def{substitution}. In all cases, \Def{simultaneous substition} is defined via the same trick as in \fullref{def:propositional_substition}.

  \begin{DefEnum}
    \ILabel{def:first_order_substition/predicate} The substition of the \hyperref[def:propositional_language/formula]{propositional formula} \( \theta \) with the \hyperref[def:first_order_language/formula]{first order formula} \( \rho \) in the propositional formula \( \varphi \) is given by \eqref{eq:def:propositional_substition/single}.

    \ILabel{def:first_order_substition/term_in_term} The substition of the \hyperref[def:first_order_language/term]{first order term} \( \kappa \) with \( \nu \) in the term \( \tau \) is
    \begin{equation}\label{eq:def:first_order_substition/term_in_term}
      \tau[\kappa \mapsto \nu] \coloneqq \begin{cases}
        \nu,                                                               &\tau = \kappa, \\
        \xi,                                                               &\tau \neq \kappa \T{and} \tau \in \Bold{Var}, \\
        f(\tau_1[\kappa \mapsto \nu], \ldots, \tau_n[\kappa \mapsto \nu]), &\tau \neq \kappa \T{and} \tau = f(\tau_1, \ldots, \tau_n).
      \end{cases}
    \end{equation}

    \ILabel{def:first_order_substition/term_in_formula} The substition of the term \( \kappa \) with the term \( \nu \) in the first order formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_substition/term_in_formula}
      \varphi[\kappa \mapsto \nu] \coloneqq \begin{cases}
        \varphi,                                                                       &\varphi \in \{ \top, \bot \}, \\
        p(\tau_1[\kappa \mapsto \nu], \ldots, \tau_n[\kappa \mapsto \nu]),             &\varphi = p(\tau_1, \ldots, \tau_n), \\
        (\tau_1[\kappa \mapsto \nu] \doteq \tau_2[\kappa \mapsto \nu]),                &\varphi = (\tau_1 \doteq \tau_2), \\
        \neg \psi[\kappa \mapsto \nu],                                                 &\varphi = \neg \psi, \\
        \psi_1[\kappa \mapsto \nu] \circ \psi_2[\xi \mapsto \nu],                      &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \text{\fullref{eq:def:first_order_substition/term_in_formula/quantifiers}},    &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \},
      \end{cases}
    \end{equation}
    where
    \begin{equation}\label{eq:def:first_order_substition/term_in_formula/quantifiers}
      \begin{cases}
        Q \xi \psi[\kappa \mapsto \nu],                                                &\xi \not\in \Bold{Var}(\kappa) \cup \Bold{Var}(\nu), \\
        Q \eta \psi[\xi \mapsto \eta][\kappa \mapsto \nu],                             &\xi \in \Bold{Var}(\kappa) \cup \Bold{Var}(\nu) \T{and} \\
                                                                                       &\eta \not\in \Bold{Var}(\kappa) \cup \Bold{Var}(\nu) \cup \Bold{Free}(\psi).
      \end{cases}
    \end{equation}

    The first rule for quantifier substitution is not really necessary but rather a convenience for ensuring that a quantifier is not renamed if unnecessary. The third rule is called \Def{renaming} \( \xi \) to \( \eta \) and assumes that there exist enough variables in the language so that we can find \( \eta \) that satisfies the condition. See \fullref{ex:first_order_substition} for a justification of the different quantifier rules.

    \ILabel{def:first_order_substition/formula_in_formula} The substition of the \hyperref[def:first_order_language/formula]{first order formula} \( \theta \) with the first order formula \( \rho \) in the first order formula \( \varphi \) is
    \begin{equation}\label{eq:def:first_order_substition/formula_in_formula}
      \varphi[\theta \mapsto \rho] \coloneqq \begin{cases}
        \rho,                                                                          &\varphi = \theta, \\
        \varphi,                                                                       &\varphi \neq \theta \T{and} \varphi \text{ is atomic}, \\
        \neg \psi[\theta \mapsto \rho],                                                &\varphi \neq \theta \T{and} \varphi = \neg \psi, \\
        \psi_1[\theta \mapsto \rho] \circ \psi_2[\xi \mapsto \rho],                    &\varphi \neq \theta \T{and} \varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
        \text{\fullref{eq:def:first_order_substition/formula_in_formula/quantifiers}}, &\varphi \neq \theta \T{and} \varphi = Q \xi \psi, Q \in \{ \forall, \exists \},
      \end{cases}
    \end{equation}
    where
    \begin{equation}\label{eq:def:first_order_substition/formula_in_formula/quantifiers}
      \begin{cases}
        Q \xi \psi[\theta \mapsto \rho],                                               &\xi \not\in \Bold{Free}(\theta) \cup \Bold{Free}(\rho), \\
        Q \eta \psi[\xi \mapsto \eta][\theta \mapsto \rho],                            &\xi \in \Bold{Free}(\theta) \cup \Bold{Free}(\rho) \T{and} \\
                                                                                       &\eta \not\in \Bold{Free}(\theta) \cup \Bold{Free}(\rho) \cup \Bold{Free}(\psi).
      \end{cases}
    \end{equation}

    The only difference in the substitutions \eqref{eq:def:first_order_substition/term_in_formula/quantifiers} and \eqref{eq:def:first_order_substition/formula_in_formula/quantifiers} is that the first deals with terms and the deals with formulas.
  \end{DefEnum}
\end{definition}

\begin{example}\label{ex:first_order_substition}
  The following term substitutions should justify the distinct cases in \eqref{eq:def:first_order_substition/term_in_formula/quantifiers}:
  \begin{ExEnum}
    \ILabel{ex:first_order_substition/1} A simple substitution without renaming:
    \begin{align*}
      &\phantom{{}={}}
      (\forall x\; p(x, y))[y \mapsto z]
      = \\ &=
      \forall x\; p(x, y)[y \mapsto z]
      = \\ &=
      \forall x\; p(y, z).
    \end{align*}

    \ILabel{ex:first_order_substition/2} A simple renaming without actual substitution:
    \begin{align*}
      &\phantom{{}={}}
      (\forall x\; p(x, y))[x \mapsto y]
      = \\ &=
      \forall z\; p(x, y)[x \mapsto z][x \mapsto y]
      = \\ &=
      \forall z\; p(z, y).
    \end{align*}

    We might have defined \( \varphi[\kappa \mapsto \nu] \) in \eqref{eq:def:first_order_substition/term_in_formula} to be \( \varphi \) if \( \xi \in \Bold{Var}(\kappa) \) and this would have leaved this exact formula unchanged. \Fullref{ex:first_order_substition/4}, however, demonstates that this definition would not have worked for nested substitution. Since the substituted formula is equivalent to the original one, we leave the definition as it is.

    \ILabel{ex:first_order_substition/3} \Fullref{ex:first_order_substition/2} but with both \( \kappa \) and \( \nu \) containing \( x \):
    \begin{align*}
      &\phantom{{}={}}
      (\forall x\; p(x, y))[x \mapsto f(x)]
      = \\ &=
      \forall z\; p(x, y)[x \mapsto z][x \mapsto f(x)]
      = \\ &=
      \forall z\; p(z, y).
    \end{align*}

    \ILabel{ex:first_order_substition/4} Only renaming with multiple quantifiers (analogous to \fullref{ex:first_order_substition/2}):
    \begin{align*}
      &\phantom{{}={}}
      (\forall y\; \forall x\; p(x, y)))[x \mapsto y]
      = \\ &=
      \forall z (\forall x\; p(x, y))[y \mapsto z][x \mapsto y]
      = \\ &=
      \forall z \forall t\; p(x, z)[x \mapsto t][x \mapsto y]
      = \\ &=
      \forall z \forall t\; p(t, z).
    \end{align*}

    \ILabel{ex:first_order_substition/5} Both renaming and substitution with multiple quantifiers:
    \begin{align*}
      &\phantom{{}={}}
      (\forall y\; (p(x, y) \vee \forall x\; p(x, y)))[x \mapsto y]
      = \\ &=
      \forall z (p(x, y) \vee \forall x\; p(x, y))[y \mapsto z][x \mapsto y]
      = \\ &=
      \forall z (p(y, z) \vee (\forall x\; p(x, y))[y \mapsto z][x \mapsto y])
      = \\ &=
      \forall z (p(y, z) \vee (\forall t\; p(x, z)[x \mapsto t][x \mapsto y]))
      = \\ &=
      \forall z (p(y, z) \vee (\forall t\; p(t, z))).
    \end{align*}

    \ILabel{ex:first_order_substition/6} Substitution of arbitrary terms rather than only variables:
    \begin{align*}
      &\phantom{{}={}}
      (\forall x\; p(x, y, f(y)))[f(y) \mapsto g(y, x)]
      = \\ &=
      \forall z\; p(x, y, f(y))[x \mapsto z][f(y) \mapsto g(y, x)]
      = \\ &=
      \forall z\; p(z, y, g(y, x)).
    \end{align*}
  \end{ExEnum}
\end{example}
